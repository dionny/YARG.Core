This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
Audio/
  AudioEnums.cs
  AudioHelpers.cs
  AudioManager.cs
  DrumSampleChannel.cs
  GlobalAudioHandler.cs
  MicDevice.cs
  PreviewContext.cs
  SampleChannel.cs
  SerializedMic.cs
  StemChannel.cs
  StemMixer.cs
  StemSettings.cs
bin/
  Debug/
    netstandard2.1/
      YARG.Core.deps.json
  Release/
    netstandard2.1/
      publish/
        YARG.Core.deps.json
      YARG.Core.deps.json
Chart/
  Events/
    ChartEvent.cs
    ChartEventExtensions.cs
    Phrase.cs
    Section.cs
    TextEvent.cs
    WaitCountdown.cs
  Loaders/
    MoonSong/
      MoonSongLoader.cs
      MoonSongLoader.Drums.cs
      MoonSongLoader.Guitar.cs
      MoonSongLoader.Lyrics.cs
      MoonSongLoader.ProGuitar.cs
      MoonSongLoader.ProKeys.cs
      MoonSongLoader.Venue.cs
      MoonSongLoader.Vocals.cs
    ISongLoader.cs
  Notes/
    DrumNote.cs
    GuitarNote.cs
    Note.cs
    NoteTrackers.cs
    NoteTrackers.t4
    ProGuitarNote.cs
    ProKeysNote.cs
    VocalNote.cs
  Sync/
    Beatline.cs
    SyncEvent.cs
    SyncTrack.cs
    TempoChange.cs
    TimeSignatureEvent.cs
    TimeSignatureEvent.Progresses.cs
    TimeSignatureEvent.Progresses.t4
  Tracks/
    Lyrics/
      LyricEvent.cs
      LyricsPhrase.cs
      LyricsTrack.cs
      LyricSymbols.cs
    Vocals/
      VocalsPart.cs
      VocalsPartExtensions.cs
      VocalsPhrase.cs
      VocalsRangeShift.cs
      VocalsTrack.cs
    InstrumentDifficulty.cs
    InstrumentDifficultyExtensions.cs
    InstrumentTrack.cs
  Venue/
    LightingEvent.cs
    PerformerEvent.cs
    PostProcessingEvent.cs
    StageEffectEvent.cs
    VenueEvent.cs
    VenueLookup.cs
    VenueTrack.cs
  ChartEventTrackers.cs
  ChartEventTrackers.t4
  MidiSettings.cs
  ParsingProperties.cs
  SongChart.AutoGeneration.cs
  SongChart.cs
  TEMP_parsing_todos.txt
Engine/
  Drums/
    Engines/
      YargDrumsEngine.cs
    DrumsEngine.cs
    DrumsEngineParameters.cs
    DrumsStats.cs
  Guitar/
    Engines/
      YargFiveFretEngine.cs
    GuitarEngine.cs
    GuitarEngineParameters.cs
    GuitarStats.cs
  ProKeys/
    Engines/
      YargProKeysEngine.cs
    ProKeysEngine.cs
    ProKeysEngineParameters.cs
    ProKeysStats.cs
    ProKeysUtilities.cs
  Vocals/
    Engines/
      YargVocalsEngine.cs
    VocalsEngine.cs
    VocalsEngineParameters.cs
    VocalsStats.cs
  BandComboType.cs
  BaseEngine.cs
  BaseEngine.Generic.cs
  BaseEngineParameters.cs
  BaseStats.cs
  EngineTimer.cs
  HitWindowSettings.cs
  SoloSection.cs
  SustainList.cs
  SyncTrackChange.cs
Extensions/
  BinaryReaderWriterExtensions.cs
  CharacterExtensions.cs
  CollectionExtensions.cs
  EnumExtensions.cs
  ICloneable.cs
  MemoryExtensions.cs
  MidiExtensions.cs
  StreamExtensions.cs
  StringExtensions.cs
  UnsafeExtensions.cs
Game/
  Presets/
    BasePreset.cs
    CameraPreset.cs
    CameraPreset.Defaults.cs
    ColorProfile.cs
    ColorProfile.Defaults.cs
    ColorProfile.FiveFretGuitar.cs
    ColorProfile.FiveLaneDrums.cs
    ColorProfile.FourLaneDrums.cs
    ColorProfile.ProKeys.cs
    EnginePreset.cs
    EnginePreset.Defaults.cs
    EnginePreset.Instruments.cs
    HighwayPreset.cs
    HighwayPreset.Defaults.cs
  Settings/
    SettingRangeAttribute.cs
    SettingSubSectionAttribute.cs
    SettingTypeAttribute.cs
  Modifier.cs
  StarAmount.cs
  YargProfile.cs
Input/
  GameInput.cs
  InputActions.cs
IO/
  ConHandler/
    CONFile.cs
    CONFileListing.cs
    CONFileStream.cs
  DTA/
    DTAEntry.cs
    YARGDTAReader.cs
  FixedArray/
    FixedArray.cs
    FixedArrayStream.cs
  Images/
    YARGImage.cs
  Ini/
    IniModifierCollection.cs
    SongIniHandler.cs
    YARGIniReader.cs
  Midi/
    YARGMidiFile.cs
    YARGMidiTrack.cs
  SngHandler/
    SngFile.cs
    SngFileStream.cs
    SngMask.cs
  TextReader/
    YARGTextContainer.cs
    YARGTextReader.cs
  AbridgedFileInfo.cs
  CharacterCodes.cs
  TextSpan.cs
  YARGChartFileReader.cs
  YARGMoggStream.cs
  YARGSongFileStream.cs
Logging/
  Formatters/
    BasicYargLogFormatter.cs
    DetailedYargLogFormatter.cs
    IYargLogFormatter.cs
    MessageOnlyYargLogFormatter.cs
  FormatWrappers/
    HexBytesFormat.cs
  Listeners/
    BaseYargLogListener.cs
    ConsoleYargLogListener.cs
    DebugYargLogListener.cs
    FileYargLogListener.cs
  LogItems/
    FormatLogItem.cs
    FormatLogItem.t4
    LogItem.cs
    MessageLogItem.cs
  LogLevel.cs
  YargLogger.Assertions.cs
  YargLogger.Assertions.t4
  YargLogger.cs
  YargLogger.Logging.cs
  YargLogger.Methods.cs
  YargLogger.Methods.t4
MoonscraperChartParser/
  Events/
    MoonNote.cs
    MoonObject.cs
    MoonPhrase.cs
    MoonText.cs
    MoonVenue.cs
  IO/
    Chart/
      ChartIOHelper.cs
      ChartReader.cs
      ChartReader.ProcessLists.cs
    Midi/
      MidFileLoader.cs
      MidIOHelper.cs
      MidReader.cs
      MidReader.ProcessLists.cs
      PhaseShiftSysEx.cs
    NoteFlagPriority.cs
  LICENSE
  Metadata.cs
  MoonChart.cs
  MoonSong.cs
  SongObjectHelper.cs
obj/
  Debug/
    netstandard2.1/
      .NETStandard,Version=v2.1.AssemblyAttributes.cs
      YARG.Core.AssemblyInfo.cs
      YARG.Core.AssemblyInfoInputs.cache
      YARG.Core.csproj.CoreCompileInputs.cache
      YARG.Core.csproj.FileListAbsolute.txt
      YARG.Core.GeneratedMSBuildEditorConfig.editorconfig
      YARG.Core.sourcelink.json
  Release/
    netstandard2.1/
      .NETStandard,Version=v2.1.AssemblyAttributes.cs
      PublishOutputs.cfbcd496df.txt
      YARG.Core.AssemblyInfo.cs
      YARG.Core.AssemblyInfoInputs.cache
      YARG.Core.csproj.CoreCompileInputs.cache
      YARG.Core.csproj.FileListAbsolute.txt
      YARG.Core.deps.json
      YARG.Core.GeneratedMSBuildEditorConfig.editorconfig
      YARG.Core.genpublishdeps.cache
      YARG.Core.sourcelink.json
  project.assets.json
  project.nuget.cache
  YARG.Core.csproj.nuget.dgspec.json
  YARG.Core.csproj.nuget.g.props
  YARG.Core.csproj.nuget.g.targets
Parsing/
  TextEvents.cs
  TextEvents.Phrases.cs
Replays/
  Analyzer/
    AnalysisResult.cs
    ReplayAnalyzer.cs
  ReplayStats/
    DrumsReplayStats.cs
    GuitarReplayStats.cs
    ProKeysReplayStats.cs
    ReplayStats.cs
    VocalReplayStats.cs
  ReplayData.cs
  ReplayFrame.cs
  ReplayInfo.cs
  ReplayIO.cs
Song/
  Cache/
    CacheGroups/
      CONEntryGroup.cs
      CONModificationGroup.cs
      CONUpdateGroup.cs
      CONUpgradeGroup.cs
      EntryGroup.cs
      IniEntryGroup.cs
      PackedCONEntryGroup.cs
      UnpackedCONEntryGroup.cs
    CacheHandler.cs
    CacheLoopable.cs
    CacheNodes.cs
    CONModification.cs
    FileCollection.cs
    SongCache.cs
  Entries/
    AvailableParts/
      AvailableParts.cs
      PartValues.cs
    Ini/
      SongEntry.IniBase.cs
      SongEntry.Sng.cs
      SongEntry.UnpackedIni.cs
    RBCON/
      RBAudio.cs
      RBIntensities.cs
      RBMetadata.cs
      RBProUpgrade.cs
      SongEntry.PackedRBCON.cs
      SongEntry.RBCON.cs
      SongEntry.UnpackedRBCON.cs
    Types/
      HashWrapper.cs
      ScanExpected.cs
      SongMetadata.cs
      SortString.cs
    SongEntry.cs
    SongEntry.Loading.cs
    SongEntry.Scanning.cs
    SongEntry.Sorting.cs
  MidiPreparsers/
    MidiDrumsPreparser.cs
    MidiEliteDrumsPreparser.cs
    MidiFiveFretPreparser.cs
    MidiInstrumentPreparser.cs
    MidiProGuitarPreparser.cs
    MidiProKeysPreparser.cs
    MidiSixFretPreparser.cs
    MidiVocalPreparser.cs
Utility/
  IBinarySerializable.cs
  JsonColorConverter.cs
  JsonHashWrapperConverter.cs
  MathUtil.cs
  NullStringBinaryWriter.cs
  RichTextUtils.cs
  SpanSplitter.cs
  StringTransformations.cs
Venue/
  VenueType.cs
Assembly.cs
InstrumentEnums.cs
YARG.Core.csproj
YARG.Core.csproj.DotSettings
YargMath.cs
YargMath.t4
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Audio/AudioEnums.cs">
namespace YARG.Core.Audio
{
    public enum SongStem
    {
        Master = -3,
        DrumSfx = -2,
        Sfx = -1,
        Song,
        Guitar,
        Bass,
        Rhythm,
        Keys,
        Vocals,
        Vocals1,
        Vocals2,
        Drums,
        Drums1,
        Drums2,
        Drums3,
        Drums4,
        Crowd,
        Preview
    }

    public enum SfxSample
    {
        NoteMiss,
        StarPowerAward,
        StarPowerGain,
        StarPowerDeploy,
        StarPowerRelease,
        Clap,
        StarGain,
        StarGold,
        Overstrum1,
        Overstrum2,
        Overstrum3,
        Overstrum4,
    }

    public enum DrumSfxSample
    {
        Vel0Pad0Smp0,
        Vel0Pad0Smp1,
        Vel0Pad0Smp2,
        Vel0Pad1Smp0,
        Vel0Pad1Smp1,
        Vel0Pad1Smp2,
        Vel0Pad2Smp0,
        Vel0Pad2Smp1,
        Vel0Pad2Smp2,
        Vel0Pad3Smp0,
        Vel0Pad3Smp1,
        Vel0Pad3Smp2,
        Vel0Pad4Smp0,
        Vel0Pad4Smp1,
        Vel0Pad4Smp2,
        Vel0Pad5Smp0,
        Vel0Pad5Smp1,
        Vel0Pad5Smp2,
        Vel0Pad6Smp0,
        Vel0Pad6Smp1,
        Vel0Pad6Smp2,
        Vel0Pad7Smp0,
        Vel0Pad7Smp1,
        Vel0Pad7Smp2,
        Vel1Pad0Smp0,
        Vel1Pad0Smp1,
        Vel1Pad0Smp2,
        Vel1Pad1Smp0,
        Vel1Pad1Smp1,
        Vel1Pad1Smp2,
        Vel1Pad2Smp0,
        Vel1Pad2Smp1,
        Vel1Pad2Smp2,
        Vel1Pad3Smp0,
        Vel1Pad3Smp1,
        Vel1Pad3Smp2,
        Vel1Pad4Smp0,
        Vel1Pad4Smp1,
        Vel1Pad4Smp2,
        Vel1Pad5Smp0,
        Vel1Pad5Smp1,
        Vel1Pad5Smp2,
        Vel1Pad6Smp0,
        Vel1Pad6Smp1,
        Vel1Pad6Smp2,
        Vel1Pad7Smp0,
        Vel1Pad7Smp1,
        Vel1Pad7Smp2,
        Vel2Pad0Smp0,
        Vel2Pad0Smp1,
        Vel2Pad0Smp2,
        Vel2Pad1Smp0,
        Vel2Pad1Smp1,
        Vel2Pad1Smp2,
        Vel2Pad2Smp0,
        Vel2Pad2Smp1,
        Vel2Pad2Smp2,
        Vel2Pad3Smp0,
        Vel2Pad3Smp1,
        Vel2Pad3Smp2,
        Vel2Pad4Smp0,
        Vel2Pad4Smp1,
        Vel2Pad4Smp2,
        Vel2Pad5Smp0,
        Vel2Pad5Smp1,
        Vel2Pad5Smp2,
        Vel2Pad6Smp0,
        Vel2Pad6Smp1,
        Vel2Pad6Smp2,
        Vel2Pad7Smp0,
        Vel2Pad7Smp1,
        Vel2Pad7Smp2
    }

    public enum DSPType
    {
        Gain,
    }
}
</file>

<file path="Audio/AudioHelpers.cs">
using System;
using System.Collections.Generic;

namespace YARG.Core.Audio
{
    public static class AudioHelpers
    {
        public static readonly Dictionary<string, SongStem> SupportedStems = new()
        {
            { "song",     SongStem.Song    },
            { "guitar",   SongStem.Guitar  },
            { "bass",     SongStem.Bass    },
            { "rhythm",   SongStem.Rhythm  },
            { "keys",     SongStem.Keys    },
            { "vocals",   SongStem.Vocals  },
            { "vocals_1", SongStem.Vocals1 },
            { "vocals_2", SongStem.Vocals2 },
            { "drums",    SongStem.Drums   },
            { "drums_1",  SongStem.Drums1  },
            { "drums_2",  SongStem.Drums2  },
            { "drums_3",  SongStem.Drums3  },
            { "drums_4",  SongStem.Drums4  },
            { "crowd",    SongStem.Crowd   },
            // "preview"
        };

        public static readonly IList<string> SfxPaths = new[]
        {
            "note_miss",
            "starpower_award",
            "starpower_gain",
            "starpower_deploy",
            "starpower_release",
            "clap",
            "star",
            "star_gold",
            "overstrum_1",
            "overstrum_2",
            "overstrum_3",
            "overstrum_4",
        };

        public static readonly IList<double> SfxVolume = new[]
        {
            0.55,
            0.5,
            0.5,
            0.4,
            0.5,
            0.16,
            1.0,
            1.0,
            0.4,
            0.4,
            0.4,
            0.4,
        };

        public static readonly List<SongStem> PitchBendAllowedStems = new()
        {
            SongStem.Guitar,
            SongStem.Bass,
            SongStem.Rhythm,
        };

        public static SongStem GetStemFromName(string stem)
        {
            return stem.ToLowerInvariant() switch
            {
                "song"       => SongStem.Song,
                "guitar"     => SongStem.Guitar,
                "bass"       => SongStem.Bass,
                "rhythm"     => SongStem.Rhythm,
                "keys"       => SongStem.Keys,
                "vocals"     => SongStem.Vocals,
                "vocals_1"   => SongStem.Vocals1,
                "vocals_2"   => SongStem.Vocals2,
                "drums"      => SongStem.Drums,
                "drums_1"    => SongStem.Drums1,
                "drums_2"    => SongStem.Drums2,
                "drums_3"    => SongStem.Drums3,
                "drums_4"    => SongStem.Drums4,
                "crowd"      => SongStem.Crowd,
                // "preview" => SongStem.Preview,
                _ => SongStem.Song,
            };
        }

        public static SongStem ToSongStem(this Instrument instrument)
        {
            return instrument switch
            {
                Instrument.FiveFretGuitar or
                Instrument.SixFretGuitar or
                Instrument.ProGuitar_17Fret or
                Instrument.ProGuitar_22Fret => SongStem.Guitar,

                Instrument.FiveFretBass or
                Instrument.SixFretBass or
                Instrument.ProBass_17Fret or
                Instrument.ProBass_22Fret => SongStem.Bass,

                Instrument.FiveFretRhythm or
                Instrument.SixFretRhythm or
                Instrument.FiveFretCoopGuitar or
                Instrument.SixFretCoopGuitar => SongStem.Rhythm,

                Instrument.Keys or
                Instrument.ProKeys => SongStem.Keys,

                Instrument.ProDrums or
                Instrument.FourLaneDrums or
                Instrument.FiveLaneDrums => SongStem.Drums,

                Instrument.Vocals or
                Instrument.Harmony => SongStem.Vocals,

                _ => throw new Exception("Unreachable.")
            };
        }

        public static SfxSample GetSfxFromName(string sfx)
        {
            return sfx.ToLowerInvariant() switch
            {
                "note_miss"         => SfxSample.NoteMiss,
                "starpower_award"   => SfxSample.StarPowerAward,
                "starpower_gain"    => SfxSample.StarPowerGain,
                "starpower_deploy"  => SfxSample.StarPowerDeploy,
                "starpower_release" => SfxSample.StarPowerRelease,
                "clap"              => SfxSample.Clap,
                "star"              => SfxSample.StarGain,
                "star_gold"         => SfxSample.StarGold,
                "overstrum_1"       => SfxSample.Overstrum1,
                "overstrum_2"       => SfxSample.Overstrum2,
                "overstrum_3"       => SfxSample.Overstrum3,
                "overstrum_4"       => SfxSample.Overstrum4,
                _                   => SfxSample.NoteMiss,
            };
        }

        // Drum SFX related
        public static readonly IList<string> DrumSfxPaths = new[]
        {
            "vel0pad0smp0",
            "vel0pad0smp1",
            "vel0pad0smp2",
            "vel0pad1smp0",
            "vel0pad1smp1",
            "vel0pad1smp2",
            "vel0pad2smp0",
            "vel0pad2smp1",
            "vel0pad2smp2",
            "vel0pad3smp0",
            "vel0pad3smp1",
            "vel0pad3smp2",
            "vel0pad4smp0",
            "vel0pad4smp1",
            "vel0pad4smp2",
            "vel0pad5smp0",
            "vel0pad5smp1",
            "vel0pad5smp2",
            "vel0pad6smp0",
            "vel0pad6smp1",
            "vel0pad6smp2",
            "vel0pad7smp0",
            "vel0pad7smp1",
            "vel0pad7smp2",
            "vel1pad0smp0",
            "vel1pad0smp1",
            "vel1pad0smp2",
            "vel1pad1smp0",
            "vel1pad1smp1",
            "vel1pad1smp2",
            "vel1pad2smp0",
            "vel1pad2smp1",
            "vel1pad2smp2",
            "vel1pad3smp0",
            "vel1pad3smp1",
            "vel1pad3smp2",
            "vel1pad4smp0",
            "vel1pad4smp1",
            "vel1pad4smp2",
            "vel1pad5smp0",
            "vel1pad5smp1",
            "vel1pad5smp2",
            "vel1pad6smp0",
            "vel1pad6smp1",
            "vel1pad6smp2",
            "vel1pad7smp0",
            "vel1pad7smp1",
            "vel1pad7smp2",
            "vel2pad0smp0",
            "vel2pad0smp1",
            "vel2pad0smp2",
            "vel2pad1smp0",
            "vel2pad1smp1",
            "vel2pad1smp2",
            "vel2pad2smp0",
            "vel2pad2smp1",
            "vel2pad2smp2",
            "vel2pad3smp0",
            "vel2pad3smp1",
            "vel2pad3smp2",
            "vel2pad4smp0",
            "vel2pad4smp1",
            "vel2pad4smp2",
            "vel2pad5smp0",
            "vel2pad5smp1",
            "vel2pad5smp2",
            "vel2pad6smp0",
            "vel2pad6smp1",
            "vel2pad6smp2",
            "vel2pad7smp0",
            "vel2pad7smp1",
            "vel2pad7smp2",
        };

        public static DrumSfxSample GetDrumSfxFromName(string sfx)
        {
            return sfx.ToLowerInvariant() switch
            {
                "vel0pad0smp0" => DrumSfxSample.Vel0Pad0Smp0,
                "vel0pad0smp1" => DrumSfxSample.Vel0Pad0Smp1,
                "vel0pad0smp2" => DrumSfxSample.Vel0Pad0Smp2,
                "vel0pad1smp0" => DrumSfxSample.Vel0Pad1Smp0,
                "vel0pad1smp1" => DrumSfxSample.Vel0Pad1Smp1,
                "vel0pad1smp2" => DrumSfxSample.Vel0Pad1Smp2,
                "vel0pad2smp0" => DrumSfxSample.Vel0Pad2Smp0,
                "vel0pad2smp1" => DrumSfxSample.Vel0Pad2Smp1,
                "vel0pad2smp2" => DrumSfxSample.Vel0Pad2Smp2,
                "vel0pad3smp0" => DrumSfxSample.Vel0Pad3Smp0,
                "vel0pad3smp1" => DrumSfxSample.Vel0Pad3Smp1,
                "vel0pad3smp2" => DrumSfxSample.Vel0Pad3Smp2,
                "vel0pad4smp0" => DrumSfxSample.Vel0Pad4Smp0,
                "vel0pad4smp1" => DrumSfxSample.Vel0Pad4Smp1,
                "vel0pad4smp2" => DrumSfxSample.Vel0Pad4Smp2,
                "vel0pad5smp0" => DrumSfxSample.Vel0Pad5Smp0,
                "vel0pad5smp1" => DrumSfxSample.Vel0Pad5Smp1,
                "vel0pad5smp2" => DrumSfxSample.Vel0Pad5Smp2,
                "vel0pad6smp0" => DrumSfxSample.Vel0Pad6Smp0,
                "vel0pad6smp1" => DrumSfxSample.Vel0Pad6Smp1,
                "vel0pad6smp2" => DrumSfxSample.Vel0Pad6Smp2,
                "vel0pad7smp0" => DrumSfxSample.Vel0Pad7Smp0,
                "vel0pad7smp1" => DrumSfxSample.Vel0Pad7Smp1,
                "vel0pad7smp2" => DrumSfxSample.Vel0Pad7Smp2,
                "vel1pad0smp0" => DrumSfxSample.Vel1Pad0Smp0,
                "vel1pad0smp1" => DrumSfxSample.Vel1Pad0Smp1,
                "vel1pad0smp2" => DrumSfxSample.Vel1Pad0Smp2,
                "vel1pad1smp0" => DrumSfxSample.Vel1Pad1Smp0,
                "vel1pad1smp1" => DrumSfxSample.Vel1Pad1Smp1,
                "vel1pad1smp2" => DrumSfxSample.Vel1Pad1Smp2,
                "vel1pad2smp0" => DrumSfxSample.Vel1Pad2Smp0,
                "vel1pad2smp1" => DrumSfxSample.Vel1Pad2Smp1,
                "vel1pad2smp2" => DrumSfxSample.Vel1Pad2Smp2,
                "vel1pad3smp0" => DrumSfxSample.Vel1Pad3Smp0,
                "vel1pad3smp1" => DrumSfxSample.Vel1Pad3Smp1,
                "vel1pad3smp2" => DrumSfxSample.Vel1Pad3Smp2,
                "vel1pad4smp0" => DrumSfxSample.Vel1Pad4Smp0,
                "vel1pad4smp1" => DrumSfxSample.Vel1Pad4Smp1,
                "vel1pad4smp2" => DrumSfxSample.Vel1Pad4Smp2,
                "vel1pad5smp0" => DrumSfxSample.Vel1Pad5Smp0,
                "vel1pad5smp1" => DrumSfxSample.Vel1Pad5Smp1,
                "vel1pad5smp2" => DrumSfxSample.Vel1Pad5Smp2,
                "vel1pad6smp0" => DrumSfxSample.Vel1Pad6Smp0,
                "vel1pad6smp1" => DrumSfxSample.Vel1Pad6Smp1,
                "vel1pad6smp2" => DrumSfxSample.Vel1Pad6Smp2,
                "vel1pad7smp0" => DrumSfxSample.Vel1Pad7Smp0,
                "vel1pad7smp1" => DrumSfxSample.Vel1Pad7Smp1,
                "vel1pad7smp2" => DrumSfxSample.Vel1Pad7Smp2,
                "vel2pad0smp0" => DrumSfxSample.Vel2Pad0Smp0,
                "vel2pad0smp1" => DrumSfxSample.Vel2Pad0Smp1,
                "vel2pad0smp2" => DrumSfxSample.Vel2Pad0Smp2,
                "vel2pad1smp0" => DrumSfxSample.Vel2Pad1Smp0,
                "vel2pad1smp1" => DrumSfxSample.Vel2Pad1Smp1,
                "vel2pad1smp2" => DrumSfxSample.Vel2Pad1Smp2,
                "vel2pad2smp0" => DrumSfxSample.Vel2Pad2Smp0,
                "vel2pad2smp1" => DrumSfxSample.Vel2Pad2Smp1,
                "vel2pad2smp2" => DrumSfxSample.Vel2Pad2Smp2,
                "vel2pad3smp0" => DrumSfxSample.Vel2Pad3Smp0,
                "vel2pad3smp1" => DrumSfxSample.Vel2Pad3Smp1,
                "vel2pad3smp2" => DrumSfxSample.Vel2Pad3Smp2,
                "vel2pad4smp0" => DrumSfxSample.Vel2Pad4Smp0,
                "vel2pad4smp1" => DrumSfxSample.Vel2Pad4Smp1,
                "vel2pad4smp2" => DrumSfxSample.Vel2Pad4Smp2,
                "vel2pad5smp0" => DrumSfxSample.Vel2Pad5Smp0,
                "vel2pad5smp1" => DrumSfxSample.Vel2Pad5Smp1,
                "vel2pad5smp2" => DrumSfxSample.Vel2Pad5Smp2,
                "vel2pad6smp0" => DrumSfxSample.Vel2Pad6Smp0,
                "vel2pad6smp1" => DrumSfxSample.Vel2Pad6Smp1,
                "vel2pad6smp2" => DrumSfxSample.Vel2Pad6Smp2,
                "vel2pad7smp0" => DrumSfxSample.Vel2Pad7Smp0,
                "vel2pad7smp1" => DrumSfxSample.Vel2Pad7Smp1,
                "vel2pad7smp2" => DrumSfxSample.Vel2Pad7Smp2,
                _              => DrumSfxSample.Vel0Pad0Smp0,
            };
        }
    }
}
</file>

<file path="Audio/AudioManager.cs">
using System;
using System.Collections.Generic;
using System.IO;
using YARG.Core.Logging;

namespace YARG.Core.Audio
{
    public abstract class AudioManager
    {
        private static float _globalSpeed = 1f;

        private bool _disposed;
        private List<StemMixer> _activeMixers = new();

        protected internal readonly SampleChannel[]     SfxSamples     = new SampleChannel[AudioHelpers.SfxPaths.Count];
        protected internal readonly DrumSampleChannel[] DrumSfxSamples = new DrumSampleChannel[AudioHelpers.DrumSfxPaths.Count];
        protected internal int PlaybackLatency;
        protected internal int MinimumBufferLength;
        protected internal int MaximumBufferLength;

        protected internal abstract ReadOnlySpan<string> SupportedFormats { get; }

        internal StemMixer? LoadCustomFile(string name, Stream stream, float speed, double volume, SongStem stem = SongStem.Song)
        {
            YargLogger.LogDebug("Loading custom audio file");
            var mixer = CreateMixer(name, stream, speed, volume, false);
            if (mixer == null)
            {
                return null;
            }

            if (!mixer.AddChannel(stem))
            {
                mixer.Dispose();
                return null;
            }
            YargLogger.LogDebug("Custom audio file loaded");
            return mixer;
        }

        internal StemMixer? LoadCustomFile(string file, float speed, double volume, SongStem stem = SongStem.Song)
        {
            var stream = new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
            var mixer = LoadCustomFile(file, stream, speed, volume, stem);
            if (mixer == null)
            {
                YargLogger.LogFormatError("Failed to load audio file{0}!", file);
                stream.Dispose();
                return null;
            }
            return mixer;
        }

        protected internal abstract StemMixer? CreateMixer(string name, float speed, double volume, bool clampStemVolume);

        protected internal abstract StemMixer? CreateMixer(string name, Stream stream, float speed, double volume, bool clampStemVolume);

        protected internal abstract MicDevice? GetInputDevice(string name);

        protected internal abstract List<(int id, string name)> GetAllInputDevices();

        protected internal abstract MicDevice? CreateDevice(int deviceId, string name);

        protected internal abstract void SetMasterVolume(double volume);

        internal void ToggleBuffer(bool enable)
        {
            ToggleBuffer_Internal(enable);
            lock (_activeMixers)
            {
                foreach (var mixer in _activeMixers)
                {
                    mixer.ToggleBuffer(enable);
                }
            }
        }

        internal void SetBufferLength(int length)
        {
            SetBufferLength_Internal(length);
            lock (_activeMixers)
            {
                foreach (var mixer in _activeMixers)
                {
                    mixer.SetBufferLength(length);
                }
            }
        }

        protected abstract void ToggleBuffer_Internal(bool enable);

        protected abstract void SetBufferLength_Internal(int length);

        internal float GlobalSpeed
        {
            get => _globalSpeed;
            set
            {
                if (_disposed || _globalSpeed == value)
                {
                    return;
                }

                _globalSpeed = value;
                lock (_activeMixers)
                {
                    foreach (var mixer in _activeMixers)
                    {
                        mixer.SetSpeed(value, true);
                    }
                }
            }
        }

        /// <summary>
        /// Communicates to the manager that the mixer is already disposed of.
        /// </summary>
        /// <remarks>Should stay limited to the Audio namespace</remarks>
        internal void AddMixer(StemMixer mixer)
        {
            lock (this)
            {
                if (_disposed)
                {
                    mixer.Dispose();
                    return;
                }

                lock (_activeMixers)
                {
                    var level = GlobalAudioHandler.LogMixerStatus ? LogLevel.Debug : LogLevel.Trace;
                    YargLogger.LogFormat(level, "Mixer \"{0}\" created", mixer.Name);
                    _activeMixers.Add(mixer);
                }
            }
        }

        /// <summary>
        /// Communicates to the manager that the mixer is already disposed of.
        /// </summary>
        /// <remarks>Should stay limited to the Audio namespace</remarks>
        internal void RemoveMixer(StemMixer mixer)
        {
            lock (_activeMixers)
            {
                var level = GlobalAudioHandler.LogMixerStatus ? LogLevel.Debug : LogLevel.Trace;
                YargLogger.LogFormat(level, "Mixer \"{0}\" disposed", mixer.Name);
                _activeMixers.Remove(mixer);
            }
        }

        protected virtual void DisposeManagedResources() { }
        protected virtual void DisposeUnmanagedResources() { }

        private void Dispose(bool disposing)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    StemMixer[] mixers;
                    lock (_activeMixers)
                    {
                        mixers = _activeMixers.ToArray();
                    }

                    foreach (var mixer in mixers)
                    {
                        mixer.Dispose();
                    }

                    foreach (var sample in SfxSamples)
                    {
                        sample?.Dispose();
                    }

                    foreach (var sample in DrumSfxSamples)
                    {
                        sample?.Dispose();
                    }

                    if (disposing)
                    {
                        DisposeManagedResources();
                    }
                    DisposeUnmanagedResources();
                    _disposed = true;
                }
            }
        }

        ~AudioManager()
        {
            Dispose(disposing: false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}
</file>

<file path="Audio/DrumSampleChannel.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace YARG.Core.Audio
{
    public abstract class DrumSampleChannel : IDisposable
    {
        public const int ROUND_ROBIN_MAX_INDEX = 3;
        private bool _disposed;

        protected readonly string _path;
        protected readonly int _playbackCount;
        protected double _volume;

        public readonly DrumSfxSample Sample;
        protected DrumSampleChannel(DrumSfxSample sample, string path, int playbackCount)
        {
            Sample = sample;
            _path = path;
            _playbackCount = playbackCount;

            GlobalAudioHandler.StemSettings[SongStem.DrumSfx].OnVolumeChange += SetVolume;
        }

        public void Play(double volume)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    _volume = volume;
                    volume *= GlobalAudioHandler.GetVolumeSetting(SongStem.DrumSfx);
                    SetVolume_Internal(volume);
                    Play_Internal();
                }
            }
        }

        private void SetVolume(double volume)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    volume *= _volume;
                    SetVolume_Internal(volume);
                }
            }
        }

        protected abstract void Play_Internal();
        protected abstract void SetVolume_Internal(double volume);

        protected virtual void DisposeManagedResources() { }
        protected virtual void DisposeUnmanagedResources() { }

        private void Dispose(bool disposing)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    GlobalAudioHandler.StemSettings[SongStem.DrumSfx].OnVolumeChange -= SetVolume;
                    if (disposing)
                    {
                        DisposeManagedResources();
                    }
                    DisposeUnmanagedResources();
                    _disposed = true;
                }
            }
        }

        ~DrumSampleChannel()
        {
            Dispose(disposing: false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}
</file>

<file path="Audio/GlobalAudioHandler.cs">
using System;
using System.Collections.Generic;
using System.IO;

namespace YARG.Core.Audio
{
    public enum AudioFxMode
    {
        Off,
        MultitrackOnly,
        On
    }

    public static class GlobalAudioHandler
    {
        public const int WHAMMY_FFT_DEFAULT = 512;
        public const int WHAMMY_OVERSAMPLE_DEFAULT = 8;
        public static readonly int MAX_THREADS = Environment.ProcessorCount switch
        {
            >= 16 => 16,
            >= 6 => Environment.ProcessorCount / 2,
            _ => 2
        };

        internal static readonly Dictionary<SongStem, StemSettings> StemSettings;

        static GlobalAudioHandler()
        {
            var vocals = new StemSettings();
            var drums = new StemSettings();

            StemSettings = new()
            {
                { SongStem.Song,    new StemSettings() },
                { SongStem.Guitar,  new StemSettings() },
                { SongStem.Bass,    new StemSettings() },
                { SongStem.Rhythm,  new StemSettings() },
                { SongStem.Keys,    new StemSettings() },
                { SongStem.Vocals,  vocals },
                { SongStem.Vocals1, vocals },
                { SongStem.Vocals2, vocals },
                { SongStem.Drums,   drums },
                { SongStem.Drums1,  drums },
                { SongStem.Drums2,  drums },
                { SongStem.Drums3,  drums },
                { SongStem.Drums4,  drums },
                { SongStem.Crowd,   new StemSettings() },
                { SongStem.Sfx,     new StemSettings() },
                { SongStem.DrumSfx, new StemSettings() },
            };
        }

        public static bool LogMixerStatus { get; internal set; }

        public static bool UseWhammyFx;
        public static bool IsChipmunkSpeedup;

        /// <summary>
        /// The number of semitones to bend the pitch by. Must be at least 1;
        /// </summary>
        public static float WhammyPitchShiftAmount = 1f;

        // Not implemented, as changing the FFT size causes BASS_FX to crash
        // /// <summary>
        // /// The size of the whammy FFT buffer. Must be a power of 2, up to 8192.
        // /// </summary>
        // /// <remarks>
        // /// Changes to this value will not be applied until the next song plays.
        // /// </remarks>
        // public int WhammyFFTSize
        // {
        //     get => (int)Math.Pow(2, _whammyFFTSize);
        //     set => _whammyFFTSize = (int)Math.Log(value, 2);
        // }
        // private int _whammyFFTSize = WHAMMY_FFT_DEFAULT;

        /// <summary>
        /// The oversampling factor of the whammy SFX. Must be at least 4.
        /// </summary>
        /// <remarks>
        /// Changes to this value will not be applied until the next song plays.
        /// </remarks>
        public static int WhammyOversampleFactor = WHAMMY_OVERSAMPLE_DEFAULT;

        public static double GetTrueVolume(SongStem stem)
        {
            return StemSettings[stem].TrueVolume;
        }

        public static double GetVolumeSetting(SongStem stem)
        {
            return StemSettings[stem].VolumeSetting;
        }

        public static void SetVolumeSetting(SongStem stem, double volume)
        {
            StemSettings[stem].VolumeSetting = volume;
        }

        public static bool GetReverbSetting(SongStem stem)
        {
            return StemSettings[stem].Reverb;
        }

        public static void SetReverbSetting(SongStem stem, bool reverb)
        {
            StemSettings[stem].Reverb = reverb;
        }

        public static float GetWhammyPitchSetting(SongStem stem)
        {
            return StemSettings[stem].WhammyPitch;
        }

        public static void SetWhammyPitchSetting(SongStem stem, float percent)
        {
            StemSettings[stem].WhammyPitch = percent;
        }

        private static object _instanceLock = new();
        private static AudioManager? _instance;

        public static void Initialize<TAudioManager>()
            where TAudioManager : AudioManager, new()
        {
            // Two locks to allow other things to happen
            lock (_instanceLock)
            {
                if (_instance == null || _instance is not TAudioManager)
                {
                    _instance?.Dispose();
                    _instance = new TAudioManager();
                }
            }
        }

        public static void Close()
        {
            lock (_instanceLock)
            {
                _instance?.Dispose();
                _instance = null;
            }
        }

        private class NotInitializedException : Exception
        {
            public NotInitializedException()
                : base("Audio manager not initialized") { }
        }

        public static ReadOnlySpan<string> SupportedFormats
        {
            get
            {
                lock ( _instanceLock)
                {
                    if (_instance == null)
                    {
                        throw new NotInitializedException();
                    }
                    return _instance.SupportedFormats;
                }
            }
        }

        public static int PlaybackLatency
        {
            get
            {
                lock (_instanceLock)
                {
                    if (_instance == null)
                    {
                        throw new NotInitializedException();
                    }
                    return _instance.PlaybackLatency;
                }
            }
        }

        public static int MinimumBufferLength
        {
            get
            {
                lock (_instanceLock)
                {
                    if (_instance == null)
                    {
                        throw new NotInitializedException();
                    }
                    return _instance.MinimumBufferLength;
                }
            }
        }

        public static int MaximumBufferLength
        {
            get
            {
                lock (_instanceLock)
                {
                    if (_instance == null)
                    {
                        throw new NotInitializedException();
                    }
                    return _instance.MaximumBufferLength;
                }
            }
        }

        public static float GlobalSpeed
        {
            get
            {
                lock (_instanceLock)
                {
                    if (_instance == null)
                    {
                        throw new NotInitializedException();
                    }
                    return _instance.GlobalSpeed;
                }
            }
            set
            {
                lock (_instanceLock)
                {
                    if (_instance == null)
                    {
                        throw new NotInitializedException();
                    }
                    _instance.GlobalSpeed = value;
                }
            }
        }

        public static void PlaySoundEffect(SfxSample sample)
        {
            lock (_instanceLock)
            {
                if (_instance == null)
                {
                    throw new NotInitializedException();
                }
                _instance.SfxSamples[(int) sample]?.Play();
            }
        }

        public static void PlayDrumSoundEffect(DrumSfxSample sample, double volume)
        {
            lock (_instanceLock)
            {
                if (_instance == null)
                {
                    throw new NotInitializedException();
                }
                _instance.DrumSfxSamples[(int) sample]?.Play(volume);
            }
        }

        public static StemMixer? LoadCustomFile(string name, Stream stream, float speed, double volume, SongStem stem = SongStem.Song)
        {
            lock (_instanceLock)
            {
                if (_instance == null)
                {
                    throw new NotInitializedException();
                }
                return _instance.LoadCustomFile(name, stream, speed, volume, stem);
            }
        }

        public static StemMixer? LoadCustomFile(string file, float speed, double volume, SongStem stem = SongStem.Song)
        {
            lock (_instanceLock)
            {
                if (_instance == null)
                {
                    throw new NotInitializedException();
                }
                return _instance.LoadCustomFile(file, speed, volume, stem);
            }
        }

        public static StemMixer? CreateMixer(string name, float speed, double mixerVolume, bool clampStemVolume)
        {
            lock (_instanceLock)
            {
                if (_instance == null)
                {
                    throw new NotInitializedException();
                }
                return _instance.CreateMixer(name, speed, mixerVolume, clampStemVolume);
            }
        }

        public static StemMixer? CreateMixer(string name, Stream stream, float speed, double mixerVolume, bool clampStemVolume)
        {
            lock (_instanceLock)
            {
                if (_instance == null)
                {
                    throw new NotInitializedException();
                }
                return _instance.CreateMixer(name, stream, speed, mixerVolume, clampStemVolume);
            }
        }

        public static MicDevice? GetInputDevice(string name)
        {
            lock (_instanceLock)
            {
                if (_instance == null)
                {
                    throw new NotInitializedException();
                }
                return _instance.GetInputDevice(name);
            }
        }

        public static List<(int id, string name)> GetAllInputDevices()
        {
            lock (_instanceLock)
            {
                if (_instance == null)
                {
                    throw new NotInitializedException();
                }
                return _instance.GetAllInputDevices();
            }
        }

        public static MicDevice? CreateDevice(int deviceId, string name)
        {
            lock (_instanceLock)
            {
                if (_instance == null)
                {
                    throw new NotInitializedException();
                }
                return _instance.CreateDevice(deviceId, name);
            }
        }

        public static void SetMasterVolume(double volume)
        {
            lock (_instanceLock)
            {
                if (_instance == null)
                {
                    throw new NotInitializedException();
                }
                _instance.SetMasterVolume(volume);
            }
        }

        public static void TogglePlaybackBuffer(bool enable)
        {
            lock (_instanceLock)
            {
                if (_instance == null)
                {
                    throw new NotInitializedException();
                }
                _instance.ToggleBuffer(enable);
            }
        }

        public static void SetBufferLength(int length)
        {
            lock (_instanceLock)
            {
                if (_instance == null)
                {
                    throw new NotInitializedException();
                }
                _instance.SetBufferLength(length);
            }
        }
    }
}
</file>

<file path="Audio/MicDevice.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace YARG.Core.Audio
{
    public readonly struct MicOutputFrame
    {
        /// <summary>
        /// The time of the input. This is NOT relative!
        /// </summary>
        public readonly double Time;

        /// <summary>
        /// Whether or not this output frame is a mic hit, or a sing output.
        /// </summary>
        public readonly bool IsHit;

        /// <summary>
        /// Pitch (in hertz) of the microphone.
        /// </summary>
        public readonly float Pitch;

        /// <summary>
        /// Volume (in dB) of the microphone.
        /// </summary>
        public readonly float Volume;

        /// <summary>
        /// Gets the pitch as a MIDI note.
        /// </summary>
        public float PitchAsMidiNote => 12f * MathF.Log(Pitch / 440f, 2f) + 69f;

        public MicOutputFrame(double time, bool isHit, float pitch, float volume)
        {
            Time = time;
            IsHit = isHit;
            Pitch = pitch;
            Volume = volume;
        }
    }

    public abstract class MicDevice : IDisposable
    {
        public const int RECORD_PERIOD_MS = 40;
        public const float UPDATES_PER_SECOND = 1000f / RECORD_PERIOD_MS;

        private bool _disposed;

        public readonly string DisplayName;
        public bool IsMonitoring;
        public bool IsRecordingOutput;

        protected MicDevice(string displayName)
        {
            DisplayName = displayName;
        }

        /// <summary>
        /// Resets the microphone streams and clears all buffers.
        /// </summary>
        /// <returns>0 if successful, otherwise an error code.</returns>
        public abstract int Reset();

        /// <summary>
        /// Dequeues an output frame from the microphone.
        /// </summary>
        /// <returns>
        /// Whether the dequeue was successful.
        /// </returns>
        public abstract bool DequeueOutputFrame(out MicOutputFrame frame);

        /// <summary>
        /// Clears the output queue.
        /// </summary>
        public abstract void ClearOutputQueue();

        /// <summary>
        /// Set the monitoring level of this Microphone Device.
        /// </summary>
        /// <param name="volume">The volume to set to.</param>
        public abstract void SetMonitoringLevel(float volume);

        /// <summary>
        /// Converts this microphone into its serialized form.
        /// </summary>
        public abstract SerializedMic Serialize();

        protected virtual void DisposeManagedResources() { }
        protected virtual void DisposeUnmanagedResources() { }

        private void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    DisposeManagedResources();
                }
                DisposeUnmanagedResources();
                _disposed = true;
            }
        }

        ~MicDevice()
        {
            Dispose(disposing: false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}
</file>

<file path="Audio/PreviewContext.cs">
using System;
using System.Threading.Tasks;
using System.Threading;
using YARG.Core.Logging;
using YARG.Core.Song;
using System.Diagnostics;

namespace YARG.Core.Audio
{
    public class PreviewContext : IDisposable
    {
        private const double DEFAULT_PREVIEW_DURATION = 30.0;
        private const double DEFAULT_START_TIME = 20.0;
        private const double DEFAULT_END_TIME = 50.0;

        public static async Task<PreviewContext?> Create(SongEntry entry, float volume, float speed, double delaySeconds, double fadeDuration, CancellationTokenSource token)
        {
            try
            {
                if (delaySeconds > 0)
                {
                    await Task.Delay(TimeSpan.FromSeconds(delaySeconds));
                }

                // Check if cancelled
                if (token.IsCancellationRequested)
                {
                    return null;
                }

                // Load the song
                var mixer = await Task.Run(() => entry.LoadPreviewAudio(speed));
                if (mixer == null || token.IsCancellationRequested)
                {
                    mixer?.Dispose();
                    return null;
                }

                double previewLength = mixer.Length;
                double previewStartTime = 0;
                if (mixer.Channels.Count > 0)
                {
                    double previewEndTime;
                    if ((entry.PreviewStartMilliseconds < 0 || entry.PreviewStartSeconds >= previewLength)
                    &&  (entry.PreviewEndMilliseconds <= 0  || entry.PreviewEndSeconds > previewLength))
                    {
                        if (DEFAULT_END_TIME <= previewLength)
                        {
                            previewStartTime = DEFAULT_START_TIME;
                            previewEndTime = DEFAULT_END_TIME;
                        }
                        else if (DEFAULT_PREVIEW_DURATION <= previewLength)
                        {
                            previewStartTime = (previewLength - DEFAULT_PREVIEW_DURATION) / 2;
                            previewEndTime = previewStartTime + DEFAULT_PREVIEW_DURATION;
                        }
                        else
                        {
                            previewStartTime = 0;
                            previewEndTime = previewLength;
                        }
                    }
                    else if (0 <= entry.PreviewStartSeconds && entry.PreviewStartSeconds < previewLength)
                    {
                        previewStartTime = entry.PreviewStartSeconds;
                        previewEndTime = entry.PreviewEndSeconds;
                        if (previewEndTime <= previewStartTime)
                        {
                            previewEndTime = previewStartTime + DEFAULT_PREVIEW_DURATION;
                        }

                        if (previewEndTime > previewLength)
                        {
                            previewEndTime = previewLength;
                        }
                    }
                    else
                    {
                        previewEndTime = entry.PreviewEndSeconds;
                        previewStartTime = previewEndTime - DEFAULT_PREVIEW_DURATION;
                        if (previewStartTime < 0)
                        {
                            previewStartTime = 0;
                        }
                    }
                    previewLength = previewEndTime - previewStartTime;
                }
                
                if (fadeDuration > previewLength / 4)
                {
                    fadeDuration = previewLength / 4;
                }
                return new PreviewContext(mixer, previewStartTime, previewLength, fadeDuration, volume, token);
            }
            catch (Exception ex)
            {
                YargLogger.LogException(ex, "Error while loading song preview!");
                return null;
            }
        }

        private StemMixer _mixer;
        private Task _task;
        private readonly double _previewStartTime;
        private readonly double _previewLength;
        private readonly double _fadeDruation;
        private readonly float _volume;
        private readonly CancellationTokenSource _token;
        private bool _disposed;

        private PreviewContext(StemMixer mixer, double previewStartTime, double previewLength, double fadeDuration, float volume, CancellationTokenSource token)
        {
            _mixer = mixer;
            _previewStartTime = previewStartTime;
            _previewLength = previewLength;
            _fadeDruation = fadeDuration;
            _volume = volume;
            _token = token;

            _task = Task.Run(Loop);
        }

        public async void Stop()
        {
            _token.Cancel();
            await _task;
        }

        private async void Loop()
        {
            try
            {
                var watch = new Stopwatch();
                while (true)
                {
                    _mixer.SetPosition(_previewStartTime);
                    _mixer.FadeIn(_volume, _fadeDruation);
                    _mixer.Play(true);
                    watch.Restart();
                    while (watch.Elapsed.TotalSeconds < _previewLength - _fadeDruation && !_token.IsCancellationRequested)
                    {
                        if (_disposed)
                        {
                            return;
                        }
                        await Task.Delay(1);
                    }

                    watch.Restart();
                    _mixer.FadeOut(_fadeDruation);
                    while (watch.Elapsed.TotalSeconds < _fadeDruation)
                    {
                        if (_disposed)
                        {
                            return;
                        }
                        await Task.Delay(1);
                    }

                    _mixer.Pause();
                    if (_token.IsCancellationRequested)
                    {
                        Dispose();
                        return;
                    }
                }
            }
            catch (Exception ex)
            {
                YargLogger.LogException(ex, "Error while looping song preview!");
            }
        }

        private void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                _disposed = true;
                if (disposing)
                {
                    _mixer.Dispose();
                }
            }
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}
</file>

<file path="Audio/SampleChannel.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace YARG.Core.Audio
{
    public abstract class SampleChannel : IDisposable
    {
        protected const double PLAYBACK_SUPPRESS_THRESHOLD = 0.05f;
        private bool _disposed;

        protected readonly string _path;
        protected readonly int _playbackCount;

        public readonly SfxSample Sample;
        protected SampleChannel(SfxSample sample, string path, int playbackCount)
        {
            Sample = sample;
            _path = path;
            _playbackCount = playbackCount;

            GlobalAudioHandler.StemSettings[SongStem.Sfx].OnVolumeChange += SetVolume;
        }

        public void Play()
        {
            lock (this)
            {
                if (!_disposed)
                {
                    Play_Internal();
                }
            }
        }

        private void SetVolume(double volume)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    SetVolume_Internal(volume);
                }
            }
        }

        protected abstract void Play_Internal();
        protected abstract void SetVolume_Internal(double volume);

        protected virtual void DisposeManagedResources() { }
        protected virtual void DisposeUnmanagedResources() { }

        private void Dispose(bool disposing)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    GlobalAudioHandler.StemSettings[SongStem.Sfx].OnVolumeChange -= SetVolume;
                    if (disposing)
                    {
                        DisposeManagedResources();
                    }
                    DisposeUnmanagedResources();
                    _disposed = true;
                }
            }
        }

        ~SampleChannel()
        {
            Dispose(disposing: false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}
</file>

<file path="Audio/SerializedMic.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace YARG.Core.Audio
{
    public class SerializedMic
    {
        public readonly string Name;
        public SerializedMic(string name)
        {
            Name = name;
        }
    }
}
</file>

<file path="Audio/StemChannel.cs">
using System;

namespace YARG.Core.Audio
{
    public abstract class StemChannel : IDisposable
    {
        public const double MINIMUM_STEM_VOLUME = 0.15;

        private bool _disposed;

        private readonly bool _clampVolume;
        protected readonly AudioManager _manager;
        public readonly SongStem Stem;

        protected StemChannel(AudioManager manager, SongStem stem, bool clampVolume)
        {
            _clampVolume = clampVolume;
            _manager = manager;
            Stem = stem;

            var settings = GlobalAudioHandler.StemSettings[Stem];
            settings.OnVolumeChange += SetVolume;
            settings.OnReverbChange += SetReverb;
            settings.OnWhammyPitchChange += SetWhammyPitch;
        }

        public void SetWhammyPitch(float percent)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    SetWhammyPitch_Internal(percent);
                }
            }
        }

        public void SetPosition(double position)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    SetPosition_Internal(position);
                }
            }
        }

        public void SetSpeed(float speed, bool shiftPitch)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    SetSpeed_Internal(speed, shiftPitch);
                }
            }
        }

        private void SetVolume(double volume)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    if (_clampVolume && volume < MINIMUM_STEM_VOLUME)
                    {
                        volume = MINIMUM_STEM_VOLUME;
                    }
                    SetVolume_Internal(volume);
                }
            }
        }

        private void SetReverb(bool reverb)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    SetReverb_Internal(reverb);
                }
            }
        }

        protected abstract void SetWhammyPitch_Internal(float percent);
        protected abstract void SetPosition_Internal(double position);
        protected abstract void SetSpeed_Internal(float speed, bool shiftPitch);

        protected abstract void SetVolume_Internal(double newVolume);
        protected abstract void SetReverb_Internal(bool reverb);

        protected virtual void DisposeManagedResources() { }
        protected virtual void DisposeUnmanagedResources() { }

        private void Dispose(bool disposing)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    GlobalAudioHandler.StemSettings[Stem].OnVolumeChange -= SetVolume;
                    if (disposing)
                    {
                        DisposeManagedResources();
                    }
                    DisposeUnmanagedResources();
                    _disposed = true;
                }
            }
        }

        ~StemChannel()
        {
            Dispose(disposing: false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}
</file>

<file path="Audio/StemMixer.cs">
using System;
using System.Collections.Generic;
using System.IO;

namespace YARG.Core.Audio
{
    public abstract class StemMixer : IDisposable
    {
        private bool _disposed;
        private bool _isPaused = true;

        protected readonly AudioManager _manager;
        protected readonly List<StemChannel> _channels = new();
        protected readonly bool _clampStemVolume;

        protected double _length;
        protected Action? _songEnd;

        public readonly string Name;

        public double Length => _length;
        public IReadOnlyList<StemChannel> Channels => _channels;
        public bool IsPaused => _isPaused;

        public abstract event Action SongEnd;

        protected StemMixer(string name, AudioManager manager,bool clampStemVolume)
        {
            Name = name;
            _manager = manager;
            _clampStemVolume = clampStemVolume;

            _manager.AddMixer(this);
        }

        public StemChannel? this[SongStem stem] => _channels.Find(x => x.Stem == stem);

        public int Play(bool restartBuffer)
        {
            lock (this)
            {
                if (_disposed)
                {
                    return -1;
                }

                int ret = Play_Internal(restartBuffer);
                if (ret != 0)
                {
                    return ret;
                }
                _isPaused = false;
                return 0;
            }
        }

        public void FadeIn(double maxVolume, double duration)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    FadeIn_Internal(maxVolume, duration);
                }
            }
        }
        public void FadeOut(double duration)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    FadeOut_Internal(duration);
                }
            }
        }

        public int Pause()
        {
            lock (this)
            {
                if (_disposed)
                {
                    return -1;
                }

                int ret = Pause_Internal();
                if (ret != 0)
                {
                    return ret;
                }
                _isPaused = true;
                return 0;
            }
        }

        public double GetPosition()
        {
            lock (this)
            {
                if (_disposed)
                {
                    return 0;
                }
                return GetPosition_Internal();
            }
        }

        public double GetVolume()
        {
            lock (this)
            {
                if (_disposed)
                {
                    return 0;
                }
                return GetVolume_Internal();
            }
        }
        public void SetPosition(double position)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    SetPosition_Internal(position);
                }
            }
        }

        public void SetVolume(double volume)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    SetVolume_Internal(volume);
                }
            }
        }


        /// <summary>
        /// Get FFT Data
        /// <paramref name="fftSize"/> is log2 of the number of samples to process
        /// eg with <paramref name="fftSize"/> equal to 9, 512 samples will be processed
        /// The number of bytes read from the channel (to perform the FFT) is returned
        /// Data is returned as a float in [0; 1] range
        /// The 1st bin contains the DC component, the 2nd contains the amplitude at 1/2048 of the channel's sample rate, followed by the amplitude at 2/2048, 3/2048, etc.
        /// with complex == false only real part of FFT is returned
        /// and (1 << fftSize) / 2 values are filled (the magnitudes of the first half of an FFT result are returned)
        /// with complex == true
        /// Return the complex FFT result rather than the magnitudes. This increases the amount of data returned (as listed above) fourfold, as it returns real and imaginary parts and the full FFT result (not only the first half). The real and imaginary parts are interleaved in the returned data. 
        /// </summary>
        public int GetFFTData(float[] buffer, int fftSize, bool complex)
        {
            lock (this)
            {
                if (_disposed)
                {
                    return -1;
                }
                return GetFFTData_Internal(buffer, fftSize, complex);
            }
        }

        /// Get sample data
        /// returned floats are in [-1; 1] range
        /// returns value of bytes read from a channel
        public int GetSampleData(float[] buffer)
        {
            lock (this)
            {
                if (_disposed)
                {
                    return -1;
                }
                return GetSampleData_Internal(buffer);
            }
        }

        public void SetSpeed(float speed, bool shiftPitch)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    SetSpeed_Internal(speed, shiftPitch);
                }
            }
        }

        public bool AddChannel(SongStem stem)
        {
            lock (this)
            {
                if (_disposed)
                {
                    return false;
                }
                return AddChannel_Internal(stem);
            }
        }

        public bool AddChannel(SongStem stem, Stream stream)
        {
            lock (this)
            {
                if (_disposed)
                {
                    return false;
                }
                return AddChannel_Internal(stem, stream);
            }
        }

        public bool AddChannel(SongStem stem, int[] indices, float[] panning)
        {
            lock (this)
            {
                if (_disposed)
                {
                    return false;
                }
                return AddChannel_Internal(stem, indices, panning);
            }
        }

        public bool RemoveChannel(SongStem stemToRemove)
        {
            lock (this)
            {
                if (_disposed)
                {
                    return false;
                }
                return RemoveChannel_Internal(stemToRemove);
            }
        }

        internal void ToggleBuffer(bool enable)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    ToggleBuffer_Internal(enable);
                }
            }
        }

        internal void SetBufferLength(int length)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    SetBufferLength_Internal(length);
                }
            }
        }

        protected abstract int Play_Internal(bool restartBuffer);
        protected abstract void FadeIn_Internal(double maxVolume, double duration);
        protected abstract void FadeOut_Internal(double duration);
        protected abstract int Pause_Internal();
        protected abstract double GetPosition_Internal();
        protected abstract double GetVolume_Internal();
        protected abstract void SetPosition_Internal(double position);
        protected abstract void SetVolume_Internal(double volume);
        protected abstract int  GetSampleData_Internal(float[] buffer);
        protected abstract int  GetFFTData_Internal(float[] buffer, int fftSize, bool complex);
        protected abstract void SetSpeed_Internal(float speed, bool shiftPitch);
        protected abstract bool AddChannel_Internal(SongStem stem);
        protected abstract bool AddChannel_Internal(SongStem stem, Stream stream);
        protected abstract bool AddChannel_Internal(SongStem stem, int[] indices, float[] panning);
        protected abstract bool RemoveChannel_Internal(SongStem stemToRemove);
        protected abstract void ToggleBuffer_Internal(bool enable);
        protected abstract void SetBufferLength_Internal(int length);

        protected virtual void DisposeManagedResources() { }
        protected virtual void DisposeUnmanagedResources() { }

        private void Dispose(bool disposing)
        {
            lock (this)
            {
                if (!_disposed)
                {
                    Pause();
                    _songEnd = null;
                    if (disposing)
                    {
                        DisposeManagedResources();
                    }
                    DisposeUnmanagedResources();
                    _manager.RemoveMixer(this);
                    _disposed = true;
                }
            }
        }

        ~StemMixer()
        {
            Dispose(disposing: false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }
    }
}
</file>

<file path="Audio/StemSettings.cs">
using System;

namespace YARG.Core.Audio
{
    public class StemSettings
    {
        public static bool ApplySettings = true;

        private Action<double>? _onVolumeChange;
        private Action<bool>? _onReverbChange;
        private Action<float>? _onWhammyPitchChange;
        private double _volume;
        private bool _reverb;
        private float _whammyPitch;

        public StemSettings()
        {
            _volume = 1;
        }

        public event Action<double> OnVolumeChange
        {
            add { _onVolumeChange += value; }
            remove { _onVolumeChange -= value; }
        }

        public event Action<bool> OnReverbChange
        {
            add { _onReverbChange += value; }
            remove { _onReverbChange -= value; }
        }

        public event Action<float> OnWhammyPitchChange
        {
            add { _onWhammyPitchChange += value; }
            remove { _onWhammyPitchChange -= value; }
        }

        public double VolumeSetting
        {
            get => _volume;
            set
            {
                _volume = Math.Clamp(value, 0, 1);
                _onVolumeChange?.Invoke(TrueVolume);
            }
        }

        public double TrueVolume => (ApplySettings ? _volume : 1);

        public bool Reverb
        {
            get => _reverb;
            set
            {
                if (value != _reverb)
                {
                    _reverb = value;
                    _onReverbChange?.Invoke(value);
                }
            }
        }

        public float WhammyPitch
        {
            get => _whammyPitch;
            set
            {
                value = Math.Clamp(value, 0, 1);
                if (value != _whammyPitch)
                {
                    _whammyPitch = value;
                    _onWhammyPitchChange?.Invoke(value);
                }
            }
        }
    }
}
</file>

<file path="bin/Debug/netstandard2.1/YARG.Core.deps.json">
{
  "runtimeTarget": {
    "name": ".NETStandard,Version=v2.1/",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETStandard,Version=v2.1": {},
    ".NETStandard,Version=v2.1/": {
      "YARG.Core/1.0.0": {
        "dependencies": {
          "Melanchall.DryWetMidi.Nativeless": "7.0.0",
          "Newtonsoft.Json": "13.0.3",
          "PolySharp": "1.13.2",
          "System.Runtime.CompilerServices.Unsafe": "6.0.0",
          "ZString": "2.5.1"
        },
        "runtime": {
          "YARG.Core.dll": {}
        }
      },
      "Melanchall.DryWetMidi.Nativeless/7.0.0": {
        "runtime": {
          "lib/netstandard2.0/Melanchall.DryWetMidi.dll": {
            "assemblyVersion": "7.0.0.0",
            "fileVersion": "7.0.0.0"
          }
        }
      },
      "Newtonsoft.Json/13.0.3": {
        "runtime": {
          "lib/netstandard2.0/Newtonsoft.Json.dll": {
            "assemblyVersion": "13.0.0.0",
            "fileVersion": "13.0.3.27908"
          }
        }
      },
      "PolySharp/1.13.2": {},
      "System.Runtime.CompilerServices.Unsafe/6.0.0": {
        "runtime": {
          "lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.dll": {
            "assemblyVersion": "6.0.0.0",
            "fileVersion": "6.0.21.52210"
          }
        }
      },
      "ZString/2.5.1": {
        "dependencies": {
          "System.Runtime.CompilerServices.Unsafe": "6.0.0"
        },
        "runtime": {
          "lib/netstandard2.1/ZString.dll": {
            "assemblyVersion": "2.5.1.0",
            "fileVersion": "2.5.1.0"
          }
        }
      }
    }
  },
  "libraries": {
    "YARG.Core/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Melanchall.DryWetMidi.Nativeless/7.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-85PE2K7X/4gHKfQOlAN32qNesYEoyBDSFHc+8O7s2q6fqgwSOipDveZI8D3cvtkVEKg/JfIadObEJHwTMvMuog==",
      "path": "melanchall.drywetmidi.nativeless/7.0.0",
      "hashPath": "melanchall.drywetmidi.nativeless.7.0.0.nupkg.sha512"
    },
    "Newtonsoft.Json/13.0.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-HrC5BXdl00IP9zeV+0Z848QWPAoCr9P3bDEZguI+gkLcBKAOxix/tLEAAHC+UvDNPv4a2d18lOReHMOagPa+zQ==",
      "path": "newtonsoft.json/13.0.3",
      "hashPath": "newtonsoft.json.13.0.3.nupkg.sha512"
    },
    "PolySharp/1.13.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-XwNhfkr7IeUiH8AE4pzob8YioxfL6nxgAx+fHEeWCObY/NZuBMfWLh39FznXbneKvagiqeeI7quIvZ6P1eVaEA==",
      "path": "polysharp/1.13.2",
      "hashPath": "polysharp.1.13.2.nupkg.sha512"
    },
    "System.Runtime.CompilerServices.Unsafe/6.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-/iUeP3tq1S0XdNNoMz5C9twLSrM/TH+qElHkXWaPvuNOt+99G75NrV0OS2EqHx5wMN7popYjpc8oTjC1y16DLg==",
      "path": "system.runtime.compilerservices.unsafe/6.0.0",
      "hashPath": "system.runtime.compilerservices.unsafe.6.0.0.nupkg.sha512"
    },
    "ZString/2.5.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-hHZnrIZAgda8j9n2gR4M7GbETcjr6EBo4CUnMtK8o2MgkgzARg+Y7XI142nNOpRRuup1LJb12/gd/tMhzwdw8g==",
      "path": "zstring/2.5.1",
      "hashPath": "zstring.2.5.1.nupkg.sha512"
    }
  }
}
</file>

<file path="bin/Release/netstandard2.1/publish/YARG.Core.deps.json">
{
  "runtimeTarget": {
    "name": ".NETStandard,Version=v2.1/",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETStandard,Version=v2.1": {},
    ".NETStandard,Version=v2.1/": {
      "YARG.Core/1.0.0": {
        "dependencies": {
          "Melanchall.DryWetMidi.Nativeless": "7.0.0",
          "Newtonsoft.Json": "13.0.3",
          "PolySharp": "1.13.2",
          "System.Runtime.CompilerServices.Unsafe": "6.0.0",
          "ZString": "2.5.1"
        },
        "runtime": {
          "YARG.Core.dll": {}
        }
      },
      "Melanchall.DryWetMidi.Nativeless/7.0.0": {
        "runtime": {
          "lib/netstandard2.0/Melanchall.DryWetMidi.dll": {
            "assemblyVersion": "7.0.0.0",
            "fileVersion": "7.0.0.0"
          }
        }
      },
      "Newtonsoft.Json/13.0.3": {
        "runtime": {
          "lib/netstandard2.0/Newtonsoft.Json.dll": {
            "assemblyVersion": "13.0.0.0",
            "fileVersion": "13.0.3.27908"
          }
        }
      },
      "PolySharp/1.13.2": {},
      "System.Runtime.CompilerServices.Unsafe/6.0.0": {
        "runtime": {
          "lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.dll": {
            "assemblyVersion": "6.0.0.0",
            "fileVersion": "6.0.21.52210"
          }
        }
      },
      "ZString/2.5.1": {
        "dependencies": {
          "System.Runtime.CompilerServices.Unsafe": "6.0.0"
        },
        "runtime": {
          "lib/netstandard2.1/ZString.dll": {
            "assemblyVersion": "2.5.1.0",
            "fileVersion": "2.5.1.0"
          }
        }
      }
    }
  },
  "libraries": {
    "YARG.Core/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Melanchall.DryWetMidi.Nativeless/7.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-85PE2K7X/4gHKfQOlAN32qNesYEoyBDSFHc+8O7s2q6fqgwSOipDveZI8D3cvtkVEKg/JfIadObEJHwTMvMuog==",
      "path": "melanchall.drywetmidi.nativeless/7.0.0",
      "hashPath": "melanchall.drywetmidi.nativeless.7.0.0.nupkg.sha512"
    },
    "Newtonsoft.Json/13.0.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-HrC5BXdl00IP9zeV+0Z848QWPAoCr9P3bDEZguI+gkLcBKAOxix/tLEAAHC+UvDNPv4a2d18lOReHMOagPa+zQ==",
      "path": "newtonsoft.json/13.0.3",
      "hashPath": "newtonsoft.json.13.0.3.nupkg.sha512"
    },
    "PolySharp/1.13.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-XwNhfkr7IeUiH8AE4pzob8YioxfL6nxgAx+fHEeWCObY/NZuBMfWLh39FznXbneKvagiqeeI7quIvZ6P1eVaEA==",
      "path": "polysharp/1.13.2",
      "hashPath": "polysharp.1.13.2.nupkg.sha512"
    },
    "System.Runtime.CompilerServices.Unsafe/6.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-/iUeP3tq1S0XdNNoMz5C9twLSrM/TH+qElHkXWaPvuNOt+99G75NrV0OS2EqHx5wMN7popYjpc8oTjC1y16DLg==",
      "path": "system.runtime.compilerservices.unsafe/6.0.0",
      "hashPath": "system.runtime.compilerservices.unsafe.6.0.0.nupkg.sha512"
    },
    "ZString/2.5.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-hHZnrIZAgda8j9n2gR4M7GbETcjr6EBo4CUnMtK8o2MgkgzARg+Y7XI142nNOpRRuup1LJb12/gd/tMhzwdw8g==",
      "path": "zstring/2.5.1",
      "hashPath": "zstring.2.5.1.nupkg.sha512"
    }
  }
}
</file>

<file path="bin/Release/netstandard2.1/YARG.Core.deps.json">
{
  "runtimeTarget": {
    "name": ".NETStandard,Version=v2.1/",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETStandard,Version=v2.1": {},
    ".NETStandard,Version=v2.1/": {
      "YARG.Core/1.0.0": {
        "dependencies": {
          "Melanchall.DryWetMidi.Nativeless": "7.0.0",
          "Newtonsoft.Json": "13.0.3",
          "PolySharp": "1.13.2",
          "System.Runtime.CompilerServices.Unsafe": "6.0.0",
          "ZString": "2.5.1"
        },
        "runtime": {
          "YARG.Core.dll": {}
        }
      },
      "Melanchall.DryWetMidi.Nativeless/7.0.0": {
        "runtime": {
          "lib/netstandard2.0/Melanchall.DryWetMidi.dll": {
            "assemblyVersion": "7.0.0.0",
            "fileVersion": "7.0.0.0"
          }
        }
      },
      "Newtonsoft.Json/13.0.3": {
        "runtime": {
          "lib/netstandard2.0/Newtonsoft.Json.dll": {
            "assemblyVersion": "13.0.0.0",
            "fileVersion": "13.0.3.27908"
          }
        }
      },
      "PolySharp/1.13.2": {},
      "System.Runtime.CompilerServices.Unsafe/6.0.0": {
        "runtime": {
          "lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.dll": {
            "assemblyVersion": "6.0.0.0",
            "fileVersion": "6.0.21.52210"
          }
        }
      },
      "ZString/2.5.1": {
        "dependencies": {
          "System.Runtime.CompilerServices.Unsafe": "6.0.0"
        },
        "runtime": {
          "lib/netstandard2.1/ZString.dll": {
            "assemblyVersion": "2.5.1.0",
            "fileVersion": "2.5.1.0"
          }
        }
      }
    }
  },
  "libraries": {
    "YARG.Core/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Melanchall.DryWetMidi.Nativeless/7.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-85PE2K7X/4gHKfQOlAN32qNesYEoyBDSFHc+8O7s2q6fqgwSOipDveZI8D3cvtkVEKg/JfIadObEJHwTMvMuog==",
      "path": "melanchall.drywetmidi.nativeless/7.0.0",
      "hashPath": "melanchall.drywetmidi.nativeless.7.0.0.nupkg.sha512"
    },
    "Newtonsoft.Json/13.0.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-HrC5BXdl00IP9zeV+0Z848QWPAoCr9P3bDEZguI+gkLcBKAOxix/tLEAAHC+UvDNPv4a2d18lOReHMOagPa+zQ==",
      "path": "newtonsoft.json/13.0.3",
      "hashPath": "newtonsoft.json.13.0.3.nupkg.sha512"
    },
    "PolySharp/1.13.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-XwNhfkr7IeUiH8AE4pzob8YioxfL6nxgAx+fHEeWCObY/NZuBMfWLh39FznXbneKvagiqeeI7quIvZ6P1eVaEA==",
      "path": "polysharp/1.13.2",
      "hashPath": "polysharp.1.13.2.nupkg.sha512"
    },
    "System.Runtime.CompilerServices.Unsafe/6.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-/iUeP3tq1S0XdNNoMz5C9twLSrM/TH+qElHkXWaPvuNOt+99G75NrV0OS2EqHx5wMN7popYjpc8oTjC1y16DLg==",
      "path": "system.runtime.compilerservices.unsafe/6.0.0",
      "hashPath": "system.runtime.compilerservices.unsafe.6.0.0.nupkg.sha512"
    },
    "ZString/2.5.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-hHZnrIZAgda8j9n2gR4M7GbETcjr6EBo4CUnMtK8o2MgkgzARg+Y7XI142nNOpRRuup1LJb12/gd/tMhzwdw8g==",
      "path": "zstring/2.5.1",
      "hashPath": "zstring.2.5.1.nupkg.sha512"
    }
  }
}
</file>

<file path="Chart/Events/ChartEvent.cs">
namespace YARG.Core.Chart
{
    /// <summary>
    /// A general event that occurs in a chart: notes, phrases, text events, etc.
    /// </summary>
    public abstract class ChartEvent
    {
        public double Time       { get; set; }
        public double TimeLength { get; set; }
        public double TimeEnd    => Time + TimeLength;

        public uint Tick       { get; set; }
        public uint TickLength { get; set; }
        public uint TickEnd    => Tick + TickLength;

        // For subclasses that set the base properties through other parameters
        public ChartEvent() {}

        public ChartEvent(double time, double timeLength, uint tick, uint tickLength)
        {
            Time = time;
            TimeLength = timeLength;
            Tick = tick;
            TickLength = tickLength;
        }

        public ChartEvent(ChartEvent other)
            : this(other.Time, other.TimeLength, other.Tick, other.TickLength)
        {
        }

        protected bool Equals(ChartEvent other)
        {
            return Time == other.Time &&
                TimeLength == other.TimeLength &&
                Tick == other.Tick &&
                TickLength == other.TickLength;
        }
    }
}
</file>

<file path="Chart/Events/ChartEventExtensions.cs">
using System;
using System.Collections.Generic;
using YARG.Core.Extensions;

namespace YARG.Core.Chart
{
    public static class ChartEventExtensions
    {
        public static List<TNote> DuplicateNotes<TNote>(this List<TNote> notes)
            where TNote : Note<TNote>
        {
            int count = notes.Count;
            var newNotes = new List<TNote>(count);
            if (count < 1)
                return newNotes;

            // Clone first note separately so we can link everything together
            var previousNote = notes[0].Clone();
            newNotes.Add(previousNote);

            // Clone the rest
            for (int i = 1; i < notes.Count; i++)
            {
                var newNote = notes[i].Clone();

                // Assign forward/backward references
                newNote.PreviousNote = previousNote;
                foreach (var child in newNote.ChildNotes)
                    child.PreviousNote = previousNote;

                previousNote.NextNote = newNote;
                foreach (var child in previousNote.ChildNotes)
                    child.NextNote = newNote;

                // Add note to list
                newNotes.Add(newNote);
                previousNote = newNote;
            }

            return newNotes;
        }

        public static double GetStartTime<TEvent>(this List<TEvent> events)
            where TEvent : ChartEvent
        {
            if (events.Count < 1)
                return 0;

            // Chart events are sorted
            var chartEvent = events[0];
            return chartEvent.Time;
        }

        public static double GetEndTime<TEvent>(this List<TEvent> events)
            where TEvent : ChartEvent
        {
            if (events.Count < 1)
                return 0;

            // Chart events are sorted
            var chartEvent = events[^1];
            return chartEvent.TimeEnd;
        }

        public static uint GetFirstTick<TEvent>(this List<TEvent> events)
            where TEvent : ChartEvent
        {
            if (events.Count < 1)
                return 0;

            // Chart events are sorted
            var chartEvent = events[0];
            return chartEvent.Tick;
        }

        public static uint GetLastTick<TEvent>(this List<TEvent> events)
            where TEvent : ChartEvent
        {
            if (events.Count < 1)
                return 0;

            // Chart events are sorted
            var chartEvent = events[^1];
            return chartEvent.TickEnd;
        }

        public static TEvent? GetPrevious<TEvent>(this List<TEvent> events, double time)
            where TEvent : ChartEvent
        {
            int index = GetIndexOfPrevious(events, time);
            if (index < 0)
                return null;

            return events[index];
        }

        public static TEvent? GetPrevious<TEvent>(this List<TEvent> events, uint tick)
            where TEvent : ChartEvent
        {
            int index = GetIndexOfPrevious(events, tick);
            if (index < 0)
                return null;

            return events[index];
        }

        public static TEvent? GetNext<TEvent>(this List<TEvent> events, double time)
            where TEvent : ChartEvent
        {
            int index = GetIndexOfNext(events, time);
            if (index < 0)
                return null;

            return events[index];
        }

        public static TEvent? GetNext<TEvent>(this List<TEvent> events, uint tick)
            where TEvent : ChartEvent
        {
            int index = GetIndexOfNext(events, tick);
            if (index < 0)
                return null;

            return events[index];
        }

        public static int GetIndexOfPrevious<TEvent>(this List<TEvent> events, double time)
            where TEvent : ChartEvent
        {
            int closestIndex = events.FindClosestEventIndex(time);
            if (closestIndex < 0)
                return -1;

            // Ensure the index we return is for an event that occurs before (or at) the given time
            while (closestIndex >= 0 && events[closestIndex].Time > time)
                closestIndex--;

            return closestIndex;
        }

        public static int GetIndexOfPrevious<TEvent>(this List<TEvent> events, uint tick)
            where TEvent : ChartEvent
        {
            int closestIndex = events.FindClosestEventIndex(tick);
            if (closestIndex < 0)
                return -1;

            // Ensure the index we return is for an event that occurs before (or at) the given tick
            while (closestIndex >= 0 && events[closestIndex].Tick > tick)
                closestIndex--;

            return closestIndex;
        }

        public static int GetIndexOfNext<TEvent>(this List<TEvent> events, double time)
            where TEvent : ChartEvent
        {
            int closestIndex = events.FindClosestEventIndex(time);
            if (closestIndex < 0)
                return -1;

            // Ensure the index we return is for an event that occurs after the given time
            int count = events.Count;
            while (closestIndex < count && events[closestIndex].Time <= time)
                closestIndex++;

            return closestIndex < count ? closestIndex : -1;
        }

        public static int GetIndexOfNext<TEvent>(this List<TEvent> events, uint tick)
            where TEvent : ChartEvent
        {
            int closestIndex = events.FindClosestEventIndex(tick);
            if (closestIndex < 0)
                return -1;

            // Ensure the index we return is for an event that occurs after the given tick
            int count = events.Count;
            while (closestIndex < count && events[closestIndex].Tick <= tick)
                closestIndex++;

            return closestIndex < count ? closestIndex : -1;
        }

        public static bool GetEventRange<TEvent>(this List<TEvent> events, double startTime, double endTime,
            out Range range)
            where TEvent : ChartEvent
        {
            range = default;

            int startIndex = events.FindClosestEventIndex(startTime);
            int endIndex = events.FindClosestEventIndex(endTime);
            if (startIndex < 0 || endIndex < 0)
                return false;

            // Ensure indexes are within time bounds
            int count = events.Count;
            while (startIndex < count && events[startIndex].Time < startTime)
                startIndex++;
            while (endIndex >= 0 && events[endIndex].Time >= endTime)
                endIndex--;

            // Ensure indexes are still in bounds
            if (startIndex >= count || endIndex < 0 || startIndex > endIndex)
                return false;

            range = new Range(startIndex, endIndex + 1);
            return true;
        }

        public static bool GetEventRange<TEvent>(this List<TEvent> events, uint startTick, uint endTick,
            out Range range)
            where TEvent : ChartEvent
        {
            range = default;

            int startIndex = events.FindClosestEventIndex(startTick);
            int endIndex = events.FindClosestEventIndex(endTick);
            if (startIndex < 0 || endIndex < 0)
                return false;

            // Ensure indexes are within tick bounds
            int count = events.Count;
            while (startIndex < count && events[startIndex].Tick < startTick)
                startIndex++;
            while (endIndex >= 0 && events[endIndex].Tick >= endTick)
                endIndex--;

            // Ensure indexes are still in bounds
            if (startIndex >= count || endIndex < 0 || startIndex > endIndex)
                return false;

            range = new Range(startIndex, endIndex + 1);
            return true;
        }

        public static TEvent? FindClosestEvent<TEvent>(this List<TEvent> events, double time)
            where TEvent : ChartEvent
        {
            return events.BinarySearch(time, EventComparer<TEvent>.CompareTime);
        }

        public static TEvent? FindClosestEvent<TEvent>(this List<TEvent> events, uint tick)
            where TEvent : ChartEvent
        {
            return events.BinarySearch(tick, EventComparer<TEvent>.CompareTick);
        }

        public static int FindClosestEventIndex<TEvent>(this List<TEvent> events, double time)
            where TEvent : ChartEvent
        {
            return events.BinarySearchIndex(time, EventComparer<TEvent>.CompareTime);
        }

        public static int FindClosestEventIndex<TEvent>(this List<TEvent> events, uint tick)
            where TEvent : ChartEvent
        {
            return events.BinarySearchIndex(tick, EventComparer<TEvent>.CompareTick);
        }

        private static class EventComparer<TEvent>
            where TEvent : ChartEvent
        {
            public static readonly Func<TEvent, double, int> CompareTime = _CompareTime;
            public static readonly Func<TEvent, uint, int> CompareTick = _CompareTick;

            private static int _CompareTime(TEvent currentEvent, double targetTime)
            {
                if (currentEvent.Time == targetTime)
                    return 0;
                else if (currentEvent.Time < targetTime)
                    return -1;
                else
                    return 1;
            }

            private static int _CompareTick(TEvent currentEvent, uint targetTick)
            {
                if (currentEvent.Tick == targetTick)
                    return 0;
                else if (currentEvent.Tick < targetTick)
                    return -1;
                else
                    return 1;
            }
        }
    }
}
</file>

<file path="Chart/Events/Phrase.cs">
using System;

namespace YARG.Core.Chart
{
    /// <summary>
    /// Possible phrase types.
    /// </summary>
    public enum PhraseType
    {
        // Note modifiers
        StarPower,   // Mainly for visuals, notes are already marked directly as SP
        TremoloLane, // Guitar strum lanes, single drum rolls
        TrillLane,   // Guitar trill lanes, double drum rolls
        DrumFill,    // Also for visuals

        // Versus modes (face-off and the like)
        VersusPlayer1,
        VersusPlayer2,

        // Other events
        Solo, // Also for visuals
        BigRockEnding,

        // Pro-keys range shifts
        ProKeys_RangeShift0,
        ProKeys_RangeShift1,
        ProKeys_RangeShift2,
        ProKeys_RangeShift3,
        ProKeys_RangeShift4,
        ProKeys_RangeShift5,
    }

    /// <summary>
    /// A phrase event that occurs in a chart.
    /// </summary>
    public class Phrase : ChartEvent, ICloneable<Phrase>
    {
        public PhraseType Type { get; }

        public Phrase(PhraseType type, double time, double timeLength, uint tick, uint tickLength)
            : base(time, timeLength, tick, tickLength)
        {
            Type = type;
        }

        public Phrase(Phrase other) : base(other)
        {
            Type = other.Type;
        }

        public Phrase Clone()
        {
            return new(this);
        }
    }
}
</file>

<file path="Chart/Events/Section.cs">
using System;

namespace YARG.Core.Chart
{
    public class Section : ChartEvent, ICloneable<Section>
    {
        public string Name { get; }

        public Section(string name, double time, uint tick) : base(time, 0, tick, 0)
        {
            Name = name;
        }

        public Section(Section other) : base(other)
        {
            Name = other.Name;
        }

        public Section Clone()
        {
            return new(this);
        }
    }
}
</file>

<file path="Chart/Events/TextEvent.cs">
using System;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A text event that occurs in a chart.
    /// </summary>
    public class TextEvent : ChartEvent, ICloneable<TextEvent>
    {
        public string Text { get; }

        public TextEvent(string text, double time, uint tick)
            : base(time, 0, tick, 0)
        {
            Text = text;
        }

        public TextEvent(TextEvent other) : base(other)
        {
            Text = other.Text;
        }

        public TextEvent Clone()
        {
            return new(this);
        }
    }
}
</file>

<file path="Chart/Events/WaitCountdown.cs">
using System.Collections.Generic;

namespace YARG.Core.Chart
{
    public class WaitCountdown : ChartEvent
    {
        public const float MIN_SECONDS = 9;
        public const uint MIN_MEASURES = 4;
        public const float MIN_MEASURE_LENGTH = 1;
        public const float FADE_ANIM_LENGTH = 0.45f;
        public const int END_COUNTDOWN_MEASURE = 1;

        public int TotalMeasures => _measureBeatlines.Count;

        //The time where the countdown should start fading out and overstrums will break combo again
        public double DeactivateTime => _measureBeatlines[^(END_COUNTDOWN_MEASURE + 1)].Time;
        public bool IsActive => MeasuresLeft > END_COUNTDOWN_MEASURE;

        private List<Beatline> _measureBeatlines;

        public int MeasuresLeft {get; private set; }

        public WaitCountdown(List<Beatline> measureBeatlines)
        {
            _measureBeatlines = measureBeatlines;

            var firstCountdownMeasure = measureBeatlines[0];
            var lastCountdownMeasure = measureBeatlines[^1];

            Time = firstCountdownMeasure.Time;
            Tick = firstCountdownMeasure.Tick;
            TimeLength = lastCountdownMeasure.Time - Time;
            TickLength = lastCountdownMeasure.Tick - Tick;

            MeasuresLeft = TotalMeasures;
        }

        public int CalculateMeasuresLeft(uint currentTick)
        {
            int newMeasuresLeft;
            if (currentTick >= TickEnd)
            {
                newMeasuresLeft = 0;
            }
            else if (currentTick < Tick)
            {
                newMeasuresLeft = TotalMeasures;
            }
            else
            {
                newMeasuresLeft = TotalMeasures - _measureBeatlines.GetIndexOfNext(currentTick);
            }

            MeasuresLeft = newMeasuresLeft;

            return newMeasuresLeft;
        }
    }
}
</file>

<file path="Chart/Loaders/MoonSong/MoonSongLoader.cs">
using System;
using System.Collections.Generic;
using System.IO;
using Melanchall.DryWetMidi.Core;
using MoonscraperChartEditor.Song;
using MoonscraperChartEditor.Song.IO;
using YARG.Core.Logging;

namespace YARG.Core.Chart
{
    using CurrentPhrases = Dictionary<MoonPhrase.Type, MoonPhrase>;

    /// <summary>
    /// Loads chart data from a MoonSong.
    /// </summary>
    internal partial class MoonSongLoader : ISongLoader
    {
        private delegate TNote CreateNoteDelegate<TNote>(MoonNote moonNote, CurrentPhrases currentPhrases)
            where TNote : Note<TNote>;
        private delegate void ProcessTextDelegate(MoonText text);

        private MoonSong _moonSong;
        private ParseSettings _settings;

        private GameMode _currentMode;
        private Instrument _currentInstrument;
        private Difficulty _currentDifficulty;

        private MoonChart.GameMode _currentMoonMode;
        private MoonSong.MoonInstrument _currentMoonInstrument;
        private MoonSong.Difficulty _currentMoonDifficulty;

        public MoonSongLoader(MoonSong song, in ParseSettings settings)
        {
            _moonSong = song;
            _settings = settings;
        }

        public static MoonSongLoader LoadSong(ParseSettings settings, string filePath)
        {
            var song = Path.GetExtension(filePath).ToLower() switch
            {
                ".mid" => MidReader.ReadMidi(ref settings, filePath),
                ".chart" => ChartReader.ReadFromFile(ref settings, filePath),
                _ => throw new ArgumentException($"Unrecognized file extension for chart path '{filePath}'!", nameof(filePath))
            };

            return new(song, settings);
        }

        public static MoonSongLoader LoadMidi(ParseSettings settings, MidiFile midi)
        {
            var song = MidReader.ReadMidi(ref settings, midi);
            return new(song, settings);
        }

        public static MoonSongLoader LoadDotChart(ParseSettings settings, ReadOnlySpan<char> chartText)
        {
            var song = ChartReader.ReadFromText(ref settings, chartText);
            return new(song, settings);
        }

        public List<TextEvent> LoadGlobalEvents()
        {
            var textEvents = new List<TextEvent>(_moonSong.events.Count);
            foreach (var moonText in _moonSong.events)
            {
                double time = _moonSong.TickToTime(moonText.tick);
                var newText = new TextEvent(moonText.text, time, moonText.tick);
                textEvents.Add(newText);
            }

            return textEvents;
        }

        public List<Section> LoadSections()
        {
            var sections = new List<Section>();

            for (var i = 0; i < _moonSong.sections.Count;)
            {
                var moonSection = _moonSong.sections[i];
                double time = _moonSong.TickToTime(moonSection.tick);
                sections.Add(new Section(moonSection.text, time, moonSection.tick));

                if (++i < _moonSong.sections.Count)
                {
                    double next = _moonSong.TickToTime(_moonSong.sections[i].tick);
                    sections[^1].TimeLength = next - time;
                    sections[^1].TickLength = _moonSong.sections[i].tick - moonSection.tick;
                }
            }

            return sections;
        }

        public SyncTrack LoadSyncTrack()
        {
            return _moonSong.syncTrack;
        }

        private InstrumentDifficulty<TNote> LoadDifficulty<TNote>(Instrument instrument, Difficulty difficulty,
            CreateNoteDelegate<TNote> createNote, ProcessTextDelegate? processText = null)
            where TNote : Note<TNote>
        {
            _currentMode = instrument.ToGameMode();
            _currentInstrument = instrument;
            _currentDifficulty = difficulty;

            _currentMoonMode = YargGameModeToMoonGameMode(_currentMode);
            _currentMoonInstrument = YargInstrumentToMoonInstrument(_currentInstrument);
            _currentMoonDifficulty = YargDifficultyToMoonDifficulty(_currentDifficulty);

            var moonChart = GetMoonChart(instrument, difficulty);
            var notes = GetNotes(moonChart, difficulty, createNote, processText);
            var phrases = GetPhrases(moonChart);
            var textEvents = GetTextEvents(moonChart);
            return new(instrument, difficulty, notes, phrases, textEvents);
        }

        private List<TNote> GetNotes<TNote>(MoonChart moonChart, Difficulty difficulty,
            CreateNoteDelegate<TNote> createNote, ProcessTextDelegate? processText = null)
            where TNote : Note<TNote>
        {
            var notes = new List<TNote>(moonChart.notes.Count);

            int moonPhraseIndex = 0;
            int moonTextIndex = 0;

            // Phrases stored here are *not* guaranteed to be active, as it's simpler that way
            // We need to check the phrase bounds anyways, which is very simple to do
            var currentPhrases = new CurrentPhrases();

            foreach (var moonNote in moonChart.notes)
            {
                // Keep track of active special phrases
                while (moonPhraseIndex < moonChart.specialPhrases.Count)
                {
                    var moonPhrase = moonChart.specialPhrases[moonPhraseIndex];
                    if (moonPhrase.tick > moonNote.tick)
                        break;

                    currentPhrases[moonPhrase.type] = moonPhrase;
                    moonPhraseIndex++;
                }

                // Send through text events, if requested
                if (processText != null)
                {
                    while (moonTextIndex < moonChart.events.Count)
                    {
                        var moonText = moonChart.events[moonTextIndex];
                        if (moonText.tick > moonNote.tick)
                            break;

                        processText(moonText);
                        moonTextIndex++;
                    }
                }

                // Skip Expert+ notes if not on Expert+
                if (difficulty != Difficulty.ExpertPlus && (moonNote.flags & MoonNote.Flags.InstrumentPlus) != 0)
                    continue;

                var newNote = createNote(moonNote, currentPhrases);
                AddNoteToList(notes, newNote);
            }

            notes.TrimExcess();
            return notes;
        }

        private List<Phrase> GetPhrases(MoonChart moonChart)
        {
            var phrases = new List<Phrase>(moonChart.specialPhrases.Count);
            foreach (var moonPhrase in moonChart.specialPhrases)
            {
                PhraseType? phraseType = moonPhrase.type switch
                {
                    MoonPhrase.Type.Starpower           => PhraseType.StarPower,
                    MoonPhrase.Type.Solo                => PhraseType.Solo,
                    MoonPhrase.Type.Versus_Player1      => PhraseType.VersusPlayer1,
                    MoonPhrase.Type.Versus_Player2      => PhraseType.VersusPlayer2,
                    MoonPhrase.Type.TremoloLane         => PhraseType.TremoloLane,
                    MoonPhrase.Type.TrillLane           => PhraseType.TrillLane,
                    MoonPhrase.Type.ProDrums_Activation => PhraseType.DrumFill,

                    MoonPhrase.Type.ProKeys_RangeShift0 => PhraseType.ProKeys_RangeShift0,
                    MoonPhrase.Type.ProKeys_RangeShift1 => PhraseType.ProKeys_RangeShift1,
                    MoonPhrase.Type.ProKeys_RangeShift2 => PhraseType.ProKeys_RangeShift2,
                    MoonPhrase.Type.ProKeys_RangeShift3 => PhraseType.ProKeys_RangeShift3,
                    MoonPhrase.Type.ProKeys_RangeShift4 => PhraseType.ProKeys_RangeShift4,
                    MoonPhrase.Type.ProKeys_RangeShift5 => PhraseType.ProKeys_RangeShift5,

                    _ => null
                };

                if (!phraseType.HasValue)
                    continue;

                double time = _moonSong.TickToTime(moonPhrase.tick);
                var newPhrase = new Phrase(phraseType.Value, time, GetLengthInTime(moonPhrase), moonPhrase.tick, moonPhrase.length);
                phrases.Add(newPhrase);
            }

            return phrases;
        }

        private List<TextEvent> GetTextEvents(MoonChart moonChart)
        {
            var textEvents = new List<TextEvent>(moonChart.events.Count);
            foreach (var moonText in moonChart.events)
            {
                double time = _moonSong.TickToTime(moonText.tick);
                var newText = new TextEvent(moonText.text, time, moonText.tick);
                textEvents.Add(newText);
            }

            return textEvents;
        }

        private NoteFlags GetGeneralFlags(MoonNote moonNote, CurrentPhrases currentPhrases)
        {
            var flags = NoteFlags.None;

            var previous = moonNote.PreviousSeperateMoonNote;
            var next = moonNote.NextSeperateMoonNote;

            // Star power
            if (currentPhrases.TryGetValue(MoonPhrase.Type.Starpower, out var starPower) && IsEventInPhrase(moonNote, starPower))
            {
                flags |= NoteFlags.StarPower;

                if (previous == null || !IsEventInPhrase(previous, starPower))
                    flags |= NoteFlags.StarPowerStart;

                if (next == null || !IsEventInPhrase(next, starPower))
                    flags |= NoteFlags.StarPowerEnd;
            }

            // Solos
            if (currentPhrases.TryGetValue(MoonPhrase.Type.Solo, out var solo) && IsEventInPhrase(moonNote, solo))
            {
                flags |= NoteFlags.Solo;

                if (previous == null || !IsEventInPhrase(previous, solo))
                    flags |= NoteFlags.SoloStart;

                if (next == null || !IsEventInPhrase(next, solo))
                    flags |= NoteFlags.SoloEnd;
            }

            return flags;
        }

        private void AddNoteToList<TNote>(List<TNote> notes, TNote note)
            where TNote : Note<TNote>
        {
            // The parent of all notes on the current tick
            var currentParent = notes.Count > 0 ? notes[^1] : null;
            // Previous parent note (on a different tick)
            var previousParent = notes.Count > 1 ? notes[^2] : null;

            // Determine if this is part of a chord
            if (currentParent != null)
            {
                if (note.Tick == currentParent.Tick)
                {
                    // Same chord, assign previous and add as child
                    note.PreviousNote = previousParent;
                    currentParent.AddChildNote(note);
                    return;
                }
                else if ((note.Tick - currentParent.Tick) <= _settings.NoteSnapThreshold)
                {
                    // Chord needs to be snapped, copy values
                    note.CopyValuesFrom(currentParent);

                    note.PreviousNote = previousParent;
                    currentParent.AddChildNote(note);
                    return;
                }
            }

            // New chord
            previousParent = currentParent;
            currentParent = note;

            // Assign next/previous note references
            if (previousParent is not null)
            {
                previousParent.NextNote = currentParent;
                foreach (var child in previousParent.ChildNotes)
                    child.NextNote = currentParent;

                currentParent.PreviousNote = previousParent;
            }

            notes.Add(note);
        }

        private double GetLengthInTime(double startTime, uint tick, uint tickLength)
        {
            return _moonSong.TickToTime(tick + tickLength) - startTime;
        }

        private double GetLengthInTime(MoonNote note)
        {
            double time = _moonSong.TickToTime(note.tick);
            return GetLengthInTime(time, note.tick, note.length);
        }

        private double GetLengthInTime(MoonPhrase phrase)
        {
            double time = _moonSong.TickToTime(phrase.tick);
            return GetLengthInTime(time, phrase.tick, phrase.length);
        }

        private static bool IsEventInPhrase(MoonObject songObj, MoonPhrase phrase)
        {
            if (songObj == null || phrase == null)
            {
                YargLogger.Assert(songObj != null);
                YargLogger.Assert(phrase != null);
                return false;
            }

            // Ensure 0-length phrases still take effect
            // (e.g. the SP phrases at the end of ExileLord - Hellidox)
            if (phrase.length == 0)
                return songObj.tick == phrase.tick;

            return phrase.tick <= songObj.tick && songObj.tick < (phrase.tick + phrase.length);
        }

        private static bool IsNoteClosestToEndOfPhrase(MoonSong song, MoonNote note, MoonPhrase phrase)
        {
            int endTick = (int) (phrase.tick + phrase.length);

            // Find the note to compare against
            MoonNote otherNote;
            {
                var previousNote = note.PreviousSeperateMoonNote;
                var nextNote = note.NextSeperateMoonNote;

                if (IsEventInPhrase(note, phrase))
                {
                    // Note is in the phrase, check if this is the last note in the phrase
                    if (nextNote is not null && !IsEventInPhrase(nextNote, phrase))
                    {
                        // The phrase ends between the given note and the next note
                        otherNote = nextNote;
                    }
                    else
                    {
                        // This is either the last note in the chart, or not the last note of the phrase
                        return nextNote is null;
                    }
                }
                else
                {
                    // Note is not in the phrase, check if the previous note is the last in the phrase
                    if (previousNote is null)
                    {
                        // This is the first note in the chart, check by distance
                        uint tickThreshold = song.resolution / 3; // 1/12th note
                        return Math.Abs((int) note.tick - endTick) < tickThreshold;
                    }
                    else if (note.tick >= endTick && previousNote.tick < endTick)
                    {
                        // The phrase ends between the previous note and the given note
                        // IsEventInPhrase() is not used here since cases such as drum activations at the end of breaks
                        // can possibly make it so that neither the previous nor given note are in the phrase
                        otherNote = previousNote;
                    }
                    else
                    {
                        // The phrase is not applicable to the given note
                        return false;
                    }
                }
            }

            // Compare the distance of each note
            // If the distances are equal, the previous note wins
            int currentDistance = Math.Abs((int) note.tick - endTick);
            int otherDistance = Math.Abs((int) otherNote.tick - endTick);
            return currentDistance < otherDistance || (currentDistance == otherDistance && note.tick < otherNote.tick);
        }

        private MoonChart GetMoonChart(Instrument instrument, Difficulty difficulty)
        {
            var moonInstrument = YargInstrumentToMoonInstrument(instrument);
            var moonDifficulty = YargDifficultyToMoonDifficulty(difficulty);
            return _moonSong.GetChart(moonInstrument, moonDifficulty);
        }

        private static MoonChart.GameMode YargGameModeToMoonGameMode(GameMode mode) => mode switch
        {
            GameMode.FiveFretGuitar => MoonChart.GameMode.Guitar,
            GameMode.SixFretGuitar => MoonChart.GameMode.GHLGuitar,

            GameMode.FourLaneDrums => MoonChart.GameMode.Drums,
            GameMode.FiveLaneDrums => MoonChart.GameMode.Drums,

            GameMode.ProGuitar => MoonChart.GameMode.ProGuitar,
            GameMode.ProKeys => MoonChart.GameMode.ProKeys,

            GameMode.Vocals => MoonChart.GameMode.Vocals,

            _ => throw new NotImplementedException($"Unhandled game mode {mode}!")
        };

        private static MoonSong.MoonInstrument YargInstrumentToMoonInstrument(Instrument instrument) => instrument switch
        {
            Instrument.FiveFretGuitar     => MoonSong.MoonInstrument.Guitar,
            Instrument.FiveFretCoopGuitar => MoonSong.MoonInstrument.GuitarCoop,
            Instrument.FiveFretBass       => MoonSong.MoonInstrument.Bass,
            Instrument.FiveFretRhythm     => MoonSong.MoonInstrument.Rhythm,
            Instrument.Keys               => MoonSong.MoonInstrument.Keys,

            Instrument.SixFretGuitar     => MoonSong.MoonInstrument.GHLiveGuitar,
            Instrument.SixFretCoopGuitar => MoonSong.MoonInstrument.GHLiveBass,
            Instrument.SixFretBass       => MoonSong.MoonInstrument.GHLiveRhythm,
            Instrument.SixFretRhythm     => MoonSong.MoonInstrument.GHLiveCoop,

            Instrument.FourLaneDrums or
            Instrument.FiveLaneDrums or
            Instrument.ProDrums => MoonSong.MoonInstrument.Drums,

            Instrument.ProGuitar_17Fret => MoonSong.MoonInstrument.ProGuitar_17Fret,
            Instrument.ProGuitar_22Fret => MoonSong.MoonInstrument.ProGuitar_22Fret,
            Instrument.ProBass_17Fret   => MoonSong.MoonInstrument.ProBass_17Fret,
            Instrument.ProBass_22Fret   => MoonSong.MoonInstrument.ProBass_22Fret,

            Instrument.ProKeys => MoonSong.MoonInstrument.ProKeys,

            // Vocals and harmony need to be handled specially
            // Instrument.Vocals  => MoonSong.MoonInstrument.Vocals,
            // Instrument.Harmony => MoonSong.MoonInstrument.Harmony1,

            _ => throw new NotImplementedException($"Unhandled instrument {instrument}!")
        };

        private static MoonSong.Difficulty YargDifficultyToMoonDifficulty(Difficulty difficulty) => difficulty switch
        {
            Difficulty.Easy       => MoonSong.Difficulty.Easy,
            Difficulty.Medium     => MoonSong.Difficulty.Medium,
            Difficulty.Hard       => MoonSong.Difficulty.Hard,
            Difficulty.Expert or
            Difficulty.ExpertPlus => MoonSong.Difficulty.Expert,
            _ => throw new InvalidOperationException($"Invalid difficulty {difficulty}!")
        };
    }
}
</file>

<file path="Chart/Loaders/MoonSong/MoonSongLoader.Drums.cs">
using System;
using System.Collections.Generic;
using MoonscraperChartEditor.Song;
using YARG.Core.Parsing;

namespace YARG.Core.Chart
{
    internal partial class MoonSongLoader : ISongLoader
    {
        private bool _discoFlip = false;

        public InstrumentTrack<DrumNote> LoadDrumsTrack(Instrument instrument)
        {
            _discoFlip = false;
            return instrument.ToGameMode() switch
            {
                GameMode.FourLaneDrums => LoadDrumsTrack(instrument, CreateFourLaneDrumNote),
                GameMode.FiveLaneDrums => LoadDrumsTrack(instrument, CreateFiveLaneDrumNote),
                _ => throw new ArgumentException($"Instrument {instrument} is not a drums instrument!", nameof(instrument))
            };
        }

        private InstrumentTrack<DrumNote> LoadDrumsTrack(Instrument instrument, CreateNoteDelegate<DrumNote> createNote)
        {
            var difficulties = new Dictionary<Difficulty, InstrumentDifficulty<DrumNote>>()
            {
                { Difficulty.Easy, LoadDifficulty(instrument, Difficulty.Easy, createNote, HandleTextEvent) },
                { Difficulty.Medium, LoadDifficulty(instrument, Difficulty.Medium, createNote, HandleTextEvent) },
                { Difficulty.Hard, LoadDifficulty(instrument, Difficulty.Hard, createNote, HandleTextEvent) },
                { Difficulty.Expert, LoadDifficulty(instrument, Difficulty.Expert, createNote, HandleTextEvent) },
                { Difficulty.ExpertPlus, LoadDifficulty(instrument, Difficulty.ExpertPlus, createNote, HandleTextEvent) },
            };
            return new(instrument, difficulties);
        }

        private DrumNote CreateFourLaneDrumNote(MoonNote moonNote, Dictionary<MoonPhrase.Type, MoonPhrase> currentPhrases)
        {
            var pad = GetFourLaneDrumPad(moonNote);
            var noteType = GetDrumNoteType(moonNote);
            var generalFlags = GetGeneralFlags(moonNote, currentPhrases);
            var drumFlags = GetDrumNoteFlags(moonNote, currentPhrases);

            double time = _moonSong.TickToTime(moonNote.tick);
            return new DrumNote(pad, noteType, drumFlags, generalFlags, time, moonNote.tick);
        }

        private DrumNote CreateFiveLaneDrumNote(MoonNote moonNote, Dictionary<MoonPhrase.Type, MoonPhrase> currentPhrases)
        {
            var pad = GetFiveLaneDrumPad(moonNote);
            var noteType = GetDrumNoteType(moonNote);
            var generalFlags = GetGeneralFlags(moonNote, currentPhrases);
            var drumFlags = GetDrumNoteFlags(moonNote, currentPhrases);

            double time = _moonSong.TickToTime(moonNote.tick);
            return new DrumNote(pad, noteType, drumFlags, generalFlags, time, moonNote.tick);
        }

        private void HandleTextEvent(MoonText text)
        {
            // Ignore on 5-lane or standard Drums
            if (_settings.DrumsType != DrumsType.FourLane && _currentInstrument is Instrument.FourLaneDrums)
                return;

            // Parse out event data
            if (!TextEvents.TryParseDrumsMixEvent(text.text, out var difficulty, out var config, out var setting))
                return;

            // Ignore if event is not for the given difficulty
            var currentDiff = _currentDifficulty;
            if (currentDiff == Difficulty.ExpertPlus)
                currentDiff = Difficulty.Expert;
            if (difficulty != currentDiff)
                return;

            _discoFlip = setting == DrumsMixSetting.DiscoFlip;
        }

        private FourLaneDrumPad GetFourLaneDrumPad(MoonNote moonNote)
        {
            var pad = _settings.DrumsType switch
            {
                DrumsType.FourLane => MoonNoteToFourLane(moonNote),
                DrumsType.FiveLane => GetFourLaneFromFiveLane(moonNote),
                _ => throw new InvalidOperationException($"Unexpected drums type {_settings.DrumsType}! (Drums type should have been calculated by now)")
            };

            return pad;
        }

        private FourLaneDrumPad GetFourLaneFromFiveLane(MoonNote moonNote)
        {
            // Conversion table:
            // | 5-lane | 4-lane Pro    |
            // | :----- | :---------    |
            // | Red    | Red           |
            // | Yellow | Yellow cymbal |
            // | Blue   | Blue tom      |
            // | Orange | Green cymbal  |
            // | Green  | Green tom     |
            // | O + G  | G cym + B tom |

            var fiveLanePad = MoonNoteToFiveLane(moonNote);
            var pad = fiveLanePad switch
            {
                FiveLaneDrumPad.Kick   => FourLaneDrumPad.Kick,
                FiveLaneDrumPad.Red    => FourLaneDrumPad.RedDrum,
                FiveLaneDrumPad.Yellow => FourLaneDrumPad.YellowCymbal,
                FiveLaneDrumPad.Blue   => FourLaneDrumPad.BlueDrum,
                FiveLaneDrumPad.Orange => FourLaneDrumPad.GreenCymbal,
                FiveLaneDrumPad.Green  => FourLaneDrumPad.GreenDrum,
                _ => throw new InvalidOperationException($"Invalid five lane drum pad {fiveLanePad}!")
            };

            // Handle potential overlaps
            if (pad is FourLaneDrumPad.GreenCymbal)
            {
                foreach (var note in moonNote.chord)
                {
                    if (note == moonNote)
                        continue;

                    var otherPad = MoonNoteToFiveLane(note);
                    pad = (pad, otherPad) switch
                    {
                        // (Calculated pad, other note in chord) => corrected pad to prevent same-color overlapping
                        (FourLaneDrumPad.GreenCymbal, FiveLaneDrumPad.Green) => FourLaneDrumPad.BlueCymbal,
                        _ => pad
                    };
                }
            }

            // Down-convert to standard 4-lane
            if (_currentInstrument is Instrument.FourLaneDrums)
            {
                pad = pad switch
                {
                    FourLaneDrumPad.YellowCymbal => FourLaneDrumPad.YellowDrum,
                    FourLaneDrumPad.BlueCymbal   => FourLaneDrumPad.BlueDrum,
                    FourLaneDrumPad.GreenCymbal  => FourLaneDrumPad.GreenDrum,
                    _ => pad
                };
            }

            return pad;
        }

        private FiveLaneDrumPad GetFiveLaneDrumPad(MoonNote moonNote)
        {
            return _settings.DrumsType switch
            {
                DrumsType.FiveLane => MoonNoteToFiveLane(moonNote),
                DrumsType.FourLane => GetFiveLaneFromFourLane(moonNote),
                _ => throw new InvalidOperationException($"Unexpected drums type {_settings.DrumsType}! (Drums type should have been calculated by now)")
            };
        }

        private FiveLaneDrumPad GetFiveLaneFromFourLane(MoonNote moonNote)
        {
            // Conversion table:
            // | 4-lane Pro    | 5-lane |
            // | :---------    | :----- |
            // | Red           | Red    |
            // | Yellow cymbal | Yellow |
            // | Yellow tom    | Blue   |
            // | Blue cymbal   | Orange |
            // | Blue tom      | Blue   |
            // | Green cymbal  | Orange |
            // | Green tom     | Green  |
            // | Y tom + B tom | R + B  |
            // | B cym + G cym | Y + O  |

            var fourLanePad = MoonNoteToFourLane(moonNote);
            var pad = fourLanePad switch
            {
                FourLaneDrumPad.Kick         => FiveLaneDrumPad.Kick,
                FourLaneDrumPad.RedDrum      => FiveLaneDrumPad.Red,
                FourLaneDrumPad.YellowCymbal => FiveLaneDrumPad.Yellow,
                FourLaneDrumPad.YellowDrum   => FiveLaneDrumPad.Blue,
                FourLaneDrumPad.BlueCymbal   => FiveLaneDrumPad.Orange,
                FourLaneDrumPad.BlueDrum     => FiveLaneDrumPad.Blue,
                FourLaneDrumPad.GreenCymbal  => FiveLaneDrumPad.Orange,
                FourLaneDrumPad.GreenDrum    => FiveLaneDrumPad.Green,
                _ => throw new InvalidOperationException($"Invalid four lane drum pad {fourLanePad}!")
            };

            // Handle special cases
            if (pad is FiveLaneDrumPad.Blue or FiveLaneDrumPad.Orange)
            {
                foreach (var note in moonNote.chord)
                {
                    if (note == moonNote)
                        continue;

                    var otherPad = MoonNoteToFourLane(note);
                    pad = (pad, otherPad) switch
                    {
                        // (Calculated pad, other note in chord) => corrected pad to prevent same-color overlapping
                        (FiveLaneDrumPad.Blue, FourLaneDrumPad.BlueDrum) => FiveLaneDrumPad.Red,
                        (FiveLaneDrumPad.Orange, FourLaneDrumPad.GreenCymbal) => FiveLaneDrumPad.Yellow,
                        _ => pad
                    };
                }
            }

            return pad;
        }

        private FourLaneDrumPad MoonNoteToFourLane(MoonNote moonNote)
        {
            var pad = moonNote.drumPad switch
            {
                MoonNote.DrumPad.Kick   => FourLaneDrumPad.Kick,
                MoonNote.DrumPad.Red    => FourLaneDrumPad.RedDrum,
                MoonNote.DrumPad.Yellow => FourLaneDrumPad.YellowDrum,
                MoonNote.DrumPad.Blue   => FourLaneDrumPad.BlueDrum,
                MoonNote.DrumPad.Orange => FourLaneDrumPad.GreenDrum,
                MoonNote.DrumPad.Green  => FourLaneDrumPad.GreenDrum,
                _ => throw new ArgumentException($"Invalid Moonscraper drum pad {moonNote.drumPad}!", nameof(moonNote))
            };

            if (_currentInstrument is not Instrument.FourLaneDrums)
            {
                var flags = moonNote.flags;

                // Disco flip
                if (_discoFlip)
                {
                    if (pad == FourLaneDrumPad.RedDrum)
                    {
                        // Red drums in disco flip are turned into yellow cymbals
                        pad = FourLaneDrumPad.YellowDrum;
                        flags |= MoonNote.Flags.ProDrums_Cymbal;
                    }
                    else if (pad == FourLaneDrumPad.YellowDrum)
                    {
                        // Both yellow cymbals and yellow drums are turned into red drums in disco flip
                        pad = FourLaneDrumPad.RedDrum;
                        flags &= ~MoonNote.Flags.ProDrums_Cymbal;
                    }
                }

                // Cymbal marking
                if ((flags & MoonNote.Flags.ProDrums_Cymbal) != 0)
                {
                    pad = pad switch
                    {
                        FourLaneDrumPad.YellowDrum => FourLaneDrumPad.YellowCymbal,
                        FourLaneDrumPad.BlueDrum   => FourLaneDrumPad.BlueCymbal,
                        FourLaneDrumPad.GreenDrum  => FourLaneDrumPad.GreenCymbal,
                        _ => throw new InvalidOperationException($"Cannot mark pad {pad} as a cymbal!")
                    };
                }
            }

            return pad;
        }

        private FiveLaneDrumPad MoonNoteToFiveLane(MoonNote moonNote)
        {
            var pad = moonNote.drumPad switch
            {
                MoonNote.DrumPad.Kick   => FiveLaneDrumPad.Kick,
                MoonNote.DrumPad.Red    => FiveLaneDrumPad.Red,
                MoonNote.DrumPad.Yellow => FiveLaneDrumPad.Yellow,
                MoonNote.DrumPad.Blue   => FiveLaneDrumPad.Blue,
                MoonNote.DrumPad.Orange => FiveLaneDrumPad.Orange,
                MoonNote.DrumPad.Green  => FiveLaneDrumPad.Green,
                _ => throw new ArgumentException($"Invalid Moonscraper drum pad {moonNote.drumPad}!", nameof(moonNote))
            };

            return pad;
        }

        private DrumNoteType GetDrumNoteType(MoonNote moonNote)
        {
            var noteType = DrumNoteType.Neutral;

            // Accents/ghosts
            if ((moonNote.flags & MoonNote.Flags.ProDrums_Accent) != 0)
                noteType = DrumNoteType.Accent;
            else if ((moonNote.flags & MoonNote.Flags.ProDrums_Ghost) != 0)
                noteType = DrumNoteType.Ghost;

            return noteType;
        }

        private DrumNoteFlags GetDrumNoteFlags(MoonNote moonNote, Dictionary<MoonPhrase.Type, MoonPhrase> currentPhrases)
        {
            var flags = DrumNoteFlags.None;

            // SP activator
            if (currentPhrases.TryGetValue(MoonPhrase.Type.ProDrums_Activation, out var activationPhrase) &&
                IsNoteClosestToEndOfPhrase(_moonSong, moonNote, activationPhrase))
            {
                flags |= DrumNoteFlags.StarPowerActivator;
            }

            return flags;
        }
    }
}
</file>

<file path="Chart/Loaders/MoonSong/MoonSongLoader.Guitar.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using MoonscraperChartEditor.Song;

namespace YARG.Core.Chart
{
    internal partial class MoonSongLoader : ISongLoader
    {
        public InstrumentTrack<GuitarNote> LoadGuitarTrack(Instrument instrument)
        {
            return instrument.ToGameMode() switch
            {
                GameMode.FiveFretGuitar => LoadGuitarTrack(instrument, CreateFiveFretGuitarNote),
                GameMode.SixFretGuitar  => LoadGuitarTrack(instrument, CreateSixFretGuitarNote),
                _ => throw new ArgumentException($"Instrument {instrument} is not a guitar instrument!")
            };
        }

        private InstrumentTrack<GuitarNote> LoadGuitarTrack(Instrument instrument, CreateNoteDelegate<GuitarNote> createNote)
        {
            var difficulties = new Dictionary<Difficulty, InstrumentDifficulty<GuitarNote>>()
            {
                { Difficulty.Easy, LoadDifficulty(instrument, Difficulty.Easy, createNote) },
                { Difficulty.Medium, LoadDifficulty(instrument, Difficulty.Medium, createNote) },
                { Difficulty.Hard, LoadDifficulty(instrument, Difficulty.Hard, createNote) },
                { Difficulty.Expert, LoadDifficulty(instrument, Difficulty.Expert, createNote) },
            };
            return new(instrument, difficulties);
        }

        private GuitarNote CreateFiveFretGuitarNote(MoonNote moonNote, Dictionary<MoonPhrase.Type, MoonPhrase> currentPhrases)
        {
            var fret = GetFiveFretGuitarFret(moonNote);
            var noteType = GetGuitarNoteType(moonNote);
            var generalFlags = GetGeneralFlags(moonNote, currentPhrases);
            var guitarFlags = GetGuitarNoteFlags(moonNote);

            double time = _moonSong.TickToTime(moonNote.tick);
            return new GuitarNote(fret, noteType, guitarFlags, generalFlags, time, GetLengthInTime(moonNote), moonNote.tick, moonNote.length);
        }

        private GuitarNote CreateSixFretGuitarNote(MoonNote moonNote, Dictionary<MoonPhrase.Type, MoonPhrase> currentPhrases)
        {
            var fret = GetSixFretGuitarFret(moonNote);
            var noteType = GetGuitarNoteType(moonNote);
            var generalFlags = GetGeneralFlags(moonNote, currentPhrases);
            var guitarFlags = GetGuitarNoteFlags(moonNote);

            double time = _moonSong.TickToTime(moonNote.tick);
            return new GuitarNote(fret, noteType, guitarFlags, generalFlags, time, GetLengthInTime(moonNote), moonNote.tick, moonNote.length);
        }

        private FiveFretGuitarFret GetFiveFretGuitarFret(MoonNote moonNote)
        {
            return moonNote.guitarFret switch
            {
                MoonNote.GuitarFret.Open   => FiveFretGuitarFret.Open,
                MoonNote.GuitarFret.Green  => FiveFretGuitarFret.Green,
                MoonNote.GuitarFret.Red    => FiveFretGuitarFret.Red,
                MoonNote.GuitarFret.Yellow => FiveFretGuitarFret.Yellow,
                MoonNote.GuitarFret.Blue   => FiveFretGuitarFret.Blue,
                MoonNote.GuitarFret.Orange => FiveFretGuitarFret.Orange,
                _ => throw new InvalidOperationException($"Invalid Moonscraper guitar fret {moonNote.guitarFret}!")
            };
        }

        private SixFretGuitarFret GetSixFretGuitarFret(MoonNote moonNote)
        {
            return moonNote.ghliveGuitarFret switch
            {
                MoonNote.GHLiveGuitarFret.Open   => SixFretGuitarFret.Open,
                MoonNote.GHLiveGuitarFret.Black1 => SixFretGuitarFret.Black1,
                MoonNote.GHLiveGuitarFret.Black2 => SixFretGuitarFret.Black2,
                MoonNote.GHLiveGuitarFret.Black3 => SixFretGuitarFret.Black3,
                MoonNote.GHLiveGuitarFret.White1 => SixFretGuitarFret.White1,
                MoonNote.GHLiveGuitarFret.White2 => SixFretGuitarFret.White2,
                MoonNote.GHLiveGuitarFret.White3 => SixFretGuitarFret.White3,
                _ => throw new InvalidOperationException($"Invalid Moonscraper guitar fret {moonNote.ghliveGuitarFret}!")
            };
        }

        private GuitarNoteType GetGuitarNoteType(MoonNote moonNote)
        {
            var type = moonNote.GetGuitarNoteType(_moonSong.hopoThreshold);

            // Apply chord HOPO cancellation, if enabled
            if (_settings.ChordHopoCancellation && type == MoonNote.MoonNoteType.Hopo &&
                !moonNote.isChord && (moonNote.flags & MoonNote.Flags.Forced_Hopo) == 0)
            {
                var previous = moonNote.PreviousSeperateMoonNote;
                if (previous is not null && previous.isChord)
                {
                    foreach (var note in previous.chord)
                    {
                        if (note.guitarFret == moonNote.guitarFret)
                        {
                            type = MoonNote.MoonNoteType.Strum;
                            break;
                        }
                    }
                }
            }

            return type switch
            {
                MoonNote.MoonNoteType.Strum => GuitarNoteType.Strum,
                MoonNote.MoonNoteType.Hopo  => GuitarNoteType.Hopo,
                MoonNote.MoonNoteType.Tap   => GuitarNoteType.Tap,
                _ => throw new InvalidOperationException($"Unhandled Moonscraper note type {type}!")
            };
        }

        private GuitarNoteFlags GetGuitarNoteFlags(MoonNote moonNote)
        {
            var flags = GuitarNoteFlags.None;

            var noteEndTick = moonNote.tick + moonNote.length;

            // Extended sustains (Forwards)
            var nextNote = moonNote.NextSeperateMoonNote;
            var ticksToNextNote = nextNote?.tick - moonNote.tick ?? 0;

            if (nextNote is not null &&
                noteEndTick > nextNote.tick &&
                ticksToNextNote > _settings.NoteSnapThreshold)
            {
                flags |= GuitarNoteFlags.ExtendedSustain;
            }

            // Extended sustains (Backwards)
            var prevNote = moonNote.PreviousSeperateMoonNote;

            if (prevNote is not null)
            {
                var prevNoteTick = prevNote.tick;
                uint largestLength = 0;

                // Must find the longest length of previous note (disjoint chords)
                while(prevNote is not null && prevNote.previous?.tick == prevNote.tick)
                {
                    largestLength = Math.Max(largestLength, prevNote.length);
                    prevNote = prevNote.previous;
                }

                var prevNoteEndTick = prevNoteTick + largestLength;
                var ticksToPrevNote = moonNote.tick - prevNoteTick;

                if (prevNoteEndTick > moonNote.tick &&
                    moonNote.length > 0 &&
                    ticksToPrevNote > _settings.NoteSnapThreshold)
                {
                    flags |= GuitarNoteFlags.ExtendedSustain;
                }
            }

            // Disjoint chords
            foreach (var note in moonNote.chord)
            {
                if (note.length != moonNote.length)
                {
                    flags |= GuitarNoteFlags.Disjoint;
                    break;
                }
            }

            return flags;
        }
    }
}
</file>

<file path="Chart/Loaders/MoonSong/MoonSongLoader.Lyrics.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using MoonscraperChartEditor.Song;
using YARG.Core.Parsing;

namespace YARG.Core.Chart
{
    internal partial class MoonSongLoader : ISongLoader
    {
        private class LyricConverter : ITextPhraseConverter
        {
            private readonly MoonSong _moonSong;

            public readonly List<LyricsPhrase> Phrases;
            private List<LyricEvent> _currentLyrics;

            public string StartEvent => TextEvents.LYRIC_PHRASE_START;
            public string EndEvent => TextEvents.LYRIC_PHRASE_END;

            public LyricConverter(MoonSong song)
            {
                _moonSong = song;
                Phrases = new();
                _currentLyrics = new();
            }

            public void AddPhrase(uint startTick, uint endTick)
            {
                if (_currentLyrics.Count < 1)
                    return;

                double startTime = _moonSong.TickToTime(startTick);
                double endTime = _moonSong.TickToTime(endTick);
                Phrases.Add(new(startTime, endTime - startTime, startTick, endTick - startTick, _currentLyrics));
                _currentLyrics = new();
            }

            public void AddPhraseEvent(string text, uint tick)
            {
                // Ignore non-lyric events
                if (!text.StartsWith(TextEvents.LYRIC_PREFIX_WITH_SPACE))
                    return;

                var lyric = text.AsSpan().Slice(TextEvents.LYRIC_PREFIX_WITH_SPACE.Length);

                LyricSymbols.DeferredLyricJoinWorkaround(_currentLyrics, ref lyric, false);

                // Handle lyric modifiers
                var flags = LyricSymbols.GetLyricFlags(lyric);

                // Strip special symbols from lyrics
                string strippedLyric = !lyric.IsEmpty
                    ? LyricSymbols.StripForLyrics(lyric.ToString())
                    : string.Empty;

                if (string.IsNullOrWhiteSpace(strippedLyric))
                {
                    // Allow empty lyrics for lyric gimmick purposes
                    flags |= LyricSymbolFlags.JoinWithNext;
                    strippedLyric = string.Empty;
                }

                double time = _moonSong.TickToTime(tick);
                _currentLyrics.Add(new(flags, strippedLyric, time, tick));
            }
        }

        public LyricsTrack LoadLyrics()
        {
            var converter = new LyricConverter(_moonSong);
            var maxTick = _moonSong.Charts.Max(x => x.events.LastOrDefault()?.tick + _moonSong.resolution ?? 0);
            TextEvents.ConvertToPhrases(_moonSong.events, converter, maxTick);
            return new LyricsTrack(converter.Phrases);
        }
    }
}
</file>

<file path="Chart/Loaders/MoonSong/MoonSongLoader.ProGuitar.cs">
using System;
using System.Collections.Generic;
using MoonscraperChartEditor.Song;

namespace YARG.Core.Chart
{
    internal partial class MoonSongLoader : ISongLoader
    {
        public InstrumentTrack<ProGuitarNote> LoadProGuitarTrack(Instrument instrument)
        {
            if (instrument.ToGameMode() != GameMode.ProGuitar)
                throw new ArgumentException($"Instrument {instrument} is not a Pro guitar instrument!", nameof(instrument));

            var difficulties = new Dictionary<Difficulty, InstrumentDifficulty<ProGuitarNote>>()
            {
                { Difficulty.Easy, LoadDifficulty(instrument, Difficulty.Easy, CreateProGuitarNote) },
                { Difficulty.Medium, LoadDifficulty(instrument, Difficulty.Medium, CreateProGuitarNote) },
                { Difficulty.Hard, LoadDifficulty(instrument, Difficulty.Hard, CreateProGuitarNote) },
                { Difficulty.Expert, LoadDifficulty(instrument, Difficulty.Expert, CreateProGuitarNote) },
            };
            return new(instrument, difficulties);
        }

        private ProGuitarNote CreateProGuitarNote(MoonNote moonNote, Dictionary<MoonPhrase.Type, MoonPhrase> currentPhrases)
        {
            var proString = GetProGuitarString(moonNote);
            int proFret = GetProGuitarFret(moonNote);
            var noteType = GetProGuitarNoteType(moonNote);
            var generalFlags = GetGeneralFlags(moonNote, currentPhrases);
            var proFlags = GetProGuitarNoteFlags(moonNote);

            double time = _moonSong.TickToTime(moonNote.tick);
            return new ProGuitarNote(proString, proFret, noteType, proFlags, generalFlags, time, GetLengthInTime(moonNote), moonNote.tick, moonNote.length);
        }

        private ProGuitarString GetProGuitarString(MoonNote moonNote)
        {
            return moonNote.proGuitarString switch
            {
                MoonNote.ProGuitarString.Red    => ProGuitarString.Red,
                MoonNote.ProGuitarString.Green  => ProGuitarString.Green,
                MoonNote.ProGuitarString.Orange => ProGuitarString.Orange,
                MoonNote.ProGuitarString.Blue   => ProGuitarString.Blue,
                MoonNote.ProGuitarString.Yellow => ProGuitarString.Yellow,
                MoonNote.ProGuitarString.Purple => ProGuitarString.Purple,
                _ => throw new InvalidOperationException($"Unhandled Moonscraper Pro guitar string {moonNote.proGuitarString}!")
            };
        }

        private int GetProGuitarFret(MoonNote moonNote)
        {
            return moonNote.proGuitarFret;
        }

        private ProGuitarNoteType GetProGuitarNoteType(MoonNote moonNote)
        {
            var type = moonNote.GetGuitarNoteType(_moonSong.hopoThreshold);
            return type switch
            {
                MoonNote.MoonNoteType.Strum => ProGuitarNoteType.Strum,
                MoonNote.MoonNoteType.Hopo  => ProGuitarNoteType.Hopo,
                MoonNote.MoonNoteType.Tap   => ProGuitarNoteType.Tap,
                _ => throw new InvalidOperationException($"Unhandled Moonscraper note type {type}!")
            };
        }

        private ProGuitarNoteFlags GetProGuitarNoteFlags(MoonNote moonNote)
        {
            var flags = ProGuitarNoteFlags.None;

            // Standard guitar flags
            var guitarFlags = GetGuitarNoteFlags(moonNote);
            if ((guitarFlags & GuitarNoteFlags.ExtendedSustain) != 0)
                flags |= ProGuitarNoteFlags.ExtendedSustain;
            if ((guitarFlags & GuitarNoteFlags.Disjoint) != 0)
                flags |= ProGuitarNoteFlags.Disjoint;

            // Muted notes
            if ((moonNote.flags & MoonNote.Flags.ProGuitar_Muted) != 0)
            {
                flags |= ProGuitarNoteFlags.Muted;
            }

            return flags;
        }
    }
}
</file>

<file path="Chart/Loaders/MoonSong/MoonSongLoader.ProKeys.cs">
using System;
using System.Collections.Generic;
using MoonscraperChartEditor.Song;

namespace YARG.Core.Chart
{
    internal partial class MoonSongLoader : ISongLoader
    {
        public InstrumentTrack<ProKeysNote> LoadProKeysTrack(Instrument instrument)
        {
            return LoadProKeysTrack(instrument, CreateProKeysNote);
        }

        private InstrumentTrack<ProKeysNote> LoadProKeysTrack(Instrument instrument, CreateNoteDelegate<ProKeysNote> createNote)
        {
            if (instrument.ToGameMode() != GameMode.ProKeys)
                throw new ArgumentException($"Instrument {instrument} is not a pro-keys instrument!", nameof(instrument));

            var difficulties = new Dictionary<Difficulty, InstrumentDifficulty<ProKeysNote>>
            {
                { Difficulty.Easy,   LoadDifficulty(instrument, Difficulty.Easy, createNote) },
                { Difficulty.Medium, LoadDifficulty(instrument, Difficulty.Medium, createNote) },
                { Difficulty.Hard,   LoadDifficulty(instrument, Difficulty.Hard, createNote) },
                { Difficulty.Expert, LoadDifficulty(instrument, Difficulty.Expert, createNote) },
            };
            return new(instrument, difficulties);
        }

        private ProKeysNote CreateProKeysNote(MoonNote moonNote, Dictionary<MoonPhrase.Type, MoonPhrase> currentPhrases)
        {
            var key = moonNote.proKeysKey;
            var generalFlags = GetGeneralFlags(moonNote, currentPhrases);
            var proKeysFlags = GetProKeysNoteFlags(moonNote, currentPhrases);

            double time = _moonSong.TickToTime(moonNote.tick);
            return new ProKeysNote(key, proKeysFlags, generalFlags, time, GetLengthInTime(moonNote),
                moonNote.tick, moonNote.length);
        }

        private ProKeysNoteFlags GetProKeysNoteFlags(MoonNote moonNote, Dictionary<MoonPhrase.Type, MoonPhrase> currentPhrases)
        {
            var flags = ProKeysNoteFlags.None;

            if (currentPhrases.TryGetValue(MoonPhrase.Type.ProKeys_Glissando, out var glissando) &&
                IsEventInPhrase(moonNote, glissando))
            {
                flags |= ProKeysNoteFlags.Glissando;
            }

            return flags;
        }
    }
}
</file>

<file path="Chart/Loaders/MoonSong/MoonSongLoader.Venue.cs">
using System;
using System.Collections.Generic;
using MoonscraperChartEditor.Song;
using YARG.Core.Logging;
using YARG.Core.Utility;

namespace YARG.Core.Chart
{
    using static VenueLookup;

    internal partial class MoonSongLoader : ISongLoader
    {

        public VenueTrack LoadVenueTrack()
        {
            var lightingEvents = new List<LightingEvent>();
            var postProcessingEvents = new List<PostProcessingEvent>();
            var performerEvents = new List<PerformerEvent>();
            var stageEvents = new List<StageEffectEvent>();

            // For merging spotlights/singalongs into a single event
            MoonVenue? spotlightCurrentEvent = null;
            MoonVenue? singalongCurrentEvent = null;
            var spotlightPerformers = Performer.None;
            var singalongPerformers = Performer.None;

            foreach (var moonVenue in _moonSong.venue)
            {
                // Prefix flags
                var splitter = moonVenue.text.AsSpan().Split(' ');
                splitter.MoveNext();
                var flags = VenueEventFlags.None;
                foreach (var (prefix, flag) in FlagPrefixLookup)
                {
                    if (splitter.Current.Equals(prefix, StringComparison.Ordinal))
                    {
                        flags |= flag;
                        splitter.MoveNext();
                    }
                }

                // Taking the allocation L here, the only way to access with a span is by going over
                // all the key-value pairs, which is 5x slower at even just 25 elements (O(n) vs O(1) with a string)
                // There's a lot of other allocations happening here anyways lol
                string text = splitter.CurrentToEnd.ToString();
                switch (moonVenue.type)
                {
                    case VenueLookup.Type.Lighting:
                    {
                        if (!LightingLookup.TryGetValue(text, out var type))
                            continue;

                        double time = _moonSong.TickToTime(moonVenue.tick);
                        lightingEvents.Add(new(type, time, moonVenue.tick));
                        break;
                    }

                    case VenueLookup.Type.PostProcessing:
                    {
                        if (!PostProcessLookup.TryGetValue(text, out var type))
                            continue;

                        double time = _moonSong.TickToTime(moonVenue.tick);
                        postProcessingEvents.Add(new(type, time, moonVenue.tick));
                        break;
                    }

                    case VenueLookup.Type.Singalong:
                    {
                        HandlePerformerEvent(performerEvents, PerformerEventType.Singalong, moonVenue,
                            ref singalongCurrentEvent, ref singalongPerformers);
                        break;
                    }

                    case VenueLookup.Type.Spotlight:
                    {
                        HandlePerformerEvent(performerEvents, PerformerEventType.Spotlight, moonVenue,
                            ref spotlightCurrentEvent, ref spotlightPerformers);
                        break;
                    }

                    case VenueLookup.Type.StageEffect:
                    {
                        if (!StageEffectLookup.TryGetValue(text, out var type))
                            continue;

                        double time = _moonSong.TickToTime(moonVenue.tick);
                        stageEvents.Add(new(type, flags, time, moonVenue.tick));
                        break;
                    }

                    default:
                    {
                        YargLogger.LogFormatDebug("Unrecognized venue text event '{0}'!", text);
                        continue;
                    }
                }
            }

            lightingEvents.TrimExcess();
            postProcessingEvents.TrimExcess();
            performerEvents.TrimExcess();
            stageEvents.TrimExcess();

            return new(lightingEvents, postProcessingEvents, performerEvents, stageEvents);
        }

        private void HandlePerformerEvent(List<PerformerEvent> events, PerformerEventType type, MoonVenue moonEvent,
            ref MoonVenue? currentEvent, ref Performer performers)
        {
            // First event
            if (currentEvent == null)
            {
                currentEvent = moonEvent;
            }
            // Start of a new event
            else if (currentEvent.tick != moonEvent.tick && performers != Performer.None)
            {
                double time = _moonSong.TickToTime(currentEvent.tick);
                // Add tracked event
                events.Add(new(type, performers, time, GetLengthInTime(currentEvent),
                    currentEvent.tick, currentEvent.length));

                // Track new event
                currentEvent = moonEvent;
                performers = Performer.None;
            }

            // Sing-along events are not optional, use the text directly
            if (!PerformerLookup.TryGetValue(moonEvent.text, out var performer))
                return;
            performers |= performer;
        }

        private double GetLengthInTime(MoonVenue ev)
        {
            double time = _moonSong.TickToTime(ev.tick);
            return GetLengthInTime(time, ev.tick, ev.length);
        }
    }
}
</file>

<file path="Chart/Loaders/MoonSong/MoonSongLoader.Vocals.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using MoonscraperChartEditor.Song;
using YARG.Core.Extensions;
using YARG.Core.Logging;
using YARG.Core.Parsing;
using YARG.Core.Utility;

namespace YARG.Core.Chart
{
    internal partial class MoonSongLoader : ISongLoader
    {
        public VocalsTrack LoadVocalsTrack(Instrument instrument)
        {
            return instrument switch
            {
                Instrument.Vocals => LoadSoloVocals(instrument),
                Instrument.Harmony => LoadHarmonyVocals(instrument),
                _ => throw new ArgumentException($"Instrument {instrument} is not a drums instrument!", nameof(instrument))
            };
        }

        private VocalsTrack LoadSoloVocals(Instrument instrument)
        {
            var parts = new List<VocalsPart>()
            {
                LoadVocalsPart(MoonSong.MoonInstrument.Vocals),
            };

            var ranges = GetRangeShifts(parts, MoonSong.MoonInstrument.Vocals);
            return new(instrument, parts, ranges);
        }

        private VocalsTrack LoadHarmonyVocals(Instrument instrument)
        {
            var parts = new List<VocalsPart>()
            {
                LoadVocalsPart(MoonSong.MoonInstrument.Harmony1),
                LoadVocalsPart(MoonSong.MoonInstrument.Harmony2),
                LoadVocalsPart(MoonSong.MoonInstrument.Harmony3),
            };

            var ranges = GetRangeShifts(parts, MoonSong.MoonInstrument.Harmony1);
            return new(instrument, parts, ranges);
        }

        private VocalsPart LoadVocalsPart(MoonSong.MoonInstrument moonInstrument)
        {
            int harmonyPart = moonInstrument switch
            {
                MoonSong.MoonInstrument.Vocals or
                MoonSong.MoonInstrument.Harmony1 => 0,
                MoonSong.MoonInstrument.Harmony2 => 1,
                MoonSong.MoonInstrument.Harmony3 => 2,
                _ => throw new ArgumentException($"MoonInstrument {moonInstrument} is not a vocals instrument!", nameof(moonInstrument))
            };
            var moonChart = _moonSong.GetChart(moonInstrument, MoonSong.Difficulty.Expert);

            var isHarmony = moonInstrument != MoonSong.MoonInstrument.Vocals;
            var notePhrases = GetVocalsPhrases(moonChart, harmonyPart);
            var otherPhrases = GetPhrases(moonChart);
            var textEvents = GetTextEvents(moonChart);
            return new(isHarmony, notePhrases, otherPhrases, textEvents);
        }

        private List<VocalsPhrase> GetVocalsPhrases(MoonChart moonChart, int harmonyPart)
        {
            var phrases = new List<VocalsPhrase>();

            // Prefill with the valid phrases
            var phraseTracker = new Dictionary<MoonPhrase.Type, MoonPhrase?>()
            {
                { MoonPhrase.Type.Starpower , null },
                { MoonPhrase.Type.Versus_Player1 , null },
                { MoonPhrase.Type.Versus_Player2 , null },
                { MoonPhrase.Type.Vocals_PercussionPhrase , null },
            };

            int moonNoteIndex = 0;
            int moonTextIndex = 0;

            for (int moonPhraseIndex = 0; moonPhraseIndex < moonChart.specialPhrases.Count;)
            {
                var moonPhrase = moonChart.specialPhrases[moonPhraseIndex++];
                if (moonPhrase.type != MoonPhrase.Type.Vocals_LyricPhrase)
                {
                    phraseTracker[moonPhrase.type] = moonPhrase;
                    continue;
                }

                // Ensure any other phrases on the same tick get tracked
                while (moonPhraseIndex < moonChart.specialPhrases.Count)
                {
                    var moonPhrase2 = moonChart.specialPhrases[moonPhraseIndex];
                    if (moonPhrase2.tick > moonPhrase.tick)
                        break;

                    phraseTracker[moonPhrase2.type] = moonPhrase2;
                    moonPhraseIndex++;
                }

                // Go through each note and lyric in the phrase
                var notes = new List<VocalNote>();
                var lyrics = new List<LyricEvent>();
                VocalNote? previousNote = null;
                uint endOfPhrase = moonPhrase.tick + moonPhrase.length;
                while (moonNoteIndex < moonChart.notes.Count)
                {
                    var moonNote = moonChart.notes[moonNoteIndex];
                    if (moonNote.tick >= endOfPhrase)
                        break;
                    moonNoteIndex++;

                    // Don't process notes that occur before the phrase
                    if (moonNote.tick < moonPhrase.tick)
                    {
                        YargLogger.LogFormatDebug("Vocals note at {0} does not exist within a phrase!", moonNote.tick);
                        continue;
                    }

                    // Handle lyric events
                    var lyricFlags = LyricSymbolFlags.None;
                    while (moonTextIndex < moonChart.events.Count)
                    {
                        var moonEvent = moonChart.events[moonTextIndex];
                        if (moonEvent.tick > moonNote.tick)
                            break;
                        moonTextIndex++;

                        string eventText = moonEvent.text;
                        // Non-lyric events
                        if (!eventText.StartsWith(TextEvents.LYRIC_PREFIX_WITH_SPACE))
                            continue;

                        var lyric = eventText.AsSpan()
                            .Slice(TextEvents.LYRIC_PREFIX_WITH_SPACE.Length).TrimStartAscii();
                        // Ignore empty lyrics
                        if (lyric.IsEmpty)
                            continue;

                        ProcessLyric(lyrics, lyric, moonEvent.tick, out lyricFlags);
                    }

                    // Create new note
                    var note = CreateVocalNote(moonNote, harmonyPart, lyricFlags);
                    if ((lyricFlags & LyricSymbolFlags.PitchSlide) != 0 && previousNote is not null)
                    {
                        previousNote.AddChildNote(note);
                        continue;
                    }

                    notes.Add(note);
                    previousNote = note;
                }

                if (notes.Count < 1)
                {
                    // This can occur on harmonies, HARM1 must contain phrases for all harmony parts
                    // so, for example, phrases with only HARM2/3 notes will cause this
                    continue;
                }

                var vocalsPhrase = CreateVocalsPhrase(moonPhrase, phraseTracker, notes, lyrics);
                phrases.Add(vocalsPhrase);
            }

            phrases.TrimExcess();
            return phrases;
        }

        private void ProcessLyric(List<LyricEvent> lyrics, ReadOnlySpan<char> lyric, uint lyricTick,
            out LyricSymbolFlags lyricFlags)
        {
            LyricSymbols.DeferredLyricJoinWorkaround(lyrics, ref lyric, addHyphen: true);

            // Handle lyric modifiers
            lyricFlags = LyricSymbols.GetLyricFlags(lyric);

            const LyricSymbolFlags noteTypeMask = LyricSymbolFlags.NonPitched | LyricSymbolFlags.PitchSlide;
            if ((lyricFlags & noteTypeMask) == noteTypeMask)
            {
                YargLogger.LogFormatDebug("Lyric '{0}' at tick {1} specifies multiple lyric types! Flags: {2}", lyric.ToString(), lyricTick, lyricFlags);

                // TODO: Should we prefer one over the other?
                // lyricFlags &= ~LyricFlags.NonPitched;
                // lyricFlags &= ~LyricFlags.PitchSlide;
            }

            // Strip special symbols from lyrics
            string strippedLyric = LyricSymbols.StripForVocals(lyric.ToString());
            if (string.IsNullOrWhiteSpace(strippedLyric))
                return;

            double time = _moonSong.TickToTime(lyricTick);
            lyrics.Add(new(lyricFlags, strippedLyric, time, lyricTick));
        }

        private List<VocalsRangeShift> GetRangeShifts(List<VocalsPart> parts, MoonSong.MoonInstrument sourceInstrument)
        {
            var ranges = new List<VocalsRangeShift>();

            if (parts.All((part) => part.NotePhrases.Count < 1))
            {
                // No phrases; add a dummy default range
                ranges.Add(new(48, 72, 0, 0, 0, 0));
                return ranges;
            }

            double shiftLength = 0;
            uint shiftStartTick = 0;

            int phraseIndex = 0;
            var indexes = new List<(int phraseIndex, int noteIndex)>(parts.Select((_) => (0, 0)));
            var chart = _moonSong.GetChart(sourceInstrument, MoonSong.Difficulty.Expert);
            foreach (var moonEvent in chart.events)
            {
                for (; phraseIndex < chart.specialPhrases.Count; phraseIndex++)
                {
                    var phrase = chart.specialPhrases[phraseIndex];
                    if (phrase.tick >= moonEvent.tick)
                        break;

                    if (phrase.type == MoonPhrase.Type.Vocals_RangeShift)
                    {
                        // Commit active shift
                        AddPitchRange(shiftStartTick, phrase.tick, shiftLength);

                        // Start new shift
                        shiftStartTick = phrase.tick;
                        double shiftStart = _moonSong.TickToTime(phrase.tick);
                        double shiftEnd = _moonSong.TickToTime(phrase.tick + phrase.length);
                        shiftLength = shiftEnd - shiftStart;
                    }
                }

                var eventText = moonEvent.text;
                if (eventText.StartsWith("range_shift"))
                {
                    // Commit active shift
                    AddPitchRange(shiftStartTick, moonEvent.tick, shiftLength);

                    // Start new shift
                    shiftStartTick = moonEvent.tick;

                    // Two forms: [range_shift] and [range_shift 0.5]
                    // The latter specifies the time of the shift in seconds
                    eventText.SplitOnce(' ', out var time);
                    if (time.IsEmpty || !double.TryParse(time, out shiftLength))
                        shiftLength = 0;
                }
                else if (eventText.StartsWith(TextEvents.LYRIC_PREFIX_WITH_SPACE))
                {
                    var lyric = eventText.AsSpan()
                        .Slice(TextEvents.LYRIC_PREFIX_WITH_SPACE.Length).TrimStartAscii();
                    // Ignore empty lyrics
                    if (lyric.IsEmpty)
                        continue;

                    // Check for the range shift symbol
                    var flags = LyricSymbols.GetLyricFlags(lyric);
                    if ((flags & LyricSymbolFlags.RangeShift) != 0)
                    {
                        // Commit active shift
                        AddPitchRange(shiftStartTick, moonEvent.tick, shiftLength);

                        // Start new shift
                        shiftStartTick = moonEvent.tick;
                        shiftLength = 0;
                    }
                }
            }

            // Finish off last range
            AddPitchRange(shiftStartTick, uint.MaxValue, shiftLength);

            // If a song is all talkies, there will be no ranges added
            // so we add a dummy range here
            if (ranges.Count < 1)
                ranges.Add(new(48, 72, 0, 0, 0, 0));

            return ranges;

            void AddPitchRange(uint startTick, uint endTick, double shiftLength)
            {
                // Determine pitch bounds for this range shift
                float minPitch = float.MaxValue;
                float maxPitch = float.MinValue;

                for (int i = 0; i < parts.Count; i++)
                {
                    var part = parts[i];
                    var (phraseIndex, noteIndex) = indexes[i];

                    for (; phraseIndex < part.NotePhrases.Count; phraseIndex++)
                    {
                        var phrase = part.NotePhrases[phraseIndex];
                        if (phrase.Tick >= endTick)
                            break;

                        if (phrase.TickEnd < startTick || phrase.IsPercussion)
                            // TODO: Percussion phrases should probably stop the range and start a new one afterwards
                            continue;

                        for (; noteIndex < phrase.PhraseParentNote.ChildNotes.Count; noteIndex++)
                        {
                            var note = phrase.PhraseParentNote.ChildNotes[noteIndex];
                            if (note.Tick >= endTick || note.TickEnd < startTick)
                                break;

                            foreach (var child in note.AllNotes)
                            {
                                if (child.Tick >= endTick || child.TickEnd < startTick || child.IsNonPitched)
                                    continue;

                                minPitch = Math.Min(minPitch, child.Pitch);
                                maxPitch = Math.Max(maxPitch, child.Pitch);
                            }
                        }

                        // Manual end due to reaching the last note in the range
                        if (noteIndex < phrase.PhraseParentNote.ChildNotes.Count)
                            break;

                        noteIndex = 0;
                    }

                    indexes[i] = (phraseIndex, noteIndex);
                }

                if (minPitch == float.MaxValue || maxPitch == float.MinValue)
                    return;

                double startTime = _moonSong.TickToTime(startTick);
                endTick = _moonSong.TimeToTick(startTime + shiftLength);
                ranges.Add(new(minPitch, maxPitch, startTime, shiftLength, startTick, endTick - startTick));
            }
        }


        private VocalNote CreateVocalNote(MoonNote moonNote, int harmonyPart, LyricSymbolFlags lyricFlags)
        {
            var vocalType = GetVocalNoteType(moonNote);
            float pitch = GetVocalNotePitch(moonNote, lyricFlags);

            double time = _moonSong.TickToTime(moonNote.tick);
            return new VocalNote(pitch, harmonyPart, vocalType, time, GetLengthInTime(moonNote), moonNote.tick, moonNote.length);
        }

        private float GetVocalNotePitch(MoonNote moonNote, LyricSymbolFlags lyricFlags)
        {
            float pitch = moonNote.vocalsPitch;

            // Unpitched/percussion notes
            if ((lyricFlags & LyricSymbolFlags.NonPitched) != 0 || (moonNote.flags & MoonNote.Flags.Vocals_Percussion) != 0)
                pitch = -1f;

            return pitch;
        }

        private VocalNoteType GetVocalNoteType(MoonNote moonNote)
        {
            var flags = VocalNoteType.Lyric;

            // Percussion notes
            if ((moonNote.flags & MoonNote.Flags.Vocals_Percussion) != 0)
            {
                flags = VocalNoteType.Percussion;
            }

            return flags;
        }

        private VocalsPhrase CreateVocalsPhrase(MoonPhrase moonPhrase, Dictionary<MoonPhrase.Type, MoonPhrase?> phrasetracker,
            List<VocalNote> notes, List<LyricEvent> lyrics)
        {
            double time = _moonSong.TickToTime(moonPhrase.tick);
            double timeLength = GetLengthInTime(moonPhrase);
            uint tick = moonPhrase.tick;
            uint tickLength = moonPhrase.length;

            var phraseFlags = GetVocalsPhraseFlags(moonPhrase, phrasetracker);

            // Convert to MoonPhrase into a vocal note phrase
            var phraseNote = new VocalNote(phraseFlags, time, timeLength, tick, tickLength);
            foreach (var note in notes)
            {
                phraseNote.AddChildNote(note);
            }

            return new VocalsPhrase(time, timeLength, tick, tickLength, phraseNote, lyrics);
        }

        private NoteFlags GetVocalsPhraseFlags(MoonPhrase moonPhrase, Dictionary<MoonPhrase.Type, MoonPhrase?> phrasetracker)
        {
            var phraseFlags = NoteFlags.None;

            // No need to check the start of the phrase, as entering the function
            // already guarantees that condition *if* the below is true
            var starPower = phrasetracker[MoonPhrase.Type.Starpower];
            if (starPower != null &&  moonPhrase.tick < starPower.tick + starPower.length)
            {
                phraseFlags |= NoteFlags.StarPower;
            }

            return phraseFlags;
        }
    }
}
</file>

<file path="Chart/Loaders/ISongLoader.cs">
using System.Collections.Generic;

namespace YARG.Core.Chart
{
    /// <summary>
    /// Interface used for loading chart files.
    /// </summary>
    internal interface ISongLoader
    {
        List<TextEvent> LoadGlobalEvents();
        List<Section> LoadSections();
        SyncTrack LoadSyncTrack();
        VenueTrack LoadVenueTrack();
        LyricsTrack LoadLyrics();

        InstrumentTrack<GuitarNote> LoadGuitarTrack(Instrument instrument);
        InstrumentTrack<ProGuitarNote> LoadProGuitarTrack(Instrument instrument);
        InstrumentTrack<ProKeysNote> LoadProKeysTrack(Instrument instrument);
        InstrumentTrack<DrumNote> LoadDrumsTrack(Instrument instrument);
        VocalsTrack LoadVocalsTrack(Instrument instrument);
    }
}
</file>

<file path="Chart/Notes/DrumNote.cs">
using System;

namespace YARG.Core.Chart
{
    public class DrumNote : Note<DrumNote>
    {
        private DrumNoteFlags _drumFlags;
        public DrumNoteFlags DrumFlags;

        public int Pad { get; }

        public DrumNoteType Type { get; set; }

        private int _padMask;

        public bool IsNeutral => Type == DrumNoteType.Neutral;
        public bool IsAccent  => Type == DrumNoteType.Accent;
        public bool IsGhost   => Type == DrumNoteType.Ghost;

        public float? HitVelocity;

        public bool IsStarPowerActivator => (DrumFlags & DrumNoteFlags.StarPowerActivator) != 0;

        public DrumNote(FourLaneDrumPad pad, DrumNoteType noteType, DrumNoteFlags drumFlags,
            NoteFlags flags, double time, uint tick)
            : this((int)pad, noteType, drumFlags, flags, time, tick)
        {
        }

        public DrumNote(FiveLaneDrumPad pad, DrumNoteType noteType, DrumNoteFlags drumFlags,
            NoteFlags flags, double time, uint tick)
            : this((int)pad, noteType, drumFlags, flags, time, tick)
        {
        }

        public DrumNote(int pad, DrumNoteType noteType, DrumNoteFlags drumFlags, NoteFlags flags, double time, uint tick)
            : base(flags, time, 0, tick, 0)
        {
            Pad = pad;
            Type = noteType;

            DrumFlags = _drumFlags = drumFlags;

            _padMask = 1 << pad;
        }

        public DrumNote(DrumNote other) : base(other)
        {
            Pad = other.Pad;
            Type = other.Type;

            DrumFlags = _drumFlags = other._drumFlags;

            _padMask = 1 << other.Pad;
        }

        public override void AddChildNote(DrumNote note)
        {
            if ((_padMask & (1 << note.Pad)) != 0) return;

            _padMask |= 1 << note.Pad;

            base.AddChildNote(note);
        }

        public override void ResetNoteState()
        {
            base.ResetNoteState();
            DrumFlags = _drumFlags;
            HitVelocity = null;
        }

        public void ActivateFlag(DrumNoteFlags drumNoteFlag)
        {
            _drumFlags |= drumNoteFlag;
            DrumFlags |= drumNoteFlag;
        }

        protected override void CopyFlags(DrumNote other)
        {
            _drumFlags = other._drumFlags;
            DrumFlags = other.DrumFlags;

            Type = other.Type;
        }

        protected override DrumNote CloneNote()
        {
            return new(this);
        }
    }

    public enum FourLaneDrumPad
    {
        Kick,

        RedDrum,
        YellowDrum,
        BlueDrum,
        GreenDrum,

        YellowCymbal,
        BlueCymbal,
        GreenCymbal,
    }

    public enum FiveLaneDrumPad
    {
        Kick,

        Red,
        Yellow,
        Blue,
        Orange,
        Green,
    }

    public enum DrumNoteType
    {
        Neutral,
        Ghost,
        Accent,
    }

    [Flags]
    public enum DrumNoteFlags
    {
        None = 0,

        StarPowerActivator = 1 << 0,
    }
}
</file>

<file path="Chart/Notes/GuitarNote.cs">
using System;

namespace YARG.Core.Chart
{
    public class GuitarNote : Note<GuitarNote>
    {
        private GuitarNoteFlags _guitarFlags;
        public GuitarNoteFlags GuitarFlags;

        public int Fret         { get; }
        public int DisjointMask { get; }
        public int NoteMask     { get; private set; }

        public GuitarNoteType Type { get; set; }

        public bool IsStrum => Type == GuitarNoteType.Strum;
        public bool IsHopo  => Type == GuitarNoteType.Hopo;
        public bool IsTap   => Type == GuitarNoteType.Tap;

        public bool IsSustain => TickLength > 0;

        public bool IsExtendedSustain => (GuitarFlags & GuitarNoteFlags.ExtendedSustain) != 0;
        public bool IsDisjoint        => (GuitarFlags & GuitarNoteFlags.Disjoint) != 0;

        public GuitarNote(FiveFretGuitarFret fret, GuitarNoteType noteType, GuitarNoteFlags guitarFlags,
            NoteFlags flags, double time, double timeLength, uint tick, uint tickLength)
            : this((int) fret, noteType, guitarFlags, flags, time, timeLength, tick, tickLength)
        {
        }

        public GuitarNote(SixFretGuitarFret fret, GuitarNoteType noteType, GuitarNoteFlags guitarFlags,
            NoteFlags flags, double time, double timeLength, uint tick, uint tickLength)
            : this((int) fret, noteType, guitarFlags, flags, time, timeLength, tick, tickLength)
        {
        }

        public GuitarNote(int fret, GuitarNoteType noteType, GuitarNoteFlags guitarFlags, NoteFlags flags,
            double time, double timeLength, uint tick, uint tickLength)
            : base(flags, time, timeLength, tick, tickLength)
        {
            Fret = fret;
            Type = noteType;

            GuitarFlags = _guitarFlags = guitarFlags;

            NoteMask = GetNoteMask(Fret);
            DisjointMask = GetNoteMask(Fret);
        }

        public GuitarNote(GuitarNote other) : base(other)
        {
            Fret = other.Fret;
            Type = other.Type;

            GuitarFlags = _guitarFlags = other._guitarFlags;

            NoteMask = GetNoteMask(Fret);
            DisjointMask = GetNoteMask(Fret);
        }

        public override void AddChildNote(GuitarNote note)
        {
            if ((NoteMask & GetNoteMask(note.Fret)) != 0) return;

            base.AddChildNote(note);

            NoteMask |= GetNoteMask(note.Fret);
        }

        public override void ResetNoteState()
        {
            base.ResetNoteState();
            GuitarFlags = _guitarFlags;
        }

        protected override void CopyFlags(GuitarNote other)
        {
            _guitarFlags = other._guitarFlags;
            GuitarFlags = other.GuitarFlags;

            Type = other.Type;
        }

        protected override GuitarNote CloneNote()
        {
            return new(this);
        }
    }

    public enum FiveFretGuitarFret
    {
        Green = 1,
        Red,
        Yellow,
        Blue,
        Orange,
        Open = 7,
    }

    public enum SixFretGuitarFret
    {
        Black1 = 1,
        Black2,
        Black3,
        White1,
        White2,
        White3,
        Open,
    }

    public enum GuitarNoteType
    {
        Strum,
        Hopo,
        Tap
    }

    [Flags]
    public enum GuitarNoteFlags
    {
        None = 0,

        ExtendedSustain = 1 << 0,
        Disjoint        = 1 << 1,
    }
}
</file>

<file path="Chart/Notes/Note.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace YARG.Core.Chart
{
    [Flags]
    public enum NoteFlags
    {
        None = 0,

        StarPower      = 1 << 0,
        StarPowerStart = 1 << 1,
        StarPowerEnd   = 1 << 2,

        Solo      = 1 << 3,
        SoloStart = 1 << 4,
        SoloEnd   = 1 << 5,
    }

    public abstract class Note<TNote> : ChartEvent, ICloneable<TNote>
        where TNote : Note<TNote>
    {
        public struct AllNotesEnumerator
        {
            private readonly TNote _note;
            private int _index;

            public AllNotesEnumerator(TNote note)
            {
                _note = note;
                _index = -1;
            }

            public TNote Current => _index == 0
                ? _note
                : _note.ChildNotes[_index - 1];

            public bool MoveNext()
            {
                _index++;
                return _index <= _note.ChildNotes.Count;
            }

            public void Reset()
            {
                _index = -1;
            }

            public AllNotesEnumerator GetEnumerator()
            {
                return this;
            }
        }

        protected readonly List<TNote> _childNotes = new();

        private NoteFlags _flags;
        public  NoteFlags Flags;

        private TNote? _originalPreviousNote;
        private TNote? _originalNextNote;

        public TNote? PreviousNote;
        public TNote? NextNote;

        public uint SustainTicksHeld;

        public TNote? Parent { get; private set; }
        public IReadOnlyList<TNote> ChildNotes => _childNotes;

        /// <summary>
        /// Returns this note's parent, and if it's null, returns itself instead.
        /// </summary>
        public TNote ParentOrSelf => Parent ?? (TNote) this;
        public bool  IsChord      => _childNotes.Count > 0;

        public bool IsParent => Parent == null;
        public bool IsChild  => !IsParent;

        public bool IsStarPower      => (Flags & NoteFlags.StarPower) != 0;
        public bool IsStarPowerStart => (Flags & NoteFlags.StarPowerStart) != 0;
        public bool IsStarPowerEnd   => (Flags & NoteFlags.StarPowerEnd) != 0;

        public bool IsSolo => (Flags & NoteFlags.Solo) != 0;
        public bool IsSoloStart => (Flags & NoteFlags.SoloStart) != 0;
        public bool IsSoloEnd   => (Flags & NoteFlags.SoloEnd) != 0;

        /// <summary>
        /// Returns an enumerator that contains all child notes and the parent note itself (allocation free).
        /// </summary>
        public AllNotesEnumerator AllNotes => new((TNote) this);

        public bool WasHit;
        public bool WasMissed;

        protected Note(NoteFlags flags, double time, double timeLength, uint tick, uint tickLength)
            : base(time, timeLength, tick, tickLength)
        {
            Flags = _flags = flags;
        }

        protected Note(Note<TNote> other) : base(other)
        {
            Flags = _flags = other._flags;

            // Child notes are not added here, since this is called before the inheritor's constructor is
        }

        public virtual void AddChildNote(TNote note)
        {
            if (note.Tick != Tick)
                throw new InvalidOperationException("Child note being added is not on the same tick!");
            if (note.ChildNotes.Count > 0)
                throw new InvalidOperationException("Child note being added has its own children!");

            note.Parent = (TNote) this;
            _childNotes.Add(note);
        }

        public void SetHitState(bool hit, bool includeChildren)
        {
            WasHit = hit;
            if (!includeChildren) return;

            foreach (var childNote in _childNotes)
            {
                childNote.SetHitState(hit, true);
            }
        }

        public void SetMissState(bool miss, bool includeChildren)
        {
            WasMissed = miss;
            if (!includeChildren) return;

            foreach (var childNote in _childNotes)
            {
                childNote.SetMissState(miss, true);
            }
        }

        public bool WasFullyHit()
        {
            if (!WasHit)
            {
                return false;
            }

            foreach (var childNote in _childNotes)
            {
                if (!childNote.WasFullyHit())
                {
                    return false;
                }
            }

            return true;
        }

        public bool WasFullyMissed()
        {
            if (!WasMissed)
            {
                return false;
            }

            foreach (var childNote in _childNotes)
            {
                if (!childNote.WasFullyMissed())
                {
                    return false;
                }
            }

            return true;
        }

        public bool WasFullyHitOrMissed()
        {
            if (!WasMissed && !WasHit)
            {
                return false;
            }

            foreach (var childNote in _childNotes)
            {
                if (!childNote.WasFullyHitOrMissed())
                {
                    return false;
                }
            }

            return true;
        }

        public void OverridePreviousNote()
        {
            // Prevent overriding previous note more than once without resetting note state
            if(_originalPreviousNote != null)
            {
                throw new InvalidOperationException("Cannot override previous note more than once");
            }

            _originalPreviousNote = PreviousNote;
            PreviousNote = null;
        }

        public void OverrideNextNote()
        {
            // Prevent overriding next note more than once without resetting note state
            if(_originalNextNote != null)
            {
                throw new InvalidOperationException("Cannot override next note more than once");
            }

            _originalNextNote = NextNote;
            NextNote = null;
        }

        public virtual void ResetNoteState()
        {
            Flags = _flags;
            WasHit = false;
            WasMissed = false;
            SustainTicksHeld = 0;

            if(_originalPreviousNote != null)
            {
                PreviousNote = _originalPreviousNote;
            }
            if (_originalNextNote != null)
            {
                NextNote = _originalNextNote;
            }

            _originalPreviousNote = null;
            _originalNextNote = null;

            foreach(var childNote in _childNotes)
            {
                childNote.ResetNoteState();
            }
        }

        protected static int GetNoteMask(int note)
        {
            // Resulting shift is 1 too high, shifting down by 1 corrects this.
            // Reason for not doing (note - 1) is this breaks open notes. (1 << (0 - 1) == 0x80000000)
            // Shifting down by 1 accounts for open notes and sets the mask to 0.
            int mask = 1 << note;
            mask >>= 1;
            return mask;
        }

        public void CopyValuesFrom(TNote other)
        {
            Time = other.Time;
            TimeLength = other.TimeLength;
            Tick = other.Tick;
            TickLength = other.TickLength;

            _flags = other._flags;
            Flags = other.Flags;

            CopyFlags(other);
        }

        public void ActivateFlag(NoteFlags noteFlag)
        {
            _flags |= noteFlag;
            Flags |= noteFlag;
        }

        public void ResetFlags()
        {
            Flags = _flags;
        }

        protected abstract void CopyFlags(TNote other);
        protected abstract TNote CloneNote();

        /// <summary>
        /// Creates a copy of this note with the same set of values.
        /// </summary>
        /// <remarks>
        /// NOTE: Next/previous references and changes in state are not preserved,
        /// notes are re-created from scratch.
        /// </remarks>
        public TNote Clone()
        {
            var newNote = CloneWithoutChildNotes();
            foreach (var child in _childNotes)
            {
                newNote.AddChildNote(child.Clone());
            }

            return newNote;
        }

        /// <summary>
        /// Creates a copy of this note with the same set of values, but without the child notes
        /// </summary>
        /// <remarks>
        /// NOTE: Next/previous references and changes in state are not preserved,
        /// notes are re-created from scratch.
        /// </remarks>
        public TNote CloneWithoutChildNotes()
        {
            var newNote = CloneNote();
            return newNote;
        }
    }
}
</file>

<file path="Chart/Notes/NoteTrackers.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

#nullable enable

namespace YARG.Core.Chart
{
    /// <summary>
    /// Tracks the current note of a note list across ticks.
    /// </summary>
    /// <remarks>
    /// Tracks child notes in addition to the parent notes contained directly within the given list.
    /// </remarks>
    public class NoteTickTracker<TNote>
        where TNote : Note<TNote>
    {
        private ChartEventTickTracker<TNote> _tracker;
        private int _childIndex = -1;

        public TNote? Current => _childIndex < 0 ? CurrentParent : CurrentChild;

        public TNote? CurrentParent => _tracker.Current;
        public TNote? CurrentChild => _childIndex >= 0 ? CurrentParent!.ChildNotes[_childIndex] : null;

        public int CurrentParentIndex => _tracker.CurrentIndex;
        public int CurrentChildIndex => _childIndex;

        public NoteTickTracker(List<TNote> notes)
        {
            _tracker = new(notes);
        }

        /// <summary>
        /// Updates the state of the note tracker to the given tick.
        /// </summary>
        /// <remarks>
        /// Resets the child note state upon a successful update.
        /// </remarks>
        /// <returns>
        /// True if a new note has been reached, false otherwise.
        /// </returns>
        public bool Update(uint tick)
        {
            if (_tracker.Update(tick))
            {
                _childIndex = -1;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Updates the state of the note tracker to the given tick by a single note.
        /// </summary>
        /// <remarks>
        /// First updates through a note's child notes, then updates to the next note.
        /// </remarks>
        /// <returns>
        /// True if a new note has been reached, false otherwise.
        /// </returns>
        public bool UpdateOnce(uint tick, [NotNullWhen(true)] out TNote? current)
        {
            var currentParent = CurrentParent;
            if (currentParent != null && _childIndex + 1 < currentParent.ChildNotes.Count)
            {
                _childIndex++;
                current = currentParent.ChildNotes[_childIndex];
                return true;
            }

            if (_tracker.UpdateOnce(tick, out current))
            {
                _childIndex = -1;
                return true;
            }

            current = Current;
            return false;
        }

        /// <summary>
        /// Resets the state of the note tracker.
        /// </summary>
        public void Reset()
        {
            _tracker.Reset();
            _childIndex = -1;
        }

        /// <summary>
        /// Resets the state of the note tracker to the given tick.
        /// </summary>
        public void ResetToTick(uint tick)
        {
            _tracker.ResetToTick(tick);
            _childIndex = -1;
        }
    }

    /// <summary>
    /// Tracks the current note of a note list across times.
    /// </summary>
    /// <remarks>
    /// Tracks child notes in addition to the parent notes contained directly within the given list.
    /// </remarks>
    public class NoteTimeTracker<TNote>
        where TNote : Note<TNote>
    {
        private ChartEventTimeTracker<TNote> _tracker;
        private int _childIndex = -1;

        public TNote? Current => _childIndex < 0 ? CurrentParent : CurrentChild;

        public TNote? CurrentParent => _tracker.Current;
        public TNote? CurrentChild => _childIndex >= 0 ? CurrentParent!.ChildNotes[_childIndex] : null;

        public int CurrentParentIndex => _tracker.CurrentIndex;
        public int CurrentChildIndex => _childIndex;

        public NoteTimeTracker(List<TNote> notes)
        {
            _tracker = new(notes);
        }

        /// <summary>
        /// Updates the state of the note tracker to the given time.
        /// </summary>
        /// <remarks>
        /// Resets the child note state upon a successful update.
        /// </remarks>
        /// <returns>
        /// True if a new note has been reached, false otherwise.
        /// </returns>
        public bool Update(double time)
        {
            if (_tracker.Update(time))
            {
                _childIndex = -1;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Updates the state of the note tracker to the given time by a single note.
        /// </summary>
        /// <remarks>
        /// First updates through a note's child notes, then updates to the next note.
        /// </remarks>
        /// <returns>
        /// True if a new note has been reached, false otherwise.
        /// </returns>
        public bool UpdateOnce(double time, [NotNullWhen(true)] out TNote? current)
        {
            var currentParent = CurrentParent;
            if (currentParent != null && _childIndex + 1 < currentParent.ChildNotes.Count)
            {
                _childIndex++;
                current = currentParent.ChildNotes[_childIndex];
                return true;
            }

            if (_tracker.UpdateOnce(time, out current))
            {
                _childIndex = -1;
                return true;
            }

            current = Current;
            return false;
        }

        /// <summary>
        /// Resets the state of the note tracker.
        /// </summary>
        public void Reset()
        {
            _tracker.Reset();
            _childIndex = -1;
        }

        /// <summary>
        /// Resets the state of the note tracker to the given time.
        /// </summary>
        public void ResetToTime(double time)
        {
            _tracker.ResetToTime(time);
            _childIndex = -1;
        }
    }

}
</file>

<file path="Chart/Notes/NoteTrackers.t4">
<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

#nullable enable

namespace YARG.Core.Chart
{
<#
var types = new (string upper, string lower, string type)[] {
    ("Tick", "tick", "uint"),
    ("Time", "time", "double"),
};

foreach (var (upper, lower, type) in types)
{
#>
    /// <summary>
    /// Tracks the current note of a note list across <#= lower #>s.
    /// </summary>
    /// <remarks>
    /// Tracks child notes in addition to the parent notes contained directly within the given list.
    /// </remarks>
    public class Note<#= upper #>Tracker<TNote>
        where TNote : Note<TNote>
    {
        private ChartEvent<#= upper #>Tracker<TNote> _tracker;
        private int _childIndex = -1;

        public TNote? Current => _childIndex < 0 ? CurrentParent : CurrentChild;

        public TNote? CurrentParent => _tracker.Current;
        public TNote? CurrentChild => _childIndex >= 0 ? CurrentParent!.ChildNotes[_childIndex] : null;

        public int CurrentParentIndex => _tracker.CurrentIndex;
        public int CurrentChildIndex => _childIndex;

        public Note<#= upper #>Tracker(List<TNote> notes)
        {
            _tracker = new(notes);
        }

        /// <summary>
        /// Updates the state of the note tracker to the given <#= lower #>.
        /// </summary>
        /// <remarks>
        /// Resets the child note state upon a successful update.
        /// </remarks>
        /// <returns>
        /// True if a new note has been reached, false otherwise.
        /// </returns>
        public bool Update(<#= type #> <#= lower #>)
        {
            if (_tracker.Update(<#= lower #>))
            {
                _childIndex = -1;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Updates the state of the note tracker to the given <#= lower #> by a single note.
        /// </summary>
        /// <remarks>
        /// First updates through a note's child notes, then updates to the next note.
        /// </remarks>
        /// <returns>
        /// True if a new note has been reached, false otherwise.
        /// </returns>
        public bool UpdateOnce(<#= type #> <#= lower #>, [NotNullWhen(true)] out TNote? current)
        {
            var currentParent = CurrentParent;
            if (currentParent != null && _childIndex + 1 < currentParent.ChildNotes.Count)
            {
                _childIndex++;
                current = currentParent.ChildNotes[_childIndex];
                return true;
            }

            if (_tracker.UpdateOnce(<#= lower #>, out current))
            {
                _childIndex = -1;
                return true;
            }

            current = Current;
            return false;
        }

        /// <summary>
        /// Resets the state of the note tracker.
        /// </summary>
        public void Reset()
        {
            _tracker.Reset();
            _childIndex = -1;
        }

        /// <summary>
        /// Resets the state of the note tracker to the given <#= lower #>.
        /// </summary>
        public void ResetTo<#= upper #>(<#= type #> <#= lower #>)
        {
            _tracker.ResetTo<#= upper #>(<#= lower #>);
            _childIndex = -1;
        }
    }

<#
}
#>
}
</file>

<file path="Chart/Notes/ProGuitarNote.cs">
using System;

namespace YARG.Core.Chart
{
    public class ProGuitarNote : Note<ProGuitarNote>
    {
        private ProGuitarNoteFlags _proFlags;
        public ProGuitarNoteFlags ProFlags;

        public int String   { get; }
        public int Fret     { get; }

        public ProGuitarNoteType Type { get; set; }

        public bool IsStrum => Type == ProGuitarNoteType.Strum;
        public bool IsHopo  => Type == ProGuitarNoteType.Hopo;
        public bool IsTap   => Type == ProGuitarNoteType.Tap;

        public bool IsSustain => TickLength > 0;

        public bool IsExtendedSustain => (ProFlags & ProGuitarNoteFlags.ExtendedSustain) != 0;
        public bool IsDisjoint        => (ProFlags & ProGuitarNoteFlags.Disjoint) != 0;

        public bool IsMuted => (ProFlags & ProGuitarNoteFlags.Muted) != 0;

        public ProGuitarNote(ProGuitarString proString, int proFret, ProGuitarNoteType type, ProGuitarNoteFlags proFlags,
            NoteFlags flags, double time, double timeLength, uint tick, uint tickLength)
            : this((int) proString, proFret, type, proFlags, flags, time, timeLength, tick, tickLength)
        {
        }

        public ProGuitarNote(int proString, int proFret, ProGuitarNoteType type, ProGuitarNoteFlags proFlags,
            NoteFlags flags, double time, double timeLength, uint tick, uint tickLength)
            : base(flags, time, timeLength, tick, tickLength)
        {
            String = proString;
            Fret = proFret;
            Type = type;

            ProFlags = _proFlags = proFlags;
        }

        public ProGuitarNote(ProGuitarNote other) : base(other)
        {
            String = other.String;
            Fret = other.Fret;
            Type = other.Type;

            ProFlags = _proFlags = other._proFlags;
        }

        public override void AddChildNote(ProGuitarNote note)
        {
            // TODO Check if string+fret already exists in the parent and skip adding if it does

            base.AddChildNote(note);
        }

        public override void ResetNoteState()
        {
            base.ResetNoteState();
            ProFlags = _proFlags;
        }

        protected override void CopyFlags(ProGuitarNote other)
        {
            _proFlags = other._proFlags;
            ProFlags = other.ProFlags;

            Type = other.Type;
        }

        protected override ProGuitarNote CloneNote()
        {
            return new(this);
        }
    }

    public enum ProGuitarString
    {
        Red,
        Green,
        Orange,
        Blue,
        Yellow,
        Purple,
    }

    public enum ProGuitarNoteType
    {
        Strum,
        Hopo,
        Tap,
    }

    [Flags]
    public enum ProGuitarNoteFlags
    {
        None = 0,

        ExtendedSustain = 1 << 0,
        Disjoint        = 1 << 1,

        Muted = 1 << 2, // TODO: would this make more sense as its own note type? physically, only strums can be muted
    }
}
</file>

<file path="Chart/Notes/ProKeysNote.cs">
using System;

namespace YARG.Core.Chart
{
    public class ProKeysNote : Note<ProKeysNote>
    {
        private ProKeysNoteFlags _proKeysFlags;
        public ProKeysNoteFlags ProKeysFlags;

        public int Key          { get; }
        public int DisjointMask { get; }
        public int NoteMask     { get; private set; }

        public bool IsGlissando => (ProKeysFlags & ProKeysNoteFlags.Glissando) != 0;

        public bool IsSustain => TickLength > 0;

        public ProKeysNote(int key, ProKeysNoteFlags proKeysFlags, NoteFlags flags,
            double time, double timeLength, uint tick, uint tickLength)
            : base(flags, time, timeLength, tick, tickLength)
        {
            Key = key;

            ProKeysFlags = _proKeysFlags = proKeysFlags;

            NoteMask = GetKeyMask(Key);
        }

        public ProKeysNote(ProKeysNote other) : base(other)
        {
            Key = other.Key;

            ProKeysFlags = _proKeysFlags = other._proKeysFlags;

            NoteMask = GetKeyMask(Key);
            DisjointMask = GetKeyMask(Key);
        }

        public override void AddChildNote(ProKeysNote note)
        {
            if ((NoteMask & GetKeyMask(note.Key)) != 0) return;

            base.AddChildNote(note);

            NoteMask |= GetKeyMask(note.Key);
        }

        public override void ResetNoteState()
        {
            base.ResetNoteState();
            ProKeysFlags = _proKeysFlags;
        }

        protected override void CopyFlags(ProKeysNote other)
        {
            _proKeysFlags = other._proKeysFlags;
            ProKeysFlags = other.ProKeysFlags;
        }

        protected override ProKeysNote CloneNote()
        {
            return new(this);
        }

        private static int GetKeyMask(int key)
        {
            return 1 << key;
        }
    }

    [Flags]
    public enum ProKeysNoteFlags
    {
        None = 0,

        Glissando = 1 << 0,
    }
}
</file>

<file path="Chart/Notes/VocalNote.cs">
using System;
using System.Linq;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A note on a vocals track.
    /// </summary>
    public class VocalNote : Note<VocalNote>
    {
        /// <summary>
        /// The type of vocals note (either a phrase, a lyrical note or a percussion hit).
        /// </summary>
        public VocalNoteType Type { get; private set; }

        /// <summary>
        /// 0-based index for the harmony part this note is a part of.
        /// HARM1 is 0, HARM2 is 1, HARM3 is 2.
        /// </summary>
        public int HarmonyPart { get; }

        /// <summary>
        /// The MIDI pitch of the note, as a float.
        /// -1 means the note is unpitched.
        /// </summary>
        public float Pitch { get; }

        /// <summary>
        /// The octave of the vocal pitch.
        /// Octaves start at -1 in MIDI: note 60 is C4, note 12 is C0, note 0 is C-1.
        /// </summary>
        public int Octave => (int) (Pitch / 12) - 1;

        /// <summary>
        /// The pitch of the note wrapped relative to an octave (0-11).
        /// C is 0, B is 11. -1 means the note is unpitched.
        /// </summary>
        public float OctavePitch => Pitch % 12;

        /// <summary>
        /// The length of this note and all of its children, in seconds.
        /// </summary>
        public double TotalTimeLength { get; private set; }

        /// <summary>
        /// The time-based end of this note and all of its children.
        /// </summary>
        public double TotalTimeEnd => Time + TotalTimeLength;

        /// <summary>
        /// The length of this note and all of its children, in ticks.
        /// </summary>
        public uint TotalTickLength { get; private set; }
        /// <summary>
        /// The tick-based end of this note and all of its children.
        /// </summary>
        public uint TotalTickEnd => Tick + TotalTickLength;

        /// <summary>
        /// Whether or not this note is non-pitched.
        /// </summary>
        public bool IsNonPitched => Pitch < 0;

        /// <summary>
        /// Whether or not this note is a percussion note.
        /// </summary>
        public bool IsPercussion => Type == VocalNoteType.Percussion;

        /// <summary>
        /// Whether or not this note is a vocal phrase.
        /// </summary>
        public bool IsPhrase => Type == VocalNoteType.Phrase;

        /// <summary>
        /// Whether or not this note is a vocal phrase that contains no notes.
        /// </summary>
        public bool IsEmptyPhrase => Type == VocalNoteType.Phrase && ChildNotes.Count == 0;

        /// <summary>
        /// Creates a new <see cref="VocalNote"/> with the given properties.
        /// This constructor should be used for notes only.
        /// </summary>
        public VocalNote(float pitch, int harmonyPart, VocalNoteType type,
            double time, double timeLength, uint tick, uint tickLength)
            : base(NoteFlags.None, time, timeLength, tick, tickLength)
        {
            Type = type;
            Pitch = pitch;
            HarmonyPart = harmonyPart;

            TotalTimeLength = timeLength;
            TotalTickLength = tickLength;
        }

        /// <summary>
        /// Creates a new <see cref="VocalNote"/> phrase with the given properties.
        /// This constructor should be used for vocal phrases only.
        /// </summary>
        public VocalNote(NoteFlags noteFlags,
            double time, double timeLength, uint tick, uint tickLength)
            : base(noteFlags, time, timeLength, tick, tickLength)
        {
            Type = VocalNoteType.Phrase;

            TotalTimeLength = timeLength;
            TotalTickLength = tickLength;
        }

        public VocalNote(VocalNote other) : base(other)
        {
            Type = other.Type;
            Pitch = other.Pitch;
            HarmonyPart = other.HarmonyPart;

            TotalTimeLength = other.TotalTimeLength;
            TotalTickLength = other.TotalTickLength;
        }

        /// <summary>
        /// Gets the pitch of this note and its children at the specified time.
        /// Clamps to the start and end if the time is out of bounds.
        /// </summary>
        public float PitchAtSongTime(double time)
        {
            if (Type == VocalNoteType.Phrase)
            {
                return -1f;
            }

            // Clamp to start
            if (time < TimeEnd || ChildNotes.Count < 1)
            {
                return Pitch;
            }

            // Search child notes
            var firstNote = this;
            foreach (var secondNote in ChildNotes)
            {
                // Check note bounds
                if (time >= firstNote.Time && time < secondNote.TimeEnd)
                {
                    // Check if time is in a specific pitch
                    if (time < firstNote.TimeEnd)
                        return firstNote.Pitch;

                    if (time >= secondNote.Time)
                        return secondNote.Pitch;

                    // Time is between the two pitches, lerp them
                    double percent = YargMath.InverseLerpD(firstNote.TimeEnd, secondNote.Time, time);
                    return YargMath.Lerp(firstNote.Pitch, secondNote.Pitch, percent);
                }

                firstNote = secondNote;
            }

            // Clamp to end
            return ChildNotes[^1].Pitch;
        }

        public override void AddChildNote(VocalNote note)
        {
            /*
             TODO Add same child note checking like the other instruments
             (but I have no idea how vocals works) - Riley
            */

            if (IsPhrase)
            {
                if (note.Tick < Tick) return;

                _childNotes.Add(note);

                // Sort child notes by tick
                _childNotes.Sort((note1, note2) =>
                {
                    if (note1.Tick > note2.Tick) return 1;
                    if (note1.Tick < note2.Tick) return -1;
                    return 0;
                });
            }
            else
            {
                if (note.Tick <= Tick || note.ChildNotes.Count > 0) return;

                _childNotes.Add(note);

                // Sort child notes by tick
                _childNotes.Sort((note1, note2) =>
                {
                    if (note1.Tick > note2.Tick) return 1;
                    if (note1.Tick < note2.Tick) return -1;
                    return 0;
                });

                // Track total length
                TotalTimeLength = _childNotes[^1].TimeEnd - Time;
                TotalTickLength = _childNotes[^1].TickEnd - Tick;
            }
        }

        protected override void CopyFlags(VocalNote other)
        {
            Type = other.Type;
        }

        protected override VocalNote CloneNote()
        {
            return new(this);
        }

        public void RemovePercussionChildNotes()
        {
            _childNotes.RemoveAll(e => e.Type == VocalNoteType.Percussion);
        }
    }

    /// <summary>
    /// Possible vocal note types.
    /// </summary>
    public enum VocalNoteType
    {
        Phrase,
        Lyric,
        Percussion
    }
}
</file>

<file path="Chart/Sync/Beatline.cs">
using System;

namespace YARG.Core.Chart
{
    public partial class Beatline : SyncEvent, IEquatable<Beatline>, ICloneable<Beatline>
    {
        public BeatlineType Type { get; }

        public Beatline(BeatlineType type, double time, uint tick) : base(time, tick)
        {
            Type = type;
        }

        public Beatline Clone()
        {
            return new(Type, Time, Tick);
        }

        public static bool operator ==(Beatline? left, Beatline? right)
        {
            if (ReferenceEquals(left, right))
                return true;

            if (left is null || right is null)
                return false;

            return left.Equals(right);
        }

        public static bool operator !=(Beatline? left, Beatline? right)
            => !(left == right);

        public bool Equals(Beatline other)
        {
            return base.Equals(other) && Type == other.Type;
        }

        public override bool Equals(object? obj)
            => obj is Beatline tempo && Equals(tempo);

        public override int GetHashCode()
            => base.GetHashCode();

        public override string ToString()
        {
            return $"{Type} line at tick {Tick}, time {Time}";
        }
    }

    public enum BeatlineType
    {
        Measure,
        Strong,
        Weak,
    }
}
</file>

<file path="Chart/Sync/SyncEvent.cs">
namespace YARG.Core.Chart
{
    public abstract class SyncEvent : ChartEvent
    {
        public SyncEvent(double time, uint tick) : base(time, 0, tick, 0)
        {
        }
    }
}
</file>

<file path="Chart/Sync/SyncTrack.cs">
using System;
using System.Collections.Generic;

namespace YARG.Core.Chart
{
    /// <summary>
    /// An instrument track and all of its difficulties.
    /// </summary>
    public class SyncTrack
    {
        /// <returns>
        /// The power of two to multiply the denominator by to increase the beatline rate.
        /// </returns>
        public delegate uint GetBeatlineRatePower(TimeSignatureChange timeSignature);
        public delegate BeatlineType GetBeatlineType(TimeSignatureChange currentTimeSig, uint beatlineCount);

        public uint Resolution { get; }
        public List<TempoChange> Tempos { get; } = new();
        public List<TimeSignatureChange> TimeSignatures { get; } = new();
        public List<Beatline> Beatlines { get; } = new();

        public SyncTrack(uint resolution)
        {
            Resolution = resolution;
        }

        public SyncTrack(uint resolution, List<TempoChange> tempos, List<TimeSignatureChange> timeSignatures,
            List<Beatline> beatlines)
            : this(resolution)
        {
            Tempos = tempos;
            TimeSignatures = timeSignatures;
            Beatlines = beatlines;

            Tempos.Sort((x, y) => x.Tick.CompareTo(y.Tick));
            TimeSignatures.Sort((x, y) => x.Tick.CompareTo(y.Tick));
        }

        /// <summary>
        /// Generates beatlines based on the tempo map.
        /// Overwrites <see cref="Beatlines"/>.
        /// </summary>
        /// <param name="endTime">
        /// The time to generate beatlines up to.
        /// </param>
        public void GenerateBeatlines(double endTime)
        {
            GenerateBeatlines(TimeToTick(endTime));
        }

        /// <summary>
        /// Generates beatlines based on the tempo map.
        /// Overwrites <see cref="Beatlines"/>.
        /// </summary>
        /// <param name="lastTick">
        /// The tick to generate beatlines up to, inclusive.
        /// </param>
        public void GenerateBeatlines(uint lastTick)
        {
            GenerateBeatlines(lastTick, GetBeatlinePower, GetBeatlineType);

            static uint GetBeatlinePower(TimeSignatureChange currentTimeSig)
            {
                return 0;
            }

            static BeatlineType GetBeatlineType(TimeSignatureChange currentTimeSig, uint beatlineCount)
            {
                // The denominator at which to generate strong beats
                const uint strongStep = 4;

                uint measureBeatCount = beatlineCount % currentTimeSig.Numerator;
                uint strongRate = currentTimeSig.Denominator is <= 4 or < strongStep
                    ? 1
                    : currentTimeSig.Denominator / strongStep;

                // 1/x time signatures
                if (currentTimeSig.Numerator == 1)
                {
                    // Only the first beatline should be a measure line
                    if (beatlineCount < 1)
                        return BeatlineType.Measure;

                    // The rest are emphasized periodically
                    return (beatlineCount % strongRate) == 0 ? BeatlineType.Strong : BeatlineType.Weak;
                }

                // Measure lines
                if (measureBeatCount == 0)
                    return BeatlineType.Measure;

                // Only use weak beats on x/8 or greater
                if (currentTimeSig.Denominator is <= 4 or < strongStep)
                    return BeatlineType.Strong;

                // Emphasize beatlines periodically
                if ((measureBeatCount % strongRate) == 0)
                {
                    // Always force the last beatline of a measure to be weak
                    if (measureBeatCount == currentTimeSig.Numerator - 1)
                        return BeatlineType.Weak;

                    return BeatlineType.Strong;
                }
                else
                {
                    return BeatlineType.Weak;
                }
            }
        }

        /// <summary>
        /// Generates beatlines based on the tempo map and provided configuration delegates.
        /// Overwrites <see cref="Beatlines"/>.
        /// </summary>
        /// <param name="endTime">
        /// The time to generate beatlines up to.
        /// </param>
        public void GenerateBeatlines(double endTime, GetBeatlineRatePower getBeatlinePower, GetBeatlineType getBeatlineType)
        {
            GenerateBeatlines(TimeToTick(endTime), getBeatlinePower, getBeatlineType);
        }

        /// <summary>
        /// Generates beatlines based on the tempo map and provided configuration delegates.
        /// Overwrites <see cref="Beatlines"/>.
        /// </summary>
        /// <param name="lastTick">
        /// The tick to generate beatlines up to, inclusive.
        /// </param>
        public void GenerateBeatlines(uint lastTick, GetBeatlineRatePower getBeatlinePower, GetBeatlineType getBeatlineType)
        {
            lastTick++;
            Beatlines.Clear();
            Beatlines.Capacity = (int) (lastTick / Resolution);

            // List indexes
            int tempoIndex = 0;
            int timeSigIndex = 0;

            // Iterate through all of the time signatures
            var currentTimeSig = TimeSignatures[timeSigIndex++];
            for (; timeSigIndex < TimeSignatures.Count; timeSigIndex++)
            {
                var nextTimeSig = TimeSignatures[timeSigIndex];

                // Determine bounds
                uint startTick = currentTimeSig.Tick;
                uint endTick = nextTimeSig.Tick - 1;

                // Generate beatlines for this time signature
                GenerateBeatsForTimeSignature(currentTimeSig, startTick, endTick);
                currentTimeSig = nextTimeSig;
            }

            // Final time signature
            GenerateBeatsForTimeSignature(currentTimeSig, currentTimeSig.Tick, lastTick);

            Beatlines.TrimExcess();

            void GenerateBeatsForTimeSignature(TimeSignatureChange timeSignature, uint startTick, uint endTick)
            {
                uint beatlineTickFactor = timeSignature.Denominator * (uint)Math.Pow(2, getBeatlinePower(timeSignature));
                uint beatlineTickRate = (Resolution * 4) / beatlineTickFactor;

                uint beatlineCount = 0;
                uint currentTick = startTick;
                var currentTempo = Tempos[tempoIndex];
                while (currentTick <= endTick)
                {
                    // Progress to current tempo
                    while (tempoIndex < Tempos.Count - 1)
                    {
                        var nextTempo = Tempos[tempoIndex + 1];
                        if (nextTempo.Tick > currentTick)
                            break;

                        currentTempo = nextTempo;
                        tempoIndex++;
                    }

                    var beatlineType = getBeatlineType(timeSignature, beatlineCount);

                    // Create beatline
                    double time = TickToTime(currentTick, currentTempo);
                    Beatlines.Add(new Beatline(beatlineType, time, currentTick));
                    beatlineCount++;
                    currentTick += beatlineTickRate;
                }
            }
        }

        public double TickToTime(uint tick)
        {
            // Find the current tempo marker at the given tick
            var currentTempo = Tempos.GetPrevious(tick);
            if (currentTempo is null)
                return 0;

            return TickToTime(tick, currentTempo);

            // Fun little tidbit: if you're between two tempo markers, you can just lerp
            // This doesn't work for the final tempo marker however, there you'll need
            // to calculate the change in time differently
            // return YargMath.Lerp(currentTempo.Time, nextTempo.Time, currentTempo.Tick, nextTempo.Tick, tick);
        }

        public uint TimeToTick(double time)
        {
            if (time < 0)
                return 0;

            // Find the current tempo marker at the given time
            var currentTempo = Tempos.GetPrevious(time);
            if (currentTempo is null)
                return 0;

            return TimeToTick(time, currentTempo);
        }

        public double TickToTime(uint tick, TempoChange currentTempo)
        {
            return currentTempo.Time + TickRangeToTimeDelta(currentTempo.Tick, tick, currentTempo);
        }

        public uint TimeToTick(double time, TempoChange currentTempo)
        {
            return currentTempo.Tick + TimeRangeToTickDelta(currentTempo.Time, time, currentTempo);
        }

        public double TickRangeToTimeDelta(uint tickStart, uint tickEnd, TempoChange currentTempo)
        {
            return TickRangeToTimeDelta(tickStart, tickEnd, Resolution, currentTempo);
        }

        public uint TimeRangeToTickDelta(double timeStart, double timeEnd, TempoChange currentTempo)
        {
            return TimeRangeToTickDelta(timeStart, timeEnd, Resolution, currentTempo);
        }

        public static double TickRangeToTimeDelta(uint tickStart, uint tickEnd, uint resolution,
            TempoChange currentTempo)
        {
            if (tickStart < currentTempo.Tick)
                throw new ArgumentOutOfRangeException(nameof(tickStart), tickStart,
                    $"The given start tick must occur during the given tempo (starting at {currentTempo.Tick})!");

            if (tickEnd < tickStart)
                throw new ArgumentOutOfRangeException(nameof(tickEnd), tickEnd,
                    $"The given end tick must occur after the starting tick ({tickStart})!");

            uint tickDelta = tickEnd - tickStart;
            double beatDelta = tickDelta / (double)resolution;
            double timeDelta = beatDelta * 60.0 / currentTempo.BeatsPerMinute;

            return timeDelta;
        }

        public static uint TimeRangeToTickDelta(double timeStart, double timeEnd, uint resolution,
            TempoChange currentTempo)
        {
            if (timeStart < currentTempo.Time)
                throw new ArgumentOutOfRangeException(nameof(timeStart), timeStart,
                    $"The given start time must occur during the given tempo (starting at {currentTempo.Tick})!");

            if (timeEnd < timeStart)
                throw new ArgumentOutOfRangeException(nameof(timeEnd), timeEnd,
                    $"The given end time must occur after the starting time ({timeStart})!");

            double timeDelta = timeEnd - timeStart;
            double beatDelta = timeDelta * currentTempo.BeatsPerMinute / 60.0;
            uint tickDelta = (uint)Math.Round(beatDelta * resolution, 8);

            return tickDelta;
        }

        public double GetStartTime()
        {
            // The sync track always starts at the very beginning of the chart
            return 0;
        }

        public double GetEndTime()
        {
            double totalEndTime = 0;

            totalEndTime = Math.Max(Tempos.GetEndTime(), totalEndTime);
            totalEndTime = Math.Max(TimeSignatures.GetEndTime(), totalEndTime);

            return totalEndTime;
        }

        public uint GetFirstTick()
        {
            // The sync track always starts at the very beginning of the chart
            return 0;
        }

        public uint GetLastTick()
        {
            uint totalLastTick = 0;

            totalLastTick = Math.Max(Tempos.GetLastTick(), totalLastTick);
            totalLastTick = Math.Max(TimeSignatures.GetLastTick(), totalLastTick);

            return totalLastTick;
        }
    }
}
</file>

<file path="Chart/Sync/TempoChange.cs">
using System;
using System.Runtime.CompilerServices;

namespace YARG.Core.Chart
{
    public class TempoChange : SyncEvent, IEquatable<TempoChange>, ICloneable<TempoChange>
    {
        private const float SECONDS_PER_MINUTE = 60f;

        public float BeatsPerMinute { get; }
        public float SecondsPerBeat => SECONDS_PER_MINUTE / BeatsPerMinute;
        public long MilliSecondsPerBeat => BpmToMicroSeconds(BeatsPerMinute) / 1000;
        public long MicroSecondsPerBeat => BpmToMicroSeconds(BeatsPerMinute);

        public TempoChange(float tempo, double time, uint tick) : base(time, tick)
        {
            BeatsPerMinute = tempo;
        }

        public TempoChange Clone()
        {
            return new(BeatsPerMinute, Time, Tick);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long BpmToMicroSeconds(float tempo)
        {
            double secondsPerBeat = SECONDS_PER_MINUTE / tempo;
            double microseconds = secondsPerBeat * 1000 * 1000;
            return (long) microseconds;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MicroSecondsToBpm(long usecs)
        {
            double secondsPerBeat = usecs / 1000f / 1000f;
            double tempo = SECONDS_PER_MINUTE / secondsPerBeat;
            return (float) tempo;
        }

        public static bool operator ==(TempoChange? left, TempoChange? right)
        {
            if (ReferenceEquals(left, right))
                return true;

            if (left is null || right is null)
                return false;

            return left.Equals(right);
        }

        public static bool operator !=(TempoChange? left, TempoChange? right)
            => !(left == right);

        public bool Equals(TempoChange other)
        {
            return base.Equals(other) && BeatsPerMinute == other.BeatsPerMinute;
        }

        public override bool Equals(object? obj)
            => obj is TempoChange tempo && Equals(tempo);

        public override int GetHashCode()
            => base.GetHashCode();

        public override string ToString()
        {
            return $"Tempo {BeatsPerMinute} at tick {Tick}, time {Time}";
        }
    }
}
</file>

<file path="Chart/Sync/TimeSignatureEvent.cs">
using System;

namespace YARG.Core.Chart
{
    public partial class TimeSignatureChange : SyncEvent, IEquatable<TimeSignatureChange>, ICloneable<TimeSignatureChange>
    {
        public const float QUARTER_NOTE_DENOMINATOR = 4f;

        public uint Numerator   { get; }
        public uint Denominator { get; }

        public TimeSignatureChange(uint numerator, uint denominator, double time, uint tick) : base(time, tick)
        {
            Numerator = numerator;
            Denominator = denominator;
        }

        public TimeSignatureChange Clone()
        {
            return new(Numerator, Denominator, Time, Tick);
        }

        /// <summary>
        /// Calculates the number of ticks per beat for this time signature.
        /// </summary>
        public uint GetTicksPerBeat(SyncTrack sync)
        {
            return (uint) (sync.Resolution * (QUARTER_NOTE_DENOMINATOR / Denominator));
        }

        /// <summary>
        /// Calculates the number of ticks per measure for this time signature.
        /// </summary>
        public uint GetTicksPerMeasure(SyncTrack sync)
        {
            return GetTicksPerBeat(sync) * Numerator;
        }

        // For template generation purposes
        private static uint GetTicksPerQuarterNote(SyncTrack sync)
        {
            return sync.Resolution;
        }

        /// <summary>
        /// Calculates the number of seconds per beat for this time signature.
        /// </summary>
        public double GetSecondsPerBeat(TempoChange tempo)
        {
            return tempo.SecondsPerBeat * (QUARTER_NOTE_DENOMINATOR / Denominator);
        }

        /// <summary>
        /// Calculates the number of seconds per measure for this time signature.
        /// </summary>
        public double GetSecondsPerMeasure(TempoChange tempo)
        {
            return GetSecondsPerBeat(tempo) * Numerator;
        }

        public static bool operator ==(TimeSignatureChange? left, TimeSignatureChange? right)
        {
            if (ReferenceEquals(left, right))
                return true;

            if (left is null || right is null)
                return false;

            return left.Equals(right);
        }

        public static bool operator !=(TimeSignatureChange? left, TimeSignatureChange? right)
            => !(left == right);

        public bool Equals(TimeSignatureChange other)
        {
            return base.Equals(other) &&
                Numerator == other.Numerator &&
                Denominator == other.Denominator;
        }

        public override bool Equals(object? obj)
            => obj is TimeSignatureChange timeSig && Equals(timeSig);

        public override int GetHashCode()
            => base.GetHashCode();

        public override string ToString()
        {
            return $"Time signature {Numerator}/{Denominator} at tick {Tick}, time {Time}";
        }
    }
}
</file>

<file path="Chart/Sync/TimeSignatureEvent.Progresses.cs">
using System;

namespace YARG.Core.Chart
{
    public partial class TimeSignatureChange
    {
        private void CheckTickStart(uint tick)
        {
            if (tick < Tick)
                throw new ArgumentOutOfRangeException($"The given tick ({tick}) must be greater than this event's tick ({Tick})!");
        }

        /// <summary>
        /// Calculates the fractional number of beats that the given tick lies at, relative to this time signature.
        /// </summary>
        public double GetBeatProgress(uint tick, SyncTrack sync)
        {
            CheckTickStart(tick);
            return (tick - Tick) / (double) GetTicksPerBeat(sync);
        }

        /// <summary>
        /// Calculates the whole number of beats that the given tick lies at, relative to this time signature.
        /// </summary>
        public uint GetBeatCount(uint tick, SyncTrack sync)
        {
            CheckTickStart(tick);
            return (tick - Tick) / GetTicksPerBeat(sync);
        }

        /// <summary>
        /// Calculates the percent of a beat that the given tick lies at, relative to this time signature.
        /// </summary>
        public double GetBeatPercentage(uint tick, SyncTrack sync)
        {
            CheckTickStart(tick);
            uint tickRate = GetTicksPerBeat(sync);
            return (tick % tickRate) / (double) tickRate;
        }

        /// <summary>
        /// Calculates the fractional number of beats that the given time lies at, relative to this time signature.
        /// </summary>
        public double GetBeatProgress(double time, SyncTrack sync, TempoChange tempo)
        {
            return GetBeatProgress(sync.TimeToTick(time, tempo), sync);
        }

        /// <summary>
        /// Calculates the whole number of beats that the given time lies at, relative to this time signature.
        /// </summary>
        public uint GetBeatCount(double time, SyncTrack sync, TempoChange tempo)
        {
            return GetBeatCount(sync.TimeToTick(time, tempo), sync);
        }

        /// <summary>
        /// Calculates the percent of a beat that the given time lies at, relative to this time signature.
        /// </summary>
        public double GetBeatPercentage(double time, SyncTrack sync, TempoChange tempo)
        {
            return GetBeatPercentage(sync.TimeToTick(time, tempo), sync);
        }

        /// <summary>
        /// Calculates the fractional number of quarter notes that the given tick lies at, relative to this time signature.
        /// </summary>
        public double GetQuarterNoteProgress(uint tick, SyncTrack sync)
        {
            CheckTickStart(tick);
            return (tick - Tick) / (double) GetTicksPerQuarterNote(sync);
        }

        /// <summary>
        /// Calculates the whole number of quarter notes that the given tick lies at, relative to this time signature.
        /// </summary>
        public uint GetQuarterNoteCount(uint tick, SyncTrack sync)
        {
            CheckTickStart(tick);
            return (tick - Tick) / GetTicksPerQuarterNote(sync);
        }

        /// <summary>
        /// Calculates the percent of a quarter note that the given tick lies at, relative to this time signature.
        /// </summary>
        public double GetQuarterNotePercentage(uint tick, SyncTrack sync)
        {
            CheckTickStart(tick);
            uint tickRate = GetTicksPerQuarterNote(sync);
            return (tick % tickRate) / (double) tickRate;
        }

        /// <summary>
        /// Calculates the fractional number of quarter notes that the given time lies at, relative to this time signature.
        /// </summary>
        public double GetQuarterNoteProgress(double time, SyncTrack sync, TempoChange tempo)
        {
            return GetQuarterNoteProgress(sync.TimeToTick(time, tempo), sync);
        }

        /// <summary>
        /// Calculates the whole number of quarter notes that the given time lies at, relative to this time signature.
        /// </summary>
        public uint GetQuarterNoteCount(double time, SyncTrack sync, TempoChange tempo)
        {
            return GetQuarterNoteCount(sync.TimeToTick(time, tempo), sync);
        }

        /// <summary>
        /// Calculates the percent of a quarter note that the given time lies at, relative to this time signature.
        /// </summary>
        public double GetQuarterNotePercentage(double time, SyncTrack sync, TempoChange tempo)
        {
            return GetQuarterNotePercentage(sync.TimeToTick(time, tempo), sync);
        }

        /// <summary>
        /// Calculates the fractional number of measures that the given tick lies at, relative to this time signature.
        /// </summary>
        public double GetMeasureProgress(uint tick, SyncTrack sync)
        {
            CheckTickStart(tick);
            return (tick - Tick) / (double) GetTicksPerMeasure(sync);
        }

        /// <summary>
        /// Calculates the whole number of measures that the given tick lies at, relative to this time signature.
        /// </summary>
        public uint GetMeasureCount(uint tick, SyncTrack sync)
        {
            CheckTickStart(tick);
            return (tick - Tick) / GetTicksPerMeasure(sync);
        }

        /// <summary>
        /// Calculates the percent of a measure that the given tick lies at, relative to this time signature.
        /// </summary>
        public double GetMeasurePercentage(uint tick, SyncTrack sync)
        {
            CheckTickStart(tick);
            uint tickRate = GetTicksPerMeasure(sync);
            return (tick % tickRate) / (double) tickRate;
        }

        /// <summary>
        /// Calculates the fractional number of measures that the given time lies at, relative to this time signature.
        /// </summary>
        public double GetMeasureProgress(double time, SyncTrack sync, TempoChange tempo)
        {
            return GetMeasureProgress(sync.TimeToTick(time, tempo), sync);
        }

        /// <summary>
        /// Calculates the whole number of measures that the given time lies at, relative to this time signature.
        /// </summary>
        public uint GetMeasureCount(double time, SyncTrack sync, TempoChange tempo)
        {
            return GetMeasureCount(sync.TimeToTick(time, tempo), sync);
        }

        /// <summary>
        /// Calculates the percent of a measure that the given time lies at, relative to this time signature.
        /// </summary>
        public double GetMeasurePercentage(double time, SyncTrack sync, TempoChange tempo)
        {
            return GetMeasurePercentage(sync.TimeToTick(time, tempo), sync);
        }
    }
}
</file>

<file path="Chart/Sync/TimeSignatureEvent.Progresses.t4">
<#@ template hostspecific="false" language="C#" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
using System;

namespace YARG.Core.Chart
{
    public partial class TimeSignatureChange
    {
        private void CheckTickStart(uint tick)
        {
            if (tick < Tick)
                throw new ArgumentOutOfRangeException($"The given tick ({tick}) must be greater than this event's tick ({Tick})!");
        }
<#
var names = new (string name, string doc)[] {
    ("Beat", "beat"),
    ("QuarterNote", "quarter note"),
    ("Measure", "measure"),
};

foreach (var (name, doc) in names)
{
#>

        /// <summary>
        /// Calculates the fractional number of <#= doc #>s that the given tick lies at, relative to this time signature.
        /// </summary>
        public double Get<#= name #>Progress(uint tick, SyncTrack sync)
        {
            CheckTickStart(tick);
            return (tick - Tick) / (double) GetTicksPer<#= name #>(sync);
        }

        /// <summary>
        /// Calculates the whole number of <#= doc #>s that the given tick lies at, relative to this time signature.
        /// </summary>
        public uint Get<#= name #>Count(uint tick, SyncTrack sync)
        {
            CheckTickStart(tick);
            return (tick - Tick) / GetTicksPer<#= name #>(sync);
        }

        /// <summary>
        /// Calculates the percent of a <#= doc #> that the given tick lies at, relative to this time signature.
        /// </summary>
        public double Get<#= name #>Percentage(uint tick, SyncTrack sync)
        {
            CheckTickStart(tick);
            uint tickRate = GetTicksPer<#= name #>(sync);
            return (tick % tickRate) / (double) tickRate;
        }

        /// <summary>
        /// Calculates the fractional number of <#= doc #>s that the given time lies at, relative to this time signature.
        /// </summary>
        public double Get<#= name #>Progress(double time, SyncTrack sync, TempoChange tempo)
        {
            return Get<#= name #>Progress(sync.TimeToTick(time, tempo), sync);
        }

        /// <summary>
        /// Calculates the whole number of <#= doc #>s that the given time lies at, relative to this time signature.
        /// </summary>
        public uint Get<#= name #>Count(double time, SyncTrack sync, TempoChange tempo)
        {
            return Get<#= name #>Count(sync.TimeToTick(time, tempo), sync);
        }

        /// <summary>
        /// Calculates the percent of a <#= doc #> that the given time lies at, relative to this time signature.
        /// </summary>
        public double Get<#= name #>Percentage(double time, SyncTrack sync, TempoChange tempo)
        {
            return Get<#= name #>Percentage(sync.TimeToTick(time, tempo), sync);
        }
<#
}
#>
    }
}
</file>

<file path="Chart/Tracks/Lyrics/LyricEvent.cs">
using System;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A text event used for chart lyrics.
    /// </summary>
    public class LyricEvent : ChartEvent, ICloneable<LyricEvent>
    {
        private readonly LyricSymbolFlags _flags;

        public string Text { get; }

        public LyricSymbolFlags Flags => _flags;

        public bool JoinWithNext  => (_flags & LyricSymbolFlags.JoinWithNext) != 0;
        public bool NonPitched    => (_flags & LyricSymbolFlags.NonPitched) != 0;
        public bool PitchSlide    => (_flags & LyricSymbolFlags.PitchSlide) != 0;
        public bool HarmonyHidden => (_flags & LyricSymbolFlags.HarmonyHidden) != 0;
        public bool StaticShift   => (_flags & LyricSymbolFlags.StaticShift) != 0;

        // Range shifts are handled externally
        // public bool RangeShift => (_flags & LyricFlags.RangeShift) != 0;

        public LyricEvent(LyricSymbolFlags flags, string text, double time, uint tick)
            : base(time, 0, tick, 0)
        {
            _flags = flags;
            Text = text;
        }

        public LyricEvent(LyricEvent other) : base(other)
        {
            _flags = other._flags;
            Text = other.Text;
        }

        public LyricEvent Clone()
        {
            return new(this);
        }

        public override string ToString()
        {
            return $"Lyric event '{Text}' at {Time}s ({Tick}t) with flags {_flags}";
        }
    }
}
</file>

<file path="Chart/Tracks/Lyrics/LyricsPhrase.cs">
using System;
using System.Collections.Generic;
using YARG.Core.Extensions;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A phrase within the lyrics track.
    /// </summary>
    public class LyricsPhrase : ChartEvent, ICloneable<LyricsPhrase>
    {
        public List<LyricEvent> Lyrics { get; } = new();

        public LyricsPhrase(double time, double timeLength, uint tick, uint tickLength, List<LyricEvent> lyrics)
            : base(time, timeLength, tick, tickLength)
        {
            Lyrics = lyrics;
        }

        public LyricsPhrase(LyricsPhrase other)
            : base(other)
        {
            Lyrics = other.Lyrics.Duplicate();
        }

        public LyricsPhrase Clone()
        {
            return new(this);
        }
    }
}
</file>

<file path="Chart/Tracks/Lyrics/LyricsTrack.cs">
using System;
using System.Collections.Generic;
using YARG.Core.Extensions;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A lyrics track.
    /// </summary>
    public class LyricsTrack : ICloneable<LyricsTrack>
    {
        public List<LyricsPhrase> Phrases { get; } = new();

        /// <summary>
        /// Whether or not any lyric phrases exist.
        /// </summary>
        public bool IsEmpty => Phrases.Count == 0;

        public LyricsTrack() { }

        public LyricsTrack(List<LyricsPhrase> parts)
        {
            Phrases = parts;
        }

        public LyricsTrack(LyricsTrack other)
            : this(other.Phrases.Duplicate())
        {
        }

        public double GetStartTime()
        {
            double totalStartTime = 0;

            if (Phrases.Count > 0)
                totalStartTime = Math.Min(Phrases[0].Time, totalStartTime);

            return totalStartTime;
        }

        public double GetEndTime()
        {
            double totalEndTime = 0;

            if (Phrases.Count > 0)
                totalEndTime = Math.Max(Phrases[^1].TimeEnd, totalEndTime);

            return totalEndTime;
        }

        public uint GetFirstTick()
        {
            uint totalFirstTick = 0;

            if (Phrases.Count > 0)
                totalFirstTick = Math.Min(Phrases[0].Tick, totalFirstTick);

            return totalFirstTick;
        }

        public uint GetLastTick()
        {
            uint totalLastTick = 0;

            if (Phrases.Count > 0)
                totalLastTick = Math.Max(Phrases[^1].TickEnd, totalLastTick);

            return totalLastTick;
        }

        public LyricsTrack Clone()
        {
            return new(this);
        }
    }
}
</file>

<file path="Chart/Tracks/Lyrics/LyricSymbols.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using YARG.Core.Utility;

namespace YARG.Core.Chart
{
    /// <summary>
    /// Flags for lyric events.
    /// </summary>
    [Flags]
    public enum LyricSymbolFlags
    {
        None = 0,

        JoinWithNext = 1 << 0,

        NonPitched = 1 << 1,
        LenientScoring = 1 << 2,
        // NonPitchedUnknown = 1 << 3, // Reserved for once '*' is figured out

        PitchSlide = 1 << 4,
        HarmonyHidden = 1 << 5,
        StaticShift = 1 << 6,
        RangeShift = 1 << 7,
    }

    /// <summary>
    /// Definitions and utilities for special symbols in lyric events.
    /// </summary>
    public static class LyricSymbols
    {
        /// <summary>Joins two lyrics together as a single word.</summary>
        /// <remarks>Displayed as-is in vocals, stripped in lyrics.</remarks>
        public const char LYRIC_JOIN_SYMBOL = '-';

        /// <summary>Joins two syllables together and stands in for a hyphen.</summary>
        /// <remarks>Replaced with a hyphen ('-') in vocals and lyrics.</remarks>
        public const char LYRIC_JOIN_HYPHEN_SYMBOL = '=';

        /// <summary>Connects two notes together with a slide from end-to-end.</summary>
        /// <remarks>Stripped out in both vocals and lyrics.</remarks>
        public const char PITCH_SLIDE_SYMBOL = '+';


        /// <summary>Marks a note as non-pitched.</summary>
        /// <remarks>Stripped out in both vocals and lyrics.</remarks>
        public const char NONPITCHED_SYMBOL = '#';

        /// <summary>Marks a note as non-pitched, with more generous scoring.</summary>
        /// <remarks>Stripped out in both vocals and lyrics.</remarks>
        public const char NONPITCHED_LENIENT_SYMBOL = '^';

        /// <summary>Marks a note as non-pitched, but its exact function is unknown.</summary>
        /// <remarks>Stripped out in both vocals and lyrics.</remarks>
        public const char NONPITCHED_UNKNOWN_SYMBOL = '*';


        /// <summary>Marks a point at which the vocals track should recalculate its range.</summary>
        /// <remarks>Stripped out in both vocals and lyrics.</remarks>
        public const char RANGE_SHIFT_SYMBOL = '%';

        /// <summary>Marks an additional shift point for the static vocals display.</summary>
        /// <remarks>Stripped out in both vocals and lyrics.</remarks>
        public const char STATIC_SHIFT_SYMBOL = '/';


        /// <summary>Hides a lyric from being displayed in Harmonies.</summary>
        /// <remarks>Stripped out in both vocals and lyrics.</remarks>
        public const char HARMONY_HIDE_SYMBOL = '$';

        /// <summary>Indicate two lexical syllables are sung as a single phonetic syllable.</summary>
        /// <remarks>
        /// Does not join two lyrics together, it is used within a single syllable specifically.
        /// Replaced with '' in vocals, replaced with a space (' ') in lyrics.
        /// </remarks>
        public const char JOINED_SYLLABLE_SYMBOL = '';

        /// <summary>Stands in for a space (' ').</summary>
        /// <remarks>Only intended for use in lyrics, but will also be replaced in vocals.</remarks>
        public const char SPACE_ESCAPE_SYMBOL = '_';

        /// <summary>Symbols which should be stripped from lyrics in vocals.</summary>
        public static readonly HashSet<char> VOCALS_STRIP_SYMBOLS = new()
        {
            PITCH_SLIDE_SYMBOL,
            NONPITCHED_SYMBOL,
            NONPITCHED_LENIENT_SYMBOL,
            NONPITCHED_UNKNOWN_SYMBOL,
            RANGE_SHIFT_SYMBOL,
            STATIC_SHIFT_SYMBOL,
            HARMONY_HIDE_SYMBOL,

            // Don't display quotation marks in vocals
            '"',
        };

        /// <summary>Symbols which should be stripped from lyrics in the lyrics track.</summary>
        public static readonly HashSet<char> LYRICS_STRIP_SYMBOLS = new()
        {
            LYRIC_JOIN_SYMBOL,
            PITCH_SLIDE_SYMBOL,
            NONPITCHED_SYMBOL,
            NONPITCHED_LENIENT_SYMBOL,
            NONPITCHED_UNKNOWN_SYMBOL,
            RANGE_SHIFT_SYMBOL,
            STATIC_SHIFT_SYMBOL,
            HARMONY_HIDE_SYMBOL,
        };

        /// <summary>Symbols which should be replaced with another in lyrics on vocals.</summary>
        public static readonly Dictionary<char, char> VOCALS_SYMBOL_REPLACEMENTS = new()
        {
            { LYRIC_JOIN_HYPHEN_SYMBOL,     '-' },
            { JOINED_SYLLABLE_SYMBOL,       '' },
            { SPACE_ESCAPE_SYMBOL,          ' ' },
        };

        /// <summary>Symbols which should be replaced with another in lyrics on the lyrics track.</summary>
        public static readonly Dictionary<char, char> LYRICS_SYMBOL_REPLACEMENTS = new()
        {
            { LYRIC_JOIN_HYPHEN_SYMBOL,  '-' },
            { JOINED_SYLLABLE_SYMBOL,    ' ' },
            { SPACE_ESCAPE_SYMBOL,       ' ' },
        };

        private static readonly Dictionary<string, string> VOCALS_STRIP_REPLACEMENTS
            = CreateStripReplacements(VOCALS_STRIP_SYMBOLS, VOCALS_SYMBOL_REPLACEMENTS);

        private static readonly Dictionary<string, string> LYRICS_STRIP_REPLACEMENTS
            = CreateStripReplacements(LYRICS_STRIP_SYMBOLS, LYRICS_SYMBOL_REPLACEMENTS);

        private static Dictionary<string, string> CreateStripReplacements(
            HashSet<char> strip, Dictionary<char, char> replace)
        {
            // Add strip characters first to ensure they don't mess with the replacements
            return strip.Select((c) => new KeyValuePair<char, char>(c, '\0'))
                .Concat(replace)
                .ToDictionary(
                    (pair) => pair.Key != '\0' ? pair.Key.ToString() : string.Empty,
                    (pair) => pair.Value != '\0' ? pair.Value.ToString() : string.Empty);
        }

        // Rich text tags allowed by Clone Hero
        // https://strikeline.myjetbrains.com/youtrack/issue/CH-226
        public const RichTextTags LYRICS_ALLOWED_TAGS = RichTextTags.Italics | RichTextTags.Bold |
            RichTextTags.Strikethrough | RichTextTags.Underline | RichTextTags.Superscript | RichTextTags.Subscript |
            RichTextTags.VerticalOffset | RichTextTags.Lowercase | RichTextTags.Uppercase | RichTextTags.SmallCaps |
            RichTextTags.CharSpace | RichTextTags.Color | RichTextTags.Monospace | RichTextTags.LineBreak;

        public static LyricSymbolFlags GetFlagForSymbol(char symbol) => symbol switch
        {
            LYRIC_JOIN_SYMBOL or
            LYRIC_JOIN_HYPHEN_SYMBOL => LyricSymbolFlags.JoinWithNext,

            PITCH_SLIDE_SYMBOL  => LyricSymbolFlags.PitchSlide,

            NONPITCHED_SYMBOL => LyricSymbolFlags.NonPitched,
            NONPITCHED_LENIENT_SYMBOL => LyricSymbolFlags.NonPitched | LyricSymbolFlags.LenientScoring,
            NONPITCHED_UNKNOWN_SYMBOL => LyricSymbolFlags.NonPitched, // | LyricSymbolFlags.NonPitchedUnknown,

            RANGE_SHIFT_SYMBOL => LyricSymbolFlags.RangeShift,

            STATIC_SHIFT_SYMBOL => LyricSymbolFlags.StaticShift,
            HARMONY_HIDE_SYMBOL => LyricSymbolFlags.HarmonyHidden,

            _ => LyricSymbolFlags.None
        };

        public static LyricSymbolFlags GetLyricFlags(ReadOnlySpan<char> lyric)
        {
            var flags = LyricSymbolFlags.None;

            if (lyric.IsEmpty)
                return flags;

            // Flags at the start of the lyric
            // Only the harmony hide symbol is valid here
            if (lyric[0] == HARMONY_HIDE_SYMBOL)
                flags |= LyricSymbolFlags.HarmonyHidden;

            // Flags at the end of the lyric
            for (; !lyric.IsEmpty; lyric = lyric[..^1])
            {
                var flag = GetFlagForSymbol(lyric[^1]);
                if (flag == LyricSymbolFlags.None)
                    break;

                flags |= flag;
            }

            return flags;
        }

        // Workaround for a certain set of badly-formatted vocal tracks which place the hyphen
        // for pitch bend lyrics on the pitch bend and not the lyric itself
        internal static void DeferredLyricJoinWorkaround(List<LyricEvent> lyrics, ref ReadOnlySpan<char> lyric, bool addHyphen)
        {
            if (lyrics.Count > 0 && !lyrics[^1].JoinWithNext &&
                (lyric.Equals("+-", StringComparison.Ordinal) || lyric.Equals("-+", StringComparison.Ordinal)))
            {
                var other = lyrics[^1];
                string text = addHyphen ? $"{other.Text}-" : other.Text;
                lyrics[^1] = new(other.Flags | LyricSymbolFlags.JoinWithNext, text, other.Time, other.Tick);
                lyric = "+";
            }
        }

        public static string StripForVocals(string lyric)
        {
            lyric = RichTextUtils.StripRichTextTags(lyric);

            var lyricBuffer = new StringBuilder(lyric);
            foreach (var (symbol, replacement) in VOCALS_STRIP_REPLACEMENTS)
            {
                lyricBuffer.Replace(symbol, replacement);
            }

            return lyricBuffer.ToString();
        }

        public static string StripForLyrics(string lyric)
        {
            lyric = RichTextUtils.StripRichTextTags(lyric, ~LYRICS_ALLOWED_TAGS);
            lyric = RichTextUtils.ReplaceColorNames(lyric);

            var lyricBuffer = new StringBuilder();
            var segmentBuffer = new StringBuilder();

            // Need to ensure rich text tags are not stripped
            int tagIndex;
            var remaining = lyric.AsSpan();
            while ((tagIndex = remaining.IndexOf('<')) >= 0)
            {
                // Split out segment before the tag
                var segment = remaining[..tagIndex];
                var tag = remaining[tagIndex..];

                // Find end of the tag
                int tagCloseIndex = tag.IndexOf('>');
                if (tagCloseIndex < 0)
                    break;

                // Include closing in tag split
                tagCloseIndex++;

                if (tagCloseIndex >= tag.Length)
                {
                    remaining = ReadOnlySpan<char>.Empty;
                }
                else
                {
                    remaining = tag[tagCloseIndex..];
                    tag = tag[..tagCloseIndex];
                }

                // Run through replacements on segment
                if (!segment.IsEmpty)
                {
                    segmentBuffer.Append(segment);
                    foreach (var (symbol, replacement) in LYRICS_STRIP_REPLACEMENTS)
                    {
                        segmentBuffer.Replace(symbol, replacement);
                    }

                    lyricBuffer.Append(segmentBuffer);
                    segmentBuffer.Clear();
                }

                // Insert tag unmodified
                lyricBuffer.Append(tag);
            }

            // Final segment of characters
            if (!remaining.IsEmpty)
            {
                segmentBuffer.Append(remaining);
                foreach (var (symbol, replacement) in LYRICS_STRIP_REPLACEMENTS)
                {
                    segmentBuffer.Replace(symbol, replacement);
                }

                lyricBuffer.Append(segmentBuffer);
            }

            return lyricBuffer.ToString();
        }
    }
}
</file>

<file path="Chart/Tracks/Vocals/VocalsPart.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using YARG.Core.Extensions;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A single part on a vocals track.
    /// </summary>
    public class VocalsPart : ICloneable<VocalsPart>
    {
        public readonly bool IsHarmony;

        public List<VocalsPhrase> NotePhrases { get; } = new();
        public List<Phrase> OtherPhrases { get; } = new();
        public List<TextEvent> TextEvents { get; } = new();

        /// <summary>
        /// Whether or not this part contains any data.
        /// </summary>
        public bool IsEmpty => NotePhrases.Count == 0 && OtherPhrases.Count == 0 && TextEvents.Count == 0;

        public VocalsPart(bool isHarmony, List<VocalsPhrase> notePhrases, List<Phrase> otherPhrases, List<TextEvent> text)
        {
            IsHarmony = isHarmony;
            NotePhrases = notePhrases;
            OtherPhrases = otherPhrases;
            TextEvents = text;
        }

        public VocalsPart(VocalsPart other)
            : this(other.IsHarmony, other.NotePhrases.Duplicate(),
                other.OtherPhrases.Duplicate(), other.TextEvents.Duplicate())
        {
        }

        public double GetStartTime()
        {
            double totalStartTime = 0;

            if (NotePhrases.Count > 0)
                totalStartTime = Math.Min(NotePhrases[0].Time, totalStartTime);

            totalStartTime = Math.Min(OtherPhrases.GetStartTime(), totalStartTime);
            totalStartTime = Math.Min(TextEvents.GetStartTime(), totalStartTime);

            return totalStartTime;
        }

        public double GetEndTime()
        {
            double totalEndTime = 0;

            if (NotePhrases.Count > 0)
                totalEndTime = Math.Max(NotePhrases[^1].TimeEnd, totalEndTime);

            totalEndTime = Math.Max(OtherPhrases.GetEndTime(), totalEndTime);
            totalEndTime = Math.Max(TextEvents.GetEndTime(), totalEndTime);

            return totalEndTime;
        }

        public uint GetFirstTick()
        {
            uint totalFirstTick = 0;

            if (NotePhrases.Count > 0)
                totalFirstTick = Math.Min(NotePhrases[0].Tick, totalFirstTick);

            totalFirstTick = Math.Min(OtherPhrases.GetFirstTick(), totalFirstTick);
            totalFirstTick = Math.Min(TextEvents.GetFirstTick(), totalFirstTick);

            return totalFirstTick;
        }

        public uint GetLastTick()
        {
            uint totalLastTick = 0;

            if (NotePhrases.Count > 0)
                totalLastTick = Math.Max(NotePhrases[^1].TickEnd, totalLastTick);

            totalLastTick = Math.Max(OtherPhrases.GetLastTick(), totalLastTick);
            totalLastTick = Math.Max(TextEvents.GetLastTick(), totalLastTick);

            return totalLastTick;
        }

        public InstrumentDifficulty<VocalNote> CloneAsInstrumentDifficulty()
        {
            var vocalNotes = NotePhrases.Select(i => i.PhraseParentNote).ToList();
            var instrument = IsHarmony ? Instrument.Harmony : Instrument.Vocals;

            var diff = new InstrumentDifficulty<VocalNote>(instrument, Difficulty.Expert,
                vocalNotes, new(OtherPhrases), new(TextEvents));

            return diff;
        }

        public VocalsPart Clone()
        {
            return new(this);
        }
    }
}
</file>

<file path="Chart/Tracks/Vocals/VocalsPartExtensions.cs">
namespace YARG.Core.Chart
{
    public static class VocalsPartExtensions
    {
        public static void ConvertAllToUnpitched(this VocalsPart vocalsTrack)
        {
            for (int i = 0; i < vocalsTrack.NotePhrases.Count; i++)
            {
                var phrase = vocalsTrack.NotePhrases[i];
                var phraseParent = phrase.PhraseParentNote;

                // Create a new phrase based off of the original one
                var newPhraseParent = new VocalNote(phraseParent.Flags, phraseParent.Time,
                    phraseParent.TimeLength, phraseParent.Tick, phraseParent.TickLength);

                foreach (var note in phraseParent.ChildNotes)
                {
                    if (note.Type == VocalNoteType.Percussion)
                    {
                        continue;
                    }

                    // Create an unpitched replacement note. Make sure to use the total lengths instead
                    // of the normal lengths.
                    var newNote = new VocalNote(-1f, note.HarmonyPart, note.Type, note.Time,
                        note.TotalTimeLength, note.Tick, note.TotalTickLength);
                    newPhraseParent.AddChildNote(newNote);
                }

                // Replace the next and previous note values
                if (i - 1 >= 0)
                {
                    var lastPhrase = vocalsTrack.NotePhrases[i - 1];
                    newPhraseParent.PreviousNote = lastPhrase.PhraseParentNote;
                    lastPhrase.PhraseParentNote.NextNote = newPhraseParent;
                }

                // Replace the phrase
                var newPhrase = new VocalsPhrase(phrase.Time, phrase.TimeLength, phrase.Tick, phrase.TickLength,
                    newPhraseParent, phrase.Lyrics);
                vocalsTrack.NotePhrases[i] = newPhrase;
            }
        }

        public static void RemovePercussion(this VocalsPart vocalsTrack)
        {
            int i = 0;
            while (i < vocalsTrack.NotePhrases.Count)
            {
                var phrase = vocalsTrack.NotePhrases[i];
                phrase.PhraseParentNote.RemovePercussionChildNotes();

                if (phrase.IsEmpty)
                {
                    vocalsTrack.NotePhrases.RemoveAt(i);
                    continue;
                }

                i++;
            }
        }
    }
}
</file>

<file path="Chart/Tracks/Vocals/VocalsPhrase.cs">
using System;
using System.Collections.Generic;
using YARG.Core.Extensions;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A lyric/percussion phrase on a vocals track.
    /// </summary>
    public class VocalsPhrase : ChartEvent, ICloneable<VocalsPhrase>
    {
        public VocalNote PhraseParentNote { get; }
        public List<LyricEvent> Lyrics { get; }

        public bool IsLyric => !PhraseParentNote.IsPercussion;
        public bool IsPercussion => PhraseParentNote.IsPercussion;

        public bool IsStarPower => PhraseParentNote.IsStarPower;

        public bool IsEmpty => PhraseParentNote.IsEmptyPhrase;

        public VocalsPhrase(double time, double timeLength, uint tick, uint tickLength,
            VocalNote phraseParentNote, List<LyricEvent> lyrics)
            : base(time, timeLength, tick, tickLength)
        {
            if (!phraseParentNote.IsPhrase)
            {
                throw new InvalidOperationException(
                    "Attempted to create a vocals phrase out of a non-phrase vocals note!");
            }

            PhraseParentNote = phraseParentNote;
            Lyrics = lyrics;
        }

        public VocalsPhrase(VocalsPhrase other)
            : base(other)
        {
            PhraseParentNote = other.PhraseParentNote.Clone();
            Lyrics = other.Lyrics.Duplicate();
        }

        public VocalsPhrase Clone()
        {
            return new(this);
        }
    }
}
</file>

<file path="Chart/Tracks/Vocals/VocalsRangeShift.cs">
using System;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A range shift on the vocals track.
    /// </summary>
    public class VocalsRangeShift : ChartEvent, ICloneable<VocalsRangeShift>
    {
        public float MinimumPitch { get; }
        public float MaximumPitch { get; }

        public VocalsRangeShift(float minPitch, float maxPitch,
            double time, double timeLength, uint tick, uint tickLength)
            : base(time, timeLength, tick, tickLength)
        {
            MinimumPitch = minPitch;
            MaximumPitch = maxPitch;
        }

        public VocalsRangeShift(VocalsRangeShift other)
            : base(other)
        {
            MinimumPitch = other.MinimumPitch;
            MaximumPitch = other.MaximumPitch;
        }

        public VocalsRangeShift Clone()
        {
            return new(this);
        }
    }
}
</file>

<file path="Chart/Tracks/Vocals/VocalsTrack.cs">
using System;
using System.Collections.Generic;
using YARG.Core.Extensions;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A vocals track.
    /// </summary>
    public class VocalsTrack : ICloneable<VocalsTrack>
    {
        public Instrument Instrument { get; }

        public List<VocalsPart> Parts { get; } = new();
        public List<VocalsRangeShift> RangeShifts { get; } = new();

        /// <summary>
        /// Whether or not this track contains any data.
        /// </summary>
        public bool IsEmpty
        {
            get
            {
                foreach (var part in Parts)
                {
                    if (!part.IsEmpty)
                        return false;
                }

                return true;
            }
        }

        public VocalsTrack(Instrument instrument)
        {
            Instrument = instrument;
        }

        public VocalsTrack(Instrument instrument, List<VocalsPart> parts, List<VocalsRangeShift> rangeShifts)
            : this(instrument)
        {
            Parts = parts;
            RangeShifts = rangeShifts;
        }

        public VocalsTrack(VocalsTrack other)
            : this(other.Instrument, other.Parts.Duplicate(), other.RangeShifts.Duplicate())
        {
        }

        // TODO: Helper methods for getting note info across all parts

        public double GetStartTime()
        {
            double totalStartTime = 0;
            foreach (var part in Parts)
            {
                totalStartTime = Math.Min(part.GetStartTime(), totalStartTime);
            }

            return totalStartTime;
        }

        public double GetEndTime()
        {
            double totalEndTime = 0;
            foreach (var part in Parts)
            {
                totalEndTime = Math.Max(part.GetEndTime(), totalEndTime);
            }

            return totalEndTime;
        }

        public uint GetFirstTick()
        {
            uint totalFirstTick = 0;
            foreach (var part in Parts)
            {
                totalFirstTick = Math.Min(part.GetFirstTick(), totalFirstTick);
            }

            return totalFirstTick;
        }

        public uint GetLastTick()
        {
            uint totalLastTick = 0;
            foreach (var part in Parts)
            {
                totalLastTick = Math.Max(part.GetLastTick(), totalLastTick);
            }

            return totalLastTick;
        }

        public VocalsTrack Clone()
        {
            return new(this);
        }
    }
}
</file>

<file path="Chart/Tracks/InstrumentDifficulty.cs">
using System;
using System.Collections.Generic;
using YARG.Core.Extensions;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A single difficulty of an instrument track.
    /// </summary>
    public class InstrumentDifficulty<TNote> : ICloneable<InstrumentDifficulty<TNote>>
        where TNote : Note<TNote>
    {
        public Instrument Instrument { get; }
        public Difficulty Difficulty { get; }

        public List<TNote> Notes { get; } = new();
        public List<Phrase> Phrases { get; } = new();
        public List<TextEvent> TextEvents { get; } = new();

        /// <summary>
        /// Whether or not this difficulty contains any data.
        /// </summary>
        /// <remarks>
        /// This should *not* be used to determine whether or not the chart is present!
        /// Use <see cref="InstrumentTrack{TNote}.TryGetDifficulty(Difficulty, out InstrumentDifficulty{TNote}?)"/> instead.
        /// </remarks>
        public bool IsEmpty => Notes.Count == 0 && Phrases.Count == 0 && TextEvents.Count == 0;

        public InstrumentDifficulty(Instrument instrument, Difficulty difficulty)
        {
            Instrument = instrument;
            Difficulty = difficulty;
        }

        public InstrumentDifficulty(Instrument instrument, Difficulty difficulty,
            List<TNote> notes, List<Phrase> phrases, List<TextEvent> text)
            : this(instrument, difficulty)
        {
            Notes = notes;
            Phrases = phrases;
            TextEvents = text;
        }

        public InstrumentDifficulty(InstrumentDifficulty<TNote> other)
            : this(other.Instrument, other.Difficulty, other.Notes.DuplicateNotes(), other.Phrases.Duplicate(),
                other.TextEvents.Duplicate())
        {
        }

        public double GetStartTime()
        {
            double totalStartTime = 0;

            totalStartTime = Math.Min(Notes.GetStartTime(), totalStartTime);
            totalStartTime = Math.Min(Phrases.GetStartTime(), totalStartTime);
            totalStartTime = Math.Min(TextEvents.GetStartTime(), totalStartTime);

            return totalStartTime;
        }

        public double GetEndTime()
        {
            double totalEndTime = 0;

            totalEndTime = Math.Max(Notes.GetEndTime(), totalEndTime);
            totalEndTime = Math.Max(Phrases.GetEndTime(), totalEndTime);
            totalEndTime = Math.Max(TextEvents.GetEndTime(), totalEndTime);

            return totalEndTime;
        }

        public uint GetFirstTick()
        {
            uint totalFirstTick = 0;

            totalFirstTick = Math.Min(Notes.GetFirstTick(), totalFirstTick);
            totalFirstTick = Math.Min(Phrases.GetFirstTick(), totalFirstTick);
            totalFirstTick = Math.Min(TextEvents.GetFirstTick(), totalFirstTick);

            return totalFirstTick;
        }

        public uint GetLastTick()
        {
            uint totalLastTick = 0;

            totalLastTick = Math.Max(Notes.GetLastTick(), totalLastTick);
            totalLastTick = Math.Max(Phrases.GetLastTick(), totalLastTick);
            totalLastTick = Math.Max(TextEvents.GetLastTick(), totalLastTick);

            return totalLastTick;
        }

        public InstrumentDifficulty<TNote> Clone()
        {
            return new(this);
        }

        public int GetTotalNoteCount()
        {
            var noteCount = 0;
            foreach (var note in Notes)
            {
                noteCount += note.ChildNotes.Count + 1;
            }

            return noteCount;
        }
    }
}
</file>

<file path="Chart/Tracks/InstrumentDifficultyExtensions.cs">
using System;

namespace YARG.Core.Chart
{
    public static class InstrumentDifficultyExtensions
    {
        public static void ConvertToGuitarType(this InstrumentDifficulty<GuitarNote> difficulty, GuitarNoteType type)
        {
            foreach (var note in difficulty.Notes)
            {
                note.Type = type;
                foreach (var child in note.ChildNotes)
                {
                    child.Type = type;
                }
            }
        }

        public static void ConvertFromTypeToType(this InstrumentDifficulty<GuitarNote> difficulty,
            GuitarNoteType from, GuitarNoteType to)
        {
            foreach (var note in difficulty.Notes)
            {
                if (note.Type != from)
                {
                    continue;
                }

                note.Type = to;
                foreach (var child in note.ChildNotes)
                {
                    child.Type = to;
                }
            }
        }

        public static void RemoveKickDrumNotes(this InstrumentDifficulty<DrumNote> difficulty)
        {
            var kickDrumPadIndex = difficulty.Instrument switch
            {
                Instrument.ProDrums      => (int) FourLaneDrumPad.Kick,
                Instrument.FourLaneDrums => (int) FourLaneDrumPad.Kick,
                Instrument.FiveLaneDrums => (int) FiveLaneDrumPad.Kick,
                _ => throw new InvalidOperationException("Cannot remove kick drum notes from non-drum track with " +
                    $"instrument {difficulty.Instrument}!")
            };

            for (int index = 0; index < difficulty.Notes.Count; index++)
            {
                var note = difficulty.Notes[index];
                if (note.Pad != kickDrumPadIndex)
                {
                    // This is not a kick drum note, but we have to check it's children too
                    int? childNoteKickIndex = null;
                    for (int i = 0; i < note.ChildNotes.Count; i++)
                    {
                        var childNote = note.ChildNotes[i];
                        if (childNote.Pad == kickDrumPadIndex)
                        {
                            childNoteKickIndex = i;
                            break;
                        }
                    }

                    if (childNoteKickIndex != null)
                    {
                        var newNote = note.CloneWithoutChildNotes();
                        for (int i = 0; i < note.ChildNotes.Count; i++)
                        {
                            if (i != childNoteKickIndex)
                            {
                                newNote.AddChildNote(note.ChildNotes[i]);
                            }
                        }

                        difficulty.Notes[index] = newNote;
                    }
                }
                else if (note.ChildNotes.Count > 0)
                {
                    // If the drum note has child notes, convert the first child note to a parent note,
                    // then assign the other child notes to this parent note.
                    // Finally, overwrite the drum note with the new parent note.
                    var firstChild = note.ChildNotes[0].CloneWithoutChildNotes();
                    for (int i = 1; i < note.ChildNotes.Count; i++)
                    {
                        firstChild.AddChildNote(note.ChildNotes[i]);
                    }

                    difficulty.Notes[index] = firstChild;
                }
                else
                {
                    // This is a single kick drum note
                    difficulty.Notes.RemoveAt(index);

                    if (note.IsStarPowerActivator)
                    {
                        // This is a single kick drum note that is a star power activator,
                        // we have to move it to the NEXT note.
                        if (index < difficulty.Notes.Count)
                        {
                            difficulty.Notes[index].DrumFlags |= DrumNoteFlags.StarPowerActivator;
                            // Also add it to the child notes
                            foreach (var childNote in difficulty.Notes[index].ChildNotes)
                            {
                                childNote.DrumFlags |= DrumNoteFlags.StarPowerActivator;
                            }
                        }
                    }

                    if (note.IsSoloStart && !note.IsSoloEnd)
                    {
                        // This is a single kick drum note that is a solo start, we have to move it to the
                        // NEXT note (we don't want to extend the solo).
                        if (index < difficulty.Notes.Count)
                        {
                            difficulty.Notes[index].Flags |= NoteFlags.SoloStart;
                            // Also add it to the child notes
                            foreach (var childNote in difficulty.Notes[index].ChildNotes)
                            {
                                childNote.Flags |= NoteFlags.SoloStart;
                            }
                        }
                    }

                    if (note.IsSoloEnd)
                    {
                        // This is a single kick drum note that is a solo end, we have to move it to the
                        // PREVIOUS note (we don't want to extend the solo).
                        if (index > 0)
                        {
                            difficulty.Notes[index - 1].Flags |= NoteFlags.SoloEnd;
                            // Also add it to the child notes
                            foreach (var childNote in difficulty.Notes[index - 1].ChildNotes)
                            {
                                childNote.Flags |= NoteFlags.SoloEnd;
                            }
                        }
                    }

                    if (note.IsStarPowerStart && !note.IsStarPowerEnd)
                    {
                        // This is a single kick drum note that is a starpower start, we have to move it to the
                        // NEXT note (we don't want to extend the starpower section).
                        if (index < difficulty.Notes.Count)
                        {
                            difficulty.Notes[index].Flags |= NoteFlags.StarPowerStart;
                            // Also add it to the child notes
                            foreach (var childNote in difficulty.Notes[index].ChildNotes)
                            {
                                childNote.Flags |= NoteFlags.StarPowerStart;
                            }
                        }
                    }

                    if (note.IsStarPowerEnd)
                    {
                        // This is a single kick drum note that is a starpower end, we have to move it to the
                        // PREVIOUS note (we don't want to extend the starpower section).
                        if (index > 0)
                        {
                            difficulty.Notes[index - 1].Flags |= NoteFlags.StarPowerEnd;
                            // Also add it to the child notes
                            foreach (var childNote in difficulty.Notes[index - 1].ChildNotes)
                            {
                                childNote.Flags |= NoteFlags.StarPowerEnd;
                            }
                        }
                    }

                    index--;
                }

                // Since we modified and/or removed notes, we have to map the previous notes correctly again
                if (index >= 0)
                {
                    if (index > 1)
                    {
                        if (index < difficulty.Notes.Count)
                        {
                            difficulty.Notes[index - 1].NextNote = difficulty.Notes[index];
                        }
                        else
                        {
                            difficulty.Notes[index - 1].NextNote = null;
                        }
                    }

                    if (index > 0)
                    {
                        difficulty.Notes[index].PreviousNote = difficulty.Notes[index - 1];
                    }
                    else
                    {
                        difficulty.Notes[index].PreviousNote = null;
                    }
                }
            }
        }

        public static void RemoveDynamics(this InstrumentDifficulty<DrumNote> difficulty)
        {
            foreach (var i in difficulty.Notes)
            {
                foreach (var note in i.AllNotes)
                {
                    note.Type = DrumNoteType.Neutral;
                }
            }
        }
    }
}
</file>

<file path="Chart/Tracks/InstrumentTrack.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace YARG.Core.Chart
{
    /// <summary>
    /// An instrument track and all of its difficulties.
    /// </summary>
    public class InstrumentTrack<TNote> : ICloneable<InstrumentTrack<TNote>>
        where TNote : Note<TNote>
    {
        public Instrument Instrument { get; }

        private Dictionary<Difficulty, InstrumentDifficulty<TNote>> _difficulties { get; } = new();

        /// <summary>
        /// Whether or not this track contains any data.
        /// </summary>
        public bool IsEmpty
        {
            get
            {
                foreach (var difficulty in _difficulties.Values)
                {
                    if (!difficulty.IsEmpty)
                        return false;
                }

                return true;
            }
        }

        public InstrumentTrack(Instrument instrument)
        {
            Instrument = instrument;
        }

        public InstrumentTrack(Instrument instrument, Dictionary<Difficulty, InstrumentDifficulty<TNote>> difficulties)
            : this(instrument)
        {
            _difficulties = difficulties;
        }

        public InstrumentTrack(InstrumentTrack<TNote> other)
            : this(other.Instrument)
        {
            foreach (var (difficulty, diffTrack) in other._difficulties)
            {
                _difficulties.Add(difficulty, diffTrack.Clone());
            }
        }

        public void AddDifficulty(Difficulty difficulty, InstrumentDifficulty<TNote> track)
            => _difficulties.Add(difficulty, track);

        public void RemoveDifficulty(Difficulty difficulty)
            => _difficulties.Remove(difficulty);

        public InstrumentDifficulty<TNote> GetDifficulty(Difficulty difficulty)
            => _difficulties[difficulty];

        public bool TryGetDifficulty(Difficulty difficulty, [NotNullWhen(true)] out InstrumentDifficulty<TNote>? track)
            => _difficulties.TryGetValue(difficulty, out track);

        // For unit tests
        internal InstrumentDifficulty<TNote> FirstDifficulty()
            => _difficulties.First().Value;

        public double GetStartTime()
        {
            double totalStartTime = 0;
            foreach (var difficulty in _difficulties.Values)
            {
                totalStartTime = Math.Min(difficulty.GetStartTime(), totalStartTime);
            }

            return totalStartTime;
        }

        public double GetEndTime()
        {
            double totalEndTime = 0;
            foreach (var difficulty in _difficulties.Values)
            {
                totalEndTime = Math.Max(difficulty.GetEndTime(), totalEndTime);
            }

            return totalEndTime;
        }

        public uint GetFirstTick()
        {
            uint totalFirstTick = 0;
            foreach (var difficulty in _difficulties.Values)
            {
                totalFirstTick = Math.Min(difficulty.GetFirstTick(), totalFirstTick);
            }

            return totalFirstTick;
        }

        public uint GetLastTick()
        {
            uint totalLastTick = 0;
            foreach (var difficulty in _difficulties.Values)
            {
                totalLastTick = Math.Max(difficulty.GetLastTick(), totalLastTick);
            }

            return totalLastTick;
        }

        public InstrumentTrack<TNote> Clone()
        {
            return new(this);
        }
    }
}
</file>

<file path="Chart/Venue/LightingEvent.cs">
using System;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A lighting event for the stage of a venue.
    /// </summary>
    public class LightingEvent : VenueEvent, ICloneable<LightingEvent>
    {
        public LightingType Type { get; }

        public LightingEvent(LightingType type, double time, uint tick)
            : base(time, 0, tick, 0)
        {
            Type = type;
        }

        public LightingEvent(LightingEvent other) : base(other)
        {
            Type = other.Type;
        }

        public LightingEvent Clone()
        {
            return new(this);
        }
    }

    /// <summary>
    /// Possible lighting types.
    /// </summary>
    public enum LightingType
    {
        // Keyframed
        Default,
        Dischord,
        Chorus,
        CoolManual,
        Stomp,
        Verse,
        WarmManual,

        // Automatic
        BigRockEnding,
        BlackoutFast,
        BlackoutSlow,
        BlackoutSpotlight,
        CoolAutomatic,
        FlareFast,
        FlareSlow,
        Frenzy,
        Intro,
        Harmony,
        Silhouettes,
        SilhouettesSpotlight,
        Searchlights,
        StrobeFastest,
        StrobeFast,
        StrobeMedium,
        StrobeSlow,
        StrobeOff,
        Sweep,
        WarmAutomatic,

        // Keyframe events
        KeyframeFirst,
        KeyframeNext,
        KeyframePrevious,

        //YARG internal
        Menu,
        Score,
        NoCue,
    }
}
</file>

<file path="Chart/Venue/PerformerEvent.cs">
using System;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A performer on the venue's stage.
    /// </summary>
    [Flags]
    public enum Performer
    {
        None = 0,

        Guitar   = 1 << 0,
        Bass     = 1 << 1,
        Drums    = 1 << 2,
        Vocals   = 1 << 3,
        Keyboard = 1 << 4,
    }

    /// <summary>
    /// A venue event involving the performers on-stage.
    /// </summary>
    public class PerformerEvent : VenueEvent, ICloneable<PerformerEvent>
    {
        public PerformerEventType Type { get; }
        public Performer Performers { get; }

        public PerformerEvent(PerformerEventType type, Performer performers,
            double time, double timeLength, uint tick, uint tickLength)
            : base(time, timeLength, tick, tickLength)
        {
            Type = type;
            Performers = performers;
        }

        public PerformerEvent(PerformerEvent other) : base(other)
        {
            Type = other.Type;
            Performers = other.Performers;
        }

        public PerformerEvent Clone()
        {
            return new(this);
        }
    }

    /// <summary>
    /// Possible types of performer events.
    /// </summary>
    public enum PerformerEventType
    {
        Spotlight,
        Singalong,
    }
}
</file>

<file path="Chart/Venue/PostProcessingEvent.cs">
using System;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A lighting event for the stage of a venue.
    /// </summary>
    public class PostProcessingEvent : VenueEvent, ICloneable<PostProcessingEvent>
    {
        public PostProcessingType Type { get; }

        public PostProcessingEvent(PostProcessingType type, double time, uint tick)
            : base(time, 0, tick, 0)
        {
            Type = type;
        }

        public PostProcessingEvent(PostProcessingEvent other) : base(other)
        {
            Type = other.Type;
        }

        public PostProcessingEvent Clone()
        {
            return new(this);
        }
    }

    /// <summary>
    /// Possible post-processing effects.
    /// </summary>
    public enum PostProcessingType
    {
        // Basic effects
        Default,
        Bloom,
        Bright,
        Contrast,
        Posterize,
        PhotoNegative,
        Mirror,

        // Color filters/effects
        BlackAndWhite,
        SepiaTone,
        SilverTone,

        Choppy_BlackAndWhite,
        PhotoNegative_RedAndBlack,
        Polarized_BlackAndWhite,
        Polarized_RedAndBlue,

        Desaturated_Blue,
        Desaturated_Red,

        Contrast_Red,
        Contrast_Green,
        Contrast_Blue,

        // Grainy
        Grainy_Film,
        Grainy_ChromaticAbberation,

        // Scanlines
        Scanlines,
        Scanlines_BlackAndWhite,
        Scanlines_Blue,
        Scanlines_Security,

        // Trails
        Trails,
        Trails_Long,
        Trails_Desaturated,
        Trails_Flickery,
        Trails_Spacey,
    }
}
</file>

<file path="Chart/Venue/StageEffectEvent.cs">
using System;

namespace YARG.Core.Chart
{
    /// <summary>
    /// Miscellaneous stage effects for venues.
    /// </summary>
    public class StageEffectEvent : VenueEvent, ICloneable<StageEffectEvent>
    {
        public StageEffect Effect { get; }

        public StageEffectEvent(StageEffect effect, VenueEventFlags flags, double time, uint tick)
            : base(flags, time, 0, tick, 0)
        {
            Effect = effect;
        }

        public StageEffectEvent(StageEffectEvent other) : base(other)
        {
            Effect = other.Effect;
        }

        public StageEffectEvent Clone()
        {
            return new(this);
        }
    }

    /// <summary>
    /// Possible stage effects.
    /// </summary>
    public enum StageEffect
    {
        BonusFx,
        FogOn,
        FogOff,
    }
}
</file>

<file path="Chart/Venue/VenueEvent.cs">
using System;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A venue event that occurs in a chart.
    /// </summary>
    public abstract class VenueEvent : ChartEvent
    {
        private readonly VenueEventFlags _flags;

        public bool IsOptional => (_flags & VenueEventFlags.Optional) != 0;

        public VenueEvent(VenueEventFlags flags, double time, double timeLength, uint tick, uint tickLength)
            : base(time, timeLength, tick, tickLength)
        {
            _flags = flags;
        }

        public VenueEvent(double time, double timeLength, uint tick, uint tickLength)
            : this(VenueEventFlags.None, time, timeLength, tick, tickLength)
        {
        }

        public VenueEvent(VenueEvent other) : base(other)
        {
            _flags = other._flags;
        }
    }

    /// <summary>
    /// Flags for venue events.
    /// </summary>
    [Flags]
    public enum VenueEventFlags
    {
        None = 0,

        Optional = 1 << 0,
    }
}
</file>

<file path="Chart/Venue/VenueLookup.cs">
using System.Collections.Generic;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A lighting event for the stage of a venue.
    /// </summary>
    public static class VenueLookup
    {
        public enum Type
        {
            Lighting,
            PostProcessing,
            Singalong,
            Spotlight,
            StageEffect,

            Unknown = 99
        }
        public static readonly Dictionary<string, (VenueLookup.Type type, string text)> VENUE_TEXT_CONVERSION_LOOKUP = new()
        {
            #region Lighting events
            // Keyframe events
            { "first", (VenueLookup.Type.Lighting, VENUE_LIGHTING_FIRST) },
            { "next",  (VenueLookup.Type.Lighting, VENUE_LIGHTING_NEXT) },
            { "prev",  (VenueLookup.Type.Lighting, VENUE_LIGHTING_PREVIOUS) },

            // RBN1 equivalents for `lighting (chorus)` and `lighting (verse)`
            { "verse",  (VenueLookup.Type.Lighting, VENUE_LIGHTING_VERSE) },
            { "chorus", (VenueLookup.Type.Lighting, VENUE_LIGHTING_CHORUS) },
            #endregion

            #region Post-processing events
            { "bloom.pp",                        (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_BLOOM) },
            { "bright.pp",                       (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_BRIGHT) },
            { "clean_trails.pp",                 (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_TRAILS) },
            { "contrast_a.pp",                   (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_POLARIZED_BLACK_WHITE) },
            { "desat_blue.pp",                   (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_DESATURATED_BLUE) },
            { "desat_posterize_trails.pp",       (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_TRAILS_DESATURATED) },
            { "film_contrast.pp",                (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_CONTRAST) },
            { "film_b+w.pp",                     (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_BLACK_WHITE) },
            { "film_sepia_ink.pp",               (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_SEPIATONE) },
            { "film_silvertone.pp",              (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_SILVERTONE) },
            { "film_contrast_red.pp",            (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_CONTRAST_RED) },
            { "film_contrast_green.pp",          (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_CONTRAST_GREEN) },
            { "film_contrast_blue.pp",           (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_CONTRAST_BLUE) },
            { "film_16mm.pp",                    (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_GRAINY_FILM) },
            { "film_blue_filter.pp",             (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_SCANLINES_BLUE) },
            { "flicker_trails.pp",               (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_TRAILS_FLICKERY) },
            { "horror_movie_special.pp",         (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_PHOTONEGATIVE_RED_BLACK) },
            { "photocopy.pp",                    (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_CHOPPY_BLACK_WHITE) },
            { "photo_negative.pp",               (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_PHOTONEGATIVE) },
            { "posterize.pp",                    (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_POSTERIZE) },
            { "ProFilm_a.pp",                    (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_DEFAULT) },
            { "ProFilm_b.pp",                    (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_DESATURATED_RED) },
            { "ProFilm_mirror_a.pp",             (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_MIRROR) },
            { "ProFilm_psychedelic_blue_red.pp", (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_POLARIZED_RED_BLUE) },
            { "shitty_tv.pp",                    (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_GRAINY_CHROMATIC_ABBERATION) },
            { "space_woosh.pp",                  (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_TRAILS_SPACEY) },
            { "video_a.pp",                      (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_SCANLINES) },
            { "video_bw.pp",                     (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_SCANLINES_BLACK_WHITE) },
            { "video_security.pp",               (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_SCANLINES_SECURITY) },
            { "video_trails.pp",                 (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_TRAILS_LONG) },
            #endregion

            #region Stage effects
            { "bonusfx",          (VenueLookup.Type.StageEffect, VENUE_STAGE_BONUS_FX) },
            { "bonusfx_optional", (VenueLookup.Type.StageEffect, VENUE_OPTIONAL_EVENT_PREFIX_WITH_SPACE + VENUE_STAGE_BONUS_FX) },
            { "FogOn",            (VenueLookup.Type.StageEffect, VENUE_STAGE_FOG_ON) },
            { "FogOff",           (VenueLookup.Type.StageEffect, VENUE_STAGE_FOG_OFF) },
            #endregion
        };

        public static readonly Dictionary<string, string> VENUE_LIGHTING_CONVERSION_LOOKUP = new()
        {
            #region Keyframed
            // { string.Empty,  VENUE_LIGHTING_DEFAULT }, // Handled by the default case
            { "chorus",      VENUE_LIGHTING_CHORUS },
            { "dischord",    VENUE_LIGHTING_DISCHORD },
            { "manual_cool", VENUE_LIGHTING_COOL_MANUAL },
            { "manual_warm", VENUE_LIGHTING_WARM_MANUAL },
            { "stomp",       VENUE_LIGHTING_STOMP },
            { "verse",       VENUE_LIGHTING_VERSE },
            #endregion

            #region Automatic
            { "blackout_fast",    VENUE_LIGHTING_BLACKOUT_FAST },
            { "blackout_slow",    VENUE_LIGHTING_BLACKOUT_SLOW },
            { "blackout_spot",    VENUE_LIGHTING_BLACKOUT_SPOTLIGHT },
            { "bre",              VENUE_LIGHTING_BIG_ROCK_ENDING },
            { "flare_fast",       VENUE_LIGHTING_FLARE_FAST },
            { "flare_slow",       VENUE_LIGHTING_FLARE_SLOW },
            { "frenzy",           VENUE_LIGHTING_FRENZY },
            { "harmony",          VENUE_LIGHTING_HARMONY },
            { "intro",            VENUE_LIGHTING_INTRO },
            { "loop_cool",        VENUE_LIGHTING_COOL_AUTOMATIC },
            { "loop_warm",        VENUE_LIGHTING_WARM_AUTOMATIC },
            { "searchlights",     VENUE_LIGHTING_SEARCHLIGHTS },
            { "silhouettes",      VENUE_LIGHTING_SILHOUETTES },
            { "silhouettes_spot", VENUE_LIGHTING_SILHOUETTES_SPOTLIGHT },
            { "strobe_fast",      VENUE_LIGHTING_STROBE_FAST },
            { "strobe_slow",      VENUE_LIGHTING_STROBE_SLOW },
            { "sweep",            VENUE_LIGHTING_SWEEP },
            #endregion
        };

        #region Venue
        // NOTE: The definitions here are not how the events themselves are represented in the chart file.
        // They're re-interpretations meant to ease certain aspects of handling them later on.

        #region General
        public const string
        VENUE_OPTIONAL_EVENT_PREFIX = "optional",
        VENUE_OPTIONAL_EVENT_PREFIX_WITH_SPACE = VENUE_OPTIONAL_EVENT_PREFIX + " ";
        #endregion

        #region Performers
        public const string
        VENUE_PERFORMER_GUITAR = "guitar",
        VENUE_PERFORMER_BASS = "bass",
        VENUE_PERFORMER_DRUMS = "drums",
        VENUE_PERFORMER_VOCALS = "vocals",
        VENUE_PERFORMER_KEYS = "keys";
        #endregion

        #region Lighting
        // Keyframed
        public const string
        VENUE_LIGHTING_DEFAULT = "default",
        VENUE_LIGHTING_DISCHORD = "dischord",
        VENUE_LIGHTING_CHORUS = "chorus",
        VENUE_LIGHTING_COOL_MANUAL = "cool_manual", // manual_cool
        VENUE_LIGHTING_STOMP = "stomp",
        VENUE_LIGHTING_VERSE = "verse",
        VENUE_LIGHTING_WARM_MANUAL = "warm_manual", // manual_warm

        // Automatic
        VENUE_LIGHTING_BIG_ROCK_ENDING = "big_rock_ending", // bre
        VENUE_LIGHTING_BLACKOUT_FAST = "blackout_fast",
        VENUE_LIGHTING_BLACKOUT_SLOW = "blackout_slow",
        VENUE_LIGHTING_BLACKOUT_SPOTLIGHT = "blackout_spotlight", // blackout_spot
        VENUE_LIGHTING_COOL_AUTOMATIC = "cool_automatic", // loop_cool
        VENUE_LIGHTING_FLARE_FAST = "flare_fast",
        VENUE_LIGHTING_FLARE_SLOW = "flare_slow",
        VENUE_LIGHTING_FRENZY = "frenzy",
        VENUE_LIGHTING_INTRO = "intro",
        VENUE_LIGHTING_HARMONY = "harmony",
        VENUE_LIGHTING_SILHOUETTES = "silhouettes",
        VENUE_LIGHTING_SILHOUETTES_SPOTLIGHT = "silhouettes_spotlight", // silhouettes_spot
        VENUE_LIGHTING_SEARCHLIGHTS = "searchlights",
        VENUE_LIGHTING_STROBE_FAST = "strobe_fast",
        VENUE_LIGHTING_STROBE_SLOW = "strobe_slow",
        VENUE_LIGHTING_SWEEP = "sweep",
        VENUE_LIGHTING_WARM_AUTOMATIC = "warm_automatic", // loop_warm

        // Keyframe events
        VENUE_LIGHTING_FIRST = "first",
        VENUE_LIGHTING_NEXT = "next",
        VENUE_LIGHTING_PREVIOUS = "previous";
        #endregion

        #region Post-processing
        public const string
        VENUE_POSTPROCESS_DEFAULT = "default", // ProFilm_a.pp

        // Basic effects
        VENUE_POSTPROCESS_BLOOM = "bloom", // bloom.pp
        VENUE_POSTPROCESS_BRIGHT = "bright", // bright.pp
        VENUE_POSTPROCESS_CONTRAST = "contrast", // film_contrast.pp
        VENUE_POSTPROCESS_MIRROR = "mirror", // ProFilm_mirror_a.pp
        VENUE_POSTPROCESS_PHOTONEGATIVE = "photonegative", // photo_negative.pp
        VENUE_POSTPROCESS_POSTERIZE = "posterize", // posterize.pp

        // Color filters/effects
        VENUE_POSTPROCESS_BLACK_WHITE = "black_white", // film_b+w.pp
        VENUE_POSTPROCESS_SEPIATONE = "sepiatone", // film_sepia_ink.pp
        VENUE_POSTPROCESS_SILVERTONE = "silvertone", // film_silvertone.pp

        VENUE_POSTPROCESS_CHOPPY_BLACK_WHITE = "choppy_black_white", // photocopy.pp
        VENUE_POSTPROCESS_PHOTONEGATIVE_RED_BLACK = "photonegative_red_black", // horror_movie_special.pp
        VENUE_POSTPROCESS_POLARIZED_BLACK_WHITE = "polarized_black_white", // contrast_a.pp
        VENUE_POSTPROCESS_POLARIZED_RED_BLUE = "polarized_red_blue", // ProFilm_psychedelic_blue_red.pp

        VENUE_POSTPROCESS_DESATURATED_RED = "desaturated_red", // ProFilm_b.pp
        VENUE_POSTPROCESS_DESATURATED_BLUE = "desaturated_blue", // desat_blue.pp

        VENUE_POSTPROCESS_CONTRAST_RED = "contrast_red", // film_contrast_red.pp
        VENUE_POSTPROCESS_CONTRAST_GREEN = "contrast_green", // film_contrast_green.pp
        VENUE_POSTPROCESS_CONTRAST_BLUE = "contrast_blue", // film_contrast_blue.pp

        // Grainy
        VENUE_POSTPROCESS_GRAINY_FILM = "grainy_film", // film_16mm.pp
        VENUE_POSTPROCESS_GRAINY_CHROMATIC_ABBERATION = "grainy_chromatic_abberation", // shitty_tv.pp

        // Scanlines
        VENUE_POSTPROCESS_SCANLINES = "scanlines", // video_a.pp
        VENUE_POSTPROCESS_SCANLINES_BLACK_WHITE = "scanlines_black_white", // video_bw.pp
        VENUE_POSTPROCESS_SCANLINES_BLUE = "scanlines_blue", // film_blue_filter.pp
        VENUE_POSTPROCESS_SCANLINES_SECURITY = "scanlines_security", // video_security.pp

        // Trails (video feed delay, a "visual echo")
        VENUE_POSTPROCESS_TRAILS = "trails", // clean_trails.pp
        VENUE_POSTPROCESS_TRAILS_LONG = "trails_long", // video_trails.pp
        VENUE_POSTPROCESS_TRAILS_DESATURATED = "trails_desaturated", // desat_posterize_trails.pp
        VENUE_POSTPROCESS_TRAILS_FLICKERY = "trails_flickery", // flicker_trails.pp
        VENUE_POSTPROCESS_TRAILS_SPACEY = "trails_spacey"; // space_woosh.pp
        #endregion

        #region Stage effects
        public const string
        VENUE_STAGE_BONUS_FX = "bonus_fx",
        VENUE_STAGE_FOG_ON = "fog_on",
        VENUE_STAGE_FOG_OFF = "fog_off";
        #endregion

        #endregion // Venue

        #region Lookups
        public static readonly Dictionary<string, VenueEventFlags> FlagPrefixLookup = new()
        {
            { VENUE_OPTIONAL_EVENT_PREFIX, VenueEventFlags.Optional },
        };

        public static readonly Dictionary<string, Performer> PerformerLookup = new()
        {
            { VENUE_PERFORMER_GUITAR, Performer.Guitar },
            { VENUE_PERFORMER_BASS,   Performer.Bass },
            { VENUE_PERFORMER_DRUMS,  Performer.Drums },
            { VENUE_PERFORMER_VOCALS, Performer.Vocals },
            { VENUE_PERFORMER_KEYS,   Performer.Keyboard },
        };

        public static readonly Dictionary<string, LightingType> LightingLookup = new()
        {
            // Keyframed
            { VENUE_LIGHTING_DEFAULT,     LightingType.Default },
            { VENUE_LIGHTING_DISCHORD,    LightingType.Dischord },
            { VENUE_LIGHTING_CHORUS,      LightingType.Chorus },
            { VENUE_LIGHTING_COOL_MANUAL, LightingType.CoolManual },
            { VENUE_LIGHTING_STOMP,       LightingType.Stomp },
            { VENUE_LIGHTING_VERSE,       LightingType.Verse },
            { VENUE_LIGHTING_WARM_MANUAL, LightingType.WarmManual },

            // Automatic
            { VENUE_LIGHTING_BIG_ROCK_ENDING,        LightingType.BigRockEnding },
            { VENUE_LIGHTING_BLACKOUT_FAST,          LightingType.BlackoutFast },
            { VENUE_LIGHTING_BLACKOUT_SLOW,          LightingType.BlackoutSlow },
            { VENUE_LIGHTING_BLACKOUT_SPOTLIGHT,     LightingType.BlackoutSpotlight },
            { VENUE_LIGHTING_COOL_AUTOMATIC,         LightingType.CoolAutomatic },
            { VENUE_LIGHTING_FLARE_FAST,             LightingType.FlareFast },
            { VENUE_LIGHTING_FLARE_SLOW,             LightingType.FlareSlow },
            { VENUE_LIGHTING_FRENZY,                 LightingType.Frenzy },
            { VENUE_LIGHTING_INTRO,                  LightingType.Intro },
            { VENUE_LIGHTING_HARMONY,                LightingType.Harmony },
            { VENUE_LIGHTING_SILHOUETTES,            LightingType.Silhouettes },
            { VENUE_LIGHTING_SILHOUETTES_SPOTLIGHT,  LightingType.SilhouettesSpotlight },
            { VENUE_LIGHTING_SEARCHLIGHTS,           LightingType.Searchlights },
            { VENUE_LIGHTING_STROBE_FAST,            LightingType.StrobeFast },
            { VENUE_LIGHTING_STROBE_SLOW,            LightingType.StrobeSlow },
            { VENUE_LIGHTING_SWEEP,                  LightingType.Sweep },
            { VENUE_LIGHTING_WARM_AUTOMATIC,         LightingType.WarmAutomatic },

            // Keyframes
            { VENUE_LIGHTING_FIRST,    LightingType.KeyframeFirst },
            { VENUE_LIGHTING_NEXT,     LightingType.KeyframeNext },
            { VENUE_LIGHTING_PREVIOUS, LightingType.KeyframePrevious },
        };

        public static readonly Dictionary<string, PostProcessingType> PostProcessLookup = new()
        {
            { VENUE_POSTPROCESS_DEFAULT, PostProcessingType.Default },

            // Basic effects
            { VENUE_POSTPROCESS_BLOOM,         PostProcessingType.Bloom },
            { VENUE_POSTPROCESS_BRIGHT,        PostProcessingType.Bright },
            { VENUE_POSTPROCESS_CONTRAST,      PostProcessingType.Contrast },
            { VENUE_POSTPROCESS_MIRROR,        PostProcessingType.Mirror },
            { VENUE_POSTPROCESS_PHOTONEGATIVE, PostProcessingType.PhotoNegative },
            { VENUE_POSTPROCESS_POSTERIZE,     PostProcessingType.Posterize },

            // Color filters/effects
            { VENUE_POSTPROCESS_BLACK_WHITE,             PostProcessingType.BlackAndWhite },
            { VENUE_POSTPROCESS_SEPIATONE,               PostProcessingType.SepiaTone },
            { VENUE_POSTPROCESS_SILVERTONE,              PostProcessingType.SilverTone },
            { VENUE_POSTPROCESS_CHOPPY_BLACK_WHITE,      PostProcessingType.Choppy_BlackAndWhite },
            { VENUE_POSTPROCESS_PHOTONEGATIVE_RED_BLACK, PostProcessingType.PhotoNegative_RedAndBlack },
            { VENUE_POSTPROCESS_POLARIZED_BLACK_WHITE,   PostProcessingType.Polarized_BlackAndWhite },
            { VENUE_POSTPROCESS_POLARIZED_RED_BLUE,      PostProcessingType.Polarized_RedAndBlue },
            { VENUE_POSTPROCESS_DESATURATED_RED,         PostProcessingType.Desaturated_Red },
            { VENUE_POSTPROCESS_DESATURATED_BLUE,        PostProcessingType.Desaturated_Blue },
            { VENUE_POSTPROCESS_CONTRAST_RED,            PostProcessingType.Contrast_Red },
            { VENUE_POSTPROCESS_CONTRAST_GREEN,          PostProcessingType.Contrast_Green },
            { VENUE_POSTPROCESS_CONTRAST_BLUE,           PostProcessingType.Contrast_Blue },

            // Grainy
            { VENUE_POSTPROCESS_GRAINY_FILM,                 PostProcessingType.Grainy_Film },
            { VENUE_POSTPROCESS_GRAINY_CHROMATIC_ABBERATION, PostProcessingType.Grainy_ChromaticAbberation },

            // Scanlines
            { VENUE_POSTPROCESS_SCANLINES,             PostProcessingType.Scanlines },
            { VENUE_POSTPROCESS_SCANLINES_BLACK_WHITE, PostProcessingType.Scanlines_BlackAndWhite },
            { VENUE_POSTPROCESS_SCANLINES_BLUE,        PostProcessingType.Scanlines_Blue },
            { VENUE_POSTPROCESS_SCANLINES_SECURITY,    PostProcessingType.Scanlines_Security },

            // Trails
            { VENUE_POSTPROCESS_TRAILS,             PostProcessingType.Trails },
            { VENUE_POSTPROCESS_TRAILS_LONG,        PostProcessingType.Trails_Long },
            { VENUE_POSTPROCESS_TRAILS_DESATURATED, PostProcessingType.Trails_Desaturated },
            { VENUE_POSTPROCESS_TRAILS_FLICKERY,    PostProcessingType.Trails_Flickery },
            { VENUE_POSTPROCESS_TRAILS_SPACEY,      PostProcessingType.Trails_Spacey },
        };

        public static readonly Dictionary<string, StageEffect> StageEffectLookup = new()
        {
            { VENUE_STAGE_BONUS_FX, StageEffect.BonusFx },
            { VENUE_STAGE_FOG_ON,   StageEffect.FogOn },
            { VENUE_STAGE_FOG_OFF,  StageEffect.FogOff },
        };
        #endregion
    }
}
</file>

<file path="Chart/Venue/VenueTrack.cs">
using System;
using System.Collections.Generic;

namespace YARG.Core.Chart
{
    /// <summary>
    /// A venue track.
    /// </summary>
    public class VenueTrack
    {
        public List<LightingEvent> Lighting { get; } = new();
        public List<PostProcessingEvent> PostProcessing { get; } = new();
        public List<PerformerEvent> Performer { get; } = new();
        public List<StageEffectEvent> Stage { get; } = new();

        public VenueTrack() { }

        public VenueTrack(List<LightingEvent> lighting, List<PostProcessingEvent> postProcessing,
            List<PerformerEvent> performer, List<StageEffectEvent> stage)
        {
            Lighting = lighting;
            PostProcessing = postProcessing;
            Performer = performer;
            Stage = stage;
        }

        public double GetStartTime()
        {
            double totalStartTime = 0;

            totalStartTime = Math.Min(Lighting.GetStartTime(), totalStartTime);
            totalStartTime = Math.Min(PostProcessing.GetStartTime(), totalStartTime);
            totalStartTime = Math.Min(Performer.GetStartTime(), totalStartTime);
            totalStartTime = Math.Min(Stage.GetStartTime(), totalStartTime);

            return totalStartTime;
        }

        public double GetEndTime()
        {
            double totalEndTime = 0;

            totalEndTime = Math.Max(Lighting.GetEndTime(), totalEndTime);
            totalEndTime = Math.Max(PostProcessing.GetEndTime(), totalEndTime);
            totalEndTime = Math.Max(Performer.GetEndTime(), totalEndTime);
            totalEndTime = Math.Max(Stage.GetEndTime(), totalEndTime);

            return totalEndTime;
        }

        public uint GetFirstTick()
        {
            uint totalFirstTick = 0;

            totalFirstTick = Math.Min(Lighting.GetFirstTick(), totalFirstTick);
            totalFirstTick = Math.Min(PostProcessing.GetFirstTick(), totalFirstTick);
            totalFirstTick = Math.Min(Performer.GetFirstTick(), totalFirstTick);
            totalFirstTick = Math.Min(Stage.GetFirstTick(), totalFirstTick);

            return totalFirstTick;
        }

        public uint GetLastTick()
        {
            uint totalLastTick = 0;

            totalLastTick = Math.Max(Lighting.GetLastTick(), totalLastTick);
            totalLastTick = Math.Max(PostProcessing.GetLastTick(), totalLastTick);
            totalLastTick = Math.Max(Performer.GetLastTick(), totalLastTick);
            totalLastTick = Math.Max(Stage.GetLastTick(), totalLastTick);

            return totalLastTick;
        }
    }
}
</file>

<file path="Chart/ChartEventTrackers.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

#nullable enable

namespace YARG.Core.Chart
{
    /// <summary>
    /// Tracks the current event of an event list across ticks.
    /// </summary>
    public class ChartEventTickTracker<TEvent>
        where TEvent : ChartEvent
    {
        private List<TEvent> _events;
        private int _eventIndex = -1;

        public TEvent? Current => _eventIndex >= 0 ? _events[_eventIndex] : null;
        public int CurrentIndex => _eventIndex;

        public ChartEventTickTracker(List<TEvent> events)
        {
            _events = events;
        }

        /// <summary>
        /// Updates the state of the event tracker to the given tick.
        /// </summary>
        /// <returns>
        /// True if a new event has been reached, false otherwise.
        /// </returns>
        public bool Update(uint tick)
        {
            int previousIndex = _eventIndex;
            while (_eventIndex + 1 < _events.Count && _events[_eventIndex + 1].Tick <= tick)
                _eventIndex++;
            return previousIndex != _eventIndex;
        }

        /// <summary>
        /// Updates the state of the event tracker to the given tick by a single event.
        /// </summary>
        /// <returns>
        /// True if a new event has been reached, false otherwise.
        /// </returns>
        public bool UpdateOnce(uint tick, [NotNullWhen(true)] out TEvent? current)
        {
            if (_eventIndex + 1 < _events.Count && _events[_eventIndex + 1].Tick <= tick)
            {
                _eventIndex++;
                current = _events[_eventIndex];
                return true;
            }

            current = Current;
            return false;
        }

        /// <summary>
        /// Resets the state of the event tracker.
        /// </summary>
        public void Reset()
        {
            _eventIndex = -1;
        }

        /// <summary>
        /// Resets the state of the event tracker to the given tick.
        /// </summary>
        public void ResetToTick(uint tick)
        {
            _eventIndex = _events.GetIndexOfPrevious(tick);
        }
    }

    /// <summary>
    /// Tracks the current event of an event list across times.
    /// </summary>
    public class ChartEventTimeTracker<TEvent>
        where TEvent : ChartEvent
    {
        private List<TEvent> _events;
        private int _eventIndex = -1;

        public TEvent? Current => _eventIndex >= 0 ? _events[_eventIndex] : null;
        public int CurrentIndex => _eventIndex;

        public ChartEventTimeTracker(List<TEvent> events)
        {
            _events = events;
        }

        /// <summary>
        /// Updates the state of the event tracker to the given time.
        /// </summary>
        /// <returns>
        /// True if a new event has been reached, false otherwise.
        /// </returns>
        public bool Update(double time)
        {
            int previousIndex = _eventIndex;
            while (_eventIndex + 1 < _events.Count && _events[_eventIndex + 1].Time <= time)
                _eventIndex++;
            return previousIndex != _eventIndex;
        }

        /// <summary>
        /// Updates the state of the event tracker to the given time by a single event.
        /// </summary>
        /// <returns>
        /// True if a new event has been reached, false otherwise.
        /// </returns>
        public bool UpdateOnce(double time, [NotNullWhen(true)] out TEvent? current)
        {
            if (_eventIndex + 1 < _events.Count && _events[_eventIndex + 1].Time <= time)
            {
                _eventIndex++;
                current = _events[_eventIndex];
                return true;
            }

            current = Current;
            return false;
        }

        /// <summary>
        /// Resets the state of the event tracker.
        /// </summary>
        public void Reset()
        {
            _eventIndex = -1;
        }

        /// <summary>
        /// Resets the state of the event tracker to the given time.
        /// </summary>
        public void ResetToTime(double time)
        {
            _eventIndex = _events.GetIndexOfPrevious(time);
        }
    }

}
</file>

<file path="Chart/ChartEventTrackers.t4">
<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

#nullable enable

namespace YARG.Core.Chart
{
<#
var types = new (string upper, string lower, string type)[] {
    ("Tick", "tick", "uint"),
    ("Time", "time", "double"),
};

foreach (var (upper, lower, type) in types)
{
#>
    /// <summary>
    /// Tracks the current event of an event list across <#= lower #>s.
    /// </summary>
    public class ChartEvent<#= upper #>Tracker<TEvent>
        where TEvent : ChartEvent
    {
        private List<TEvent> _events;
        private int _eventIndex = -1;

        public TEvent? Current => _eventIndex >= 0 ? _events[_eventIndex] : null;
        public int CurrentIndex => _eventIndex;

        public ChartEvent<#= upper #>Tracker(List<TEvent> events)
        {
            _events = events;
        }

        /// <summary>
        /// Updates the state of the event tracker to the given <#= lower #>.
        /// </summary>
        /// <returns>
        /// True if a new event has been reached, false otherwise.
        /// </returns>
        public bool Update(<#= type #> <#= lower #>)
        {
            int previousIndex = _eventIndex;
            while (_eventIndex + 1 < _events.Count && _events[_eventIndex + 1].<#= upper #> <= <#= lower #>)
                _eventIndex++;
            return previousIndex != _eventIndex;
        }

        /// <summary>
        /// Updates the state of the event tracker to the given <#= lower #> by a single event.
        /// </summary>
        /// <returns>
        /// True if a new event has been reached, false otherwise.
        /// </returns>
        public bool UpdateOnce(<#= type #> <#= lower #>, [NotNullWhen(true)] out TEvent? current)
        {
            if (_eventIndex + 1 < _events.Count && _events[_eventIndex + 1].<#= upper #> <= <#= lower #>)
            {
                _eventIndex++;
                current = _events[_eventIndex];
                return true;
            }

            current = Current;
            return false;
        }

        /// <summary>
        /// Resets the state of the event tracker.
        /// </summary>
        public void Reset()
        {
            _eventIndex = -1;
        }

        /// <summary>
        /// Resets the state of the event tracker to the given <#= lower #>.
        /// </summary>
        public void ResetTo<#= upper #>(<#= type #> <#= lower #>)
        {
            _eventIndex = _events.GetIndexOfPrevious(<#= lower #>);
        }
    }

<#
}
#>
}
</file>

<file path="Chart/MidiSettings.cs">
using System.Text;
using Melanchall.DryWetMidi.Core;
using YARG.Core.IO;

namespace YARG.Core.Chart
{
    public static class MidiSettings
    {
        public static readonly ReadingSettings Instance = new()
        {
            InvalidChunkSizePolicy = InvalidChunkSizePolicy.Ignore,
            NotEnoughBytesPolicy = NotEnoughBytesPolicy.Ignore,
            NoHeaderChunkPolicy = NoHeaderChunkPolicy.Ignore,
            InvalidChannelEventParameterValuePolicy = InvalidChannelEventParameterValuePolicy.ReadValid,
            TextEncoding = YARGTextReader.UTF8Strict,
        };
	}

    public static class MidiSettingsLatin1
    {
        public static readonly ReadingSettings Instance = new()
        {
            InvalidChunkSizePolicy = InvalidChunkSizePolicy.Ignore,
            NotEnoughBytesPolicy = NotEnoughBytesPolicy.Ignore,
            NoHeaderChunkPolicy = NoHeaderChunkPolicy.Ignore,
            InvalidChannelEventParameterValuePolicy = InvalidChannelEventParameterValuePolicy.ReadValid,
            TextEncoding = YARGTextReader.Latin1,
        };
	}
}
</file>

<file path="Chart/ParsingProperties.cs">
using System;

namespace YARG.Core.Chart
{
    /// <summary>
    /// The type of drums contained in the chart.
    /// </summary>
    [Flags]
    public enum DrumsType
    {
        Unknown = 0,
        FourLane = 1 << 0,
        ProDrums = 1 << 1,
        FiveLane = 1 << 2,
        // For scanning
        FourOrPro = FourLane | ProDrums,
        FourOrFive = FourLane | FiveLane,
        ProOrFive = ProDrums | FiveLane,
        Any = FourOrFive | FiveLane | ProDrums,
    }

    /// <summary>
    /// Settings used when parsing charts.
    /// </summary>
    public struct ParseSettings
    {
        /// <summary>
        /// The default settings to use for parsing.
        /// </summary>
        public static readonly ParseSettings Default = new()
        {
            DrumsType = DrumsType.Unknown,
            HopoThreshold = SETTING_DEFAULT,
            SustainCutoffThreshold = SETTING_DEFAULT,
            ChordHopoCancellation = false,
            StarPowerNote = SETTING_DEFAULT,
            NoteSnapThreshold = 0,
        };

        public static readonly ParseSettings Default_Chart = new()
        {
            DrumsType = DrumsType.Unknown,
            HopoThreshold = SETTING_DEFAULT,
            SustainCutoffThreshold = 0,
            ChordHopoCancellation = false,
            StarPowerNote = SETTING_DEFAULT,
            NoteSnapThreshold = 0,
        };

        public static readonly ParseSettings Default_Midi = new()
        {
            DrumsType = DrumsType.Unknown,
            HopoThreshold = SETTING_DEFAULT,
            SustainCutoffThreshold = SETTING_DEFAULT,
            ChordHopoCancellation = false,
            StarPowerNote = 116,
            NoteSnapThreshold = 0,
        };

        /// <summary>
        /// The value used to indicate a setting should be overwritten with the
        /// appropriate default value for the chart being parsed.
        /// </summary>
        public const int SETTING_DEFAULT = -1;

        /// <summary>
        /// The drums mode to parse the drums track as.
        /// </summary>
        public DrumsType DrumsType;

        /// <summary>
        /// The tick distance between notes to use as the HOPO threshold.
        /// </summary>
        /// <remarks>
        /// Uses the <c>hopo_threshold</c> tag from song.ini files.<br/>
        /// Defaults to a 1/12th note.
        /// </remarks>
        public long HopoThreshold;

        /// <summary>
        /// Skip marking single notes after chords as HOPOs
        /// if the single note shares a fret with the chord.
        /// </summary>
        public bool ChordHopoCancellation;

        /// <summary>
        /// The tick threshold to use for sustain cutoffs.
        /// </summary>
        /// <remarks>
        /// Uses the <c>sustain_cutoff_threshold</c> tag from song.ini files.<br/>
        /// Defaults to a 1/12th note in .mid, and 0 in .chart.
        /// </remarks>
        public long SustainCutoffThreshold;

        /// <summary>
        /// The tick threshold to use for snapping together single notes into chords.
        /// </summary>
        /// <remarks>
        /// Defaults to 10 in CON files, and 0 in other charts.
        /// </remarks>
        public long NoteSnapThreshold;

        /// <summary>
        /// The MIDI note to use for Star Power phrases in .mid charts.
        /// </summary>
        /// <remarks>
        /// Uses the <c>multiplier_note</c> and <c>star_power_note</c> tags from song.ini files.<br/>
        /// Defaults to 116.
        /// </remarks>
        public int StarPowerNote;
    }
}
</file>

<file path="Chart/SongChart.AutoGeneration.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using Melanchall.DryWetMidi.Core;
using YARG.Core.Logging;
using YARG.Core.Parsing;

namespace YARG.Core.Chart
{
    /// <summary>
    /// The chart data for a song.
    /// </summary>
    public partial class SongChart
    {
        private void PostProcessSections()
        {
            uint lastTick = GetLastTick();

            // If there are no sections in the chart, auto-generate some sections.
            // This prevents issues with songs with no sections, such as in practice mode.
            if (Sections.Count == 0)
            {
                const int AUTO_GEN_SECTION_COUNT = 10;
                ReadOnlySpan<double> factors = stackalloc double[AUTO_GEN_SECTION_COUNT]{
                    0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0
                };

                uint startTick = 0;
                double startTime = SyncTrack.TickToTime(0);

                for (int i = 0; i < AUTO_GEN_SECTION_COUNT; i++)
                {
                    uint endTick = (uint)(lastTick * factors[i]);
                    double endTime = SyncTrack.TickToTime(endTick);

                    // "0% - 10%", "10% - 20%", etc.
                    var sectionName = $"{i * 10}% - {i + 1}0%";

                    var section = new Section(sectionName, startTime, startTick)
                    {
                        TickLength = endTick - startTick,
                        TimeLength = endTime - startTime,
                    };

                    Sections.Add(section);

                    // Set the start of the next section to the end of this one
                    startTick = endTick;
                    startTime = endTime;
                }
            }
            else
            {
                // Otherwise make sure the length of the last section is correct
                var lastSection = Sections[^1];
                lastSection.TickLength = lastTick - lastSection.Tick;
                lastSection.TimeLength = SyncTrack.TickToTime(lastTick) - lastSection.Time;
            }
        }

        private void FixDrumPhraseEnds()
        {
            foreach (var drumTrack in new List<InstrumentTrack<DrumNote>> { ProDrums, FiveLaneDrums, FourLaneDrums })
            {
                FixDrumPhraseEnds(drumTrack, n => n.IsSoloEnd, NoteFlags.SoloEnd);
                FixDrumPhraseEnds(drumTrack, n => n.IsStarPowerEnd, NoteFlags.StarPowerEnd);
            }
        }

        private static void FixDrumPhraseEnds(InstrumentTrack<DrumNote> drumTrack, Predicate<DrumNote> isPhraseEnd,
            NoteFlags phraseEndFlag)
        {
            if (!drumTrack.TryGetDifficulty(Difficulty.ExpertPlus, out var trackExpertPlus))
            {
                return;
            }

            if (!drumTrack.TryGetDifficulty(Difficulty.Expert, out var trackExpert))
            {
                return;
            }

            var notesExpertPlus = trackExpertPlus.Notes;
            var notesExpert = trackExpert.Notes;

            var phraseEndsExpertPlus = notesExpertPlus
                .Where(n => isPhraseEnd(n)).ToArray();
            var phraseEndsExpert = notesExpert
                .Where(n => isPhraseEnd(n)).ToArray();

            if (phraseEndsExpertPlus.Length <= phraseEndsExpert.Length)
            {
                return;
            }

            var i = 1;
            foreach (var phraseEndExpertPlus in phraseEndsExpertPlus)
            {
                while (i < notesExpert.Count && notesExpert[i].Tick <= phraseEndExpertPlus.Tick)
                {
                    i++;
                }

                var phraseEndExpert = notesExpert[i - 1];
                if (!isPhraseEnd(phraseEndExpert))
                {
                    phraseEndExpert.ActivateFlag(phraseEndFlag);
                }
            }
        }

        private void CreateDrumActivationPhrases()
        {
            var newActivationPhrases = new List<Phrase>();
            bool chartNeedsActivationPhrases = true;
            bool chartWasParsed = false;

            foreach (var drumTrack in new List<InstrumentTrack<DrumNote>> { ProDrums, FiveLaneDrums, FourLaneDrums })
            {
                var allPossibleDifficulties = Enum.GetValues(typeof(Difficulty));

                if (!chartWasParsed)
                {
                    // Prioritize denser charts for parsing
                    Array.Reverse(allPossibleDifficulties);
                }

                foreach (Difficulty difficultyType in allPossibleDifficulties)
                {
                    if (drumTrack.TryGetDifficulty(difficultyType, out var thisDifficultyTrack))
                    {
                        if (thisDifficultyTrack.IsEmpty)
                        {
                            // Difficulty exists but contains no data, ignore
                            continue;
                        }

                        if (!chartWasParsed)
                        {
                            // This is the first difficulty found with drum chart data
                            // Parse once and apply generated phrases to all difficulties
                            ParseForActivationPhrases(thisDifficultyTrack, newActivationPhrases);
                            chartWasParsed = true;

                            if (newActivationPhrases.Count == 0)
                            {
                                // No new activation phrases were added after parsing the chart
                                // Assume that no other difficulties will need this either
                                chartNeedsActivationPhrases = false;
                                break;
                            }
                        }

                        ApplyDrumActivationPhrases(thisDifficultyTrack, newActivationPhrases);
                    }
                }

                if (!chartNeedsActivationPhrases)
                {
                    break;
                }
            }
        }

        private void ParseForActivationPhrases(InstrumentDifficulty<DrumNote> diffChart, List<Phrase> newActivationPhrases)
        {
            var starPowerPhrases = new List<Phrase>();
            var soloPhrases = new List<Phrase>();

            foreach (var thisPhrase in diffChart.Phrases)
            {
                switch (thisPhrase.Type)
                {
                    case PhraseType.DrumFill:
                        // Assume that any drum chart with manually placed fill phrases will have enough. Stop here
                        YargLogger.LogDebug("Prevented generating Activation phrases for a Drum chart that already has them");
                        return;

                    case PhraseType.StarPower:
                        starPowerPhrases.Add(thisPhrase);
                        break;

                    case PhraseType.Solo:
                        soloPhrases.Add(thisPhrase);
                        break;
                }
            }

            // Activation cannot occur before the player has enough SP to activate
            if (starPowerPhrases.Count == 0)
            {
                YargLogger.LogDebug("Cannot generate Activation phrases for Drum chart. Not enough Star Power phrases available.");
                return;
            }

            // Limits for placing activation phrases (in seconds)
            const float MIN_SPACING_TIME = 2;
            const float MAX_SPACING_TIME = 10;

            // Update this time to the latest SP/Solo/Activation phrase encountered for comparison with the above constants
            // Start parsing after the end of the 1st SP phrase
            double spacingRefTime = starPowerPhrases[0].TimeEnd;
            int currentSPPhraseIndex = 0;

            // Align activation phrases with measure boundaries that have already been evaluated
            var measureBeatLines = SyncTrack.Beatlines.Where(x => x.Type == BeatlineType.Measure).ToList();

            int currentMeasureIndex = measureBeatLines.GetIndexOfPrevious(spacingRefTime);
            int totalMeasures = measureBeatLines.Count;

            // Prefer section boundaries and time signature changes for activation placement when possible
            int currentSectionIndex = Sections.GetIndexOfPrevious(spacingRefTime);

            var timeSigChanges = SyncTrack.TimeSignatures;
            int currentTimeSigIndex = timeSigChanges.GetIndexOfPrevious(spacingRefTime);

            // Do not place activation phrases inside of solo phrases
            int currentSoloIndex = soloPhrases.GetIndexOfPrevious(spacingRefTime);
            uint lastSoloTick = soloPhrases.GetLastTick();

            while (currentMeasureIndex < totalMeasures - 4)
            {
                // Try to move forward 4 measures
                int measuresPerActivator = 4;

                // If that is too long of a wait at the current tempo/time signature do 2 measures instead
                if (measureBeatLines[currentMeasureIndex + measuresPerActivator].Time - spacingRefTime > MAX_SPACING_TIME)
                {
                    measuresPerActivator = 2;
                }

                currentMeasureIndex += measuresPerActivator;

                var currentMeasureLine = measureBeatLines[currentMeasureIndex];

                int newSectionIndex = Sections.GetIndexOfPrevious(currentMeasureLine.Tick);
                if (newSectionIndex > currentSectionIndex)
                {
                    // Moved forward into a new section
                    currentSectionIndex = newSectionIndex;
                    var currentSection = Sections[currentSectionIndex];

                    //move the activation point to the start of this section
                    currentMeasureIndex = measureBeatLines.GetIndexOfPrevious(currentSection.Tick);
                    currentMeasureLine = measureBeatLines[currentMeasureIndex];
                }
                else
                {
                    // Still in the same section (or no sections exist), look for a time signature change
                    int newTimeSigIndex = timeSigChanges.GetIndexOfPrevious(currentMeasureLine.Tick);
                    if (newTimeSigIndex > currentTimeSigIndex)
                    {
                        // Moved forward into a new time signature
                        currentTimeSigIndex = newTimeSigIndex;
                        var currentTimeSig = timeSigChanges[currentTimeSigIndex];

                        //move the activation point to the start of this time signature
                        currentMeasureIndex = measureBeatLines.GetIndexOfPrevious(currentTimeSig.Tick);
                        currentMeasureLine = measureBeatLines[currentMeasureIndex];
                    }
                }

                uint currentMeasureTick = currentMeasureLine.Tick;

                int newSPPhraseIndex = starPowerPhrases.GetIndexOfPrevious(currentMeasureTick);
                if (newSPPhraseIndex > currentSPPhraseIndex)
                {
                    // New SP phrase encountered. Update reference time to the end of this SP phrase
                    // To keep the next activation phrase from appearing too close
                    currentSPPhraseIndex = newSPPhraseIndex;
                    spacingRefTime = Math.Max(starPowerPhrases[currentSPPhraseIndex].TimeEnd, spacingRefTime);
                }

                // Prevent placing an activation phrase here if it overlaps with a solo section
                if (soloPhrases.Count > 0 && currentMeasureTick < lastSoloTick)
                {
                    int newSoloIndex = soloPhrases.GetIndexOfPrevious(currentMeasureTick);

                    if (newSoloIndex > currentSoloIndex)
                    {
                        // Moved forward into a new solo
                        currentSoloIndex = newSoloIndex;
                        spacingRefTime = Math.Max(soloPhrases[currentSoloIndex].TimeEnd, spacingRefTime);
                    }
                }

                // This measure line is inside of or too close to an SP, solo, or activation phrase
                double currentMeasureTime = currentMeasureLine.Time;
                if (currentMeasureTime - spacingRefTime < MIN_SPACING_TIME)
                {
                    continue;
                }

                // Do not put an activation phrase here if there aren't enough notes to hit after activating SP
                const uint SP_MIN_NOTES = 16;
                int starPowerEndMeasureIndex = Math.Min(currentMeasureIndex + 4, totalMeasures - 1);
                uint starPowerEndTick = measureBeatLines[starPowerEndMeasureIndex].Tick;

                int totalNotesForStarPower = 0;
                var testNote = diffChart.Notes.GetNext(currentMeasureTick);
                while (totalNotesForStarPower < SP_MIN_NOTES && testNote != null && testNote.Tick <= starPowerEndTick)
                {
                    totalNotesForStarPower += testNote.ChildNotes.Count + 1;
                    testNote = testNote.NextNote;
                }

                if (totalNotesForStarPower < SP_MIN_NOTES)
                {
                    continue;
                }

                // This is a good place to put an Activation phrase
                spacingRefTime = currentMeasureLine.Time;

                // Mark the start of a drum fill phrase one measure before this bar line
                var previousMeasureLine = measureBeatLines[currentMeasureIndex - 1];
                double fillPhraseStartTime = previousMeasureLine.Time;
                uint fillPhraseStartTick = previousMeasureLine.Tick;

                var newDrumFillPhrase = new Phrase(
                    PhraseType.DrumFill,
                    fillPhraseStartTime,
                    currentMeasureTime - fillPhraseStartTime,
                    fillPhraseStartTick,
                    currentMeasureTick - fillPhraseStartTick
                );

                newActivationPhrases.Add(newDrumFillPhrase);
                YargLogger.LogFormatDebug("Generated a Drums SP Activation phrase from tick {0} to {1}", fillPhraseStartTick, newDrumFillPhrase.TickEnd);
            }
        }

        private void ApplyDrumActivationPhrases(InstrumentDifficulty<DrumNote> diffChart, List<Phrase> newActivationPhrases)
        {
            var allNotes = diffChart.Notes;
            uint lastNoteTick = allNotes.GetLastTick();

            foreach (var newPhrase in newActivationPhrases)
            {
                uint barLineTick = newPhrase.TickEnd;

                if (barLineTick > lastNoteTick)
                {
                    // Reached the end of this chart
                    return;
                }

                // Attempt to retrieve an activation note directly on the bar line
                var activationNote = allNotes.GetNext(barLineTick - 1);

                bool searchForAltNote = false;

                if (activationNote != null && activationNote.Tick == barLineTick)
                {
                    if (!IsIdealDrumActivationNote(activationNote, diffChart.Instrument, diffChart.Difficulty))
                    {
                        searchForAltNote = true;
                    }
                }
                else
                {
                    searchForAltNote = true;
                    activationNote = null;
                }

                if (searchForAltNote)
                {
                    // Allow a window of +/- an eighth note for syncopated activator notes
                    uint eighthNoteTickLength = newPhrase.TickLength / 8;

                    var testNote = allNotes.GetNext(barLineTick - eighthNoteTickLength - 1);
                    while (testNote != null && testNote.Tick <= barLineTick + eighthNoteTickLength)
                    {
                        if (activationNote == null)
                        {
                            activationNote = testNote;
                        }

                        if (IsIdealDrumActivationNote(testNote, diffChart.Instrument, diffChart.Difficulty))
                        {
                            activationNote = testNote;
                            break;
                        }

                        testNote = testNote.NextNote;
                    }
                }

                if (activationNote == null)
                {
                    // There are no notes in the syncopation window for this phrase
                    // Do not add to this difficulty
                    continue;
                }

                // Add the activator flag to all notes in this chord
                foreach (var note in activationNote.AllNotes)
                {
                    note.ActivateFlag(DrumNoteFlags.StarPowerActivator);
                }

                uint activationTick = activationNote.Tick;

                var phraseToApply = new Phrase(newPhrase);
                if (activationTick != barLineTick)
                {
                    // Adjust phrase length to line up with the selected activation note
                    phraseToApply.TickLength = activationTick - phraseToApply.Tick;
                    phraseToApply.TimeLength = activationNote.Time - phraseToApply.Time;
                }

                int newPhraseIndex = diffChart.Phrases.GetIndexOfNext(phraseToApply.Tick);

                if (newPhraseIndex != -1)
                {
                    // Insert new activation phrase at the appopriate index
                    diffChart.Phrases.Insert(newPhraseIndex, phraseToApply);
                }
                else
                {
                    // Add new phrase to the end of the list
                    diffChart.Phrases.Add(phraseToApply);
                }
            }
        }

        private static bool IsIdealDrumActivationNote(DrumNote note, Instrument instrument, Difficulty difficulty)
        {
            // Ignore this check on Easy/Beginner where chords are sparse
            if (difficulty < Difficulty.Medium)
            {
                return true;
            }

            bool containsCrash = false;
            bool containsKick = false;
            bool containsSnare = false;

            foreach (var childNote in note.AllNotes)
            {
                var thisPad = childNote.Pad;
                if (instrument == Instrument.FiveLaneDrums)
                {
                    containsCrash |= thisPad == (int) FiveLaneDrumPad.Orange;
                    containsKick |= thisPad == (int) FiveLaneDrumPad.Kick;
                    containsSnare |= thisPad == (int) FiveLaneDrumPad.Red;
                }
                else
                {
                    if (instrument == Instrument.FourLaneDrums)
                    {
                        containsCrash |= thisPad == (int) FourLaneDrumPad.GreenDrum;
                    }
                    else
                    {
                        containsCrash |= thisPad == (int) FourLaneDrumPad.GreenCymbal;
                    }

                    containsSnare |= thisPad == (int) FourLaneDrumPad.RedDrum;
                    containsKick |= thisPad == (int) FourLaneDrumPad.Kick;
                }
            }

            return containsCrash && (containsKick || containsSnare);
        }
    }
}
</file>

<file path="Chart/SongChart.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using Melanchall.DryWetMidi.Core;
using YARG.Core.Logging;
using YARG.Core.Parsing;

namespace YARG.Core.Chart
{
    /// <summary>
    /// The chart data for a song.
    /// </summary>
    public partial class SongChart
    {
        public uint Resolution => SyncTrack.Resolution;

        public List<TextEvent> GlobalEvents { get; set; } = new();
        public List<Section> Sections { get; set; } = new();

        public SyncTrack SyncTrack { get; set; }
        public VenueTrack VenueTrack { get; set; } = new();
        public LyricsTrack Lyrics { get; set; } = new();

        public InstrumentTrack<GuitarNote> FiveFretGuitar { get; set; } = new(Instrument.FiveFretGuitar);
        public InstrumentTrack<GuitarNote> FiveFretCoop { get; set; } = new(Instrument.FiveFretCoopGuitar);
        public InstrumentTrack<GuitarNote> FiveFretRhythm { get; set; } = new(Instrument.FiveFretRhythm);
        public InstrumentTrack<GuitarNote> FiveFretBass { get; set; } = new(Instrument.FiveFretBass);
        public InstrumentTrack<GuitarNote> Keys { get; set; } = new(Instrument.Keys);

        public IEnumerable<InstrumentTrack<GuitarNote>> FiveFretTracks
        {
            get
            {
                yield return FiveFretGuitar;
                yield return FiveFretCoop;
                yield return FiveFretRhythm;
                yield return FiveFretBass;
                yield return Keys;
            }
        }

        // Not supported yet
        public InstrumentTrack<GuitarNote> SixFretGuitar { get; set; } = new(Instrument.SixFretGuitar);
        public InstrumentTrack<GuitarNote> SixFretCoop { get; set; } = new(Instrument.SixFretCoopGuitar);
        public InstrumentTrack<GuitarNote> SixFretRhythm { get; set; } = new(Instrument.SixFretRhythm);
        public InstrumentTrack<GuitarNote> SixFretBass { get; set; } = new(Instrument.SixFretBass);

        public IEnumerable<InstrumentTrack<GuitarNote>> SixFretTracks
        {
            get
            {
                yield return SixFretGuitar;
                yield return SixFretCoop;
                yield return SixFretRhythm;
                yield return SixFretBass;
            }
        }

        public InstrumentTrack<DrumNote> FourLaneDrums { get; set; } = new(Instrument.FourLaneDrums);
        public InstrumentTrack<DrumNote> ProDrums { get; set; } = new(Instrument.ProDrums);
        public InstrumentTrack<DrumNote> FiveLaneDrums { get; set; } = new(Instrument.FiveLaneDrums);

        // public InstrumentTrack<DrumNote> EliteDrums { get; set; } = new(Instrument.EliteDrums);

        public IEnumerable<InstrumentTrack<DrumNote>> DrumsTracks
        {
            get
            {
                yield return FourLaneDrums;
                yield return ProDrums;
                yield return FiveLaneDrums;
            }
        }

        public InstrumentTrack<ProGuitarNote> ProGuitar_17Fret { get; set; } = new(Instrument.ProGuitar_17Fret);
        public InstrumentTrack<ProGuitarNote> ProGuitar_22Fret { get; set; } = new(Instrument.ProGuitar_22Fret);
        public InstrumentTrack<ProGuitarNote> ProBass_17Fret { get; set; } = new(Instrument.ProBass_17Fret);
        public InstrumentTrack<ProGuitarNote> ProBass_22Fret { get; set; } = new(Instrument.ProBass_22Fret);

        public IEnumerable<InstrumentTrack<ProGuitarNote>> ProGuitarTracks
        {
            get
            {
                yield return ProGuitar_17Fret;
                yield return ProGuitar_22Fret;
                yield return ProBass_17Fret;
                yield return ProBass_22Fret;
            }
        }

        public InstrumentTrack<ProKeysNote> ProKeys { get; set; } = new(Instrument.ProKeys);

        public VocalsTrack Vocals { get; set; } = new(Instrument.Vocals);
        public VocalsTrack Harmony { get; set; } = new(Instrument.Harmony);

        public IEnumerable<VocalsTrack> VocalsTracks
        {
            get
            {
                yield return Vocals;
                yield return Harmony;
            }
        }

        // public InstrumentTrack<DjNote> Dj { get; set; } = new(Instrument.Dj);

        // To explicitly allow creation without going through a file
        public SongChart(uint resolution)
        {
            SyncTrack = new(resolution);
        }

        internal SongChart(ISongLoader loader)
        {
            GlobalEvents = loader.LoadGlobalEvents();
            SyncTrack = loader.LoadSyncTrack();
            VenueTrack = loader.LoadVenueTrack();
            Sections = loader.LoadSections();
            Lyrics = loader.LoadLyrics();

            FiveFretGuitar = loader.LoadGuitarTrack(Instrument.FiveFretGuitar);
            FiveFretCoop = loader.LoadGuitarTrack(Instrument.FiveFretCoopGuitar);
            FiveFretRhythm = loader.LoadGuitarTrack(Instrument.FiveFretRhythm);
            FiveFretBass = loader.LoadGuitarTrack(Instrument.FiveFretBass);
            Keys = loader.LoadGuitarTrack(Instrument.Keys);

            SixFretGuitar = loader.LoadGuitarTrack(Instrument.SixFretGuitar);
            SixFretCoop = loader.LoadGuitarTrack(Instrument.SixFretCoopGuitar);
            SixFretRhythm = loader.LoadGuitarTrack(Instrument.SixFretRhythm);
            SixFretBass = loader.LoadGuitarTrack(Instrument.SixFretBass);

            FourLaneDrums = loader.LoadDrumsTrack(Instrument.FourLaneDrums);
            ProDrums = loader.LoadDrumsTrack(Instrument.ProDrums);
            FiveLaneDrums = loader.LoadDrumsTrack(Instrument.FiveLaneDrums);

            // EliteDrums = loader.LoadDrumsTrack(Instrument.EliteDrums);

            ProGuitar_17Fret = loader.LoadProGuitarTrack(Instrument.ProGuitar_17Fret);
            ProGuitar_22Fret = loader.LoadProGuitarTrack(Instrument.ProGuitar_22Fret);
            ProBass_17Fret = loader.LoadProGuitarTrack(Instrument.ProBass_17Fret);
            ProBass_22Fret = loader.LoadProGuitarTrack(Instrument.ProBass_22Fret);

            ProKeys = loader.LoadProKeysTrack(Instrument.ProKeys);

            Vocals = loader.LoadVocalsTrack(Instrument.Vocals);
            Harmony = loader.LoadVocalsTrack(Instrument.Harmony);

            // Dj = loader.LoadDjTrack(Instrument.Dj);

            // Ensure beatlines are present
            if (SyncTrack.Beatlines is null or { Count: < 1 })
            {
                SyncTrack.GenerateBeatlines(GetLastTick());
            }

            // Use beatlines to place auto-generated drum activation phrases for charts without manually authored phrases
            CreateDrumActivationPhrases();

            PostProcessSections();
            FixDrumPhraseEnds();
        }

        public void Append(SongChart song)
        {
            if (!song.FiveFretGuitar.IsEmpty)
                FiveFretGuitar = song.FiveFretGuitar;

            if (!song.FiveFretCoop.IsEmpty)
                FiveFretCoop = song.FiveFretCoop;

            if (!song.FiveFretRhythm.IsEmpty)
                FiveFretRhythm = song.FiveFretRhythm;

            if (!song.FiveFretBass.IsEmpty)
                FiveFretBass = song.FiveFretBass;

            if (!song.Keys.IsEmpty)
                Keys = song.Keys;

            if (!song.SixFretGuitar.IsEmpty)
                SixFretGuitar = song.SixFretGuitar;

            if (!song.SixFretCoop.IsEmpty)
                SixFretCoop = song.SixFretCoop;

            if (!song.SixFretRhythm.IsEmpty)
                SixFretRhythm = song.SixFretRhythm;

            if (!song.SixFretBass.IsEmpty)
                SixFretBass = song.SixFretBass;

            if (!song.FourLaneDrums.IsEmpty)
                FourLaneDrums = song.FourLaneDrums;

            if (!song.ProDrums.IsEmpty)
                ProDrums = song.ProDrums;

            if (!song.FiveLaneDrums.IsEmpty)
                FiveLaneDrums = song.FiveLaneDrums;

            if (!song.ProGuitar_17Fret.IsEmpty)
                ProGuitar_17Fret = song.ProGuitar_17Fret;

            if (!song.ProGuitar_22Fret.IsEmpty)
                ProGuitar_22Fret = song.ProGuitar_22Fret;

            if (!song.ProBass_17Fret.IsEmpty)
                ProBass_17Fret = song.ProBass_17Fret;

            if (!song.ProBass_22Fret.IsEmpty)
                ProBass_22Fret = song.ProBass_22Fret;

            if (!song.ProKeys.IsEmpty)
                ProKeys = song.ProKeys;

            if (!song.Vocals.IsEmpty)
                Vocals = song.Vocals;

            if (!song.Harmony.IsEmpty)
                Harmony = song.Harmony;
        }

        public static SongChart FromFile(in ParseSettings settings, string filePath)
        {
            var loader = MoonSongLoader.LoadSong(settings, filePath);
            return new(loader);
        }

        public static SongChart FromMidi(in ParseSettings settings, MidiFile midi)
        {
            var loader = MoonSongLoader.LoadMidi(settings, midi);
            return new(loader);
        }

        public static SongChart FromDotChart(in ParseSettings settings, ReadOnlySpan<char> chartText)
        {
            var loader = MoonSongLoader.LoadDotChart(settings, chartText);
            return new(loader);
        }

        public InstrumentTrack<GuitarNote> GetFiveFretTrack(Instrument instrument)
        {
            return instrument switch
            {
                Instrument.FiveFretGuitar => FiveFretGuitar,
                Instrument.FiveFretCoopGuitar => FiveFretCoop,
                Instrument.FiveFretRhythm => FiveFretRhythm,
                Instrument.FiveFretBass => FiveFretBass,
                Instrument.Keys => Keys,
                _ => throw new ArgumentException($"Instrument {instrument} is not a 5-fret guitar instrument!")
            };
        }

        public InstrumentTrack<GuitarNote> GetSixFretTrack(Instrument instrument)
        {
            return instrument switch
            {
                Instrument.SixFretGuitar => SixFretGuitar,
                Instrument.SixFretCoopGuitar => SixFretCoop,
                Instrument.SixFretRhythm => SixFretRhythm,
                Instrument.SixFretBass => SixFretBass,
                _ => throw new ArgumentException($"Instrument {instrument} is not a 6-fret guitar instrument!")
            };
        }

        public InstrumentTrack<DrumNote> GetDrumsTrack(Instrument instrument)
        {
            return instrument switch
            {
                Instrument.FourLaneDrums => FourLaneDrums,
                Instrument.ProDrums => ProDrums,
                Instrument.FiveLaneDrums => FiveLaneDrums,
                _ => throw new ArgumentException($"Instrument {instrument} is not a drums instrument!")
            };
        }

        public InstrumentTrack<ProGuitarNote> GetProGuitarTrack(Instrument instrument)
        {
            return instrument switch
            {
                Instrument.ProGuitar_17Fret => ProGuitar_17Fret,
                Instrument.ProGuitar_22Fret => ProGuitar_22Fret,
                Instrument.ProBass_17Fret => ProBass_17Fret,
                Instrument.ProBass_22Fret => ProBass_22Fret,
                _ => throw new ArgumentException($"Instrument {instrument} is not a Pro Guitar instrument!")
            };
        }

        public VocalsTrack GetVocalsTrack(Instrument instrument)
        {
            return instrument switch
            {
                Instrument.Vocals => Vocals,
                Instrument.Harmony => Harmony,
                _ => throw new ArgumentException($"Instrument {instrument} is not a vocals instrument!")
            };
        }

        public double GetStartTime()
        {
            static double TrackMin<TNote>(IEnumerable<InstrumentTrack<TNote>> tracks) where TNote : Note<TNote>
                => tracks.Min((track) => track.GetStartTime());
            static double VoxMin(IEnumerable<VocalsTrack> tracks)
                => tracks.Min((track) => track.GetStartTime());

            double totalStartTime = 0;

            // Tracks

            totalStartTime = Math.Min(TrackMin(FiveFretTracks), totalStartTime);
            totalStartTime = Math.Min(TrackMin(SixFretTracks), totalStartTime);
            totalStartTime = Math.Min(TrackMin(DrumsTracks), totalStartTime);
            totalStartTime = Math.Min(TrackMin(ProGuitarTracks), totalStartTime);

            totalStartTime = Math.Min(ProKeys.GetStartTime(), totalStartTime);

            totalStartTime = Math.Min(VoxMin(VocalsTracks), totalStartTime);

            // Global

            totalStartTime = Math.Min(Lyrics.GetStartTime(), totalStartTime);

            // Deliberately excluded, as they're not major contributors to the chart bounds
            // totalStartTime = Math.Min(GlobalEvents.GetStartTime(), totalStartTime);
            // totalStartTime = Math.Min(Sections.GetStartTime(), totalStartTime);
            // totalStartTime = Math.Min(SyncTrack.GetStartTime(), totalStartTime);
            // totalStartTime = Math.Min(VenueTrack.GetStartTime(), totalStartTime);

            return totalStartTime;
        }

        public double GetEndTime()
        {
            static double TrackMax<TNote>(IEnumerable<InstrumentTrack<TNote>> tracks) where TNote : Note<TNote>
                => tracks.Max((track) => track.GetEndTime());
            static double VoxMax(IEnumerable<VocalsTrack> tracks)
                => tracks.Max((track) => track.GetEndTime());

            double totalEndTime = 0;

            // Tracks

            totalEndTime = Math.Max(TrackMax(FiveFretTracks), totalEndTime);
            totalEndTime = Math.Max(TrackMax(SixFretTracks), totalEndTime);
            totalEndTime = Math.Max(TrackMax(DrumsTracks), totalEndTime);
            totalEndTime = Math.Max(TrackMax(ProGuitarTracks), totalEndTime);

            totalEndTime = Math.Max(ProKeys.GetEndTime(), totalEndTime);

            totalEndTime = Math.Max(VoxMax(VocalsTracks), totalEndTime);

            // Global

            totalEndTime = Math.Max(Lyrics.GetEndTime(), totalEndTime);

            // Deliberately excluded, as they're not major contributors to the chart bounds
            // totalEndTime = Math.Max(GlobalEvents.GetEndTime(), totalEndTime);
            // totalEndTime = Math.Max(Sections.GetEndTime(), totalEndTime);
            // totalEndTime = Math.Max(SyncTrack.GetEndTime(), totalEndTime);
            // totalEndTime = Math.Max(VenueTrack.GetEndTime(), totalEndTime);

            return totalEndTime;
        }

        public uint GetFirstTick()
        {
            static uint TrackMin<TNote>(IEnumerable<InstrumentTrack<TNote>> tracks) where TNote : Note<TNote>
                => tracks.Min((track) => track.GetFirstTick());
            static uint VoxMin(IEnumerable<VocalsTrack> tracks)
                => tracks.Min((track) => track.GetFirstTick());

            uint totalFirstTick = 0;

            // Tracks

            totalFirstTick = Math.Min(TrackMin(FiveFretTracks), totalFirstTick);
            totalFirstTick = Math.Min(TrackMin(SixFretTracks), totalFirstTick);
            totalFirstTick = Math.Min(TrackMin(DrumsTracks), totalFirstTick);
            totalFirstTick = Math.Min(TrackMin(ProGuitarTracks), totalFirstTick);

            totalFirstTick = Math.Min(ProKeys.GetFirstTick(), totalFirstTick);

            totalFirstTick = Math.Min(VoxMin(VocalsTracks), totalFirstTick);

            // Global

            totalFirstTick = Math.Min(Lyrics.GetFirstTick(), totalFirstTick);

            // Deliberately excluded, as they're not major contributors to the chart bounds
            // totalFirstTick = Math.Min(GlobalEvents.GetFirstTick(), totalFirstTick);
            // totalFirstTick = Math.Min(Sections.GetFirstTick(), totalFirstTick);
            // totalFirstTick = Math.Min(SyncTrack.GetFirstTick(), totalFirstTick);
            // totalFirstTick = Math.Min(VenueTrack.GetFirstTick(), totalFirstTick);

            return totalFirstTick;
        }

        public uint GetLastTick()
        {
            static uint TrackMax<TNote>(IEnumerable<InstrumentTrack<TNote>> tracks) where TNote : Note<TNote>
                => tracks.Max((track) => track.GetLastTick());
            static uint VoxMax(IEnumerable<VocalsTrack> tracks)
                => tracks.Max((track) => track.GetLastTick());

            uint totalLastTick = 0;

            // Tracks

            totalLastTick = Math.Max(TrackMax(FiveFretTracks), totalLastTick);
            totalLastTick = Math.Max(TrackMax(SixFretTracks), totalLastTick);
            totalLastTick = Math.Max(TrackMax(DrumsTracks), totalLastTick);
            totalLastTick = Math.Max(TrackMax(ProGuitarTracks), totalLastTick);

            totalLastTick = Math.Max(ProKeys.GetLastTick(), totalLastTick);

            totalLastTick = Math.Max(VoxMax(VocalsTracks), totalLastTick);

            // Global

            totalLastTick = Math.Max(Lyrics.GetLastTick(), totalLastTick);

            // Deliberately excluded, as they're not major contributors to the chart bounds
            // totalLastTick = Math.Max(GlobalEvents.GetLastTick(), totalLastTick);
            // totalLastTick = Math.Max(Sections.GetLastTick(), totalLastTick);
            // totalLastTick = Math.Max(SyncTrack.GetLastTick(), totalLastTick);
            // totalLastTick = Math.Max(VenueTrack.GetLastTick(), totalLastTick);

            return totalLastTick;
        }

        public TextEvent? GetEndEvent()
        {
            // Reverse-search through a limited amount of events
            for (int i = 1; i <= 10; i++)
            {
                int index = GlobalEvents.Count - i;
                if (index < 0)
                    break;

                var text = GlobalEvents[index];
                if (text.Text == TextEvents.END_MARKER)
                    return text;
            }

            return null;
        }
    }
}
</file>

<file path="Chart/TEMP_parsing_todos.txt">
Detect unison phrases
Venue [verse] and [chorus] events need to have corresponding [lighting ()] events ignored
Venue post-procesing note conversions may need to be tweaked
CON song updates/upgrades
CON MILO event parsing
</file>

<file path="Engine/Drums/Engines/YargDrumsEngine.cs">
using System;
using YARG.Core.Chart;
using YARG.Core.Input;
using YARG.Core.Logging;

namespace YARG.Core.Engine.Drums.Engines
{
    public class YargDrumsEngine : DrumsEngine
    {
        public YargDrumsEngine(InstrumentDifficulty<DrumNote> chart, SyncTrack syncTrack,
            DrumsEngineParameters engineParameters, bool isBot)
            : base(chart, syncTrack, engineParameters, isBot)
        {
        }

        protected override void MutateStateWithInput(GameInput gameInput)
        {
            // Do not use gameInput.Button here!
            // Drum inputs are handled as axes, not buttons, for velocity support.
            // Every button release has its gameInput.Axis set to 0, so this works safely.
            if (gameInput.Axis > 0)
            {
                Action = gameInput.GetAction<DrumsAction>();
                PadHit = ConvertInputToPad(EngineParameters.Mode, gameInput.GetAction<DrumsAction>());
                HitVelocity = gameInput.Axis;
            }
        }

        protected override void UpdateHitLogic(double time)
        {
            UpdateStarPower();

            // Update bot (will return if not enabled)
            UpdateBot(time);

            // Only check hit if there are notes left
            if (NoteIndex < Notes.Count)
            {
                CheckForNoteHit();
            }
            else if (Action is { } padAction)
            {
                OnPadHit?.Invoke(padAction, false, HitVelocity.GetValueOrDefault(0));
                ResetPadState();
            }
        }

        protected override void CheckForNoteHit()
        {
            for (int i = NoteIndex; i < Notes.Count; i++)
            {
                bool isFirstNoteInWindow = i == NoteIndex;
                bool stopSkipping = false;

                var parentNote = Notes[i];

                // For drums, each note in the chord are treated separately
                foreach (var note in parentNote.AllNotes)
                {
                    // Miss out the back end
                    if (!IsNoteInWindow(note, out bool missed))
                    {
                        if (isFirstNoteInWindow && missed)
                        {
                            // If one of the notes in the chord was missed out the back end,
                            // that means all of them would miss.
                            foreach (var missedNote in parentNote.AllNotes)
                            {
                                // Allow drummers to skip SP activation notes without being penalized.
                                if (missedNote.IsStarPowerActivator && CanStarPowerActivate)
                                {
                                    HitNote(missedNote, true);
                                    continue;
                                }
                                MissNote(missedNote);
                            }
                        }

                        // You can't skip ahead if the note is not in the hit window to begin with
                        stopSkipping = true;
                        break;
                    }

                    // Hit note
                    if (CanNoteBeHit(note))
                    {
                        bool awardVelocityBonus = ApplyVelocity(note);

                        // TODO - Deadly Dynamics modifier check on awardVelocityBonus

                        HitNote(note);
                        OnPadHit?.Invoke(Action!.Value, true, HitVelocity.GetValueOrDefault(0));

                        if (awardVelocityBonus)
                        {
                            const int velocityBonus = POINTS_PER_NOTE / 2;
                            AddScore(velocityBonus);
                            YargLogger.LogFormatTrace("Velocity bonus of {0} points was awarded to a note at tick {1}.", velocityBonus, note.Tick);
                        }

                        ResetPadState();

                        // You can't hit more than one note with the same input
                        stopSkipping = true;
                        break;
                    }
                    else
                    {
                        //YargLogger.LogFormatDebug("Cant hit note (Index: {0}) at {1}.", i, CurrentTime);
                    }
                }

                if (stopSkipping)
                {
                    break;
                }
            }

            // If no note was hit but the user hit a pad, then over hit
            if (PadHit != null)
            {
                OnPadHit?.Invoke(Action!.Value, false, HitVelocity.GetValueOrDefault(0));
                Overhit();
                ResetPadState();
            }
        }

        protected override bool CanNoteBeHit(DrumNote note)
        {
            return note.Pad == PadHit;
        }

        protected override void UpdateBot(double time)
        {
            if (!IsBot || NoteIndex >= Notes.Count)
            {
                return;
            }

            var note = Notes[NoteIndex];

            if (time < note.Time)
            {
                return;
            }

            // Each note in the "chord" is hit separately on drums
            foreach (var chordNote in note.AllNotes)
            {
                Action = ConvertPadToAction(EngineParameters.Mode, chordNote.Pad);
                PadHit = chordNote.Pad;
                CheckForNoteHit();
            }
        }

        private void ResetPadState()
        {
            Action = null;
            PadHit = null;
            HitVelocity = null;
        }
    }
}
</file>

<file path="Engine/Drums/DrumsEngine.cs">
using System;
using YARG.Core.Chart;
using YARG.Core.Input;
using YARG.Core.Logging;

namespace YARG.Core.Engine.Drums
{
    public abstract class DrumsEngine : BaseEngine<DrumNote, DrumsEngineParameters,
        DrumsStats>
    {
        public delegate void OverhitEvent();

        public delegate void PadHitEvent(DrumsAction action, bool noteWasHit, float velocity);

        public OverhitEvent? OnOverhit;
        public PadHitEvent?  OnPadHit;

        /// <summary>
        /// The integer value for the pad that was inputted this update. <c>null</c> is none, and the value can
        /// be based off of <see cref="FourLaneDrumPad"/> or <see cref="FiveLaneDrumPad"/>.
        /// </summary>
        protected int? PadHit;

        protected float? HitVelocity;

        protected DrumsAction? Action;

        protected DrumsEngine(InstrumentDifficulty<DrumNote> chart, SyncTrack syncTrack,
            DrumsEngineParameters engineParameters, bool isBot)
            : base(chart, syncTrack, engineParameters, true, isBot)
        {
            GetWaitCountdowns(Notes);
        }

        public override void Reset(bool keepCurrentButtons = false)
        {
            PadHit = null;
            HitVelocity = null;
            Action = null;

            base.Reset(keepCurrentButtons);
        }

        public virtual void Overhit()
        {
            // Can't overhit before first note is hit/missed
            if (NoteIndex == 0)
            {
                return;
            }

            // Cancel overhit if past last note
            if (NoteIndex >= Chart.Notes.Count - 1)
            {
                return;
            }

            // Cancel overhit if WaitCountdown is active
            if (IsWaitCountdownActive)
            {
                YargLogger.LogFormatTrace("Overhit prevented during WaitCountdown at time: {0}, tick: {1}",
                    CurrentTime, CurrentTick);
                return;
            }

            if (NoteIndex < Notes.Count)
            {
                // Don't remove the phrase if the current note being overstrummed is the start of a phrase
                if (!Notes[NoteIndex].IsStarPowerStart)
                {
                    StripStarPower(Notes[NoteIndex]);
                }
            }

            ResetCombo();
            EngineStats.Overhits++;

            UpdateMultiplier();

            OnOverhit?.Invoke();
        }

        protected override void HitNote(DrumNote note)
        {
            HitNote(note, false);
        }

        protected void HitNote(DrumNote note, bool activationAutoHit)
        {
            if (note.WasHit || note.WasMissed)
            {
                YargLogger.LogFormatTrace("Tried to hit/miss note twice (Pad: {0}, Index: {1}, Hit: {2}, Missed: {3})",
                    note.Pad, NoteIndex, note.WasHit, note.WasMissed);
                return;
            }

            note.SetHitState(true, false);

            // Detect if the last note(s) were skipped
            bool skipped = SkipPreviousNotes(note.ParentOrSelf);

            // Make sure that the note is fully hit, so the last hit note awards the starpower.
            if (note.IsStarPower && note.IsStarPowerEnd && note.ParentOrSelf.WasFullyHit())
            {
                AwardStarPower(note);
                EngineStats.StarPowerPhrasesHit++;
            }

            if (note.IsSoloStart)
            {
                StartSolo();
            }

            if (IsSoloActive)
            {
                Solos[CurrentSoloIndex].NotesHit++;
            }

            if (note.IsSoloEnd && note.ParentOrSelf.WasFullyHitOrMissed())
            {
                EndSolo();
            }

            if (!activationAutoHit && note.IsStarPowerActivator && CanStarPowerActivate &&
                note.ParentOrSelf.WasFullyHit())
            {
                ActivateStarPower();
            }

            IncrementCombo();

            EngineStats.NotesHit++;

            UpdateMultiplier();

            AddScore(note);

            // If it's an auto hit, act as if it *wasn't* hit visually.
            // Score and such is accounted for above.
            if (!activationAutoHit)
            {
                OnNoteHit?.Invoke(NoteIndex, note);
            }

            base.HitNote(note);
        }

        protected bool ApplyVelocity(DrumNote hitNote)
        {
            // Neutral notes cannot award bonus points here
            if (hitNote.IsNeutral) return false;

            // Bots will always hit at a velocity of 1, just give them the bonus
            if (IsBot) return true;

            // Hit velocity was not recorded for this note, bonus will always be false
            if (HitVelocity is not { } lastInputVelocity) return false;

            hitNote.HitVelocity = lastInputVelocity;

            // Apply bonus points from successful ghost / accent note hits
            float awardThreshold = EngineParameters.VelocityThreshold;
            float situationalVelocityWindow = EngineParameters.SituationalVelocityWindow;

            var compareNote = hitNote.PreviousNote;

            while (compareNote != null)
            {
                if (hitNote.Time - compareNote.Time > situationalVelocityWindow)
                {
                    // This note is too far in the past to consider for comparison, stop searching
                    compareNote = null;
                    break;
                }

                if (compareNote.HitVelocity != null && compareNote.Pad == hitNote.Pad)
                {
                    // Comparison note is assigned to the same pad and has stored velocity data
                    // Stop searching and use this note for comparison
                    break;
                }

                compareNote = compareNote.PreviousNote;
            }

            if (compareNote != null)
            {
                //compare this note's velocity against the velocity recorded for the last note
                float? relativeVelocityThreshold;

                if (compareNote.Type == hitNote.Type)
                {
                    // Comparison note is the same ghost/accent type as this note
                    // If this note was awarded a velocity bonus, allow multiple consecutive hits at the previous velocity
                    relativeVelocityThreshold = compareNote.HitVelocity;
                }
                else
                {
                    // Comparison note is not of the same ghost/accent type as this note
                    // Award a velocity bonus if this note was hit with a delta value greater than the previous hit
                    relativeVelocityThreshold = compareNote.HitVelocity - awardThreshold;
                }

                awardThreshold = Math.Max(awardThreshold, relativeVelocityThreshold ?? 0);
            }

            bool awardVelocityBonus = false;

            if (hitNote.IsGhost)
            {
                awardVelocityBonus = lastInputVelocity < awardThreshold;
                YargLogger.LogFormatTrace("Ghost note was hit with a velocity of {0} at tick {1}. Bonus awarded: {2}",
                    lastInputVelocity, hitNote.Tick, awardVelocityBonus);
            }
            else if (hitNote.IsAccent)
            {
                awardVelocityBonus = lastInputVelocity > (1 - awardThreshold);
                YargLogger.LogFormatTrace("Accent note was hit with a velocity of {0} at tick {1}. Bonus awarded: {2}",
                    lastInputVelocity, hitNote.Tick, awardVelocityBonus);
            }

            return awardVelocityBonus;
        }

        protected override void MissNote(DrumNote note)
        {
            if (note.WasHit || note.WasMissed)
            {
                YargLogger.LogFormatTrace("Tried to hit/miss note twice (Pad: {0}, Index: {1}, Hit: {2}, Missed: {3})",
                    note.Pad, NoteIndex, note.WasHit, note.WasMissed);
                return;
            }

            note.SetMissState(true, false);

            if (note.IsStarPower)
            {
                StripStarPower(note);
            }

            if (note.IsSoloEnd && note.ParentOrSelf.WasFullyHitOrMissed())
            {
                EndSolo();
            }

            if (note.IsSoloStart)
            {
                StartSolo();
            }

            ResetCombo();

            UpdateMultiplier();

            OnNoteMissed?.Invoke(NoteIndex, note);
            base.MissNote(note);
        }

        protected int GetPointsPerNote()
        {
            return EngineParameters.Mode == DrumsEngineParameters.DrumMode.ProFourLane
                ? POINTS_PER_PRO_NOTE
                : POINTS_PER_NOTE;
        }

        protected override void AddScore(DrumNote note)
        {
            int pointsPerNote = GetPointsPerNote();
            AddScore(pointsPerNote);
            EngineStats.NoteScore += pointsPerNote;
        }

        protected sealed override int CalculateBaseScore()
        {
            int pointsPerNote = GetPointsPerNote();

            int score = 0;
            foreach (var note in Notes)
            {
                score += pointsPerNote * (1 + note.ChildNotes.Count);
            }

            return score;
        }

        protected static bool IsTomInput(GameInput input)
        {
            return input.GetAction<DrumsAction>() switch
            {
                DrumsAction.RedDrum or
                    DrumsAction.YellowDrum or
                    DrumsAction.BlueDrum or
                    DrumsAction.GreenDrum => true,
                _ => false,
            };
        }

        protected static bool IsCymbalInput(GameInput input)
        {
            return input.GetAction<DrumsAction>() switch
            {
                DrumsAction.YellowCymbal or
                    DrumsAction.BlueCymbal or
                    DrumsAction.OrangeCymbal or
                    DrumsAction.GreenCymbal => true,
                _ => false,
            };
        }

        protected static bool IsKickInput(GameInput input)
        {
            return input.GetAction<DrumsAction>() == DrumsAction.Kick;
        }

        protected static bool IsNoteInput(GameInput input)
        {
            return IsTomInput(input) || IsCymbalInput(input) || IsKickInput(input);
        }

        protected static int ConvertInputToPad(DrumsEngineParameters.DrumMode mode, DrumsAction action)
        {
            return mode switch
            {
                DrumsEngineParameters.DrumMode.NonProFourLane => action switch
                {
                    DrumsAction.Kick => (int) FourLaneDrumPad.Kick,

                    DrumsAction.RedDrum    => (int) FourLaneDrumPad.RedDrum,
                    DrumsAction.YellowDrum => (int) FourLaneDrumPad.YellowDrum,
                    DrumsAction.BlueDrum   => (int) FourLaneDrumPad.BlueDrum,
                    DrumsAction.GreenDrum  => (int) FourLaneDrumPad.GreenDrum,

                    DrumsAction.YellowCymbal => (int) FourLaneDrumPad.YellowDrum,
                    DrumsAction.BlueCymbal   => (int) FourLaneDrumPad.BlueDrum,
                    DrumsAction.GreenCymbal  => (int) FourLaneDrumPad.GreenDrum,

                    _ => -1
                },
                DrumsEngineParameters.DrumMode.ProFourLane => action switch
                {
                    DrumsAction.Kick => (int) FourLaneDrumPad.Kick,

                    DrumsAction.RedDrum    => (int) FourLaneDrumPad.RedDrum,
                    DrumsAction.YellowDrum => (int) FourLaneDrumPad.YellowDrum,
                    DrumsAction.BlueDrum   => (int) FourLaneDrumPad.BlueDrum,
                    DrumsAction.GreenDrum  => (int) FourLaneDrumPad.GreenDrum,

                    DrumsAction.YellowCymbal => (int) FourLaneDrumPad.YellowCymbal,
                    DrumsAction.BlueCymbal   => (int) FourLaneDrumPad.BlueCymbal,
                    DrumsAction.GreenCymbal  => (int) FourLaneDrumPad.GreenCymbal,

                    _ => -1
                },
                DrumsEngineParameters.DrumMode.FiveLane => action switch
                {
                    DrumsAction.Kick => (int) FiveLaneDrumPad.Kick,

                    DrumsAction.RedDrum   => (int) FiveLaneDrumPad.Red,
                    DrumsAction.BlueDrum  => (int) FiveLaneDrumPad.Blue,
                    DrumsAction.GreenDrum => (int) FiveLaneDrumPad.Green,

                    DrumsAction.YellowCymbal => (int) FiveLaneDrumPad.Yellow,
                    DrumsAction.OrangeCymbal => (int) FiveLaneDrumPad.Orange,

                    _ => -1
                },
                _ => throw new Exception("Unreachable.")
            };
        }

        protected static DrumsAction ConvertPadToAction(DrumsEngineParameters.DrumMode mode, int pad)
        {
            return mode switch
            {
                DrumsEngineParameters.DrumMode.NonProFourLane => pad switch
                {
                    (int) FourLaneDrumPad.Kick => DrumsAction.Kick,

                    (int) FourLaneDrumPad.RedDrum    => DrumsAction.RedDrum,
                    (int) FourLaneDrumPad.YellowDrum => DrumsAction.YellowDrum,
                    (int) FourLaneDrumPad.BlueDrum   => DrumsAction.BlueDrum,
                    (int) FourLaneDrumPad.GreenDrum  => DrumsAction.GreenDrum,

                    _ => throw new Exception("Unreachable.")
                },
                DrumsEngineParameters.DrumMode.ProFourLane => pad switch
                {
                    (int) FourLaneDrumPad.Kick => DrumsAction.Kick,

                    (int) FourLaneDrumPad.RedDrum    => DrumsAction.RedDrum,
                    (int) FourLaneDrumPad.YellowDrum => DrumsAction.YellowDrum,
                    (int) FourLaneDrumPad.BlueDrum   => DrumsAction.BlueDrum,
                    (int) FourLaneDrumPad.GreenDrum  => DrumsAction.GreenCymbal,

                    (int) FourLaneDrumPad.YellowCymbal => DrumsAction.YellowCymbal,
                    (int) FourLaneDrumPad.BlueCymbal   => DrumsAction.BlueCymbal,
                    (int) FourLaneDrumPad.GreenCymbal  => DrumsAction.GreenCymbal,

                    _ => throw new Exception("Unreachable.")
                },
                DrumsEngineParameters.DrumMode.FiveLane => pad switch
                {
                    (int) FiveLaneDrumPad.Kick => DrumsAction.Kick,

                    (int) FiveLaneDrumPad.Red   => DrumsAction.RedDrum,
                    (int) FiveLaneDrumPad.Blue  => DrumsAction.BlueDrum,
                    (int) FiveLaneDrumPad.Green => DrumsAction.GreenDrum,

                    (int) FiveLaneDrumPad.Yellow => DrumsAction.YellowCymbal,
                    (int) FiveLaneDrumPad.Orange => DrumsAction.OrangeCymbal,

                    _ => throw new Exception("Unreachable.")
                },
                _ => throw new Exception("Unreachable.")
            };
        }

        protected override bool CanSustainHold(DrumNote note) => throw new InvalidOperationException();
    }
}
</file>

<file path="Engine/Drums/DrumsEngineParameters.cs">
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.IO;

namespace YARG.Core.Engine.Drums
{
    public class DrumsEngineParameters : BaseEngineParameters
    {
        public enum DrumMode : byte
        {
            NonProFourLane,
            ProFourLane,
            FiveLane
        }

        /// <summary>
        /// What mode the inputs should be processed in.
        /// </summary>
        public readonly DrumMode Mode;

        //Ghost notes are below this threshold, Accent notes are above 1 - threshold
        public readonly float VelocityThreshold;

        // The maximum allowed time (seconds) between notes to use context-sensitive velocity scoring
        public readonly float SituationalVelocityWindow;

        public DrumsEngineParameters(HitWindowSettings hitWindow, int maxMultiplier, float[] starMultiplierThresholds,
            DrumMode mode)
            : base(hitWindow, maxMultiplier, 0, 0, starMultiplierThresholds)
        {
            Mode = mode;
            VelocityThreshold = 0.35f;
            SituationalVelocityWindow = 1.5f;
        }

        public DrumsEngineParameters(ref FixedArrayStream stream, int version)
            : base(ref stream, version)
        {
            Mode = (DrumMode) stream.ReadByte();
            VelocityThreshold = stream.Read<float>(Endianness.Little);
            SituationalVelocityWindow = stream.Read<float>(Endianness.Little);
        }

        public override void Serialize(BinaryWriter writer)
        {
            base.Serialize(writer);

            writer.Write((byte) Mode);
            writer.Write(VelocityThreshold);
            writer.Write(SituationalVelocityWindow);
        }

        public override string ToString()
        {
            return
                $"{base.ToString()}\n" +
                $"Velocity threshold: {VelocityThreshold}\n" +
                $"Situational velocity window: {SituationalVelocityWindow}";
        }
    }
}
</file>

<file path="Engine/Drums/DrumsStats.cs">
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.IO;
using YARG.Core.Replays;

namespace YARG.Core.Engine.Drums
{
    public class DrumsStats : BaseStats
    {
        /// <summary>
        /// Number of overhits which have occurred.
        /// </summary>
        public int Overhits;

        public DrumsStats()
        {
        }

        public DrumsStats(DrumsStats stats) : base(stats)
        {
            Overhits = stats.Overhits;
        }

        public DrumsStats(ref FixedArrayStream stream, int version)
            : base(ref stream, version)
        {
            Overhits = stream.Read<int>(Endianness.Little);
        }

        public override void Reset()
        {
            base.Reset();
            Overhits = 0;
        }

        public override void Serialize(BinaryWriter writer)
        {
            base.Serialize(writer);

            writer.Write(Overhits);
        }

        public override ReplayStats ConstructReplayStats(string name)
        {
            return new DrumsReplayStats(name, this);
        }
    }
}
</file>

<file path="Engine/Guitar/Engines/YargFiveFretEngine.cs">
using System;
using YARG.Core.Chart;
using YARG.Core.Input;
using YARG.Core.Logging;

namespace YARG.Core.Engine.Guitar.Engines
{
    public class YargFiveFretEngine : GuitarEngine
    {
        public YargFiveFretEngine(InstrumentDifficulty<GuitarNote> chart, SyncTrack syncTrack,
            GuitarEngineParameters engineParameters, bool isBot)
            : base(chart, syncTrack, engineParameters, isBot)
        {
        }

        protected override void UpdateBot(double time)
        {
            if (!IsBot || NoteIndex >= Notes.Count)
            {
                return;
            }

            var note = Notes[NoteIndex];

            if (time < note.Time)
            {
                return;
            }

            LastButtonMask = ButtonMask;
            ButtonMask = (byte) note.NoteMask;

            YargLogger.LogFormatTrace("[Bot] Set button mask to: {0}", ButtonMask);

            HasTapped = ButtonMask != LastButtonMask;
            IsFretPress = true;
            HasStrummed = false;
            StrumLeniencyTimer.Start(time);

            foreach (var sustain in ActiveSustains)
            {
                var sustainNote = sustain.Note;

                if (!sustainNote.IsExtendedSustain)
                {
                    continue;
                }

                if (sustainNote.IsDisjoint)
                {
                    ButtonMask |= (byte) sustainNote.DisjointMask;

                    YargLogger.LogFormatTrace("[Bot] Added Disjoint Sustain Mask {0} to button mask. {1}", sustainNote.DisjointMask, ButtonMask);
                }
                else
                {
                    ButtonMask |= (byte) sustainNote.NoteMask;

                    YargLogger.LogFormatTrace("[Bot] Added Sustain Mask {0} to button mask. {1}", sustainNote.NoteMask, ButtonMask);
                }
            }
        }

        protected override void MutateStateWithInput(GameInput gameInput)
        {
            var action = gameInput.GetAction<GuitarAction>();

            // Star power
            if (action is GuitarAction.StarPower)
            {
                IsStarPowerInputActive = gameInput.Button;
            }
            else if (action is GuitarAction.Whammy)
            {
                StarPowerWhammyTimer.Start(gameInput.Time);
            }
            else if (action is GuitarAction.StrumDown or GuitarAction.StrumUp && gameInput.Button)
            {
                HasStrummed = true;
            }
            else if (IsFretInput(gameInput))
            {
                LastButtonMask = ButtonMask;
                HasFretted = true;
                IsFretPress = gameInput.Button;

                ToggleFret(gameInput.Action, gameInput.Button);

                // No other frets are held, enable the "open fret"
                if ((ButtonMask & ~OPEN_MASK) == 0)
                {
                    ButtonMask |= OPEN_MASK;
                }
                else
                {
                    // Some frets are held, disable the "open fret"
                    ButtonMask &= unchecked((byte) ~OPEN_MASK);
                }
            }

            YargLogger.LogFormatTrace("Mutated input state: Button Mask: {0}, HasFretted: {1}, HasStrummed: {2}",
                ButtonMask, HasFretted, HasStrummed);
        }

        protected override void UpdateHitLogic(double time)
        {
            UpdateStarPower();
            UpdateTimers();

            bool strumEatenByHopo = false;

            // This is up here so overstrumming still works when there are no notes left
            if (HasStrummed)
            {
                // Hopo was hit recently, eat strum input
                if (HopoLeniencyTimer.IsActive)
                {
                    StrumLeniencyTimer.Disable();

                    // Disable hopo leniency as hopos can only eat one strum
                    HopoLeniencyTimer.Disable();

                    strumEatenByHopo = true;
                    ReRunHitLogic = true;
                }
                else
                {
                    // Strummed while strum leniency is active (double strum)
                    if (StrumLeniencyTimer.IsActive)
                    {
                        Overstrum();
                    }
                }

                if (!strumEatenByHopo)
                {
                    double offset = 0;

                    if (NoteIndex >= Notes.Count || !IsNoteInWindow(Notes[NoteIndex]))
                    {
                        offset = EngineParameters.StrumLeniencySmall;
                    }

                    StartTimer(ref StrumLeniencyTimer, CurrentTime, offset);

                    ReRunHitLogic = true;
                }
            }

            // Update bot (will return if not enabled)
            UpdateBot(time);

            // Quit early if there are no notes left
            if (NoteIndex >= Notes.Count)
            {
                HasStrummed = false;
                HasFretted = false;
                IsFretPress = false;
                UpdateSustains();
                return;
            }

            var note = Notes[NoteIndex];

            var hitWindow = EngineParameters.HitWindow.CalculateHitWindow(GetAverageNoteDistance(note));
            var frontEnd = EngineParameters.HitWindow.GetFrontEnd(hitWindow);

            if (HasFretted)
            {
                HasTapped = true;

                // This is the time the front end will expire. Used for hit logic with infinite front end
                FrontEndExpireTime = CurrentTime + Math.Abs(frontEnd);

                // Check for fret ghosting
                // We want to run ghost logic regardless of the setting for the ghost counter
                bool ghosted = CheckForGhostInput(note);

                // This variable controls hit logic for ghosting
                WasNoteGhosted = EngineParameters.AntiGhosting && (ghosted || WasNoteGhosted);

                // Add ghost inputs to stats regardless of the setting for anti ghosting
                if (ghosted)
                {
                    EngineStats.GhostInputs++;
                }
            }

            CheckForNoteHit();
            UpdateSustains();

            HasStrummed = false;
            HasFretted = false;
            IsFretPress = false;
        }

        protected override void CheckForNoteHit()
        {
            for (int i = NoteIndex; i < Notes.Count; i++)
            {
                bool isFirstNoteInWindow = i == NoteIndex;
                var note = Notes[i];

                if (note.WasFullyHitOrMissed())
                {
                    break;
                }

                if (!IsNoteInWindow(note, out bool missed))
                {
                    if (isFirstNoteInWindow && missed)
                    {
                        MissNote(note);
                        YargLogger.LogFormatTrace("Missed note (Index: {0}, Mask: {1}) at {2}", i,
                            note.NoteMask, CurrentTime);
                    }

                    break;
                }

                // Cannot hit the note
                if (!CanNoteBeHit(note))
                {
                    YargLogger.LogFormatTrace("Cant hit note (Index: {0}, Mask {1}) at {2}. Buttons: {3}", i,
                        note.NoteMask, CurrentTime, ButtonMask);
                    // This does nothing special, it's just logging strum leniency
                    if (isFirstNoteInWindow && HasStrummed && StrumLeniencyTimer.IsActive)
                    {
                        YargLogger.LogFormatTrace("Starting strum leniency at {0}, will end at {1}", CurrentTime,
                            StrumLeniencyTimer.EndTime);
                    }

                    // Note skipping not allowed on the first note if hopo/tap
                    if ((note.IsHopo || note.IsTap) && NoteIndex == 0)
                    {
                        break;
                    }

                    // Continue to the next note (skipping the current one)
                    continue;
                }

                // Handles hitting a hopo notes
                // If first note is a hopo then it can be hit without combo (for practice mode)
                bool hopoCondition = note.IsHopo && isFirstNoteInWindow &&
                    (EngineStats.Combo > 0 || NoteIndex == 0);

                // If a note is a tap then it can be hit only if it is the closest note, unless
                // the combo is 0 then it can be hit regardless of the distance (note skipping)
                bool tapCondition = note.IsTap && (isFirstNoteInWindow || EngineStats.Combo == 0);

                bool frontEndIsExpired = note.Time > FrontEndExpireTime;
                bool canUseInfFrontEnd =
                    EngineParameters.InfiniteFrontEnd || !frontEndIsExpired || NoteIndex == 0;

                // Attempt to hit with hopo/tap rules
                if (HasTapped && (hopoCondition || tapCondition) && canUseInfFrontEnd && !WasNoteGhosted)
                {
                    HitNote(note);
                    YargLogger.LogFormatTrace("Hit note (Index: {0}, Mask: {1}) at {2} with hopo rules",
                        i, note.NoteMask, CurrentTime);
                    break;
                }

                // If hopo/tap checks failed then the note can be hit if it was strummed
                if ((HasStrummed || StrumLeniencyTimer.IsActive) &&
                    (isFirstNoteInWindow || (NoteIndex > 0 && EngineStats.Combo == 0)))
                {
                    HitNote(note);
                    if (HasStrummed)
                    {
                        YargLogger.LogFormatTrace("Hit note (Index: {0}, Mask: {1}) at {2} with strum input",
                            i, note.NoteMask, CurrentTime);
                    }
                    else
                    {
                        YargLogger.LogFormatTrace("Hit note (Index: {0}, Mask: {1}) at {2} with strum leniency",
                            i, note.NoteMask, CurrentTime);
                    }

                    break;
                }
            }
        }

        protected override bool CanNoteBeHit(GuitarNote note)
        {
            byte buttonsMasked = ButtonMask;
            if (ActiveSustains.Count > 0)
            {
                foreach (var sustain in ActiveSustains)
                {
                    var sustainNote = sustain.Note;

                    if (sustainNote.IsExtendedSustain)
                    {
                        // Remove the note mask if its an extended sustain
                        // Difference between NoteMask and DisjointMask is that DisjointMask is only a single fret
                        // while NoteMask is the entire chord

                        // TODO Notes cannot be hit if a sustain of the same fret is being held e.g H-ELL Solo 3C5

                        //byte sameFretsHeld = (byte) ((byte) (sustain.Note.NoteMask & note.NoteMask) & ButtonMask);

                        var maskToRemove = sustainNote.IsDisjoint ? sustainNote.DisjointMask : sustainNote.NoteMask;
                        buttonsMasked &= unchecked((byte) ~maskToRemove);
                        //buttonsMasked |= sameFretsHeld;
                    }
                }

                // If the resulting masked buttons are 0, we need to apply the Open Mask so open notes can be hit
                // Need to make a copy of the button mask to prevent modifying the original
                byte buttonMaskCopy = ButtonMask;
                if (buttonsMasked == 0)
                {
                    buttonsMasked |= OPEN_MASK;
                    buttonMaskCopy |= OPEN_MASK;
                }

                // We dont want to use masked buttons for hit logic if the buttons are identical
                if (buttonsMasked != buttonMaskCopy && IsNoteHittable(note, buttonsMasked))
                {
                    return true;
                }
            }

            // If masked/extended sustain logic didn't work, try original ButtonMask
            return IsNoteHittable(note, ButtonMask);

            static bool IsNoteHittable(GuitarNote note, byte buttonsMasked)
            {
                // Only used for sustain logic
                bool useDisjointSustainMask = note is { IsDisjoint: true, WasHit: true };

                // Use the DisjointMask for comparison if disjointed and was hit (for sustain logic)
                int noteMask = useDisjointSustainMask ? note.DisjointMask : note.NoteMask;

                // If disjointed and is sustain logic (was hit), can hit if disjoint mask matches
                if (useDisjointSustainMask && (note.DisjointMask & buttonsMasked) != 0)
                {
                    if ((note.DisjointMask & buttonsMasked) != 0)
                    {
                        return true;
                    }

                    if ((note.NoteMask & OPEN_MASK) != 0)
                    {
                        return true;
                    }
                }

                // Open chords
                // Contains open fret but the note mask is not strictly the open mask
                if ((noteMask & OPEN_MASK) != 0 && noteMask != OPEN_MASK)
                {
                    // Open chords are basically normal chords except no anchoring in any circumstances
                    // Prevents HOPO/Tap chords from being anchored

                    var buttonsMaskedWithOpen = buttonsMasked | OPEN_MASK;

                    if (buttonsMaskedWithOpen == noteMask)
                    {
                        return true;
                    }
                }

                // If holding exact note mask, can hit
                if (buttonsMasked == noteMask)
                {
                    return true;
                }

                // Anchoring

                // XORing the two masks will give the anchor (held frets) around the note.
                int anchorButtons = buttonsMasked ^ noteMask;

                // Chord logic
                if (note.IsChord)
                {
                    if (note.IsStrum)
                    {
                        // Buttons must match note mask exactly for strum chords
                        return buttonsMasked == noteMask;
                    }

                    // Anchoring hopo/tap chords

                    // Gets the lowest fret of the chord.
                    var chordMask = 0;
                    for (var fret = GuitarAction.GreenFret; fret <= GuitarAction.OrangeFret; fret++)
                    {
                        chordMask = 1 << (int) fret;

                        // If the current fret mask is part of the chord, break
                        if ((chordMask & note.NoteMask) == chordMask)
                        {
                            break;
                        }
                    }

                    // Anchor part:
                    // Lowest fret of chord must be bigger or equal to anchor buttons
                    // (can't hold note higher than the highest fret of chord)

                    // Button mask subtract the anchor must equal chord mask (all frets of chord held)
                    return chordMask >= anchorButtons && buttonsMasked - anchorButtons == note.NoteMask;
                }

                // Anchoring single notes
                // Anchors are buttons held lower than the note mask

                // Remove the open mask from note otherwise this will always pass (as its higher than all notes)
                // This is only used for single notes, open chords are handled above
                return anchorButtons < (noteMask & unchecked((byte) ~OPEN_MASK));
            }
        }

        protected override void HitNote(GuitarNote note)
        {
            if (note.IsHopo || note.IsTap)
            {
                HasTapped = false;
                StartTimer(ref HopoLeniencyTimer, CurrentTime);
            }
            else
            {
                // This line allows for hopos/taps to be hit using infinite front end after strumming
                HasTapped = true;

                // Does the same thing but ensures it still works when infinite front end is disabled
                EngineTimer.Reset(ref FrontEndExpireTime);
            }

            StrumLeniencyTimer.Disable();

            for(int i = 0; i < ActiveSustains.Count; i++)
            {
                var sustainNote = ActiveSustains[i].Note;

                var sustainMask = sustainNote.IsDisjoint ? sustainNote.DisjointMask : sustainNote.NoteMask;
                if ((sustainMask & note.NoteMask) != 0)
                {
                    EndSustain(i, true, CurrentTick >= sustainNote.TickEnd);
                }
            }

            base.HitNote(note);
        }

        protected override void MissNote(GuitarNote note)
        {
            HasTapped = false;
            base.MissNote(note);
        }

        protected void UpdateTimers()
        {
            if (HopoLeniencyTimer.IsActive && HopoLeniencyTimer.IsExpired(CurrentTime))
            {
                HopoLeniencyTimer.Disable();

                ReRunHitLogic = true;
            }

            if (StrumLeniencyTimer.IsActive)
            {
                //YargTrace.LogInfo("Strum Leniency: Enabled");
                if (StrumLeniencyTimer.IsExpired(CurrentTime))
                {
                    //YargTrace.LogInfo("Strum Leniency: Expired. Overstrumming");
                    Overstrum();
                    StrumLeniencyTimer.Disable();

                    ReRunHitLogic = true;
                }
            }
        }

        protected bool CheckForGhostInput(GuitarNote note)
        {
            // First note cannot be ghosted, nor can a note be ghosted if a button is unpressed (pulloff)
            if (note.PreviousNote is null || !IsFretPress)
            {
                return false;
            }

            // Note can only be ghosted if it's in timing window
            if (!IsNoteInWindow(note))
            {
                return false;
            }

            // Input is a hammer-on if the highest fret held is higher than the highest fret of the previous mask
            bool isHammerOn = GetMostSignificantBit(ButtonMask) > GetMostSignificantBit(LastButtonMask);

            // Input is a hammer-on and the button pressed is not part of the note mask (incorrect fret)
            if (isHammerOn && (ButtonMask & note.NoteMask) == 0)
            {
                return true;
            }

            return false;
        }

        private static int GetMostSignificantBit(int mask)
        {
            // Gets the most significant bit of the mask
            var msbIndex = 0;
            while (mask != 0)
            {
                mask >>= 1;
                msbIndex++;
            }

            return msbIndex;
        }
    }
}
</file>

<file path="Engine/Guitar/GuitarEngine.cs">
using System;
using YARG.Core.Chart;
using YARG.Core.Input;
using YARG.Core.Logging;

namespace YARG.Core.Engine.Guitar
{
    public abstract class GuitarEngine : BaseEngine<GuitarNote, GuitarEngineParameters,
        GuitarStats>
    {
        protected const byte OPEN_MASK = 64;

        public delegate void OverstrumEvent();

        public OverstrumEvent? OnOverstrum;

        public byte ButtonMask { get; protected set; } = OPEN_MASK;

        public byte LastButtonMask { get; protected set; }

        protected bool HasFretted;
        protected bool HasStrummed;
        protected bool HasTapped = true;
        protected bool HasWhammied;

        protected bool IsFretPress;

        public bool WasNoteGhosted { get; protected set; }

        /// <summary>
        /// The amount of time a hopo is allowed to take a strum input.
        /// Strum after this time and it will overstrum.
        /// </summary>
        protected EngineTimer HopoLeniencyTimer;

        /// <summary>
        /// The amount of time a strum can be inputted before fretting the correct note.
        /// Fretting after this time will overstrum.
        /// </summary>
        protected EngineTimer StrumLeniencyTimer;

        protected double FrontEndExpireTime;

        protected GuitarEngine(InstrumentDifficulty<GuitarNote> chart, SyncTrack syncTrack,
            GuitarEngineParameters engineParameters, bool isBot)
            : base(chart, syncTrack, engineParameters, false, isBot)
        {
            StrumLeniencyTimer = new EngineTimer(engineParameters.StrumLeniency);
            HopoLeniencyTimer = new EngineTimer(engineParameters.HopoLeniency);
            StarPowerWhammyTimer = new EngineTimer(engineParameters.StarPowerWhammyBuffer);

            GetWaitCountdowns(Notes);
        }

        public EngineTimer GetHopoLeniencyTimer() => HopoLeniencyTimer;
        public EngineTimer GetStrumLeniencyTimer() => StrumLeniencyTimer;
        public double GetFrontEndExpireTime() => FrontEndExpireTime;

        protected override void GenerateQueuedUpdates(double nextTime)
        {
            base.GenerateQueuedUpdates(nextTime);
            var previousTime = CurrentTime;

            // Check all timers
            if (HopoLeniencyTimer.IsActive)
            {
                if (IsTimeBetween(HopoLeniencyTimer.EndTime, previousTime, nextTime))
                {
                    YargLogger.LogFormatTrace("Queuing hopo leniency end time at {0}", HopoLeniencyTimer.EndTime);
                    QueueUpdateTime(HopoLeniencyTimer.EndTime, "HOPO Leniency End");
                }
            }

            if (StrumLeniencyTimer.IsActive)
            {
                if (IsTimeBetween(StrumLeniencyTimer.EndTime, previousTime, nextTime))
                {
                    YargLogger.LogFormatTrace("Queuing strum leniency end time at {0}",
                        StrumLeniencyTimer.EndTime);
                    QueueUpdateTime(StrumLeniencyTimer.EndTime, "Strum Leniency End");
                }
            }
        }

        public override void Reset(bool keepCurrentButtons = false)
        {
            byte buttons = ButtonMask;

            ButtonMask = OPEN_MASK;

            HasFretted = false;
            HasStrummed = false;
            HasTapped = true;

            WasNoteGhosted = false;

            StrumLeniencyTimer.Disable();
            HopoLeniencyTimer.Disable();
            StarPowerWhammyTimer.Disable();

            FrontEndExpireTime = 0;

            ActiveSustains.Clear();

            base.Reset(keepCurrentButtons);

            if (keepCurrentButtons)
            {
                ButtonMask = buttons;
            }
        }

        protected virtual void Overstrum()
        {
            // Can't overstrum before first note is hit/missed
            if (NoteIndex == 0)
            {
                return;
            }

            // Cancel overstrum if past last note and no active sustains
            if (NoteIndex >= Chart.Notes.Count && ActiveSustains.Count == 0)
            {
                return;
            }

            // Cancel overstrum if WaitCountdown is active
            if (IsWaitCountdownActive)
            {
                YargLogger.LogFormatTrace("Overstrum prevented during WaitCountdown at time: {0}, tick: {1}", CurrentTime, CurrentTick);
                return;
            }

            YargLogger.LogFormatTrace("Overstrummed at {0}", CurrentTime);

            // Break all active sustains
            for (int i = 0; i < ActiveSustains.Count; i++)
            {
                var sustain = ActiveSustains[i];
                ActiveSustains.RemoveAt(i);
                YargLogger.LogFormatTrace("Ended sustain (end time: {0}) at {1}", sustain.GetEndTime(SyncTrack, 0), CurrentTime);
                i--;

                double finalScore = CalculateSustainPoints(ref sustain, CurrentTick);
                EngineStats.CommittedScore += (int) Math.Ceiling(finalScore);
                OnSustainEnd?.Invoke(sustain.Note, CurrentTime, sustain.HasFinishedScoring);
            }

            if (NoteIndex < Notes.Count)
            {
                // Don't remove the phrase if the current note being overstrummed is the start of a phrase
                if (!Notes[NoteIndex].IsStarPowerStart)
                {
                    StripStarPower(Notes[NoteIndex]);
                }
            }

            ResetCombo();
            EngineStats.Overstrums++;

            UpdateMultiplier();

            OnOverstrum?.Invoke();
        }

        protected override bool CanSustainHold(GuitarNote note)
        {
            var mask = note.IsDisjoint ? note.DisjointMask : note.NoteMask;

            var buttonsMasked = ButtonMask;
            if ((mask & OPEN_MASK) != 0)
            {
                buttonsMasked |= OPEN_MASK;
            }

            bool extendedSustainHold = (mask & buttonsMasked) == mask;

            // Open chord
            if ((note.ParentOrSelf.NoteMask & OPEN_MASK) != 0 && note.ParentOrSelf.NoteMask != OPEN_MASK &&
                (note.DisjointMask & OPEN_MASK) != 0)
            {
                if (note.IsDisjoint || note.IsExtendedSustain)
                {
                    return true;
                }
            }

            return note.IsExtendedSustain ? extendedSustainHold : CanNoteBeHit(note);
        }

        protected override void HitNote(GuitarNote note)
        {
            if (note.WasHit || note.WasMissed)
            {
                YargLogger.LogFormatTrace("Tried to hit/miss note twice (Fret: {0}, Index: {1}, Hit: {2}, Missed: {3})", note.Fret, NoteIndex, note.WasHit, note.WasMissed);
                return;
            }

            note.SetHitState(true, true);

            // Detect if the last note(s) were skipped
            bool skipped = SkipPreviousNotes(note);

            if (note.IsStarPower && note.IsStarPowerEnd)
            {
                AwardStarPower(note);
                EngineStats.StarPowerPhrasesHit++;
            }

            if (note.IsSoloStart)
            {
                StartSolo();
            }

            if (IsSoloActive)
            {
                Solos[CurrentSoloIndex].NotesHit++;
            }

            if (note.IsSoloEnd)
            {
                EndSolo();
            }

            IncrementCombo();

            EngineStats.NotesHit++;

            UpdateMultiplier();

            AddScore(note);

            if (note.IsDisjoint)
            {
                foreach (var chordNote in note.AllNotes)
                {
                    if (!chordNote.IsSustain)
                    {
                        continue;
                    }

                    StartSustain(chordNote);
                }
            }
            else if (note.IsSustain)
            {
                StartSustain(note);
            }

            WasNoteGhosted = false;

            OnNoteHit?.Invoke(NoteIndex, note);
            base.HitNote(note);
        }

        protected override void MissNote(GuitarNote note)
        {
            if (note.WasHit || note.WasMissed)
            {
                YargLogger.LogFormatTrace("Tried to hit/miss note twice (Fret: {0}, Index: {1}, Hit: {2}, Missed: {3})", note.Fret, NoteIndex, note.WasHit, note.WasMissed);
                return;
            }

            note.SetMissState(true, true);

            if (note.IsStarPower)
            {
                StripStarPower(note);
            }

            if (note.IsSoloEnd)
            {
                EndSolo();
            }

            if (note.IsSoloStart)
            {
                StartSolo();
            }

            WasNoteGhosted = false;

            ResetCombo();

            UpdateMultiplier();

            OnNoteMissed?.Invoke(NoteIndex, note);
            base.MissNote(note);
        }

        protected override void AddScore(GuitarNote note)
        {
            int notePoints = POINTS_PER_NOTE * (1 + note.ChildNotes.Count);
            EngineStats.NoteScore += notePoints;
            AddScore(notePoints);
        }

        protected override void UpdateMultiplier()
        {
            int previousMultiplier = EngineStats.ScoreMultiplier;
            base.UpdateMultiplier();
            int newMultiplier = EngineStats.ScoreMultiplier;

            // Rebase sustains when the multiplier changes so that
            // there aren't huge jumps in points on extended sustains
            if (newMultiplier != previousMultiplier)
            {
                // Temporarily reset multiplier to calculate score correctly
                EngineStats.ScoreMultiplier = previousMultiplier;
                RebaseSustains(CurrentTick);
                EngineStats.ScoreMultiplier = newMultiplier;
            }
        }

        public override void SetSpeed(double speed)
        {
            base.SetSpeed(speed);
            HopoLeniencyTimer.SetSpeed(speed);
            StrumLeniencyTimer.SetSpeed(speed);
        }

        protected sealed override int CalculateBaseScore()
        {
            int score = 0;
            foreach (var note in Notes)
            {
                score += POINTS_PER_NOTE * (1 + note.ChildNotes.Count);
                score += (int) Math.Ceiling(note.TickLength / TicksPerSustainPoint);

                // If a note is disjoint, each sustain is counted separately.
                if (note.IsDisjoint)
                {
                    foreach (var child in note.ChildNotes)
                    {
                        score += (int) Math.Ceiling(child.TickLength / TicksPerSustainPoint);
                    }
                }
            }

            return score;
        }

        protected void ToggleFret(int fret, bool active)
        {
            ButtonMask = (byte) (active ? ButtonMask | (1 << fret) : ButtonMask & ~(1 << fret));
        }

        public bool IsFretHeld(GuitarAction fret)
        {
            return (ButtonMask & (1 << (int) fret)) != 0;
        }

        protected static bool IsFretInput(GameInput input)
        {
            return input.GetAction<GuitarAction>() switch
            {
                GuitarAction.GreenFret or
                    GuitarAction.RedFret or
                    GuitarAction.YellowFret or
                    GuitarAction.BlueFret or
                    GuitarAction.OrangeFret or
                    GuitarAction.White3Fret => true,
                _ => false,
            };
        }

        protected static bool IsStrumInput(GameInput input)
        {
            return input.GetAction<GuitarAction>() switch
            {
                GuitarAction.StrumUp or
                    GuitarAction.StrumDown => true,
                _ => false,
            };
        }
    }
}
</file>

<file path="Engine/Guitar/GuitarEngineParameters.cs">
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.IO;

namespace YARG.Core.Engine.Guitar
{
    public class GuitarEngineParameters : BaseEngineParameters
    {
        public readonly double HopoLeniency;
        public readonly double StrumLeniency;
        public readonly double StrumLeniencySmall;
        public readonly bool InfiniteFrontEnd;
        public readonly bool AntiGhosting;

        public GuitarEngineParameters(HitWindowSettings hitWindow, int maxMultiplier, double spWhammyBuffer,
            double sustainDropLeniency, float[] starMultiplierThresholds, double hopoLeniency, double strumLeniency,
            double strumLeniencySmall, bool infiniteFrontEnd, bool antiGhosting)
            : base(hitWindow, maxMultiplier, spWhammyBuffer, sustainDropLeniency, starMultiplierThresholds)
        {
            HopoLeniency = hopoLeniency;

            StrumLeniency = strumLeniency;
            StrumLeniencySmall = strumLeniencySmall;

            InfiniteFrontEnd = infiniteFrontEnd;
            AntiGhosting = antiGhosting;
        }

        public GuitarEngineParameters(ref FixedArrayStream stream, int version)
            : base(ref stream, version)
        {
            HopoLeniency = stream.Read<double>(Endianness.Little);

            StrumLeniency = stream.Read<double>(Endianness.Little);
            StrumLeniencySmall = stream.Read<double>(Endianness.Little);

            InfiniteFrontEnd = stream.ReadBoolean();
            AntiGhosting = stream.ReadBoolean();
        }

        public override void Serialize(BinaryWriter writer)
        {
            base.Serialize(writer);

            writer.Write(HopoLeniency);

            writer.Write(StrumLeniency);
            writer.Write(StrumLeniencySmall);

            writer.Write(InfiniteFrontEnd);
            writer.Write(AntiGhosting);
        }

        public override string ToString()
        {
            return
                $"{base.ToString()}\n" +
                $"Infinite front-end: {InfiniteFrontEnd}\n" +
                $"Anti-ghosting: {AntiGhosting}\n" +
                $"Hopo leniency: {HopoLeniency}\n" +
                $"Strum leniency: {StrumLeniency}\n" +
                $"Strum leniency (small): {StrumLeniencySmall}\n" +
                $"Star power whammy buffer: {StarPowerWhammyBuffer}";
        }
    }
}
</file>

<file path="Engine/Guitar/GuitarStats.cs">
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.IO;
using YARG.Core.Replays;

namespace YARG.Core.Engine.Guitar
{
    public class GuitarStats : BaseStats
    {
        /// <summary>
        /// Number of overstrums which have occurred.
        /// </summary>
        public int Overstrums;

        /// <summary>
        /// Number of hammer-ons/pull-offs which have been strummed.
        /// </summary>
        public int HoposStrummed;

        /// <summary>
        /// Number of ghost inputs the player has made.
        /// </summary>
        public int GhostInputs;

        public GuitarStats()
        {
        }

        public GuitarStats(GuitarStats stats) : base(stats)
        {
            Overstrums = stats.Overstrums;
            HoposStrummed = stats.HoposStrummed;
            GhostInputs = stats.GhostInputs;
            SustainScore = stats.SustainScore;
        }

        public GuitarStats(ref FixedArrayStream stream, int version)
            : base(ref stream, version)
        {
            Overstrums = stream.Read<int>(Endianness.Little);
            HoposStrummed = stream.Read<int>(Endianness.Little);
            GhostInputs = stream.Read<int>(Endianness.Little);
            SustainScore = stream.Read<int>(Endianness.Little);
        }

        public override void Reset()
        {
            base.Reset();
            Overstrums = 0;
            HoposStrummed = 0;
            GhostInputs = 0;
            SustainScore = 0;
        }

        public override void Serialize(BinaryWriter writer)
        {
            base.Serialize(writer);

            writer.Write(Overstrums);
            writer.Write(HoposStrummed);
            writer.Write(GhostInputs);
            writer.Write(SustainScore);
        }

        public override ReplayStats ConstructReplayStats(string name)
        {
            return new GuitarReplayStats(name, this);
        }
    }
}
</file>

<file path="Engine/ProKeys/Engines/YargProKeysEngine.cs">
using System;
using YARG.Core.Chart;
using YARG.Core.Input;
using YARG.Core.Logging;

namespace YARG.Core.Engine.ProKeys.Engines
{
    public class YargProKeysEngine : ProKeysEngine
    {
        public YargProKeysEngine(InstrumentDifficulty<ProKeysNote> chart, SyncTrack syncTrack,
            ProKeysEngineParameters engineParameters, bool isBot) : base(chart, syncTrack, engineParameters, isBot)
        {
        }

        protected override void MutateStateWithInput(GameInput gameInput)
        {
            var action = gameInput.GetAction<ProKeysAction>();

            if (action is ProKeysAction.StarPower)
            {
                IsStarPowerInputActive = gameInput.Button;
            }
            else if (action is ProKeysAction.TouchEffects)
            {
                StarPowerWhammyTimer.Start(gameInput.Time);
            }
            else
            {
                if (gameInput.Button)
                {
                    KeyHit = (int) action;
                }
                else
                {
                    KeyReleased = (int) action;
                }

                PreviousKeyMask = KeyMask;
                ToggleKey((int) action, gameInput.Button);
                KeyPressTimes[(int) action] = gameInput.Time;

                OnKeyStateChange?.Invoke((int) action, gameInput.Button);
            }
        }

        protected override void UpdateHitLogic(double time)
        {
            UpdateStarPower();

            // Update bot (will return if not enabled)
            UpdateBot(time);

            if (FatFingerTimer.IsActive)
            {
                // Fat Fingered key was released before the timer expired
                if (KeyReleased == FatFingerKey && !FatFingerTimer.IsExpired(CurrentTime))
                {
                    YargLogger.LogFormatTrace("Released fat fingered key at {0}. Note was hit: {1}", CurrentTime, FatFingerNote!.WasHit);

                    // The note must be hit to disable the timer
                    if (FatFingerNote!.WasHit)
                    {
                        YargLogger.LogDebug("Disabling fat finger timer as the note has been hit.");
                        FatFingerTimer.Disable();
                        FatFingerKey = null;
                        FatFingerNote = null;
                    }
                }
                else if(FatFingerTimer.IsExpired(CurrentTime))
                {
                    YargLogger.LogFormatTrace("Fat Finger timer expired at {0}", CurrentTime);

                    var fatFingerKeyMask = 1 << FatFingerKey;

                    var isHoldingWrongKey = (KeyMask & fatFingerKeyMask) == fatFingerKeyMask;

                    // Overhit if key is still held OR if key is not held but note was not hit either
                    if (isHoldingWrongKey || (!isHoldingWrongKey && !FatFingerNote!.WasHit))
                    {
                        YargLogger.LogFormatTrace("Overhit due to fat finger with key {0}. KeyMask: {1}. Holding: {2}. WasHit: {3}",
                            FatFingerKey, KeyMask, isHoldingWrongKey, FatFingerNote!.WasHit);
                        Overhit(FatFingerKey!.Value);
                    }

                    FatFingerTimer.Disable();
                    FatFingerKey = null;
                    FatFingerNote = null;
                }
            }

            // Quit early if there are no notes left
            if (NoteIndex >= Notes.Count)
            {
                KeyHit = null;
                KeyReleased = null;
                UpdateSustains();
                return;
            }

            CheckForNoteHit();
            UpdateSustains();
        }

        protected override void CheckForNoteHit()
        {
            var parentNote = Notes[NoteIndex];

            // Miss out the back end
            if (!IsNoteInWindow(parentNote, out bool missed))
            {
                if (missed)
                {
                    // If one of the notes in the chord was missed out the back end,
                    // that means all of them would miss.
                    foreach (var missedNote in parentNote.AllNotes)
                    {
                        MissNote(missedNote);
                    }
                }
            }
            else
            {
                double hitWindow = EngineParameters.HitWindow.CalculateHitWindow(GetAverageNoteDistance(parentNote));
                double frontEnd = EngineParameters.HitWindow.GetFrontEnd(hitWindow);
                double backEnd = EngineParameters.HitWindow.GetBackEnd(hitWindow);

                // Hit whole note
                if (CanNoteBeHit(parentNote))
                {
                    foreach (var childNote in parentNote.AllNotes)
                    {
                        HitNote(childNote);
                    }

                    KeyHit = null;
                }
                else
                {
                    // Note cannot be hit in full, try to use chord staggering logic

                    if (parentNote.IsChord)
                    {
                        // Note is a chord and chord staggering was active and is now expired
                        if (ChordStaggerTimer.IsActive && ChordStaggerTimer.IsExpired(CurrentTime))
                        {
                            YargLogger.LogFormatTrace("Ending chord staggering at {0}", CurrentTime);
                            foreach (var note in parentNote.AllNotes)
                            {
                                // This key in the chord was held by the time chord staggering ended, so it can be hit
                                if ((KeyMask & note.DisjointMask) == note.DisjointMask && IsKeyInTime(note, frontEnd))
                                {
                                    HitNote(note);
                                    YargLogger.LogFormatTrace("Hit staggered note {0} in chord", note.Key);
                                }
                                else
                                {
                                    YargLogger.LogFormatTrace("Missing note {0} due to chord staggering", note.Key);
                                    MissNote(note);
                                }
                            }

                            ChordStaggerTimer.Disable();
                        }
                        else
                        {
                            foreach (var note in parentNote.AllNotes)
                            {
                                // Go to next note if the key hit does not match the note's key
                                if (KeyHit != note.Key)
                                {
                                    continue;
                                }

                                if (!ChordStaggerTimer.IsActive)
                                {
                                    StartTimer(ref ChordStaggerTimer, CurrentTime);
                                    YargLogger.LogFormatTrace("Starting chord staggering at {0}. End time is {1}",
                                        CurrentTime, ChordStaggerTimer.EndTime);

                                    var chordStaggerEndTime = ChordStaggerTimer.EndTime;

                                    double noteMissTime = note.Time + backEnd;

                                    // Time has surpassed the back end of this note
                                    if (chordStaggerEndTime > noteMissTime)
                                    {
                                        double diff = noteMissTime - chordStaggerEndTime;
                                        StartTimer(ref ChordStaggerTimer, CurrentTime - Math.Abs(diff));

                                        YargLogger.LogFormatTrace(
                                            "Chord stagger window shortened by {0}. New end time is {1}. Note backend time is {2}",
                                            diff, ChordStaggerTimer.EndTime, noteMissTime);
                                    }
                                }

                                KeyHit = null;
                                break;
                            }
                        }
                    }
                }
            }

            // If no note was hit but the user hit a key, then over hit
            if (KeyHit != null)
            {
                static ProKeysNote? CheckForAdjacency(ProKeysNote fullNote, int key)
                {
                    foreach (var note in fullNote.AllNotes)
                    {
                        if (ProKeysUtilities.IsAdjacentKey(note.Key, key))
                        {
                            return note;
                        }
                    }

                    return null;
                }

                ProKeysNote? adjacentNote;
                bool isAdjacent;
                bool inWindow;

                // Try to fat finger previous note first

                // Previous note can only be fat fingered if the current distance from the note
                // is within the fat finger threshold (default 100ms)
                if (parentNote.PreviousNote is not null
                    && CurrentTime - parentNote.PreviousNote.Time < FatFingerTimer.SpeedAdjustedThreshold)
                {
                    adjacentNote = CheckForAdjacency(parentNote.PreviousNote, KeyHit.Value);
                    isAdjacent = adjacentNote != null;
                    inWindow = IsNoteInWindow(parentNote.PreviousNote, out _);

                }
                // Try to fat finger current note (upcoming note)
                else
                {
                    adjacentNote = CheckForAdjacency(parentNote, KeyHit.Value);
                    isAdjacent = adjacentNote != null;
                    inWindow = IsNoteInWindow(parentNote, out _);
                }

                var isFatFingerActive = FatFingerTimer.IsActive;

                if (!inWindow || !isAdjacent || isFatFingerActive)
                {
                    Overhit(KeyHit.Value);

                    // TODO Maybe don't disable the timer/use a flag saying no more fat fingers allowed for the current note.

                    FatFingerTimer.Disable();
                    FatFingerKey = null;
                    FatFingerNote = null;
                }
                else
                {
                    StartTimer(ref FatFingerTimer, CurrentTime);
                    FatFingerKey = KeyHit.Value;

                    FatFingerNote = adjacentNote;

                    YargLogger.LogFormatTrace("Hit adjacent key {0} to note {1}. Starting fat finger timer at {2}. End time: {3}. Key is {4}", FatFingerKey, adjacentNote!.Key, CurrentTime,
                        FatFingerTimer.EndTime, FatFingerKey);
                }

                KeyHit = null;
            }
        }

        protected override bool CanNoteBeHit(ProKeysNote note)
        {
            double hitWindow = EngineParameters.HitWindow.CalculateHitWindow(GetAverageNoteDistance(note));
            double frontEnd = EngineParameters.HitWindow.GetFrontEnd(hitWindow);

            if((KeyMask & note.NoteMask) == note.NoteMask)
            {
                foreach (var childNote in note.AllNotes)
                {
                    if (!IsKeyInTime(childNote, frontEnd))
                    {
                        return false;
                    }
                }

                return true;
            }

            // Glissando hit logic
            // Forces the first glissando to be hit correctly, then the rest can be hit "loosely"
            if (note.PreviousNote is not null && note.IsGlissando && note.PreviousNote.IsGlissando)
            {
                var keyDiff = KeyMask ^ PreviousKeyMask;
                var keysPressed = keyDiff & KeyMask;
                //var keysReleased = keyDiff & PreviousKeyMask;

                foreach (var child in note.AllNotes)
                {
                    var pressCopy = keysPressed;

                    int i = 0;
                    while (pressCopy > 0)
                    {
                        if((pressCopy & 1) != 0 && IsKeyInTime(child, i, frontEnd))
                        {
                            // It's not ideal that this is here but there's no way to know what key hit the note
                            // within HitNote() so we have to set the press time here
                            KeyPressTimes[i] = DEFAULT_PRESS_TIME;
                            return true;
                        }

                        i++;
                        pressCopy >>= 1;
                    }
                }
            }

            return false;
        }

        protected override void UpdateBot(double time)
        {
            if (!IsBot || NoteIndex >= Notes.Count)
            {
                return;
            }

            var note = Notes[NoteIndex];

            if (time < note.Time)
            {
                return;
            }

            // Disables keys that are not in the current note
            int key = 0;
            for (var mask = KeyMask; mask > 0; mask >>= 1)
            {
                if ((mask & 1) == 1)
                {
                    MutateStateWithInput(new GameInput(note.Time, key, false));
                }

                key++;
            }


            // Press keys for current note
            foreach (var chordNote in note.AllNotes)
            {
                MutateStateWithInput(new GameInput(note.Time, chordNote.Key, true));
                CheckForNoteHit();
            }
        }
    }
}
</file>

<file path="Engine/ProKeys/ProKeysEngine.cs">
using System;
using YARG.Core.Chart;
using YARG.Core.Input;
using YARG.Core.Logging;

namespace YARG.Core.Engine.ProKeys
{
    public abstract class ProKeysEngine : BaseEngine<ProKeysNote, ProKeysEngineParameters,
        ProKeysStats>
    {
        protected const double DEFAULT_PRESS_TIME = -9999;

        public delegate void KeyStateChangeEvent(int key, bool isPressed);
        public delegate void OverhitEvent(int key);

        public KeyStateChangeEvent? OnKeyStateChange;

        public OverhitEvent? OnOverhit;

        // Used for hit logic. May not be the same value as KeyHeldMask
        public int KeyMask { get; protected set; }

        public int PreviousKeyMask { get; protected set; }

        protected double[] KeyPressTimes = new double[(int)ProKeysAction.Key25 + 1];

        /// <summary>
        /// The integer value for the key that was hit this update. <c>null</c> is none.
        /// </summary>
        protected int? KeyHit;

        /// <summary>
        /// The integer value for the key that was released this update. <c>null</c> is none.
        /// </summary>
        protected int? KeyReleased;

        protected int? FatFingerKey;

        protected EngineTimer ChordStaggerTimer;
        protected EngineTimer FatFingerTimer;

        protected ProKeysNote? FatFingerNote;

        protected ProKeysEngine(InstrumentDifficulty<ProKeysNote> chart, SyncTrack syncTrack,
            ProKeysEngineParameters engineParameters, bool isBot)
            : base(chart, syncTrack, engineParameters, true, isBot)
        {
            ChordStaggerTimer = new(engineParameters.ChordStaggerWindow);
            FatFingerTimer = new(engineParameters.FatFingerWindow);

            KeyPressTimes = new double[(int)ProKeysAction.Key25 + 1];
            for(int i = 0; i < KeyPressTimes.Length; i++)
            {
                KeyPressTimes[i] = -9999;
            }

            GetWaitCountdowns(Notes);
        }

        public EngineTimer GetChordStaggerTimer() => ChordStaggerTimer;
        public EngineTimer GetFatFingerTimer() => FatFingerTimer;

        public ReadOnlySpan<double> GetKeyPressTimes() => KeyPressTimes;

        protected override void GenerateQueuedUpdates(double nextTime)
        {
            base.GenerateQueuedUpdates(nextTime);
            var previousTime = CurrentTime;

            if (ChordStaggerTimer.IsActive)
            {
                if (IsTimeBetween(ChordStaggerTimer.EndTime, previousTime, nextTime))
                {
                    YargLogger.LogFormatTrace("Queuing chord stagger end time at {0}", ChordStaggerTimer.EndTime);
                    QueueUpdateTime(ChordStaggerTimer.EndTime, "Chord Stagger End");
                }
            }

            if (FatFingerTimer.IsActive)
            {
                if (IsTimeBetween(FatFingerTimer.EndTime, previousTime, nextTime))
                {
                    YargLogger.LogFormatTrace("Queuing fat finger end time at {0}", FatFingerTimer.EndTime);
                    QueueUpdateTime(FatFingerTimer.EndTime, "Fat Finger End");
                }
            }
        }

        public override void Reset(bool keepCurrentButtons = false)
        {
            KeyMask = 0;

            for(int i = 0; i < KeyPressTimes.Length; i++)
            {
                KeyPressTimes[i] = -9999;
            }

            KeyHit = null;
            KeyReleased = null;

            FatFingerKey = null;

            ChordStaggerTimer.Disable();
            FatFingerTimer.Disable();

            FatFingerNote = null;

            base.Reset(keepCurrentButtons);
        }

        protected virtual void Overhit(int key)
        {
            // Can't overstrum before first note is hit/missed
            if (NoteIndex == 0)
            {
                return;
            }

            // Cancel overstrum if past last note and no active sustains
            if (NoteIndex >= Chart.Notes.Count && ActiveSustains.Count == 0)
            {
                return;
            }

            // Cancel overstrum if WaitCountdown is active
            if (IsWaitCountdownActive)
            {
                YargLogger.LogFormatTrace("Overstrum prevented during WaitCountdown at time: {0}, tick: {1}", CurrentTime, CurrentTick);
                return;
            }

            YargLogger.LogFormatTrace("Overhit at {0}", CurrentTime);

            // Break all active sustains
            for (int i = 0; i < ActiveSustains.Count; i++)
            {
                var sustain = ActiveSustains[i];
                ActiveSustains.RemoveAt(i);
                YargLogger.LogFormatTrace("Ended sustain (end time: {0}) at {1}", sustain.GetEndTime(SyncTrack, 0), CurrentTime);
                i--;

                double finalScore = CalculateSustainPoints(ref sustain, CurrentTick);
                EngineStats.CommittedScore += (int) Math.Ceiling(finalScore);
                OnSustainEnd?.Invoke(sustain.Note, CurrentTime, sustain.HasFinishedScoring);
            }

            if (NoteIndex < Notes.Count)
            {
                // Don't remove the phrase if the current note being overstrummed is the start of a phrase
                if (!Notes[NoteIndex].IsStarPowerStart)
                {
                    StripStarPower(Notes[NoteIndex]);
                }
            }

            ResetCombo();
            EngineStats.Overhits++;

            UpdateMultiplier();

            OnOverhit?.Invoke(key);
        }

        protected override bool CanSustainHold(ProKeysNote note)
        {
            return (KeyMask & note.DisjointMask) != 0;
        }

        protected override void HitNote(ProKeysNote note)
        {
            if (note.WasHit || note.WasMissed)
            {
                YargLogger.LogFormatTrace("Tried to hit/miss note twice (Key: {0}, Index: {1}, Hit: {2}, Missed: {3})",
                    note.Key, NoteIndex, note.WasHit, note.WasMissed);
                return;
            }

            bool partiallyHit = false;
            foreach(var child in note.ParentOrSelf.AllNotes)
            {
                if (child.WasHit || child.WasMissed)
                {
                    partiallyHit = true;
                    break;
                }
            }

            note.SetHitState(true, false);

            KeyPressTimes[note.Key] = DEFAULT_PRESS_TIME;

            // Detect if the last note(s) were skipped
            // bool skipped = SkipPreviousNotes(note);

            if (note.IsStarPower && note.IsStarPowerEnd && note.ParentOrSelf.WasFullyHit())
            {
                AwardStarPower(note);
                EngineStats.StarPowerPhrasesHit++;
            }

            if (note.IsSoloStart)
            {
                StartSolo();
            }

            if (IsSoloActive)
            {
                Solos[CurrentSoloIndex].NotesHit++;
            }

            if (note.IsSoloEnd && note.ParentOrSelf.WasFullyHitOrMissed())
            {
                EndSolo();
            }

            if (note.ParentOrSelf.WasFullyHit())
            {
                ChordStaggerTimer.Disable();
            }

            // Only increase combo for the first note in a chord
            if (!partiallyHit)
            {
                IncrementCombo();
            }

            EngineStats.NotesHit++;

            UpdateMultiplier();

            AddScore(note);

            if (note.IsSustain)
            {
                StartSustain(note);
            }

            OnNoteHit?.Invoke(NoteIndex, note);
            base.HitNote(note);
        }

        protected override void MissNote(ProKeysNote note)
        {
            if (note.WasHit || note.WasMissed)
            {
                YargLogger.LogFormatTrace("Tried to hit/miss note twice (Key: {0}, Index: {1}, Hit: {2}, Missed: {3})",
                    note.Key, NoteIndex, note.WasHit, note.WasMissed);
                return;
            }

            note.SetMissState(true, false);

            KeyPressTimes[note.Key] = DEFAULT_PRESS_TIME;

            if (note.IsStarPower)
            {
                StripStarPower(note);
            }

            if (note.IsSoloEnd && note.ParentOrSelf.WasFullyHitOrMissed())
            {
                EndSolo();
            }

            if (note.IsSoloStart)
            {
                StartSolo();
            }

            // If no notes within a chord were hit, combo is 0
            if (note.ParentOrSelf.WasFullyMissed())
            {
                ResetCombo();
            }
            else
            {
                // If any of the notes in a chord were hit, the combo for that note is rewarded, but it is reset back to 1
                ResetCombo();
                IncrementCombo();
            }

            UpdateMultiplier();

            OnNoteMissed?.Invoke(NoteIndex, note);
            base.HitNote(note);
        }

        protected override void AddScore(ProKeysNote note)
        {
            AddScore(POINTS_PER_PRO_NOTE);
            EngineStats.NoteScore += POINTS_PER_NOTE;
        }

        protected sealed override int CalculateBaseScore()
        {
            int score = 0;
            foreach (var note in Notes)
            {
                score += POINTS_PER_PRO_NOTE * (1 + note.ChildNotes.Count);

                foreach (var child in note.AllNotes)
                {
                    score += (int) Math.Ceiling(child.TickLength / TicksPerSustainPoint);
                }
            }

            return score;
        }

        protected void ToggleKey(int key, bool active)
        {
            KeyMask = active ? KeyMask | (1 << key) : KeyMask & ~(1 << key);
        }

        protected bool IsKeyInTime(ProKeysNote note, int key, double frontEnd)
        {
            return KeyPressTimes[key] > note.Time + frontEnd;
        }

        protected bool IsKeyInTime(ProKeysNote note, double frontEnd) => IsKeyInTime(note, note.Key, frontEnd);
    }
}
</file>

<file path="Engine/ProKeys/ProKeysEngineParameters.cs">
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.IO;

namespace YARG.Core.Engine.ProKeys
{
    public class ProKeysEngineParameters : BaseEngineParameters
    {
        public readonly double ChordStaggerWindow;

        public readonly double FatFingerWindow;

        public ProKeysEngineParameters(HitWindowSettings hitWindow, int maxMultiplier, double spWhammyBuffer,
            double sustainDropLeniency, float[] starMultiplierThresholds, double chordStaggerWindow, double fatFingerWindow)
            : base(hitWindow, maxMultiplier, spWhammyBuffer, sustainDropLeniency, starMultiplierThresholds)
        {
            ChordStaggerWindow = chordStaggerWindow;
            FatFingerWindow = fatFingerWindow;
        }

        public ProKeysEngineParameters(ref FixedArrayStream stream, int version)
            : base(ref stream, version)
        {
            ChordStaggerWindow = stream.Read<double>(Endianness.Little);
            FatFingerWindow = stream.Read<double>(Endianness.Little);
        }

        public override void Serialize(BinaryWriter writer)
        {
            base.Serialize(writer);

            writer.Write(ChordStaggerWindow);
            writer.Write(FatFingerWindow);
        }

        public override string ToString()
        {
            return
                $"{base.ToString()}\n" +
                $"Chord stagger window: {ChordStaggerWindow}\n" +
                $"Fat finger window: {FatFingerWindow}";
        }
    }
}
</file>

<file path="Engine/ProKeys/ProKeysStats.cs">
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.IO;
using YARG.Core.Replays;

namespace YARG.Core.Engine.ProKeys
{
    public class ProKeysStats : BaseStats
    {
        /// <summary>
        /// Number of overhits which have occurred.
        /// </summary>
        public int Overhits;

        public ProKeysStats()
        {
        }

        public ProKeysStats(ProKeysStats stats) : base(stats)
        {
            Overhits = stats.Overhits;
        }

        public ProKeysStats(ref FixedArrayStream stream, int version)
            : base(ref stream, version)
        {
            Overhits = stream.Read<int>(Endianness.Little);
        }

        public override void Reset()
        {
            base.Reset();
            Overhits = 0;
        }

        public override void Serialize(BinaryWriter writer)
        {
            base.Serialize(writer);

            writer.Write(Overhits);
        }

        public override ReplayStats ConstructReplayStats(string name)
        {
            return new ProKeysReplayStats(name, this);
        }
    }
}
</file>

<file path="Engine/ProKeys/ProKeysUtilities.cs">
using System;

namespace YARG.Core.Engine.ProKeys
{
    public static class ProKeysUtilities
    {
        /*

         One octave of piano key indices for reference (in hex):
          ________________________________
         |  |#| |#|  |  |#| |#| |#|  |   |
         |  |1| |3|  |  |6| |8| |A|  |   |
         | 0 | 2 | 4 | 5 | 7 | 9 | B | 0 |
         |___|___|___|___|___|___|___|___|
         ^----------^ ^-------------^
          Lower Half    Upper Half

        */

        /// <returns>
        /// Whether or not the specified note index is a black key.
        /// </returns>
        /// <param name="noteIndex">The note index of the key mod 12.</param>
        public static bool IsBlackKey(int noteIndex)
        {
            return noteIndex is 1 or 3 or 6 or 8 or 10;
        }

        /// <returns>
        /// Whether or not the specified note index is a white key.
        /// </returns>
        /// <param name="noteIndex">The note index of the key mod 12.</param>
        public static bool IsWhiteKey(int noteIndex)
        {
            return !IsBlackKey(noteIndex);
        }

        /// <return>
        /// <c>true</c> if there is a missing black key (gap) between the specified black key
        /// and the next one.
        /// </return>
        /// <param name="noteIndex">The note index of the key mod 12.</param>
        public static bool IsGapOnNextBlackKey(int noteIndex)
        {
            return noteIndex is 3 or 10;
        }

        /// <return>
        /// <c>true</c> if the specified key is on the lower half of the octave.
        /// </return>
        /// <param name="noteIndex">The note index of the key mod 12.</param>
        public static bool IsLowerHalfKey(int noteIndex)
        {
            return noteIndex is >= 0 and <= 4;
        }

        /// <return>
        /// <c>true</c> if the specified key is on the upper half of the octave.
        /// </return>
        /// <param name="noteIndex">The note index of the key mod 12.</param>
        public static bool IsUpperHalfKey(int noteIndex)
        {
            return !IsLowerHalfKey(noteIndex);
        }

        public static bool IsAdjacentKey(int noteIndex, int adjacentNoteIndex)
        {
            var difference = Math.Abs(adjacentNoteIndex - noteIndex);

            if (difference == 1)
            {
                return true;
            }

            if (IsWhiteKey(noteIndex))
            {
                if (IsWhiteKey(adjacentNoteIndex) && difference == 2)
                {
                    return true;
                }
            } else if (IsBlackKey(noteIndex))
            {
                if (IsBlackKey(adjacentNoteIndex) && difference == 2)
                {
                    return true;
                }
            }

            return false;
        }
    }
}
</file>

<file path="Engine/Vocals/Engines/YargVocalsEngine.cs">
using System;
using YARG.Core.Chart;
using YARG.Core.Input;
using YARG.Core.Logging;

namespace YARG.Core.Engine.Vocals.Engines
{
    public class YargVocalsEngine : VocalsEngine
    {
        public YargVocalsEngine(InstrumentDifficulty<VocalNote> chart, SyncTrack syncTrack,
            VocalsEngineParameters engineParameters, bool isBot)
            : base(chart, syncTrack, engineParameters, isBot)
        {
        }

        protected override void UpdateBot(double songTime)
        {
            if (!IsBot)
            {
                return;
            }

            var phrase = Notes[NoteIndex];

            // Handle singing notes
            var singNote = GetNoteInPhraseAtSongTick(phrase, CurrentTick);
            if (singNote is not null)
            {
                // Bots are queued extra updates to account for in-between "inputs"
                PitchSang = singNote.PitchAtSongTime(songTime);
                HasSang = true;
                OnSing?.Invoke(true);
            }
            else
            {
                // Stop hitting to prevent the hit particles from showing up too much
                OnHit?.Invoke(false);
            }

            // Handle percussion notes
            var percussion = GetNextPercussionNote(phrase, CurrentTick);
            if (percussion is not null && songTime >= percussion.Time)
            {
                HasHit = true;
            }
        }

        protected override void MutateStateWithInput(GameInput gameInput)
        {
            var action = gameInput.GetAction<VocalsAction>();

            if (action is VocalsAction.Hit && gameInput.Button)
            {
                HasHit = true;
            }
            else if (action is VocalsAction.Pitch)
            {
                HasSang = true;
                PitchSang = gameInput.Axis;

                OnSing?.Invoke(true);
            }
            else if (action is VocalsAction.StarPower)
            {
                IsStarPowerInputActive = gameInput.Button;
            }
        }

        protected override void UpdateHitLogic(double time)
        {
            UpdateStarPower();

            // Quit early if there are no notes left
            if (NoteIndex >= Notes.Count)
            {
                HasSang = false;
                return;
            }

            UpdateBot(time);

            var phrase = Notes[NoteIndex];
            PhraseTicksTotal ??= GetTicksInPhrase(phrase);

            CheckForNoteHit();

            // Check for the end of a phrase
            if (CurrentTick > phrase.TickEnd)
            {
                bool hasNotes = PhraseTicksTotal.Value != 0;

                var percentHit = PhraseTicksHit / PhraseTicksTotal.Value;
                if (!hasNotes)
                {
                    percentHit = 1.0;
                }

                bool hit = percentHit >= EngineParameters.PhraseHitPercent;
                if (hit)
                {
                    EngineStats.TicksHit += PhraseTicksTotal.Value;
                    HitNote(phrase);
                }
                else
                {
                    var ticksHit = (uint) Math.Round(PhraseTicksHit);

                    EngineStats.TicksHit += ticksHit;
                    EngineStats.TicksMissed += PhraseTicksTotal.Value - ticksHit;

                    MissNote(phrase, percentHit);
                }

                PhraseTicksHit = 0;
                PhraseTicksTotal = null;

                if (hasNotes)
                {
                    OnPhraseHit?.Invoke(percentHit / EngineParameters.PhraseHitPercent, hit);
                }
            }
        }

        protected override void CheckForNoteHit()
        {
            CheckSingingHit();
            CheckPercussionHit();
        }

        private void CheckSingingHit()
        {
            if (!HasSang)
            {
                return;
            }

            HasSang = false;
            var lastSingTick = LastSingTick;
            LastSingTick = CurrentTick;

            // If the last sing detected was on the same tick (or less), skip it
            // since we've already handled that tick.
            if (lastSingTick >= CurrentTick)
            {
                return;
            }

            var phrase = Notes[NoteIndex];

            // Get the note that we should currently be targeting
            var note = GetNoteInPhraseAtSongTick(phrase, CurrentTick);
            if (note is null)
            {
                // If we're not on a note, we cannot be hitting a note
                OnHit?.Invoke(false);

                return;
            }

            OnTargetNoteChanged?.Invoke(note);

            // This will never be a percussion note here
            if (CanVocalNoteBeHit(note, out float hitPercent))
            {
                // We will apply a leniency here and assume that it will also hit all other
                // ticks, since the user cannot change pitch between inputs.
                var maxLeniency = 1.0 / EngineParameters.ApproximateVocalFps;
                var lastTick = Math.Max(
                    SyncTrack.TimeToTick(CurrentTime - maxLeniency),
                    lastSingTick);

                var ticksSinceLast = CurrentTick - lastTick;
                PhraseTicksHit += ticksSinceLast * hitPercent;

                OnHit?.Invoke(true);
            }
            else
            {
                OnHit?.Invoke(false);
            }
        }

        private void CheckPercussionHit()
        {
            var phrase = Notes[NoteIndex];
            var note = GetNextPercussionNote(phrase, CurrentTick);

            if (note is not null)
            {
                if (IsNoteInWindow(note, out var missed))
                {
                    if (HasHit)
                    {
                        HitNote(note);
                    }
                }
                else if (missed)
                {
                    // Miss out the back end
                    MissNote(note);
                }
            }
            else
            {
                // Singing (or any noise) can result in a call to CheckPercussionHit() as well, so we need to check SingToActivateStarPower here.
                if (HasHit && CanStarPowerActivate && EngineParameters.SingToActivateStarPower)
                {
                    ActivateStarPower();
                }
            }

            HasHit = false;
        }

        protected override bool CanVocalNoteBeHit(VocalNote note, out float hitPercent)
        {
            // If it is non-pitched, it is always hittable
            if (note.IsNonPitched)
            {
                hitPercent = 1f;
                return true;
            }

            var expectedPitch = note.PitchAtSongTime(CurrentTime);

            // Formula for calculating the distance to the expected pitch, while ignoring octaves
            float distanceToExpected = Math.Min(
                Mod(PitchSang - expectedPitch, 12f),
                Mod(expectedPitch - PitchSang, 12f));

            // If it is within the full points window, award full points
            if (distanceToExpected <= EngineParameters.PitchWindowPerfect)
            {
                hitPercent = 1f;
                return true;
            }

            // If it is outside of the total pitch window, then award no points
            if (distanceToExpected > EngineParameters.PitchWindow)
            {
                hitPercent = 0f;
                return false;
            }

            hitPercent = YargMath.InverseLerpF(
                EngineParameters.PitchWindow,
                EngineParameters.PitchWindowPerfect,
                distanceToExpected);
            return true;

            // Positive remainder
            static float Mod(float a, float b)
            {
                var remainder = a % b;
                if (remainder < 0)
                {
                    if (b < 0)
                    {
                        return remainder - b;
                    }

                    return remainder + b;
                }

                return remainder;
            }
        }

        protected override bool CanNoteBeHit(VocalNote note) => throw new NotImplementedException();
    }
}
</file>

<file path="Engine/Vocals/VocalsEngine.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using YARG.Core.Chart;
using YARG.Core.Logging;

namespace YARG.Core.Engine.Vocals
{
    public abstract class VocalsEngine :
        BaseEngine<VocalNote, VocalsEngineParameters, VocalsStats>
    {
        protected const int POINTS_PER_PERCUSSION = 100;

        public delegate void TargetNoteChangeEvent(VocalNote targetNote);

        public delegate void PhraseHitEvent(double hitPercentAfterParams, bool fullPoints);

        public TargetNoteChangeEvent? OnTargetNoteChanged;

        public Action<bool>? OnSing;
        public Action<bool>? OnHit;

        public PhraseHitEvent? OnPhraseHit;

        /// <summary>
        /// Whether or not the player/bot has hit their mic in the current update.
        /// </summary>
        protected bool HasHit;

        /// <summary>
        /// Whether or not the player/bot sang in the current update.
        /// </summary>
        protected bool HasSang;

        /// <summary>
        /// The float value for the last pitch sang (as a MIDI note).
        /// </summary>
        public float PitchSang { get; protected set; }

        /// <summary>
        /// The amount of ticks in the current phrase.
        /// </summary>
        public uint? PhraseTicksTotal { get; protected set; }

        /// <summary>
        /// The amount of ticks hit in the current phrase.
        /// This is a decimal since you can get fractions of a point for singing slightly off.
        /// </summary>
        public double PhraseTicksHit { get; protected set; }

        /// <summary>
        /// The last tick where there was a successful sing input.
        /// </summary>
        public uint LastSingTick { get; protected set; }

        protected VocalsEngine(InstrumentDifficulty<VocalNote> chart, SyncTrack syncTrack,
            VocalsEngineParameters engineParameters, bool isBot)
            : base(chart, syncTrack, engineParameters, false, isBot)
        {
        }

        public override void Reset(bool keepCurrentButtons = false)
        {
            HasSang = false;
            PitchSang = 0f;

            PhraseTicksTotal = null;
            PhraseTicksHit = 0;

            LastSingTick = 0;

            base.Reset(keepCurrentButtons);
        }

        public void BuildCountdownsFromSelectedPart()
        {
            // Vocals selected, build countdowns from solo vocals line only
            GetWaitCountdowns(Notes);
        }

        public void BuildCountdownsFromAllParts(List<VocalsPart> allParts)
        {
            // Get notes from all available vocals parts
            var allNotes = new List<VocalNote>();

            for (int p = 0; p < allParts.Count; p++)
            {
                allNotes.AddRange(allParts[p].CloneAsInstrumentDifficulty().Notes);
            }

            if (allParts.Count > 1)
            {
                // Sort combined list by Note time
                allNotes.Sort((a, b) => (int)(a.Tick - b.Tick));
            }

            GetWaitCountdowns(allNotes);
        }

        protected override void GenerateQueuedUpdates(double nextTime)
        {
            base.GenerateQueuedUpdates(nextTime);
            var previousTime = CurrentTime;

            // For bots, queue up updates every approximate vocal input frame to simulate
            // a stream of inputs. Make sure that the previous time has been properly set.
            if (IsBot && previousTime > 0.0)
            {
                double timeForFrame = 1.0 / EngineParameters.ApproximateVocalFps;
                int nextUpdateIndex = (int) Math.Floor(previousTime / timeForFrame) + 1;
                double nextUpdateTime = nextUpdateIndex * EngineParameters.ApproximateVocalFps;

                for (double time = nextUpdateTime; time < nextTime; time += timeForFrame)
                {
                    QueueUpdateTime(time, "Bot Input");
                }
            }
        }

        protected override void HitNote(VocalNote note)
        {
            note.SetHitState(true, false);

            if (note.IsPercussion)
            {
                AddScore(note);
                OnNoteHit?.Invoke(NoteIndex, note);
            }
            else
            {
                if (note.IsStarPower)
                {
                    AwardStarPower(note);
                    EngineStats.StarPowerPhrasesHit++;
                }

                if (note.IsSoloStart)
                {
                    StartSolo();
                }

                if (IsSoloActive)
                {
                    Solos[CurrentSoloIndex].NotesHit++;
                }

                if (note.IsSoloEnd)
                {
                    EndSolo();
                }

                // If there aren't any ticks in the phrase, then don't add
                // any score or update the multiplier.
                var ticks = GetTicksInPhrase(note);
                if (ticks != 0)
                {
                    IncrementCombo();

                    AddScore(note);

                    UpdateMultiplier();
                }

                // No matter what, we still wanna count this as a phrase hit though
                EngineStats.NotesHit++;

                OnNoteHit?.Invoke(NoteIndex, note);

                // I want to call base.HitNote here, but I have no idea how vocals handles hit state so I'm scared to
                NoteIndex++;
            }
        }

        protected override void MissNote(VocalNote note)
        {
            if (note.IsPercussion)
            {
                note.SetMissState(true, false);
                OnNoteMissed?.Invoke(NoteIndex, note);
            }
            else
            {
                MissNote(note, 0);
            }
        }

        protected void MissNote(VocalNote note, double hitPercent)
        {
            note.SetMissState(true, false);

            if (note.IsStarPower)
            {
                StripStarPower(note);
            }

            if (note.IsSoloEnd)
            {
                EndSolo();
            }
            if (note.IsSoloStart)
            {
                StartSolo();
            }

            ResetCombo();

            AddPartialScore(hitPercent);

            UpdateMultiplier();

            OnNoteMissed?.Invoke(NoteIndex, note);

            // I want to call base.MissNote here, but I have no idea how vocals handles miss state so I'm scared to
            NoteIndex++;
        }

        /// <summary>
        /// Checks if the given vocal note can be hit with the current input
        /// </summary>
        /// <param name="note">The note to attempt to hit.</param>
        /// <param name="hitPercent">The hit percent of the note (0 to 1).</param>
        protected abstract bool CanVocalNoteBeHit(VocalNote note, out float hitPercent);

        /// <returns>
        /// Gets the amount of ticks in the phrase.
        /// </returns>
        protected static uint GetTicksInPhrase(VocalNote phrase)
        {
            uint totalTime = 0;
            foreach (var phraseNote in phrase.ChildNotes)
            {
                if (phraseNote.IsPercussion)
                {
                    continue;
                }

                totalTime += phraseNote.TotalTickLength;
            }

            return totalTime;
        }

        /// <returns>
        /// The note in the specified <paramref name="phrase"/> at the specified song <paramref name="tick"/>.
        /// </returns>
        protected static VocalNote? GetNoteInPhraseAtSongTick(VocalNote phrase, uint tick)
        {
            return phrase
                .ChildNotes
                .FirstOrDefault(phraseNote =>
                    !phraseNote.IsPercussion &&
                    tick >= phraseNote.Tick &&
                    tick <= phraseNote.TotalTickEnd);
        }

        protected static VocalNote? GetNextPercussionNote(VocalNote phrase, uint tick)
        {
            foreach (var note in phrase.ChildNotes)
            {
                // Skip sang vocal notes
                if (!note.IsPercussion && note.Tick < tick)
                {
                    continue;
                }

                // Skip hit/missed percussion notes
                if (note.IsPercussion && (note.WasHit || note.WasMissed))
                {
                    continue;
                }

                // If the next note in the phrase is not a percussion note, then
                // we can't hit the note until the note before it is done.
                if (!note.IsPercussion)
                {
                    return null;
                }

                // Otherwise, we found it!
                return note;
            }

            return null;
        }

        protected override void AddScore(VocalNote note)
        {
            if (note.IsPercussion)
            {
                AddScore(POINTS_PER_PERCUSSION);
                EngineStats.NoteScore += POINTS_PER_PERCUSSION;
            }
            else
            {
                AddScore(EngineParameters.PointsPerPhrase);
                EngineStats.NoteScore += EngineParameters.PointsPerPhrase;
            }
        }

        protected void AddPartialScore(double hitPercent)
        {
            int score = (int) Math.Round(EngineParameters.PointsPerPhrase * hitPercent);
            AddScore(score);
        }

        protected override void UpdateMultiplier()
        {
            EngineStats.ScoreMultiplier = Math.Min(EngineStats.Combo + 1, 4);

            if (EngineStats.IsStarPowerActive)
            {
                EngineStats.ScoreMultiplier *= 2;
            }
        }

        protected sealed override int CalculateBaseScore()
        {
            return Notes.Where(note => note.ChildNotes.Count > 0).Sum(_ => EngineParameters.PointsPerPhrase);
        }

        protected override bool CanSustainHold(VocalNote note) => throw new InvalidOperationException();
    }
}
</file>

<file path="Engine/Vocals/VocalsEngineParameters.cs">
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.IO;

namespace YARG.Core.Engine.Vocals
{
    public class VocalsEngineParameters : BaseEngineParameters
    {
        /// <summary>
        /// The total size of the pitch window. If the player sings outside of it, no hit
        /// percent is awarded.
        /// </summary>
        public readonly float PitchWindow;

        /// <summary>
        /// The total size of the pitch window that awards full points. If the player sings
        /// outside of it while in the normal pitch window, the amount of fill percent
        /// awarded will decrease gradually.
        /// </summary>
        public readonly float PitchWindowPerfect;

        /// <summary>
        /// The percent of ticks that have to be correct in a phrase for it to count for full points.
        /// </summary>
        public readonly double PhraseHitPercent;

        /// <summary>
        /// How often the vocals give a pitch reading (approximately). This is used to determine
        /// the leniency for hit ticks.
        /// </summary>
        public readonly double ApproximateVocalFps;

        /// <summary>
        /// Whether or not the player can sing to activate starpower.
        /// </summary>
        public readonly bool SingToActivateStarPower;

        /// <summary>
        /// Base score awarded per complete vocal phrase.
        /// </summary>
        public readonly int PointsPerPhrase;

        public VocalsEngineParameters(HitWindowSettings hitWindow, int maxMultiplier, float[] starMultiplierThresholds,
            float pitchWindow, float pitchWindowPerfect, double phraseHitPercent, double approximateVocalFps,
            bool singToActivateStarPower, int pointsPerPhrase)
            : base(hitWindow, maxMultiplier, 0, 0, starMultiplierThresholds)
        {
            PitchWindow = pitchWindow;
            PitchWindowPerfect = pitchWindowPerfect;
            PhraseHitPercent = phraseHitPercent;
            ApproximateVocalFps = approximateVocalFps;
            SingToActivateStarPower = singToActivateStarPower;
            PointsPerPhrase = pointsPerPhrase;
        }

        public VocalsEngineParameters(ref FixedArrayStream stream, int version)
            : base(ref stream, version)
        {
            PitchWindow = stream.Read<float>(Endianness.Little);
            PitchWindowPerfect = stream.Read<float>(Endianness.Little);
            PhraseHitPercent = stream.Read<double>(Endianness.Little);
            ApproximateVocalFps = stream.Read<double>(Endianness.Little);
            SingToActivateStarPower = stream.ReadBoolean();
            PointsPerPhrase = stream.Read<int>(Endianness.Little);
        }

        public override void Serialize(BinaryWriter writer)
        {
            base.Serialize(writer);

            writer.Write(PitchWindow);
            writer.Write(PitchWindowPerfect);
            writer.Write(PhraseHitPercent);
            writer.Write(ApproximateVocalFps);
            writer.Write(SingToActivateStarPower);
            writer.Write(PointsPerPhrase);
        }
    }
}
</file>

<file path="Engine/Vocals/VocalsStats.cs">
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.IO;
using YARG.Core.Replays;

namespace YARG.Core.Engine.Vocals
{
    public class VocalsStats : BaseStats
    {
        /// <summary>
        /// The amount of note ticks that was hit by the vocalist.
        /// </summary>
        public uint TicksHit;

        /// <summary>
        /// The amount of note ticks that were missed by the vocalist.
        /// </summary>
        public uint TicksMissed;

        /// <summary>
        /// The total amount of note ticks.
        /// </summary>
        public uint TotalTicks => TicksHit + TicksMissed;

        public override float Percent => TotalTicks == 0 ? 1f : (float) TicksHit / TotalTicks;

        public override int BandComboUnits => 10;

        public VocalsStats()
        {
        }

        public VocalsStats(VocalsStats stats) : base(stats)
        {
            TicksHit = stats.TicksHit;
            TicksMissed = stats.TicksMissed;
        }

        public VocalsStats(ref FixedArrayStream stream, int version)
            : base(ref stream, version)
        {
            TicksHit = stream.Read<uint>(Endianness.Little);
            TicksMissed = stream.Read<uint>(Endianness.Little);
        }

        public override void Reset()
        {
            base.Reset();
            TicksHit = 0;
            TicksMissed = 0;
        }

        public override void Serialize(BinaryWriter writer)
        {
            base.Serialize(writer);

            writer.Write(TicksHit);
            writer.Write(TicksMissed);
        }

        public override ReplayStats ConstructReplayStats(string name)
        {
            return new VocalsReplayStats(name, this);
        }
    }
}
</file>

<file path="Engine/BandComboType.cs">
namespace YARG.Core.Engine
{
    public enum BandComboType
    {
        Off,
        Lenient,
        Strict
    }
}
</file>

<file path="Engine/BaseEngine.cs">
using System;
using System.Collections.Generic;
using YARG.Core.Chart;
using YARG.Core.Input;
using YARG.Core.Logging;

namespace YARG.Core.Engine
{
    public abstract class BaseEngine
    {
        protected const int POINTS_PER_NOTE     = 50;
        protected const int POINTS_PER_PRO_NOTE = POINTS_PER_NOTE + 10;
        protected const int POINTS_PER_BEAT     = 25;

        // Max number of measures that SP will last when draining
        // SP draining is done based on measures
        protected const int STAR_POWER_MAX_MEASURES = 8;

        // Max number of beats that it takes to fill SP when gaining
        // SP gain from whammying is done based on beats
        protected const int STAR_POWER_MAX_BEATS = (STAR_POWER_MAX_MEASURES * 4) - 2; // - 2 for leniency

        // Beat fraction to use for the sustain burst threshold
        protected const int SUSTAIN_BURST_FRACTION = 4;

        public delegate void StarPowerStatusEvent(bool active);
        public delegate void SoloStartEvent(SoloSection soloSection);
        public delegate void SoloEndEvent(SoloSection soloSection);
        public delegate void ComboResetEvent();
        public delegate void ComboIncrementEvent(int amount);

        public StarPowerStatusEvent? OnStarPowerStatus;
        public SoloStartEvent?       OnSoloStart;
        public SoloEndEvent?         OnSoloEnd;
        public ComboResetEvent?      OnComboReset;
        public ComboIncrementEvent?  OnComboIncrement;

        public bool IsInputQueued => InputQueue.Count > 0;

        public bool CanStarPowerActivate => BaseStats.StarPowerTickAmount >= TicksPerHalfSpBar;

        public int BaseScore { get; protected set; }

        public abstract BaseEngineParameters BaseParameters { get; }
        public abstract BaseStats            BaseStats      { get; }

        protected bool StarPowerIsAllowed = true;

        protected readonly SyncTrack SyncTrack;

        protected readonly uint Resolution;

        public readonly uint TicksPerQuarterSpBar;
        public readonly uint TicksPerHalfSpBar;
        public readonly uint TicksPerFullSpBar;

        protected List<SoloSection> Solos = new();

        protected List<WaitCountdown> WaitCountdowns = new();

        protected readonly Queue<GameInput> InputQueue = new();

        protected readonly List<SyncTrackChange> SyncTrackChanges = new();

        private readonly List<EngineFrameUpdate> _scheduledUpdates = new();

        private readonly List<double> _starPowerTempoTsTicks = new();

        public int NoteIndex { get; protected set; }

        public double CurrentTime { get; protected set; }
        public double LastUpdateTime { get; protected set; }

        public double LastQueuedInputTime { get; protected set; }

        public uint CurrentTick { get; protected set; }
        public uint LastTick { get; protected set; }

        public int CurrentSoloIndex { get; protected set; }
        public int CurrentStarIndex { get; protected set; }
        public int CurrentWaitCountdownIndex { get; protected set; }

        public bool IsSoloActive { get; protected set; }

        public bool IsWaitCountdownActive { get; protected set; }
        public bool IsStarPowerInputActive { get; protected set; }

        protected EngineTimer StarPowerWhammyTimer;

        public uint LastStarPowerWhammyTick { get; protected set; }

        public uint StarPowerTickPosition { get; protected set; }
        public uint PreviousStarPowerTickPosition { get; protected set; }

        public uint StarPowerTickActivationPosition { get; protected set; }
        public uint StarPowerTickEndPosition { get; protected set; }

        public double StarPowerActivationTime { get; protected set; }
        public double StarPowerEndTime { get; protected set; }

        public readonly struct EngineFrameUpdate
        {
            public EngineFrameUpdate(double time, string reason)
            {
                Time = time;
                Reason = reason;
            }

            public readonly double Time;
            public readonly string Reason;
        }

        /// <summary>
        /// Whether or not the specified engine should treat a note as a chord, or separately.
        /// For example, guitars would treat each note as a chord, where as drums would treat them
        /// as singular pieces.
        /// </summary>
        protected readonly bool TreatChordAsSeparate;

        protected bool ReRunHitLogic;

        protected readonly bool IsBot;

        protected int CurrentSyncIndex;

        protected int NextSyncIndex => CurrentSyncIndex + 1;

        protected SyncTrackChange CurrentSyncTrackState => SyncTrackChanges[CurrentSyncIndex];

        protected BaseEngine(SyncTrack syncTrack, bool isChordSeparate, bool isBot)
        {
            SyncTrack = syncTrack;
            Resolution = syncTrack.Resolution;

            TicksPerQuarterSpBar = (uint) Math.Round((double) STAR_POWER_MAX_BEATS / 4 * syncTrack.Resolution);
            TicksPerHalfSpBar = TicksPerQuarterSpBar * 2;
            TicksPerFullSpBar = TicksPerQuarterSpBar * 4;

            TreatChordAsSeparate = isChordSeparate;
            IsBot = isBot;

            int tsIndex = 0;
            int changeIndex = 0;
            for (int i = 0; i < syncTrack.Tempos.Count; i++)
            {
                var tempo = syncTrack.Tempos[i];
                var timeSignature = syncTrack.TimeSignatures[tsIndex];

                SyncTrackChanges.Add(new SyncTrackChange(changeIndex, tempo, timeSignature, tempo.Time, tempo.Tick));
                changeIndex++;

                uint nextTempoTick = i + 1 < syncTrack.Tempos.Count ? syncTrack.Tempos[i + 1].Tick : uint.MaxValue;
                for (int nextTsIndex = tsIndex + 1; nextTsIndex < syncTrack.TimeSignatures.Count; nextTsIndex++)
                {
                    var nextTs = syncTrack.TimeSignatures[nextTsIndex];
                    if (nextTs.Tick >= nextTempoTick)
                    {
                        break;
                    }

                    if (nextTs.Tick == tempo.Tick)
                    {
                        SyncTrackChanges[^1].TimeSignature = nextTs;
                    }
                    else
                    {
                        SyncTrackChanges.Add(new SyncTrackChange(changeIndex, tempo, nextTs, nextTs.Time,
                            nextTs.Tick));
                        changeIndex++;
                    }

                    tsIndex = nextTsIndex;
                }
            }

            _starPowerTempoTsTicks.Add(0);
            for (int i = 1; i < SyncTrackChanges.Count; i++)
            {
                var change = SyncTrackChanges[i];
                var prevChange = SyncTrackChanges[i - 1];

                double deltaTime = change.Time - prevChange.Time;

                var tempo = syncTrack.Tempos.GetPrevious(change.Tick - 1);
                var ts = syncTrack.TimeSignatures.GetPrevious(change.Tick - 1);

                // Calculate the number of star power ticks that occur during this tempo
                var starPowerTicks = GetStarPowerDrainPeriodToTicks(deltaTime, tempo!, ts!);
                _starPowerTempoTsTicks.Add(_starPowerTempoTsTicks[^1] + starPowerTicks);
            }

            CurrentSyncIndex = 0;
        }

        public EngineTimer GetStarPowerWhammyTimer() => StarPowerWhammyTimer;

        /// <summary>
        /// Gets the number of notes the engine recognizes in a specific note parent.
        /// This number is determined by <see cref="TreatChordAsSeparate"/>.
        /// </summary>
        public int GetNumberOfNotes<T>(T type) where T : Note<T>
        {
            return TreatChordAsSeparate ? type.ChildNotes.Count + 1 : 1;
        }

        protected uint GetCurrentTick(double time)
        {
            return SyncTrack.TimeToTick(time);
        }

        public void Update(double time)
        {
            YargLogger.LogFormatTrace("---- Starting update loop with time {0} ----", time);

            if (!IsBot)
            {
                ProcessInputs(time);
            }

            // Update to the given time
            if (InputQueue.Count > 0)
            {
                YargLogger.LogWarning("Input queue was not fully cleared!");
            }

            YargLogger.LogFormatTrace("Running frame update at {0}", time);
            RunQueuedUpdates(time);
            RunEngineLoop(time);
        }

        private void ProcessInputs(double time)
        {
            while (InputQueue.TryPeek(out var input))
            {
                // Stop here if the inputs are in the future
                if (input.Time > time)
                {
                    YargLogger.LogFormatWarning(
                        "Queued input is in the future! Time being updated to: {0}, input time: {1}", time, input.Time);
                    break;
                }

                // Dequeue this here so inputs that don't meet the above condition aren't completely skipped
                InputQueue.Dequeue();

                // Skip inputs that are in the past
                if (input.Time < CurrentTime)
                {
                    YargLogger.FailFormat(
                        "Queued input is in the past! Current time: {0}, input time: {1}", CurrentTime,
                        input.Time);
                    continue;
                }

                YargLogger.LogFormatTrace("Processing input {0} ({1}) update at {2}", input.GetAction<GuitarAction>(),
                    input.Button, input.Time);
                RunQueuedUpdates(input.Time);

                // Update engine state with input.
                MutateStateWithInput(input);

                // Run the engine.
                RunEngineLoop(input.Time);

                // Skip non-input update if possible
                if (input.Time == time)
                {
                    if (InputQueue.Count > 0)
                    {
                        YargLogger.LogWarning(
                            "Input queue was not fully cleared! Remaining inputs are possibly in the future");
                    }

                    return;
                }
            }
        }

        private void RunQueuedUpdates(double time)
        {
            // 'for' is used here to prevent enumeration exceptions,
            // the list of scheduled updates will be modified by the updates we're running

            GenerateQueuedUpdates(time);
            _scheduledUpdates.Sort((x, y) => x.Time.CompareTo(y.Time));

            if (_scheduledUpdates.Count > 0)
            {
                YargLogger.LogFormatTrace("{0} updates ready to be simulated", _scheduledUpdates.Count);
            }

            while (_scheduledUpdates.Count > 0)
            {
                double updateTime = _scheduledUpdates[0].Time;

                // Skip updates that are in the past
                if (updateTime < CurrentTime)
                {
                    YargLogger.FailFormat(
                        "Scheduled update is in the past! Current time: {0}, update time: {1}", CurrentTime,
                        updateTime);

                    _scheduledUpdates.RemoveAt(0);
                }

                // There should be no scheduled updates for times beyond the one we want to update to
                if (updateTime >= time)
                {
                    YargLogger.FailFormat("Update time is >= than the given time! Update time: {0}, given time: {1}",
                        updateTime, time);
                    break;
                }

                YargLogger.LogFormatTrace("Running scheduled update at {0} ({1})", updateTime,
                    item2: _scheduledUpdates[0].Reason);
                RunEngineLoop(updateTime);

                _scheduledUpdates.RemoveAt(0);

                // Generate updates up to the next existing update.
                // This is done to handle any updates that need to be queued if something changes.
                // (For example: a sustain starting then ending within the range of already existing updates)
                if (_scheduledUpdates.Count > 0)
                {
                    GenerateQueuedUpdates(_scheduledUpdates[0].Time);
                }
                else
                {
                    GenerateQueuedUpdates(time);
                }

                _scheduledUpdates.Sort((x, y) => x.Time.CompareTo(y.Time));
            }
        }

        protected abstract void UpdateBot(double time);

        protected virtual void GenerateQueuedUpdates(double nextTime)
        {
            YargLogger.LogFormatTrace("Generating queued updates up to {0}", nextTime);
            var previousTime = CurrentTime;

            if (BaseStats.IsStarPowerActive)
            {
                if (IsTimeBetween(StarPowerEndTime, previousTime, nextTime))
                {
                    YargLogger.LogFormatDebug("Queuing Star Power End Time at {0}", StarPowerEndTime);
                    QueueUpdateTime(StarPowerEndTime, "SP End Time");
                }
            }
        }

        protected abstract void UpdateTimeVariables(double time);

        /// <summary>
        /// Queue an input to be processed by the engine.
        /// </summary>
        /// <param name="input">The input to queue into the engine.</param>
        public void QueueInput(ref GameInput input)
        {
            // If the game attempts to queue an input that goes backwards in time, the engine
            // can't handle it and it will cause inconsistencies! In these rare cases, the
            // engine will be forced to move these times forwards a *tiny* bit to prevent
            // issues.

            // In the case that the queue is not in order...
            if (input.Time < LastQueuedInputTime)
            {
                YargLogger.LogFormatWarning(
                    "Engine was forced to move an input time! Previous queued input: {0}, input being queued: {1}",
                    LastQueuedInputTime, input.Time);

                input = new GameInput(LastQueuedInputTime, input.Action, input.Integer);
            }

            // In the case that the input is before the current time...
            if (input.Time < CurrentTime)
            {
                YargLogger.LogFormatWarning(
                    "Engine was forced to move an input time! Current time: {0}, input being queued: {1}",
                    CurrentTime, input.Time);

                input = new GameInput(CurrentTime, input.Action, input.Integer);
            }

            InputQueue.Enqueue(input);
            LastQueuedInputTime = input.Time;
        }

        public void QueueUpdateTime(double time, string reason)
        {
            // Ignore updates for the current time
            if (time == CurrentTime)
            {
                return;
            }

            // Disallow updates in the past
            if (time < CurrentTime)
            {
                YargLogger.FailFormat(
                    "Cannot queue update in the past! Current time: {0}, time being queued: {1}", CurrentTime,
                    time);
                return;
            }

            // Ignore duplicate updates
            foreach (var update in _scheduledUpdates)
            {
                if (update.Time == time)
                {
                    return;
                }
            }

            _scheduledUpdates.Add(new EngineFrameUpdate(time, reason));
        }

        private void RunEngineLoop(double time)
        {
            do
            {
                ReRunHitLogic = false;
                UpdateTimeVariables(time);
                UpdateHitLogic(time);
            } while (ReRunHitLogic);
        }

        public virtual void Reset(bool keepCurrentButtons = false)
        {
            NoteIndex = 0;

            CurrentTime = double.MinValue;
            LastUpdateTime = double.MinValue;

            LastQueuedInputTime = double.MinValue;

            CurrentTick = 0;
            LastTick = 0;

            CurrentSoloIndex = 0;
            CurrentStarIndex = 0;
            CurrentWaitCountdownIndex = 0;

            IsSoloActive = false;

            IsWaitCountdownActive = false;
            IsStarPowerInputActive = false;
        }

        protected abstract void MutateStateWithInput(GameInput gameInput);

        /// <summary>
        /// Executes engine logic with respect to the given time.
        /// </summary>
        /// <param name="time">The time in which to simulate hit logic at.</param>
        /// <returns>True if a note was updated (hit or missed). False if no changes.</returns>
        protected abstract void UpdateHitLogic(double time);

        protected virtual void UpdateMultiplier()
        {
            BaseStats.ScoreMultiplier = Math.Min((BaseStats.Combo / 10) + 1, BaseParameters.MaxMultiplier);

            if (BaseStats.IsStarPowerActive)
            {
                BaseStats.ScoreMultiplier *= 2;
            }
        }

        public double GetStarPowerBarAmount()
        {
            return BaseStats.StarPowerTickAmount / (double) TicksPerFullSpBar;
        }

        protected void ActivateStarPower()
        {
            if (BaseStats.IsStarPowerActive)
            {
                return;
            }

            StarPowerActivationTime = CurrentTime;
            StarPowerTickActivationPosition = StarPowerTickPosition;

            StarPowerTickEndPosition = StarPowerTickActivationPosition + BaseStats.StarPowerTickAmount;
            StarPowerEndTime = GetStarPowerDrainTickToTime(StarPowerTickEndPosition, CurrentSyncTrackState);

            BaseStats.StarPowerActivationCount++;

            YargLogger.LogFormatTrace("Activated at SP tick {0}, ends at SP tick {1}. Start time: {2}, End time: {3}",
                StarPowerTickActivationPosition, StarPowerTickEndPosition, StarPowerActivationTime, StarPowerEndTime);

            RebaseProgressValues(CurrentTick);
            BaseStats.IsStarPowerActive = true;

            UpdateMultiplier();
            OnStarPowerStatus?.Invoke(true);
        }

        protected void ReleaseStarPower()
        {
            YargLogger.LogFormatTrace("Star Power ended at {0} (tick: {1})", CurrentTime,
                StarPowerTickPosition);
            BaseStats.IsStarPowerActive = false;
            BaseStats.TimeInStarPower += CurrentTime - StarPowerActivationTime;

            RebaseProgressValues(CurrentTick);

            UpdateMultiplier();
            OnStarPowerStatus?.Invoke(false);
        }

        protected void GainStarPower(uint ticks)
        {
            var prevTicks = BaseStats.StarPowerTickAmount;
            BaseStats.StarPowerTickAmount += ticks;

            // Limit amount of ticks to a full bar.
            if (BaseStats.StarPowerTickAmount > TicksPerFullSpBar)
            {
                BaseStats.StarPowerTickAmount = TicksPerFullSpBar;
            }

            // Add the amount of ticks gained to the total ticks gained
            BaseStats.TotalStarPowerTicks += BaseStats.StarPowerTickAmount - prevTicks;
            BaseStats.TotalStarPowerBarsFilled = (double) BaseStats.TotalStarPowerTicks / TicksPerFullSpBar;

            if (BaseStats.IsStarPowerActive)
            {
                StarPowerTickEndPosition = StarPowerTickPosition + BaseStats.StarPowerTickAmount;
                StarPowerEndTime = GetStarPowerDrainTickToTime(StarPowerTickEndPosition, CurrentSyncTrackState);
                YargLogger.LogFormatTrace("New end tick and time: {0}, {1}", StarPowerTickEndPosition, StarPowerEndTime);
            }

            RebaseProgressValues(CurrentTick);
        }

        protected void DrainStarPower(uint starPowerTicks)
        {
            int newAmount = (int) BaseStats.StarPowerTickAmount - (int) starPowerTicks;

            if (newAmount <= 0)
            {
                newAmount = 0;
            }

            BaseStats.StarPowerTickAmount = (uint) newAmount;
        }

        protected virtual void UpdateStarPower()
        {
            PreviousStarPowerTickPosition = StarPowerTickPosition;
            StarPowerTickPosition = GetStarPowerDrainTimeToTicks(CurrentTime, CurrentSyncTrackState);

            if (BaseStats.IsStarPowerActive)
            {
                DrainStarPower(StarPowerTickPosition - PreviousStarPowerTickPosition);

                if (BaseStats.StarPowerTickAmount <= 0)
                {
                    ReleaseStarPower();
                }
            }

            if (IsStarPowerInputActive && CanStarPowerActivate)
            {
                ActivateStarPower();
            }
        }

        /// <summary>
        /// Calculates the drain to gain ratio for Star Power for a given <see cref="TimeSignatureChange"/>
        /// </summary>
        /// <param name="timeSignature"></param>
        /// <returns></returns>
        /// <remarks>
        /// The drain factor notes how much longer a game tick lasts during Star Power drain. If there are 192 game ticks
        /// and the drain factor was 1.6, then the Star Power drain would be 192/1.6 = 120 game ticks. This is the number of
        /// Star Power ticks that would be drained during the 192 game ticks.
        /// </remarks>
        private double GetStarPowerDrainFactor(TimeSignatureChange timeSignature)
        {
            var standardDrain = 4.0 / timeSignature.Denominator * timeSignature.Numerator * STAR_POWER_MAX_MEASURES;

            return standardDrain / STAR_POWER_MAX_BEATS;
        }

        /// <summary>
        /// Calculates the number of Star Power ticks that occur during a given period of time.
        /// </summary>
        /// <param name="period">Time period in seconds</param>
        /// <param name="tempo">Tempo to drain at</param>
        /// <param name="timeSignature">Time Signature to drain at</param>
        /// <returns></returns>
        private double GetStarPowerDrainPeriodToTicks(double period, TempoChange tempo,
            TimeSignatureChange timeSignature)
        {
            var drainFactor = GetStarPowerDrainFactor(timeSignature);

            // Amount of time in between each chart tick.
            var timePerTick = (double) tempo.SecondsPerBeat / Resolution;

            // Amount of time in between each star power tick during star power.
            var timePerStarPowerTick = timePerTick * drainFactor;

            var starPowerTicksInPeriod = period / timePerStarPowerTick;

            return starPowerTicksInPeriod;
        }

        private double GetStarPowerDrainTicksToPeriod(double ticks, TempoChange tempo, TimeSignatureChange timeSignature)
        {
            var drainFactor = GetStarPowerDrainFactor(timeSignature);

            // Amount of time in between each chart tick.
            var timePerTick = (double) tempo.SecondsPerBeat / Resolution;

            // Amount of time in between each star power tick during star power.
            var timePerStarPowerTick = timePerTick * drainFactor;

            // Inverse of PeriodToTicks
            var period = ticks * timePerStarPowerTick;

            return period;
        }

        private uint GetStarPowerDrainTimeToTicks(double time, SyncTrackChange change)
        {
            var tempo = change.Tempo;
            var ts = change.TimeSignature;

            // If the result is just truncated first, it can sometimes end up with the result rounding down when
            // it's extremely close to the next tick (i.e 1 bit off). This can cause it to be off by a whole tick.

            // Ticks can only go up to 2^32, which double can handle precisely to 6 decimal places.
            // This is why the result is rounded to 6 decimal places, then truncated to an integer.
            return (uint) Math.Round(GetStarPowerDrainPeriodToTicks(time - change.Time, tempo, ts) +
                _starPowerTempoTsTicks[change.Index], 6);
        }

        private double GetStarPowerDrainTickToTime(uint starPowerTick, SyncTrackChange currentSync)
        {
            // var change = SyncTrackChanges.GetPrevious(starPowerTick)!;
            // var tempo = change.Tempo;
            // var ts = change.TimeSignature;
            //
            // var offset = GetStarPowerDrainTicksToPeriod(starPowerTick - _starPowerTempoTsTicks[change.Index], tempo, ts);
            //
            // return change.Time + offset;

            var syncSpTick = _starPowerTempoTsTicks[currentSync.Index];

            int high = _starPowerTempoTsTicks.Count - 1;
            int low = 0;
            if (starPowerTick < syncSpTick)
            {
                high = currentSync.Index;
            }
            else if (starPowerTick > syncSpTick)
            {
                low = currentSync.Index;
            }

            while (low < high)
            {
                int mid = (low + high) / 2;
                if (_starPowerTempoTsTicks[mid] < starPowerTick)
                {
                    low = mid + 1;
                }
                else
                {
                    high = mid;
                }
            }

            // Get the change that the star power tick is in
            if (low < _starPowerTempoTsTicks.Count - 1)
            {
                low--;
            }

            var change = SyncTrackChanges[low];
            var tempo = change.Tempo;
            var ts = change.TimeSignature;

            var offset = GetStarPowerDrainTicksToPeriod(starPowerTick - _starPowerTempoTsTicks[change.Index], tempo, ts);

            return change.Time + offset;
        }

        protected virtual void RebaseProgressValues(uint baseTick)
        {

        }

        protected virtual void UpdateProgressValues(uint tick)
        {

        }

        public abstract void AllowStarPower(bool isAllowed);

        /// <summary>
        /// Resets the engine's state back to default and then processes the list of inputs up to the given time.
        /// </summary>
        /// <param name="time">Time to process up to.</param>
        /// <param name="inputs">List of inputs to execute against.</param>
        /// <returns>The input index that was processed up to.</returns>
        public int ProcessUpToTime(double time, IEnumerable<GameInput> inputs)
        {
            Reset();

            var inputIndex = 0;
            foreach (var input in inputs)
            {
                if (input.Time > time)
                {
                    break;
                }

                InputQueue.Enqueue(input);
                inputIndex++;
            }

            Update(time);

            return inputIndex;
        }

        public abstract (double FrontEnd, double BackEnd) CalculateHitWindow();

        public virtual void SetSpeed(double speed)
        {
            BaseParameters.SongSpeed = speed;
            BaseParameters.HitWindow.Scale = speed;

            StarPowerWhammyTimer.SetSpeed(speed);
        }

        protected static void StartTimer(ref EngineTimer timer, double startTime, double offset = 0)
        {
            if (offset > 0)
            {
                timer.StartWithOffset(startTime, offset);
            }
            else
            {
                timer.Start(startTime);
            }
        }

        protected static bool IsTimeBetween(double time, double prevTime, double nextTime)
        {
            return time > prevTime && time < nextTime;
        }

        protected void IncrementCombo()
        {
            BaseStats.Combo++;
            BaseStats.MaxCombo = Math.Max(BaseStats.MaxCombo, BaseStats.Combo);
            OnComboIncrement?.Invoke(BaseStats.BandComboUnits);
        }

        protected void ResetCombo()
        {
            BaseStats.Combo = 0;
            OnComboReset?.Invoke();
        }
    }
}
</file>

<file path="Engine/BaseEngine.Generic.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using YARG.Core.Chart;
using YARG.Core.Logging;
using YARG.Core.Utility;

namespace YARG.Core.Engine
{
    public abstract class BaseEngine<TNoteType, TEngineParams, TEngineStats> : BaseEngine
        where TNoteType : Note<TNoteType>
        where TEngineParams : BaseEngineParameters
        where TEngineStats : BaseStats, new()
    {
        // Max number of measures that SP will last when draining
        // SP draining is done based on measures
        protected const double STAR_POWER_MEASURE_AMOUNT = 1.0 / STAR_POWER_MAX_MEASURES;

        // Max number of beats that it takes to fill SP when gaining
        // SP gain from whammying is done based on beats
        protected const double STAR_POWER_BEAT_AMOUNT = 1.0 / STAR_POWER_MAX_BEATS;

        // Number of measures that SP phrases will grant when hit
        protected const int    STAR_POWER_PHRASE_MEASURE_COUNT = 2;
        protected const double STAR_POWER_PHRASE_AMOUNT = STAR_POWER_PHRASE_MEASURE_COUNT * STAR_POWER_MEASURE_AMOUNT;

        public delegate void NoteHitEvent(int noteIndex, TNoteType note);

        public delegate void NoteMissedEvent(int noteIndex, TNoteType note);

        public delegate void StarPowerPhraseHitEvent(TNoteType note);

        public delegate void StarPowerPhraseMissEvent(TNoteType note);

        public delegate void SustainStartEvent(TNoteType note);

        public delegate void SustainEndEvent(TNoteType note, double timeEnded, bool finished);

        public delegate void CountdownChangeEvent(int measuresLeft, double countdownLength, double endTime);

        public NoteHitEvent?    OnNoteHit;
        public NoteMissedEvent? OnNoteMissed;

        public StarPowerPhraseHitEvent?  OnStarPowerPhraseHit;
        public StarPowerPhraseMissEvent? OnStarPowerPhraseMissed;

        public SustainStartEvent? OnSustainStart;
        public SustainEndEvent?   OnSustainEnd;

        public CountdownChangeEvent? OnCountdownChange;

        protected SustainList<TNoteType> ActiveSustains = new(10);

        protected          int[]  StarScoreThresholds { get; }
        protected readonly double TicksPerSustainPoint;
        protected readonly uint   SustainBurstThreshold;

        public readonly TEngineStats EngineStats;

        protected readonly InstrumentDifficulty<TNoteType> Chart;

        protected readonly List<TNoteType> Notes;
        protected readonly TEngineParams   EngineParameters;

        public override BaseEngineParameters BaseParameters => EngineParameters;
        public override BaseStats            BaseStats      => EngineStats;

        protected BaseEngine(InstrumentDifficulty<TNoteType> chart, SyncTrack syncTrack,
            TEngineParams engineParameters, bool isChordSeparate, bool isBot)
            : base(syncTrack, isChordSeparate, isBot)
        {
            Chart = chart;
            Notes = Chart.Notes;
            EngineParameters = engineParameters;

            EngineStats = new TEngineStats();
            Reset();

            EngineStats.ScoreMultiplier = 1;
            if (TreatChordAsSeparate)
            {
                foreach (var note in Notes)
                {
                    EngineStats.TotalNotes += GetNumberOfNotes(note);
                }
            }
            else
            {
                EngineStats.TotalNotes = Notes.Count;
            }

            EngineStats.TotalStarPowerPhrases = Chart.Phrases.Count((phrase) => phrase.Type == PhraseType.StarPower);

            TicksPerSustainPoint = Resolution / (double) POINTS_PER_BEAT;
            SustainBurstThreshold = Resolution / SUSTAIN_BURST_FRACTION;

            // This method should only rely on the `Notes` property (which is assigned above).
            // ReSharper disable once VirtualMemberCallInConstructor
            BaseScore = CalculateBaseScore();

            float[] multiplierThresholds = engineParameters.StarMultiplierThresholds;
            StarScoreThresholds = new int[multiplierThresholds.Length];
            for (int i = 0; i < multiplierThresholds.Length; i++)
            {
                StarScoreThresholds[i] = (int) (BaseScore * multiplierThresholds[i]);
            }

            Solos = GetSoloSections();
        }

        protected override void GenerateQueuedUpdates(double nextTime)
        {
            base.GenerateQueuedUpdates(nextTime);
            var previousTime = CurrentTime;

            foreach (var sustain in ActiveSustains)
            {
                var burstTime = sustain.GetEndTime(SyncTrack, SustainBurstThreshold);
                var endTime = sustain.GetEndTime(SyncTrack, 0);

                var scaledDropLeniency = EngineParameters.SustainDropLeniency * EngineParameters.SongSpeed;
                var leniencyDropTime = sustain.LeniencyDropTime + scaledDropLeniency;

                if (sustain.IsLeniencyHeld && IsTimeBetween(leniencyDropTime, previousTime, nextTime))
                {
                    YargLogger.LogFormatTrace("Queuing sustain (tick: {0}) leniency drop time at {1}", sustain.Note.Tick,
                        leniencyDropTime);
                    QueueUpdateTime(leniencyDropTime, "Sustain Leniency Drop");
                }

                // Burst time is for scoring, so that scoring finishes at the correct time
                if (IsTimeBetween(burstTime, previousTime, nextTime))
                {
                    YargLogger.LogFormatTrace("Queuing sustain (tick: {0}) burst time at {1}", sustain.Note.Tick,
                        burstTime);
                    QueueUpdateTime(burstTime, "Sustain Burst");
                }

                // The true end of the sustain is for hit logic. Sustains are "kept" even after the burst ticks so must
                // also be handled.
                if (IsTimeBetween(endTime, previousTime, nextTime))
                {
                    YargLogger.LogFormatTrace("Queuing sustain (tick: {0}) end time at {1}", sustain.Note.Tick,
                        endTime);
                    QueueUpdateTime(endTime, "Sustain End");
                }
            }

            for (int i = NoteIndex; i < Notes.Count; i++)
            {
                var note = Notes[i];

                var hitWindow = EngineParameters.HitWindow.CalculateHitWindow(GetAverageNoteDistance(note));

                var noteFrontEnd = note.Time + EngineParameters.HitWindow.GetFrontEnd(hitWindow);
                var noteBackEnd = note.Time + EngineParameters.HitWindow.GetBackEnd(hitWindow);

                // Note will not reach front end yet
                if (nextTime < noteFrontEnd)
                {
                    //YargLogger.LogFormatTrace("Note {0} front end will not be reached at {1}", i, nextTime);
                    break;
                }

                if (!IsBot)
                {
                    // Earliest the note can be hit
                    if (IsTimeBetween(noteFrontEnd, previousTime, nextTime))
                    {
                        YargLogger.LogFormatTrace("Queuing note {0} front end hit time at {1}", i, noteFrontEnd);
                        QueueUpdateTime(noteFrontEnd, "Note Front End");
                    }
                }
                else
                {
                    if (IsTimeBetween(note.Time, previousTime, nextTime))
                    {
                        YargLogger.LogFormatTrace("Queuing bot note {0} at {1}", i, note.Time);
                        QueueUpdateTime(note.Time, "Bot Note Time");
                    }
                }

                // Note will not be out of time on the exact back end
                // So we increment the back end by 1 bit exactly
                // (essentially just 1 epsilon bigger)
                var noteBackEndIncrement = MathUtil.BitIncrement(noteBackEnd);

                if (IsTimeBetween(noteBackEndIncrement, previousTime, nextTime))
                {
                    YargLogger.LogFormatTrace("Queuing note {0} back end miss time at {1}", i, noteBackEndIncrement);
                    QueueUpdateTime(noteBackEndIncrement, "Note Back End");
                }
            }

            if (CurrentWaitCountdownIndex < WaitCountdowns.Count)
            {
                // Queue updates for countdown start/end/change

                if (IsWaitCountdownActive)
                {
                    var currentCountdown = WaitCountdowns[CurrentWaitCountdownIndex];
                    double deactivateTime = currentCountdown.DeactivateTime;

                    if (IsTimeBetween(deactivateTime, previousTime, nextTime))
                    {
                        YargLogger.LogFormatTrace("Queuing countdown {0} deactivation at {1}", CurrentWaitCountdownIndex, deactivateTime);
                        QueueUpdateTime(deactivateTime, "Deactivate Countdown");
                    }
                }
                else
                {
                    int nextCountdownIndex;

                    if (previousTime < WaitCountdowns[CurrentWaitCountdownIndex].Time)
                    {
                        // No countdowns are currently displayed
                        // CurrentWaitCountdownIndex has already been incremented for the next countdown
                        nextCountdownIndex = CurrentWaitCountdownIndex;
                    }
                    else
                    {
                        // A countdown is currently onscreen, but is past its deactivation time and is fading out
                        // CurrentWaitCountdownIndex will not be incremented until the progress bar no longer needs updating
                        nextCountdownIndex = CurrentWaitCountdownIndex + 1;
                    }

                    if (nextCountdownIndex < WaitCountdowns.Count)
                    {
                        double nextCountdownStartTime = WaitCountdowns[nextCountdownIndex].Time;

                        if (IsTimeBetween(nextCountdownStartTime, previousTime, nextTime))
                        {
                            YargLogger.LogFormatTrace("Queuing countdown {0} start time at {1}", nextCountdownIndex, nextCountdownStartTime);
                            QueueUpdateTime(nextCountdownStartTime, "Activate Countdown");
                        }
                    }
                }
            }

            if (StarPowerWhammyTimer.IsActive)
            {
                if (IsTimeBetween(StarPowerWhammyTimer.EndTime, previousTime, nextTime))
                {
                    YargLogger.LogFormatTrace("Queuing star power whammy end time at {0}",
                        StarPowerWhammyTimer.EndTime);
                    QueueUpdateTime(StarPowerWhammyTimer.EndTime, "Star Power Whammy End");
                }
            }
        }

        protected override void UpdateTimeVariables(double time)
        {
            if (time < CurrentTime)
            {
                YargLogger.FailFormat("Time cannot go backwards! Current time: {0}, new time: {1}", CurrentTime,
                    time);
            }

            LastUpdateTime = CurrentTime;
            LastTick = CurrentTick;

            CurrentTime = time;
            CurrentTick = GetCurrentTick(time);

            while (NextSyncIndex < SyncTrackChanges.Count && CurrentTick >= SyncTrackChanges[NextSyncIndex].Tick)
            {
                CurrentSyncIndex++;
            }

            // Only check for WaitCountdowns in this chart if there are any remaining
            if (CurrentWaitCountdownIndex < WaitCountdowns.Count)
            {
                var currentCountdown = WaitCountdowns[CurrentWaitCountdownIndex];

                if (time >= currentCountdown.Time)
                {
                    if (!IsWaitCountdownActive && time < currentCountdown.DeactivateTime)
                    {
                        // Entered new countdown window
                        IsWaitCountdownActive = true;
                        YargLogger.LogFormatTrace("Countdown {0} activated at time {1}. Expected time: {2}", CurrentWaitCountdownIndex, time, currentCountdown.Time);
                    }

                    if (time <= currentCountdown.DeactivateTime + WaitCountdown.FADE_ANIM_LENGTH)
                    {
                        // This countdown is currently displayed onscreen
                        int newMeasuresLeft = currentCountdown.CalculateMeasuresLeft(CurrentTick);

                        if (IsWaitCountdownActive && !currentCountdown.IsActive)
                        {
                            IsWaitCountdownActive = false;
                            YargLogger.LogFormatTrace("Countdown {0} deactivated at time {1}. Expected time: {2}", CurrentWaitCountdownIndex, time, currentCountdown.DeactivateTime);
                        }

                        UpdateCountdown(newMeasuresLeft, currentCountdown.TimeLength, currentCountdown.TimeEnd);
                    }
                    else
                    {
                        CurrentWaitCountdownIndex++;
                    }
                }
            }
        }

        public override void AllowStarPower(bool isAllowed)
        {
            if (isAllowed == StarPowerIsAllowed)
            {
                return;
            }

            StarPowerIsAllowed = isAllowed;

            foreach (var note in Notes)
            {
                if (isAllowed)
                {
                    note.ResetFlags();
                }
                else if (note.IsStarPower)
                {
                    note.Flags &= ~NoteFlags.StarPower;
                    foreach (var childNote in note.ChildNotes)
                    {
                        childNote.Flags &= ~NoteFlags.StarPower;
                    }
                }
            }
        }

        public override void Reset(bool keepCurrentButtons = false)
        {
            base.Reset();

            InputQueue.Clear();

            EngineStats.Reset();

            foreach (var note in Notes)
            {
                note.ResetNoteState();

                if (!StarPowerIsAllowed && note.IsStarPower)
                {
                    note.Flags &= ~NoteFlags.StarPower;
                    foreach (var childNote in note.ChildNotes)
                    {
                        childNote.Flags &= ~NoteFlags.StarPower;
                    }
                }
            }

            foreach (var solo in Solos)
            {
                solo.NotesHit = 0;
                solo.SoloBonus = 0;
            }
        }

        protected abstract void CheckForNoteHit();

        /// <summary>
        /// Checks if the given note can be hit with the current input
        /// </summary>
        /// <param name="note">The Note to attempt to hit.</param>
        /// <returns>True if note can be hit. False otherwise.</returns>
        protected abstract bool CanNoteBeHit(TNoteType note);

        protected abstract bool CanSustainHold(TNoteType note);

        protected virtual void HitNote(TNoteType note)
        {
            if (note.ParentOrSelf.WasFullyHitOrMissed())
            {
                AdvanceToNextNote(note);
            }
        }

        protected virtual void MissNote(TNoteType note)
        {
            if (note.ParentOrSelf.WasFullyHitOrMissed())
            {
                AdvanceToNextNote(note);
            }
        }

        protected bool SkipPreviousNotes(TNoteType current)
        {
            bool skipped = false;
            var prevNote = current.PreviousNote;
            while (prevNote is not null && !prevNote.WasFullyHitOrMissed())
            {
                skipped = true;
                YargLogger.LogFormatTrace("Missed note (Index: {0}) ({1}) due to note skip at {2}", NoteIndex, prevNote.IsParent ? "Parent" : "Child", CurrentTime);
                MissNote(prevNote);

                if (TreatChordAsSeparate)
                {
                    foreach (var child in prevNote.ChildNotes)
                    {
                        YargLogger.LogFormatTrace("Missed note (Index: {0}) ({1}) due to note skip at {2}", NoteIndex, child.IsParent ? "Parent" : "Child", CurrentTime);
                        MissNote(child);
                    }
                }

                prevNote = prevNote.PreviousNote;
            }

            return skipped;
        }

        protected abstract void AddScore(TNoteType note);

        protected void AddScore(int score)
        {
            int scoreMultiplier = score * EngineStats.ScoreMultiplier;

            // scoreMultiplier includes combo+star power score
            EngineStats.CommittedScore += scoreMultiplier;

            if (EngineStats.IsStarPowerActive)
            {
                // Amount of points just from Star Power is half of the current multiplier (8x total -> 4x SP points)
                var spScore = scoreMultiplier / 2;

                EngineStats.StarPowerScore += spScore;

                // Subtract score from the note that was just hit to get the multiplier points
                EngineStats.MultiplierScore += spScore - score;
            }
            else
            {
                EngineStats.MultiplierScore += scoreMultiplier - score;
            }
            UpdateStars();
        }

        protected virtual void UpdateSustains()
        {
            EngineStats.PendingScore = 0;

            bool isStarPowerSustainActive = false;
            for (int i = 0; i < ActiveSustains.Count; i++)
            {
                ref var sustain = ref ActiveSustains[i];
                var note = sustain.Note;

                isStarPowerSustainActive |= note.IsStarPower;

                // If we're close enough to the end of the sustain, finish it
                // Provides leniency for sustains with no gap (and just in general)
                bool isBurst;

                // Sustain is too short for a burst
                if (SustainBurstThreshold > note.TickLength)
                {
                    isBurst = CurrentTick >= note.Tick;
                }
                else
                {
                    isBurst = CurrentTick >= note.TickEnd - SustainBurstThreshold;
                }

                bool isEndOfSustain = CurrentTick >= note.TickEnd;

                uint sustainTick = isBurst || isEndOfSustain ? note.TickEnd : CurrentTick;

                bool dropped = false;

                if(!CanSustainHold(note))
                {
                    // Currently beind held by sustain drop leniency
                    if (sustain.IsLeniencyHeld)
                    {
                        if (CurrentTime >= sustain.LeniencyDropTime + EngineParameters.SustainDropLeniency * EngineParameters.SongSpeed)
                        {
                            dropped = true;
                            YargLogger.LogFormatTrace("Dropping sustain using leniency time at {0}", CurrentTime);
                        }
                    }
                    else
                    {
                        sustain.IsLeniencyHeld = true;
                        sustain.LeniencyDropTime = CurrentTime;
                    }
                }
                else
                {
                    sustain.IsLeniencyHeld = false;
                }

                // If the sustain has not finished scoring, then we need to calculate the points
                if (!sustain.HasFinishedScoring)
                {
                    // Sustain has reached burst threshold, so all points have been given
                    if (isBurst || isEndOfSustain)
                    {
                        sustain.HasFinishedScoring = true;
                    }

                    // Sustain has ended, so commit the points
                    if (dropped || isBurst || isEndOfSustain)
                    {
                        YargLogger.LogFormatTrace("Finished scoring sustain ({0}) at {1} (dropped: {2}, burst: {3})",
                            sustain.Note.Tick, CurrentTime, dropped, isBurst);

                        double finalScore = CalculateSustainPoints(ref sustain, sustainTick);
                        var points = (int) Math.Ceiling(finalScore);

                        AddScore(points);

                        // SustainPoints must include the multiplier, but NOT the star power multiplier
                        int sustainPoints = points * EngineStats.ScoreMultiplier;
                        if (EngineStats.IsStarPowerActive)
                        {
                            sustainPoints /= 2;
                        }

                        EngineStats.SustainScore += sustainPoints;
                    }
                    else
                    {
                        double score = CalculateSustainPoints(ref sustain, sustainTick);

                        var sustainPoints = (int) Math.Ceiling(score);

                        // It's ok to use multiplier here because PendingScore is only temporary to show the correct
                        // score on the UI.
                        EngineStats.PendingScore += sustainPoints * EngineStats.ScoreMultiplier;
                    }
                }

                // Only remove the sustain if its dropped or has reached the final tick
                if (dropped || isEndOfSustain)
                {
                    EndSustain(i, dropped, isEndOfSustain);
                    i--;
                }
            }

            UpdateStars();

            if (isStarPowerSustainActive && StarPowerWhammyTimer.IsActive)
            {
                var whammyTicks = CurrentTick - LastStarPowerWhammyTick;

                GainStarPower(whammyTicks);
                EngineStats.StarPowerWhammyTicks += whammyTicks;

                LastStarPowerWhammyTick = CurrentTick;
            }

            // Whammy is disabled after sustains are updated.
            // This is because all the ticks that have accumulated will have been accounted for when it is disabled.
            // Whereas disabling it before could mean there are some ticks which should have been whammied but weren't.
            if (StarPowerWhammyTimer.IsActive && StarPowerWhammyTimer.IsExpired(CurrentTime))
            {
                StarPowerWhammyTimer.Disable();
            }
        }

        protected virtual void StartSustain(TNoteType note)
        {
            if (ActiveSustains.Count == 0)
            {
                LastStarPowerWhammyTick = CurrentTick;
            }

            var sustain = new ActiveSustain<TNoteType>(note);

            ActiveSustains.Add(sustain);

            YargLogger.LogFormatTrace("Started sustain at {0} (tick len: {1}, time len: {2})", CurrentTime, note.TickLength, note.TimeLength);

            OnSustainStart?.Invoke(note);
        }

        protected virtual void EndSustain(int sustainIndex, bool dropped, bool isEndOfSustain)
        {
            var sustain = ActiveSustains[sustainIndex];
            YargLogger.LogFormatTrace("Ended sustain ({0}) at {1} (dropped: {2}, end: {3})", sustain.Note.Tick, CurrentTime, dropped, isEndOfSustain);
            ActiveSustains.RemoveAt(sustainIndex);

            OnSustainEnd?.Invoke(sustain.Note, CurrentTime, sustain.HasFinishedScoring);
        }

        protected void UpdateStars()
        {
            // Update which star we're on
            while (CurrentStarIndex < StarScoreThresholds.Length &&
                EngineStats.StarScore > StarScoreThresholds[CurrentStarIndex])
            {
                CurrentStarIndex++;
            }

            // Calculate current star progress
            float progress = 0f;
            if (CurrentStarIndex < StarScoreThresholds.Length)
            {
                int previousPoints = CurrentStarIndex > 0 ? StarScoreThresholds[CurrentStarIndex - 1] : 0;
                int nextPoints = StarScoreThresholds[CurrentStarIndex];
                progress = YargMath.InverseLerpF(previousPoints, nextPoints, EngineStats.StarScore);
            }

            EngineStats.Stars = CurrentStarIndex + progress;
        }

        protected virtual void StripStarPower(TNoteType? note)
        {
            if (note is null || !note.IsStarPower)
            {
                return;
            }

            // Strip star power from the note and all its children
            note.Flags &= ~NoteFlags.StarPower;
            foreach (var childNote in note.ChildNotes)
            {
                childNote.Flags &= ~NoteFlags.StarPower;
            }

            // Look back until finding the start of the phrase
            if (!note.IsStarPowerStart)
            {
                var prevNote = note.PreviousNote;
                while (prevNote is not null && prevNote.IsStarPower)
                {
                    prevNote.Flags &= ~NoteFlags.StarPower;
                    foreach (var childNote in prevNote.ChildNotes)
                    {
                        childNote.Flags &= ~NoteFlags.StarPower;
                    }

                    if (prevNote.IsStarPowerStart)
                    {
                        break;
                    }

                    prevNote = prevNote.PreviousNote;
                }
            }

            // Look forward until finding the end of the phrase
            if (!note.IsStarPowerEnd)
            {
                var nextNote = note.NextNote;
                while (nextNote is not null && nextNote.IsStarPower)
                {
                    nextNote.Flags &= ~NoteFlags.StarPower;
                    foreach (var childNote in nextNote.ChildNotes)
                    {
                        childNote.Flags &= ~NoteFlags.StarPower;
                    }

                    if (nextNote.IsStarPowerEnd)
                    {
                        break;
                    }

                    nextNote = nextNote.NextNote;
                }
            }

            OnStarPowerPhraseMissed?.Invoke(note);
        }

        protected virtual uint CalculateStarPowerGain(uint tick) => tick - LastTick;

        protected void AwardStarPower(TNoteType note)
        {
            GainStarPower(TicksPerQuarterSpBar);

            OnStarPowerPhraseHit?.Invoke(note);
        }

        protected void StartSolo()
        {
            if (CurrentSoloIndex >= Solos.Count)
            {
                return;
            }

            IsSoloActive = true;
            OnSoloStart?.Invoke(Solos[CurrentSoloIndex]);
        }

        protected void EndSolo()
        {
            if (!IsSoloActive)
            {
                return;
            }

            var currentSolo = Solos[CurrentSoloIndex];

            double soloPercentage = currentSolo.NotesHit / (double) currentSolo.NoteCount;

            if (soloPercentage < 0.6)
            {
                currentSolo.SoloBonus = 0;
            }
            else
            {
                double multiplier = Math.Clamp((soloPercentage - 0.6) / 0.4, 0, 1);

                // Old engine says this is 200 *, but I'm not sure that's right?? Isn't it 2x the note's worth, not 4x?
                double points = 100 * currentSolo.NotesHit * multiplier;

                // Round down to nearest 50 (kinda just makes sense I think?)
                points -= points % 50;

                currentSolo.SoloBonus = (int) points;
            }

            EngineStats.SoloBonuses += currentSolo.SoloBonus;

            IsSoloActive = false;

            OnSoloEnd?.Invoke(Solos[CurrentSoloIndex]);
            CurrentSoloIndex++;
        }

        protected override void UpdateProgressValues(uint tick)
        {
            base.UpdateProgressValues(tick);

            EngineStats.PendingScore = 0;
            for (int i = 0; i < ActiveSustains.Count; i++)
            {
                ref var sustain = ref ActiveSustains[i];
                EngineStats.PendingScore += (int) CalculateSustainPoints(ref sustain, tick);
            }
        }

        protected override void RebaseProgressValues(uint baseTick)
        {
            base.RebaseProgressValues(baseTick);
            RebaseSustains(baseTick);
        }

        protected void RebaseSustains(uint baseTick)
        {
            EngineStats.PendingScore = 0;
            for (int i = 0; i < ActiveSustains.Count; i++)
            {
                ref var sustain = ref ActiveSustains[i];
                // Don't rebase sustains that haven't started yet
                if (baseTick < sustain.BaseTick)
                {
                    YargLogger.AssertFormat(baseTick < sustain.Note.Tick,
                        "Sustain base tick cannot go backwards! Attempted to go from {0} to {1}",
                        sustain.BaseTick, baseTick);

                    continue;
                }

                double sustainScore = CalculateSustainPoints(ref sustain, baseTick);

                sustain.BaseTick = Math.Clamp(baseTick, sustain.Note.Tick, sustain.Note.TickEnd);
                sustain.BaseScore = sustainScore;
                EngineStats.PendingScore += (int) sustainScore;
            }
        }

        protected void UpdateCountdown(int measuresLeft, double countdownLength, double endTime)
        {
            OnCountdownChange?.Invoke(measuresLeft, countdownLength, endTime);
        }

        public sealed override (double FrontEnd, double BackEnd) CalculateHitWindow()
        {
            var maxWindow = EngineParameters.HitWindow.MaxWindow;

            if (NoteIndex >= Notes.Count)
            {
                return (EngineParameters.HitWindow.GetFrontEnd(maxWindow),
                    EngineParameters.HitWindow.GetBackEnd(maxWindow));
            }

            var noteDistance = GetAverageNoteDistance(Notes[NoteIndex]);
            var hitWindow = EngineParameters.HitWindow.CalculateHitWindow(noteDistance);

            return (EngineParameters.HitWindow.GetFrontEnd(hitWindow),
                EngineParameters.HitWindow.GetBackEnd(hitWindow));
        }

        /// <summary>
        /// Calculates the base score of the chart, which can be used to calculate star thresholds.
        /// </summary>
        /// <remarks>
        /// Please be mindful that this virtual method is called in the constructor of
        /// <see cref="BaseEngine{TNoteType,TEngineParams,TEngineStats,TEngineState}"/>.
        /// <b>ONLY</b> use the <see cref="Notes"/> property to calculate this.
        /// </remarks>
        protected abstract int CalculateBaseScore();

        protected bool IsNoteInWindow(TNoteType note) => IsNoteInWindow(note, out _);

        protected bool IsNoteInWindow(TNoteType note, double time) =>
            IsNoteInWindow(note, out _, time);

        protected bool IsNoteInWindow(TNoteType note, out bool missed) =>
            IsNoteInWindow(note, out missed, CurrentTime);

        protected bool IsNoteInWindow(TNoteType note, out bool missed, double time)
        {
            missed = false;

            double hitWindow = EngineParameters.HitWindow.CalculateHitWindow(GetAverageNoteDistance(note));
            double frontend = EngineParameters.HitWindow.GetFrontEnd(hitWindow);
            double backend = EngineParameters.HitWindow.GetBackEnd(hitWindow);

            // Time has not reached the front end of this note
            if (time < note.Time + frontend)
            {
                return false;
            }

            // Time has surpassed the back end of this note
            if (time > note.Time + backend)
            {
                missed = true;
                return false;
            }

            return true;
        }

        protected double CalculateSustainPoints(ref ActiveSustain<TNoteType> sustain, uint tick)
        {
            uint scoreTick = Math.Clamp(tick, sustain.Note.Tick, sustain.Note.TickEnd);

            sustain.Note.SustainTicksHeld = scoreTick - sustain.Note.Tick;

            // Sustain points are awarded at a constant rate regardless of tempo
            // double deltaScore = CalculateBeatProgress(scoreTick, sustain.BaseTick, POINTS_PER_BEAT);
            double deltaScore = (scoreTick - sustain.BaseTick) / TicksPerSustainPoint;
            return sustain.BaseScore + deltaScore;
        }

        private void AdvanceToNextNote(TNoteType note)
        {
            NoteIndex++;
            ReRunHitLogic = true;
        }

        public double GetAverageNoteDistance(TNoteType note)
        {
            double previousToCurrent;
            double currentToNext = EngineParameters.HitWindow.MaxWindow / 2;

            if (note.NextNote is not null)
            {
                currentToNext = (note.NextNote.Time - note.Time) / 2;
            }

            if (note.PreviousNote is not null)
            {
                previousToCurrent = (note.Time - note.PreviousNote.Time) / 2;
            }
            else
            {
                previousToCurrent = currentToNext;
            }

            return previousToCurrent + currentToNext;
        }

        private List<SoloSection> GetSoloSections()
        {
            var soloSections = new List<SoloSection>();

            if (Notes.Count > 0 && Notes[0].IsSolo)
            {
                Notes[0].ActivateFlag(NoteFlags.SoloStart);
            }

            if (Notes.Count > 0 && Notes[^1].IsSolo)
            {
                Notes[^1].ActivateFlag(NoteFlags.SoloEnd);
            }

            for (int i = 0; i < Notes.Count; i++)
            {
                var curr = Notes[i];
                if (!curr.IsSoloStart)
                {
                    continue;
                }

                int soloNoteCount = 0;
                while (true)
                {
                    soloNoteCount += GetNumberOfNotes(curr);
                    if (curr.IsSoloEnd)
                    {
                        break;
                    }
                    curr = Notes[++i];
                }
                soloSections.Add(new SoloSection(soloNoteCount));
            }
            return soloSections;
        }

        protected void GetWaitCountdowns(List<TNoteType> notes)
        {
            var allMeasureBeatLines = SyncTrack.Beatlines.Where(x => x.Type == BeatlineType.Measure).ToList();

            WaitCountdowns = new List<WaitCountdown>();
            for (int i = 0; i < notes.Count; i++)
            {
                // Compare the note at the current index against the previous note
                // Create a countdown if the distance between the notes is > 10s
                Note<TNoteType> noteOne;

                uint noteOneTickEnd = 0;
                double noteOneTimeEnd = 0;

                if (i > 0) {
                    noteOne = notes[i-1];
                    noteOneTickEnd = noteOne.TickEnd;
                    noteOneTimeEnd = noteOne.TimeEnd;
                }

                Note<TNoteType> noteTwo = notes[i];
                double noteTwoTime = noteTwo.Time;

                if (noteTwoTime - noteOneTimeEnd >= WaitCountdown.MIN_SECONDS)
                {
                    uint noteTwoTick = noteTwo.Tick;

                    // Determine the total number of measures that will pass during this countdown
                    List<Beatline> beatlinesThisCountdown = new();

                    // Countdown should start at end of the first note if it's directly on a measure line
                    // Otherwise it should start at the beginning of the next measure

                    // Increasing measure index if there's no more measures causes an exception
                    // Temporary fix by adding a check for the last measure
                    // Affects 1/1 time signatures
                    int curMeasureIndex = allMeasureBeatLines.GetIndexOfPrevious(noteOneTickEnd);
                    if (curMeasureIndex == -1)
                    {
                        // In songs with no events at time 0, it's possible to have no previous note.
                        // In that case, just use 0.
                        curMeasureIndex = 0;
                    }
                    if (allMeasureBeatLines[curMeasureIndex].Tick < noteOneTickEnd
                        && curMeasureIndex + 1 < allMeasureBeatLines.Count)
                    {
                        curMeasureIndex++;
                    }

                    var curMeasureline = allMeasureBeatLines[curMeasureIndex];
                    while (curMeasureline.Tick <= noteTwoTick)
                    {
                        // Skip counting on measures that are too close together
                        if (beatlinesThisCountdown.Count == 0 ||
                            curMeasureline.Time - beatlinesThisCountdown.Last().Time >= WaitCountdown.MIN_MEASURE_LENGTH)
                        {
                            beatlinesThisCountdown.Add(curMeasureline);
                        }

                        curMeasureIndex++;

                        if (curMeasureIndex >= allMeasureBeatLines.Count)
                        {
                            break;
                        }

                        curMeasureline = allMeasureBeatLines[curMeasureIndex];
                    }

                    // Prevent showing countdowns < 4 measures at low BPMs
                    int countdownTotalMeasures = beatlinesThisCountdown.Count;
                    if (countdownTotalMeasures >= WaitCountdown.MIN_MEASURES)
                    {
                        // Create a WaitCountdown instance to reference at runtime
                        var newCountdown = new WaitCountdown(beatlinesThisCountdown);

                        WaitCountdowns.Add(newCountdown);
                        YargLogger.LogFormatTrace("Created a WaitCountdown at time {0} of {1} measures and {2} seconds in length",
                                                 newCountdown.Time, countdownTotalMeasures, beatlinesThisCountdown[^1].Time - noteOneTimeEnd);
                    }
                }
            }
        }
    }
}
</file>

<file path="Engine/BaseEngineParameters.cs">
using System.Globalization;
using System.IO;
using System.Linq;
using YARG.Core.Extensions;
using YARG.Core.IO;

namespace YARG.Core.Engine
{
    public abstract class BaseEngineParameters
    {
        public readonly HitWindowSettings HitWindow;

        public readonly int MaxMultiplier;

        public readonly double StarPowerWhammyBuffer;

        public readonly double SustainDropLeniency;

        public readonly float[] StarMultiplierThresholds;

        public double SongSpeed;

        protected BaseEngineParameters(HitWindowSettings hitWindow, int maxMultiplier, double spWhammyBuffer,
            double sustainDropLeniency, float[] starMultiplierThresholds)
        {
            HitWindow = hitWindow;
            StarPowerWhammyBuffer = spWhammyBuffer;
            SustainDropLeniency = sustainDropLeniency;
            MaxMultiplier = maxMultiplier;
            StarMultiplierThresholds = starMultiplierThresholds;
        }

        protected BaseEngineParameters(ref FixedArrayStream stream, int version)
        {
            HitWindow = new HitWindowSettings(ref stream, version);
            MaxMultiplier = stream.Read<int>(Endianness.Little);
            StarPowerWhammyBuffer = stream.Read<double>(Endianness.Little);

            // Version 7 but DATA_MIN was increased so no need to version check
            SustainDropLeniency = stream.Read<double>(Endianness.Little);

            // Read star multiplier thresholds
            int count = stream.Read<int>(Endianness.Little);
            StarMultiplierThresholds = new float[count];
            for (int i = 0; i < StarMultiplierThresholds.Length; i++)
            {
                StarMultiplierThresholds[i] = stream.Read<float>(Endianness.Little);
            }

            SongSpeed = stream.Read<double>(Endianness.Little);
        }

        public virtual void Serialize(BinaryWriter writer)
        {
            HitWindow.Serialize(writer);
            writer.Write(MaxMultiplier);
            writer.Write(StarPowerWhammyBuffer);

            writer.Write(SustainDropLeniency);

            // Write star multiplier thresholds
            writer.Write(StarMultiplierThresholds.Length);
            foreach (var f in StarMultiplierThresholds)
            {
                writer.Write(f);
            }

            writer.Write(SongSpeed);
        }

        public override string ToString()
        {
            var thresholds = string.Join(", ",
                StarMultiplierThresholds.Select(i => i.ToString(CultureInfo.InvariantCulture)));

            return
                $"Hit window: ({HitWindow.MinWindow}, {HitWindow.MaxWindow})\n" +
                $"Hit window dynamic: {HitWindow.IsDynamic}\n" +
                $"Max multiplier: {MaxMultiplier}\n" +
                $"Star thresholds: {thresholds}";
        }
    }
}
</file>

<file path="Engine/BaseStats.cs">
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.IO;
using YARG.Core.Replays;

namespace YARG.Core.Engine
{
    public abstract class BaseStats
    {
        /// <summary>
        /// Finalized score (e.g from notes hit and sustains)
        /// </summary>
        public int CommittedScore;

        /// <summary>
        /// Score that is currently pending addition (e.g. from active sustains).
        /// These points are recalculated every update, and only get added once their
        /// final condition has been met.
        /// </summary>
        /// <remarks>
        /// These points are still earned, but their total value is not final yet.
        /// Adding them immediately would result in problems such as precision errors.
        /// </remarks>
        public int PendingScore;

        /// <summary>
        /// Total score across all score values.
        /// </summary>
        /// <remarks>
        /// Calculated from <see cref="CommittedScore"/>, <see cref="PendingScore"/>, and <see cref="SoloBonuses"/>.
        /// </remarks>
        public int TotalScore => CommittedScore + PendingScore + SoloBonuses;

        /// <summary>
        /// Total score earned from hitting notes.
        /// </summary>
        public int NoteScore;

        /// <summary>
        /// Total score earned from holding sustains.
        /// </summary>
        public int SustainScore;

        /// <summary>
        /// Total score earned from score multipliers.
        /// </summary>
        public int MultiplierScore;

        /// <summary>
        /// The score used to calculate star progress.
        /// </summary>
        /// <remarks>
        /// Calculated from <see cref="CommittedScore"/> and <see cref="PendingScore"/>.
        /// <see cref="SoloBonuses"/> is not included in star progress.
        /// </remarks>
        public int StarScore => CommittedScore + PendingScore;

        /// <summary>
        /// The player's current combo (such as 500 note streak)
        /// </summary>
        public int Combo;

        /// <summary>
        /// The player's current combo, when counted as part of the Band Streak.
        /// </summary>
        public virtual int ComboInBandUnits => Combo * BandComboUnits;

        /// <summary>
        /// How much the band combo should increment per note or phrase hit for this instrument.
        /// </summary>
        public virtual int BandComboUnits => 1;

        /// <summary>
        /// The player's highest combo achieved.
        /// </summary>
        public int MaxCombo;

        /// <summary>
        /// The player's current score multiplier (e.g 2x, 3x)
        /// </summary>
        public int ScoreMultiplier;

        /// <summary>
        /// Number of notes which have been hit.
        /// </summary>
        public int NotesHit;

        /// <summary>
        /// Number of notes in the chart. This value should never be modified.
        /// </summary>
        public int TotalNotes;

        /// <summary>
        /// Number of notes which have been missed.
        /// </summary>
        /// <remarks>Value is calculated from <see cref="TotalNotes"/> - <see cref="NotesHit"/>.</remarks>
        public int NotesMissed => TotalNotes - NotesHit;

        /// <summary>
        /// The percent of notes hit.
        /// </summary>
        public virtual float Percent => TotalNotes == 0 ? 1f : (float) NotesHit / TotalNotes;

        public uint StarPowerTickAmount;

        public uint TotalStarPowerTicks;

        public double TotalStarPowerBarsFilled;

        public int StarPowerActivationCount;

        public double TimeInStarPower;

        /// <summary>
        /// Amount of Star Power/Overdrive gained from whammy during the current whammy period.
        /// </summary>
        public uint StarPowerWhammyTicks;

        /// <summary>
        /// True if the player currently has Star Power/Overdrive active.
        /// </summary>
        public bool IsStarPowerActive;

        /// <summary>
        /// Number of Star Power phrases which have been hit.
        /// </summary>
        public int StarPowerPhrasesHit;

        /// <summary>
        /// Number of Star Power phrases in the chart. This value should never be modified.
        /// </summary>
        public int TotalStarPowerPhrases;

        /// <summary>
        /// Number of Star Power phrases which have been missed.
        /// </summary>
        /// <remarks>Value is calculated from <see cref="TotalStarPowerPhrases"/> - <see cref="StarPowerPhrasesHit"/>.</remarks>
        public int StarPowerPhrasesMissed => TotalStarPowerPhrases - StarPowerPhrasesHit;

        /// <summary>
        /// Amount of points earned from solo bonuses.
        /// </summary>
        public int SoloBonuses;

        public int StarPowerScore;

        /// <summary>
        /// The number of stars the player has achieved, along with the progress to the next star.
        /// </summary>
        public float Stars;

        protected BaseStats()
        {
        }

        protected BaseStats(BaseStats stats)
        {
            CommittedScore = stats.CommittedScore;
            PendingScore = stats.PendingScore;
            Combo = stats.Combo;
            MaxCombo = stats.MaxCombo;
            ScoreMultiplier = stats.ScoreMultiplier;
            NotesHit = stats.NotesHit;
            TotalNotes = stats.TotalNotes;

            StarPowerTickAmount = stats.StarPowerTickAmount;
            TotalStarPowerTicks = stats.TotalStarPowerTicks;
            TotalStarPowerBarsFilled = stats.TotalStarPowerBarsFilled;
            StarPowerActivationCount = stats.StarPowerActivationCount;
            TimeInStarPower = stats.TimeInStarPower;
            StarPowerWhammyTicks = stats.StarPowerWhammyTicks;
            IsStarPowerActive = stats.IsStarPowerActive;

            StarPowerPhrasesHit = stats.StarPowerPhrasesHit;
            TotalStarPowerPhrases = stats.TotalStarPowerPhrases;

            SoloBonuses = stats.SoloBonuses;
            StarPowerScore = stats.StarPowerScore;

            Stars = stats.Stars;
        }

        protected BaseStats(ref FixedArrayStream stream, int version)
        {
            CommittedScore = stream.Read<int>(Endianness.Little);
            PendingScore = stream.Read<int>(Endianness.Little);

            Combo = stream.Read<int>(Endianness.Little);
            MaxCombo = stream.Read<int>(Endianness.Little);
            ScoreMultiplier = stream.Read<int>(Endianness.Little);

            NotesHit = stream.Read<int>(Endianness.Little);
            TotalNotes = stream.Read<int>(Endianness.Little);

            StarPowerTickAmount = stream.Read<uint>(Endianness.Little);
            TotalStarPowerTicks = stream.Read<uint>(Endianness.Little);
            TimeInStarPower = stream.Read<double>(Endianness.Little);
            StarPowerWhammyTicks = stream.Read<uint>(Endianness.Little);
            IsStarPowerActive = stream.ReadBoolean();

            StarPowerPhrasesHit = stream.Read<int>(Endianness.Little);
            TotalStarPowerPhrases = stream.Read<int>(Endianness.Little);

            SoloBonuses = stream.Read<int>(Endianness.Little);
            StarPowerScore = stream.Read<int>(Endianness.Little);

            // Deliberately not read so that stars can be re-calculated if thresholds change
            // Stars = reader.ReadInt32();
        }

        public virtual void Reset()
        {
            CommittedScore = 0;
            PendingScore = 0;
            Combo = 0;
            MaxCombo = 0;
            ScoreMultiplier = 1;
            NotesHit = 0;
            // Don't reset TotalNotes
            // TotalNotes = 0;

            StarPowerTickAmount = 0;
            TotalStarPowerTicks = 0;
            TotalStarPowerBarsFilled = 0;
            StarPowerActivationCount = 0;
            TimeInStarPower = 0;
            StarPowerWhammyTicks = 0;
            IsStarPowerActive = false;

            StarPowerPhrasesHit = 0;
            // TotalStarPowerPhrases = 0;

            SoloBonuses = 0;
            StarPowerScore = 0;

            Stars = 0;
        }

        public virtual void Serialize(BinaryWriter writer)
        {
            writer.Write(CommittedScore);
            writer.Write(PendingScore);

            writer.Write(Combo);
            writer.Write(MaxCombo);
            writer.Write(ScoreMultiplier);

            writer.Write(NotesHit);
            writer.Write(TotalNotes);

            writer.Write(StarPowerTickAmount);
            writer.Write(TotalStarPowerTicks);
            writer.Write(TimeInStarPower);
            writer.Write(StarPowerWhammyTicks);
            writer.Write(IsStarPowerActive);

            writer.Write(StarPowerPhrasesHit);
            writer.Write(TotalStarPowerPhrases);

            writer.Write(SoloBonuses);
            writer.Write(StarPowerScore);

            // Deliberately not written so that stars can be re-calculated with different thresholds
            // writer.Write(Stars);
        }

        public abstract ReplayStats ConstructReplayStats(string name);
    }
}
</file>

<file path="Engine/EngineTimer.cs">
using System;
using Cysharp.Text;
using YARG.Core.Extensions;

namespace YARG.Core.Engine
{
    public struct EngineTimer
    {
        private const double NOT_STARTED = double.MaxValue;

        private double _startTime;
        private double _speed;

        public readonly double TimeThreshold;

        public double SpeedAdjustedThreshold => TimeThreshold * _speed;

        public readonly double StartTime => _startTime;
        public readonly double EndTime => _startTime + TimeThreshold * _speed;

        public bool IsActive { get; private set; }

        static EngineTimer()
        {
            Utf16ValueStringBuilder.RegisterTryFormat<EngineTimer>(TryFormat);
        }

        public EngineTimer(double threshold)
        {
            _startTime = NOT_STARTED;
            _speed = 1.0;

            TimeThreshold = threshold;

            IsActive = false;
        }

        public void Start(double currentTime)
        {
            Start(ref _startTime, currentTime);
            IsActive = true;
        }

        public void StartWithOffset(double currentTime, double offset)
        {
            StartWithOffset(ref _startTime, currentTime, TimeThreshold * _speed, offset);
            IsActive = true;
        }

        public void Disable()
        {
            IsActive = false;
        }

        public readonly bool IsExpired(double currentTime)
        {
            return currentTime >= EndTime;
        }

        public void SetSpeed(double speed)
        {
            _speed = speed;
        }

        public static void Start(ref double startTime, double currentTime)
        {
            startTime = currentTime;
        }

        public static void StartWithOffset(ref double startTime, double currentTime, double threshold, double offset)
        {
            double diff = Math.Abs(threshold - offset);
            startTime = currentTime - diff;
        }

        public static void Reset(ref double startTime)
        {
            startTime = NOT_STARTED;
        }

        public readonly override string ToString()
        {
            if (StartTime == NOT_STARTED)
                return "Not started";

            return $"{StartTime:0.000000} - {EndTime:0.000000}";
        }

        public readonly bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default, IFormatProvider? provider = null)
        {
            return TryFormat(this, destination, out charsWritten, format);
        }

        private static bool TryFormat(EngineTimer timer, Span<char> dest, out int written, ReadOnlySpan<char> format)
        {
            written = 0;

            if (timer.StartTime == NOT_STARTED)
                return dest.TryWriteAndAdvance("Not started", ref written);

            if (!dest.TryWriteAndAdvance(timer.StartTime, ref written, "0.000000"))
                return false;

            if (!dest.TryWriteAndAdvance(" - ", ref written))
                return false;

            if (!dest.TryWriteAndAdvance(timer.EndTime, ref written, "0.000000"))
                return false;

            return true;
        }
    }
}
</file>

<file path="Engine/HitWindowSettings.cs">
using System;
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.IO;

namespace YARG.Core.Engine
{
    public class HitWindowSettings
    {
        /// <summary>
        /// The scale factor of the hit window. This should be used to scale the window
        /// up/down during speed ups and slow downs.
        /// </summary>
        /// <remarks>
        /// This value is <b>NOT</b> serialized as it should be set when first creating the
        /// engine based on the song speed.
        /// </remarks>
        public double Scale;

        /// <summary>
        /// The maximum window size. If the hit window is not dynamic, this value will be used.
        /// </summary>
        public readonly double MaxWindow;

        /// <summary>
        /// The minimum window size. This value will only be used if the window is dynamic.
        /// </summary>
        public readonly double MinWindow;

        /// <summary>
        /// Whether the hit window size can change over time.
        /// This is usually done by looking at the time in between notes.
        /// </summary>
        public readonly bool IsDynamic;

        public readonly double DynamicWindowSlope;

        public readonly double DynamicWindowScale;

        public readonly double DynamicWindowGamma;

        /// <summary>
        /// The front to back ratio of the hit window.
        /// </summary>
        public readonly double FrontToBackRatio;

        private readonly double _minMaxWindowRatio;

        public HitWindowSettings(double maxWindow, double minWindow, double frontToBackRatio, bool isDynamic,
            double dwSlope, double dwScale, double dwGamma)
        {
            // Swap max and min if necessary to ensure that max is always larger than min
            if (maxWindow < minWindow)
            {
                (maxWindow, minWindow) = (minWindow, maxWindow);
            }

            Scale = 1.0;
            MaxWindow = maxWindow;
            MinWindow = minWindow;
            FrontToBackRatio = frontToBackRatio;

            IsDynamic = isDynamic;
            DynamicWindowSlope = Math.Clamp(dwSlope, 0, 1);
            DynamicWindowScale = Math.Clamp(dwScale, 0.3, 3);
            DynamicWindowGamma = Math.Clamp(dwGamma, 0.1, 10);

            _minMaxWindowRatio = MinWindow / MaxWindow;
        }

        public HitWindowSettings(ref FixedArrayStream stream, int version)
        {
            Scale = 1;
            MaxWindow = stream.Read<double>(Endianness.Little);
            MinWindow = stream.Read<double>(Endianness.Little);
            FrontToBackRatio = stream.Read<double>(Endianness.Little);
            IsDynamic = stream.ReadBoolean();

            DynamicWindowSlope = stream.Read<double>(Endianness.Little);
            DynamicWindowScale = stream.Read<double>(Endianness.Little);
            DynamicWindowGamma = stream.Read<double>(Endianness.Little);

            _minMaxWindowRatio = MinWindow / MaxWindow;
        }

        public void Serialize(BinaryWriter writer)
        {
            writer.Write(MaxWindow);
            writer.Write(MinWindow);
            writer.Write(FrontToBackRatio);
            writer.Write(IsDynamic);

            writer.Write(DynamicWindowSlope);
            writer.Write(DynamicWindowScale);
            writer.Write(DynamicWindowGamma);
        }

        /// <summary>
        /// Calculates the size of the front end of the hit window.
        /// The <see cref="Scale"/> is taken into account.
        /// </summary>
        /// <param name="fullWindow">
        /// The full hit window size. This should be passed in from <see cref="CalculateHitWindow"/>.
        /// </param>
        public double GetFrontEnd(double fullWindow)
        {
            return -(Math.Abs(fullWindow / 2) * FrontToBackRatio) * Scale;
        }

        /// <summary>
        /// Calculates the size of the back end of the hit window.
        /// The <see cref="Scale"/> is taken into account.
        /// </summary>
        /// <param name="fullWindow">
        /// The full hit window size. This should be passed in from <see cref="CalculateHitWindow"/>.
        /// </param>
        public double GetBackEnd(double fullWindow)
        {
            return Math.Abs(fullWindow / 2) * (2 - FrontToBackRatio) * Scale;
        }

        /// <summary>
        /// This method should be used to determine the full hit window size.
        /// This value can then be passed into the <see cref="GetFrontEnd"/>
        /// and <see cref="GetBackEnd"/> methods.
        /// </summary>
        /// <param name="averageTimeDistance">
        /// The average time distance between the notes at this time.
        /// </param>
        /// <returns>
        /// The size of the full hit window.
        /// </returns>
        public double CalculateHitWindow(double averageTimeDistance)
        {
            if (!IsDynamic)
            {
                return MaxWindow;
            }

            return Dark_Yarg_Impl(averageTimeDistance);
        }

        private double Original_Yarg_Impl(double averageTimeDistance)
        {
            averageTimeDistance *= 1000;

            double sqrt = Math.Sqrt(averageTimeDistance + _minMaxWindowRatio);
            double tenth = 0.1 * averageTimeDistance;
            double realSize = tenth * sqrt + MinWindow * 1000;

            realSize /= 1000;

            return Math.Clamp(realSize, MinWindow, MaxWindow);
        }

        private double Second_Yarg_Impl(double averageTimeDistance)
        {
            averageTimeDistance *= 1000;

            double minOverFive = MinWindow / 5 * 1000;

            double sqrt = minOverFive * Math.Sqrt(averageTimeDistance * _minMaxWindowRatio);
            double eighthAverage = 0.125 * averageTimeDistance;
            double realSize = eighthAverage + sqrt + MinWindow * 1000;

            realSize /= 1000;

            return Math.Clamp(realSize, MinWindow, MaxWindow);
        }

        private double Third_Yarg_Impl(double averageTimeDistance)
        {
            averageTimeDistance *= 1000;

            double realSize = Curve(Math.Sqrt(MinWindow * 1000 / 40) * averageTimeDistance) + MinWindow * 1000;

            realSize /= 1000;

            return Math.Clamp(realSize, MinWindow, MaxWindow);

            static double Curve(double x)
            {
                return 0.2 * x + Math.Sqrt(17 * x);
            }
        }

        private double Dark_Yarg_Impl(double averageTimeDistance)
        {
            averageTimeDistance *= 1000;

            double realSize = Curve(averageTimeDistance);

            realSize /= 1000;

            return Math.Clamp(realSize, MinWindow, MaxWindow);

            double Curve(double x)
            {
                double minWindowMillis = MinWindow * 1000;
                double maxWindowMillis = MaxWindow * 1000;

                double maxMultiScale = maxWindowMillis * DynamicWindowScale;

                double gammaPow = Math.Pow(x / maxMultiScale, DynamicWindowGamma);

                double minMultiSlope = minWindowMillis * DynamicWindowSlope;
                double result = gammaPow * (maxWindowMillis - minMultiSlope) + minMultiSlope;

                return result;
            }
        }
    }
}
</file>

<file path="Engine/SoloSection.cs">
namespace YARG.Core.Engine
{
    public class SoloSection
    {

        public int NoteCount { get; }

        public int NotesHit { get; set; }
        
        public int SoloBonus { get; set; }

        public SoloSection(int noteCount)
        {
            NoteCount = noteCount;
        }

    }
}
</file>

<file path="Engine/SustainList.cs">
using System.Collections;
using System.Collections.Generic;
using YARG.Core.Chart;

namespace YARG.Core.Engine
{
    public class SustainList<TNoteType> : IEnumerable<ActiveSustain<TNoteType>> where TNoteType : Note<TNoteType>
    {
        public struct SustainEnumerator : IEnumerator<ActiveSustain<TNoteType>>
        {
            private readonly SustainList<TNoteType> _list;

            private int _index;

            private ActiveSustain<TNoteType>? _current;

            public SustainEnumerator(SustainList<TNoteType> list)
            {
                _list = list;
                _index = 0;

                _current = default;
            }

            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                if (_index < _list.Count)
                {
                    _current = _list[_index];
                    _index++;
                    return true;
                }

                _index = _list.Count;
                _current = default;
                return false;
            }

            public ActiveSustain<TNoteType> Current => _current!.Value;

            object IEnumerator.Current => Current;

            public void Reset()
            {
                _index = 0;
                _current = default;
            }

        }

        public ref ActiveSustain<TNoteType> this[int index] => ref _items[index];

        private ActiveSustain<TNoteType>[] _items;

        public int Count { get; private set; }

        public SustainList() : this(0)
        {
        }

        public SustainList(int capacity)
        {
            _items = new ActiveSustain<TNoteType>[capacity];
        }

        public void Add(ActiveSustain<TNoteType> sustain)
        {
            // Resize the array if necessary
            if (Count == _items.Length)
            {
                var newItems = new ActiveSustain<TNoteType>[_items.Length * 2];
                _items.CopyTo(newItems, 0);
                _items = newItems;
            }

            _items[Count++] = sustain;
        }

        public void RemoveAt(int index)
        {
            for (int i = index; i < Count - 1; i++)
            {
                _items[i] = _items[i + 1];
            }

            Count--;
        }

        public void Clear()
        {
            Count = 0;
        }

        public SustainEnumerator GetEnumerator() => new(this);

        IEnumerator<ActiveSustain<TNoteType>> IEnumerable<ActiveSustain<TNoteType>>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable<ActiveSustain<TNoteType>>)this).GetEnumerator();
    }

    public struct ActiveSustain<TNoteType> where TNoteType : Note<TNoteType>
    {
        public TNoteType Note;
        public uint      BaseTick;
        public double    BaseScore;

        public bool HasFinishedScoring;
        public bool IsLeniencyHeld;

        public double LeniencyDropTime;

        public ActiveSustain(TNoteType note)
        {
            Note = note;
            BaseTick = note.Tick;
            BaseScore = 0;

            HasFinishedScoring = false;
            IsLeniencyHeld = false;

            LeniencyDropTime = -9999;
        }

        public double GetEndTime(SyncTrack syncTrack, uint sustainBurstThreshold)
        {
            // Sustain is too short for a burst, so clamp the burst to the start position of the note
            if (sustainBurstThreshold > Note.TickLength)
            {
                return Note.Time;
            }

            return syncTrack.TickToTime(Note.TickEnd - sustainBurstThreshold);
        }
    }
}
</file>

<file path="Engine/SyncTrackChange.cs">
using YARG.Core.Chart;

namespace YARG.Core.Engine
{
    public class SyncTrackChange : SyncEvent
    {
        public readonly int Index;

        public TempoChange Tempo;

        public TimeSignatureChange TimeSignature;

        public SyncTrackChange(int index, TempoChange tempo, TimeSignatureChange timeSig, double time, uint tick) : base(time, tick)
        {
            Index = index;
            Tempo = tempo;
            TimeSignature = timeSig;
        }
    }
}
</file>

<file path="Extensions/BinaryReaderWriterExtensions.cs">
using System;
using System.Drawing;
using System.IO;

namespace YARG.Core.Extensions
{
    public static class BinaryReaderExtensions
    {
        public static Color ReadColor(this BinaryReader reader)
        {
            int argb = reader.ReadInt32();
            return Color.FromArgb(argb);
        }

        public static Guid ReadGuid(this BinaryReader reader)
        {
            Span<byte> span = stackalloc byte[16];
            if (reader.Read(span) != span.Length)
            {
                throw new EndOfStreamException("Failed to read GUID, ran out of bytes!");
            }
            return new Guid(span);
        }
    }

    public static class BinaryWriterExtensions
    {
        public static void Write(this BinaryWriter writer, Color color)
        {
            writer.Write(color.ToArgb());
        }

        public static void Write(this BinaryWriter writer, Guid guid)
        {
            Span<byte> span = stackalloc byte[16];
            if (!guid.TryWriteBytes(span))
            {
                throw new InvalidOperationException("Failed to write GUID bytes.");
            }

            writer.Write(span);
        }
    }
}
</file>

<file path="Extensions/CharacterExtensions.cs">
using System.Globalization;
using System.Runtime.CompilerServices;

namespace YARG.Core.Extensions
{
    // A majority of this is modified from mscorlib
    // https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Char.cs
    public static class CharacterExtensions
    {
        /// <summary>
        /// Indicates whether a character is within the specified inclusive range.
        /// </summary>
        /// <remarks>
        /// The method does not validate that <paramref name="maxInclusive"/> is greater than or equal
        /// to <paramref name="minInclusive"/>.  If <paramref name="maxInclusive"/> is less than
        /// <paramref name="minInclusive"/>, the behavior is undefined.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsBetween(this char c, char minInclusive, char maxInclusive)
            => (uint) (c - minInclusive) <= (uint) (maxInclusive - minInclusive);

        /// <summary>
        /// Indicates whether a Unicode category is within the specified inclusive range.
        /// </summary>
        /// <remarks>
        /// The method does not validate that <paramref name="maxInclusive"/> is greater than or equal
        /// to <paramref name="minInclusive"/>.  If <paramref name="maxInclusive"/> is less than
        /// <paramref name="minInclusive"/>, the behavior is undefined.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsBetween(this UnicodeCategory c, UnicodeCategory minInclusive, UnicodeCategory maxInclusive)
            => (uint) (c - minInclusive) <= (uint) (maxInclusive - minInclusive);

        #region ASCII
        public const byte ASCII_LOWERCASE_FLAG = 0x20;
        public const byte ASCII_MAX_VALUE = 0x7F;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static byte GetAsciiCharacterInfo(this char c)
            => c.IsAscii() ? Latin1CharInfo[c] : LATIN1_INFO_DEFAULT;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UnicodeCategory GetAsciiUnicodeCategory(this char c)
            => (UnicodeCategory) (GetAsciiCharacterInfo(c) & LATIN1_CATEGORY_MASK);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsAscii(this char c)
            => (uint) c <= ASCII_MAX_VALUE;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsAsciiLetter(this char c)
            => IsBetween((char) (c | ASCII_LOWERCASE_FLAG), 'a', 'z');

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsAsciiLetterUpper(this char c)
            => IsBetween(c, 'A', 'Z');

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsAsciiLetterLower(this char c)
            => IsBetween(c, 'a', 'z');

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsAsciiDigit(this char c)
            => c.IsBetween('0', '9');

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsAsciiWhitespace(this char c)
            => (uint) c <= 32;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static char ToAsciiUpper(this char c)
            => (char) (c & ~ASCII_LOWERCASE_FLAG);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static char ToAsciiLower(this char c)
            => (char) (c | ASCII_LOWERCASE_FLAG);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryAsciiToNumber(this char c, out int value)
        {
            uint converted = (uint) c - '0';
            value = (int) converted;
            return converted <= 9;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryAsciiToNumber(this char c, out uint value)
        {
            value = (uint) c - '0';
            return value <= 9;
        }
        #endregion

        #region Latin1
        // Private implementation details for the table below
        private const byte LATIN1_WHITESPACE_FLAG = 0x80;
        private const byte LATIN1_UPPERCASE_FLAG = 0x40;
        private const byte LATIN1_LOWERCASE_FLAG = 0x20;
        private const byte LATIN1_CATEGORY_MASK = 0x1F;
        private const byte LATIN1_INFO_DEFAULT = (byte) UnicodeCategory.OtherNotAssigned;

        // Contains information about the C0, Basic Latin, C1, and Latin-1 Supplement ranges [ U+0000..U+00FF ]:
        // - 0x80 means 'is whitespace'
        // - 0x40 means 'is uppercase letter'
        // - 0x20 means 'is lowercase letter'
        // - bottom 5 bits are the UnicodeCategory of the character
        private static readonly byte[] Latin1CharInfo = new byte[]
        {
            // 0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
            0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x0E, 0x0E, // U+0000..U+000F
            0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, // U+0010..U+001F
            0x8B, 0x18, 0x18, 0x18, 0x1A, 0x18, 0x18, 0x18, 0x14, 0x15, 0x18, 0x19, 0x18, 0x13, 0x18, 0x18, // U+0020..U+002F
            0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x18, 0x18, 0x19, 0x19, 0x19, 0x18, // U+0030..U+003F
            0x18, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, // U+0040..U+004F
            0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x14, 0x18, 0x15, 0x1B, 0x12, // U+0050..U+005F
            0x1B, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, // U+0060..U+006F
            0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x14, 0x19, 0x15, 0x19, 0x0E, // U+0070..U+007F
            0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x8E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, // U+0080..U+008F
            0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, // U+0090..U+009F
            0x8B, 0x18, 0x1A, 0x1A, 0x1A, 0x1A, 0x1C, 0x18, 0x1B, 0x1C, 0x04, 0x16, 0x19, 0x0F, 0x1C, 0x1B, // U+00A0..U+00AF
            0x1C, 0x19, 0x0A, 0x0A, 0x1B, 0x21, 0x18, 0x18, 0x1B, 0x0A, 0x04, 0x17, 0x0A, 0x0A, 0x0A, 0x18, // U+00B0..U+00BF
            0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, // U+00C0..U+00CF
            0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x19, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x21, // U+00D0..U+00DF
            0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, // U+00E0..U+00EF
            0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x19, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, // U+00F0..U+00FF
        };

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static byte GetLatin1CharacterInfo(this char c)
            => c.IsLatin1() ? Latin1CharInfo[c] : LATIN1_INFO_DEFAULT;

        /// <summary>
        /// Gets the Unicode category for the given Latin-1 character.
        /// </summary>
        /// <returns>
        /// If the character is Latin-1, its corresponding category; otherwise <see cref="UnicodeCategory.OtherNotAssigned"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UnicodeCategory GetLatin1UnicodeCategory(this char c)
            => (UnicodeCategory) (c.GetLatin1CharacterInfo() & LATIN1_CATEGORY_MASK);

        /// <summary>
        /// Determines whether or not the given character is Latin-1.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsLatin1(this char c)
            => (uint) c < Latin1CharInfo.Length;

        /// <summary>
        /// Determines whether or not the given character is a Latin-1 letter character.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsLatin1Letter(this char c)
            => c.GetLatin1UnicodeCategory().IsBetween(UnicodeCategory.UppercaseLetter, UnicodeCategory.OtherLetter);

        /// <summary>
        /// Determines whether or not the given character is a Latin-1 uppercase letter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsLatin1LetterUpper(this char c)
            => (c.GetLatin1CharacterInfo() & LATIN1_UPPERCASE_FLAG) != 0;

        /// <summary>
        /// Determines whether or not the given character is a Latin-1 lowercase letter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsLatin1LetterLower(this char c)
            => (c.GetLatin1CharacterInfo() & LATIN1_LOWERCASE_FLAG) != 0;

        /// <summary>
        /// Determines whether or not the given character is a Latin-1 number character.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsLatin1Number(this char c)
            => c.GetLatin1UnicodeCategory().IsBetween(UnicodeCategory.DecimalDigitNumber, UnicodeCategory.OtherNumber);

        /// <summary>
        /// Determines whether or not the given character is a Latin-1 digit character (0-9).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsLatin1Digit(this char c)
            => c.GetLatin1UnicodeCategory() == UnicodeCategory.DecimalDigitNumber;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsLatin1Punctuation(this char c)
            => c.GetLatin1UnicodeCategory().IsBetween(UnicodeCategory.ConnectorPunctuation, UnicodeCategory.OtherPunctuation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsLatin1Whitespace(this char c)
            => c.GetLatin1UnicodeCategory().IsBetween(UnicodeCategory.SpaceSeparator, UnicodeCategory.Surrogate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsLatin1WhitespaceOnly(this char c)
            => (c.GetLatin1CharacterInfo() & LATIN1_WHITESPACE_FLAG) != 0;
        #endregion
    }
}
</file>

<file path="Extensions/CollectionExtensions.cs">
using System;
using System.Collections.Generic;

namespace YARG.Core.Extensions
{
    public static class CollectionExtensions
    {
        /// <summary>
        /// Duplicates the list and every element inside it, such that the new list is
        /// entirely independent and shares no references with the original.
        /// </summary>
        public static List<T> Duplicate<T>(this List<T> list)
            where T : ICloneable<T>
        {
            var newlist = new List<T>();

            foreach (var ev in list)
            {
                var newEvent = ev.Clone();
                newlist.Add(newEvent);
            }

            return newlist;
        }

        /// <summary>
        /// Shuffles the list using the Fisher-Yates shuffle algorithm, using the given random number generator.
        /// </summary>
        /// <remarks>
        /// https://stackoverflow.com/questions/273313/randomize-a-listt
        /// </remarks>
        public static void Shuffle<T>(this List<T> list, Random random)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(0, n + 1);
                (list[k], list[n]) = (list[n], list[k]);
            }
        }

        /// <summary>
        /// Picks a random value from the list using the given random number generator.
        /// </summary>
        public static T PickRandom<T>(this List<T> list, Random random)
        {
            return list[random.Next(0, list.Count)];
        }

        /// <summary>
        /// Searches for an item in the list using the given search object and comparer function.
        /// </summary>
        /// <returns>
        /// The item from the list, or default if the list contains no elements.<br/>
        /// If no exact match was found, the item returned is the one that matches the most closely.
        /// </returns>
        public static TItem? BinarySearch<TItem, TSearch>(this List<TItem> list, TSearch searchObject,
            Func<TItem, TSearch, int> comparer)
        {
            int index = list.BinarySearchIndex(searchObject, comparer);
            if (index < 0)
                return default;

            return list[index];
        }

        /// <summary>
        /// Searches for an item in the list using the given search object and comparer function.
        /// </summary>
        /// <returns>
        /// The index of the item in the list, or -1 if the list contains no elements.<br/>
        /// If no exact match was found, the index returned is that of the item that matches the most closely.
        /// </returns>
        public static int BinarySearchIndex<TItem, TSearch>(this List<TItem> list, TSearch searchObject,
            Func<TItem, TSearch, int> comparer)
        {
            int low = 0;
            int high = list.Count - 1;
            int index = -1;

            while (low <= high)
            {
                int mid = (low + high) / 2;
                index = mid;

                var current = list[mid];
                int comparison = comparer(current, searchObject);
                if (comparison == 0)
                {
                    // The objects are equal
                    return index;
                }
                else if (comparison < 0)
                {
                    // The current object is less than the search object, exclude current lower bound
                    low = mid + 1;
                }
                else
                {
                    // The current object is greater than the search object, exclude current higher bound
                    high = mid - 1;
                }
            }

            return index;
        }

        /// <summary>
        /// Attempts to peek at the beginning of the queue.
        /// </summary>
        /// <returns>
        /// The peeked value, if available; otherwise the default value of <typeparamref name="T"/>.
        /// </returns>
        public static T? PeekOrDefault<T>(this Queue<T> queue)
        {
            if (queue.TryPeek(out var o))
            {
                return o;
            }

            return default;
        }

        /// <summary>
        /// Attempts to dequeue a value from the queue.
        /// </summary>
        /// <returns>
        /// The peeked value, if available; otherwise the default value of <typeparamref name="T"/>.
        /// </returns>
        public static T? DequeueOrDefault<T>(this Queue<T> queue)
        {
            if (queue.TryDequeue(out var o))
            {
                return o;
            }

            return default;
        }
    }
}
</file>

<file path="Extensions/EnumExtensions.cs">
using System;
using System.Runtime.CompilerServices;

namespace YARG.Core.Extensions
{
    public static class EnumExtensions<TEnum>
        where TEnum : Enum
    {
        public static readonly TEnum[] Values = (TEnum[])Enum.GetValues(typeof(TEnum));
        public static int Count => Values.Length;
    }

    public static class EnumExtensions
    {
        #region Non-boxing generic conversion of enums: https://stackoverflow.com/a/4026609
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryConvert<TEnum>(this TEnum @enum, out int value)
            where TEnum : unmanaged, Enum
        {
            bool success;
            (value, success) = Unsafe.SizeOf<TEnum>() switch
            {
                sizeof(int)   => (Unsafe.As<TEnum, int>(ref @enum), true),
                sizeof(short) => (Unsafe.As<TEnum, short>(ref @enum), true),
                sizeof(byte)  => (Unsafe.As<TEnum, byte>(ref @enum), true),
                _ => (0, false)
            };

            return success;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Convert<TEnum>(this TEnum @enum)
            where TEnum : unmanaged, Enum
        {
            if (!TryConvert(@enum, out int value))
                throw new ArgumentException($"Cannot convert {typeof(TEnum).Name} to an integer!", nameof(TEnum));

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryConvert<TEnum>(this int value, out TEnum @enum)
            where TEnum : unmanaged, Enum
        {
            short shortValue;
            byte byteValue;
            unchecked
            {
                shortValue = (short) value;
                byteValue = (byte) value;
            }
            bool success;
            (@enum, success) = Unsafe.SizeOf<TEnum>() switch
            {
                sizeof(int)   => (Unsafe.As<int, TEnum>(ref value), true),
                sizeof(short) => (Unsafe.As<short, TEnum>(ref shortValue), true),
                sizeof(byte)  => (Unsafe.As<byte, TEnum>(ref byteValue), true),
                _ => (default, false)
            };

            return success;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TEnum Convert<TEnum>(this int value)
            where TEnum : unmanaged, Enum
        {
            if (!TryConvert(value, out TEnum @enum))
                throw new ArgumentException($"Cannot convert the given integer to {typeof(TEnum).Name}!", nameof(TEnum));

            return @enum;
        }
        #endregion
    }
}
</file>

<file path="Extensions/ICloneable.cs">
using System.Diagnostics.CodeAnalysis;

// Since this is a generic version of an existing interface
// in the System namespace
namespace System
{
    /// <summary>
    /// Supports cloning in a generic fashion.
    /// </summary>
    public interface ICloneable<T> : ICloneable
    {
        /// <summary>
        /// Creates a copy of this object with the same set of values.
        /// </summary>
        [return: NotNull] // thanks Roslyn
        new T Clone();

        object ICloneable.Clone() => Clone();
    }
}
</file>

<file path="Extensions/MemoryExtensions.cs">
using System;
using YARG.Core.Logging;

namespace YARG.Core.Extensions
{
    public static class MemoryExtensions
    {
        public static bool TryWriteAndAdvance(ref this Span<char> dest, ReadOnlySpan<char> source, ref int written)
        {
            if (!source.TryCopyTo(dest))
                return false;

            dest = dest[source.Length..];
            written += source.Length;
            return true;
        }

        public static bool TryWriteAndAdvance(ref this Span<char> dest, char value, ref int written)
        {
            if (dest.Length < 1)
                return false;

            dest[0] = value;
            dest = dest[1..];
            written++;
            return true;
        }

        public static bool TryWriteAndAdvance(ref this Span<char> dest, int value, ref int written,
            ReadOnlySpan<char> format = default)
        {
            bool success = value.TryFormat(dest, out int valueWritten, format);
            written += valueWritten;

            if (success)
                dest = dest[valueWritten..];

            return success;
        }

        public static bool TryWriteAndAdvance(ref this Span<char> dest, double value, ref int written,
            ReadOnlySpan<char> format = default)
        {
            bool success = value.TryFormat(dest, out int valueWritten, format);
            written += valueWritten;

            if (success)
                dest = dest[valueWritten..];

            return success;
        }

        public static string ToHexString(this byte[] buffer, bool dashes = true)
            => buffer.AsSpan().ToHexString(dashes);

        public static string ToHexString(this Memory<byte> buffer, bool dashes = true)
            => ToHexString((ReadOnlySpan<byte>)buffer.Span, dashes);

        public static string ToHexString(this Span<byte> buffer, bool dashes = true)
            => ToHexString((ReadOnlySpan<byte>)buffer, dashes);

        public static string ToHexString(this ReadOnlyMemory<byte> buffer, bool dashes = true)
            => ToHexString(buffer.Span, dashes);

        public static string ToHexString(this ReadOnlySpan<byte> buffer, bool dashes = true)
        {
            Span<char> chars = stackalloc char[(buffer.Length * 3) - 1];
            bool success = TryFormatHex(buffer, chars, out _, dashes);
            YargLogger.Assert(success, "Failed to format bytes as hex string!");
            return new string(chars);
        }

        public static bool TryFormatHex(this byte[] buffer, Span<char> destination,
            out int charsWritten, bool dashes = true)
            => TryFormatHex(buffer.AsSpan(), destination, out charsWritten, dashes);

        public static bool TryFormatHex(this Memory<byte> buffer, Span<char> destination,
            out int charsWritten, bool dashes = true)
            => TryFormatHex((ReadOnlySpan<byte>)buffer.Span, destination, out charsWritten, dashes);

        public static bool TryFormatHex(this Span<byte> buffer, Span<char> destination,
            out int charsWritten, bool dashes = true)
            => TryFormatHex((ReadOnlySpan<byte>)buffer, destination, out charsWritten, dashes);

        public static bool TryFormatHex(this ReadOnlyMemory<byte> buffer, Span<char> destination,
            out int charsWritten, bool dashes = true)
            => TryFormatHex(buffer.Span, destination, out charsWritten, dashes);

        public static bool TryFormatHex(this ReadOnlySpan<byte> buffer, Span<char> destination,
            out int charsWritten, bool dashes = true)
        {
            const string characters = "0123456789ABCDEF";

            if (buffer.IsEmpty)
            {
                charsWritten = 0;
                return true;
            }

            int charsNeeded = (buffer.Length * 3) - 1;
            if (destination.Length < charsNeeded)
            {
                // Hint as to how many characters are needed
                charsWritten = charsNeeded;
                return false;
            }

            static void WriteByte(Span<char> destination, byte value, ref int index, ref int charsWritten)
            {
                destination[index++] = characters[(value & 0xF0) >> 4];
                destination[index++] = characters[value & 0x0F];
                charsWritten += 2;
            }

            // Write first byte directly
            int destIndex = 0;
            charsWritten = 0;
            WriteByte(destination, buffer[0], ref destIndex, ref charsWritten);

            if (dashes)
            {
                for (int i = 1; i < buffer.Length; i++)
                {
                    destination[destIndex++] = '-';
                    charsWritten++;
                    WriteByte(destination, buffer[i], ref destIndex, ref charsWritten);
                }
            }
            else
            {
                for (int i = 1; i < buffer.Length; i++)
                {
                    WriteByte(destination, buffer[i], ref destIndex, ref charsWritten);
                }
            }

            return true;
        }
    }
}
</file>

<file path="Extensions/MidiExtensions.cs">
using Melanchall.DryWetMidi.Core;

namespace YARG.Core.Extensions
{
    public static class MidiExtensions
    {
        public static void Merge(this MidiFile targetFile, MidiFile sourceFile)
        {
            // Index 1 to skip the sync track
            for (int sourceIndex = 1; sourceIndex < sourceFile.Chunks.Count; sourceIndex++)
            {
                if (sourceFile.Chunks[sourceIndex] is not TrackChunk sourceTrack)
                    continue;

                // Add immediately if the track has no name,
                // no reasonable way to compare if so
                string sourceName = sourceTrack.GetTrackName();
                if (string.IsNullOrEmpty(sourceName))
                {
                    targetFile.Chunks.Add(sourceTrack);
                    continue;
                }

                // Replace any existing tracks first
                bool isExisting = false;
                for (int targetIndex = 1; targetIndex < targetFile.Chunks.Count; targetIndex++)
                {
                    if (targetFile.Chunks[targetIndex] is not TrackChunk targetTrack)
                        continue;

                    if (sourceName == targetTrack.GetTrackName())
                    {
                        targetFile.Chunks[targetIndex] = sourceTrack;
                        isExisting = true;
                        break;
                    }
                }

                // Otherwise, add it
                if (!isExisting)
                    targetFile.Chunks.Add(sourceTrack);
            }
        }

        public static string GetTrackName(this TrackChunk track)
        {
            // The first event is not always the track name,
            // so we need to search through everything at tick 0
            for (int i = 0; i < track.Events.Count; i++)
            {
                var midiEvent = track.Events[i];

                // Search until the first event that's not at position 0,
                // indicated by the first non-zero delta-time
                if (midiEvent.DeltaTime != 0)
                    break;

                if (midiEvent.EventType == MidiEventType.SequenceTrackName &&
                    midiEvent is SequenceTrackNameEvent trackName)
                    return trackName.Text;
            }

            return "";
        }
    }
}
</file>

<file path="Extensions/StreamExtensions.cs">
using System;
using System.Drawing;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;

namespace YARG.Core.Extensions
{
    public enum Endianness
    {
        Little = 0,
        Big = 1,
    };

    public static class StreamExtensions
    {
        public static TType Read<TType>(this Stream stream, Endianness endianness)
            where TType : unmanaged, IComparable, IComparable<TType>, IConvertible, IEquatable<TType>, IFormattable
        {
            TType value = default;
            unsafe
            {
                if (stream.Read(new Span<byte>(&value, sizeof(TType))) != sizeof(TType))
                {
                    throw new EndOfStreamException($"Not enough data in the stream to read {typeof(TType)} ({sizeof(TType)} bytes)!");
                }
                CorrectByteOrder(&value, endianness);
            }
            return value;
        }

        public static bool ReadBoolean(this Stream stream)
        {
            byte b = (byte)stream.ReadByte();
            unsafe
            {
                return *(bool*)&b;
            }
        }

        public static int Read7BitEncodedInt(this Stream stream)
        {
            uint result = 0;
            byte byteReadJustNow;

            const int MaxBytesWithoutOverflow = 4;
            for (int shift = 0; shift < MaxBytesWithoutOverflow * 7; shift += 7)
            {
                byteReadJustNow = (byte) stream.ReadByte();
                result |= (byteReadJustNow & 0x7Fu) << shift;
                if (byteReadJustNow <= 0x7Fu)
                {
                    return (int) result;
                }
            }

            byteReadJustNow = (byte) stream.ReadByte();
            if (byteReadJustNow > 0b_1111u)
            {
                throw new Exception("LEB value exceeds max allowed");
            }

            result |= (uint) byteReadJustNow << MaxBytesWithoutOverflow * 7;
            return (int) result;
        }

        public static string ReadString(this Stream stream)
        {
            int length = Read7BitEncodedInt(stream);
            if (length == 0)
            {
                return string.Empty;
            }

            if (stream is UnmanagedMemoryStream unmanaged) unsafe
            {
                string str = Encoding.UTF8.GetString(unmanaged.PositionPointer, length);
                stream.Position += length;
                return str;
            }
            else if (stream is MemoryStream managed)
            {
                string str = Encoding.UTF8.GetString(managed.GetBuffer(), (int) managed.Position, length);
                stream.Position += length;
                return str;
            }

            var bytes = stream.ReadBytes(length);
            return Encoding.UTF8.GetString(bytes);
        }

        public static Color ReadColor(this Stream stream)
        {
            int argb = stream.Read<int>(Endianness.Little);
            return Color.FromArgb(argb);
        }

        public static Guid ReadGuid(this Stream stream)
        {
            Span<byte> span = stackalloc byte[16];
            if (stream.Read(span) != span.Length)
            {
                throw new EndOfStreamException("Failed to read GUID, ran out of bytes!");
            }
            return new Guid(span);
        }

        public static byte[] ReadBytes(this Stream stream, int length)
        {
            byte[] buffer = new byte[length];
            if (stream.Read(buffer, 0, length) != length)
            {
                throw new EndOfStreamException($"Not enough data in the stream to read {length} bytes!");
            }
            return buffer;
        }

        public static void Write<TType>(this Stream stream, TType value, Endianness endianness)
            where TType : unmanaged, IComparable, IComparable<TType>, IConvertible, IEquatable<TType>, IFormattable
        {
            unsafe
            {
                CorrectByteOrder(&value, endianness);
                stream.Write(new Span<byte>(&value, sizeof(TType)));
            }
        }

        public static void Write(this Stream stream, bool value)
        {
            unsafe
            {
                stream.WriteByte(*(byte*) &value);
            }
        }

        public static void Write7BitEncodedInt(this Stream stream, int value)
        {
            // Write out an int 7 bits at a time.  The high bit of the byte,
            // when on, tells reader to continue reading more bytes.
            uint v = (uint) value;   // support negative numbers
            while (v >= 0x80)
            {
                stream.WriteByte((byte) (v | 0x80));
                v >>= 7;
            }
            stream.WriteByte((byte) v);
        }

        public static unsafe void Write(this Stream stream, string value)
        {
            if (value.Length == 0)
            {
                stream.WriteByte(0);
                return;
            }

            var buffer = stackalloc byte[value.Length * 4];
            fixed (char* chars = value)
            {
                int len = Encoding.UTF8.GetBytes(chars, value.Length, buffer, value.Length * 4);
                stream.Write7BitEncodedInt(len);
                stream.Write(new ReadOnlySpan<byte>(buffer, len));
            }
        }

        public static void Write(this Stream stream, Color color)
        {
            stream.Write(color.ToArgb(), Endianness.Little);
        }

        public static void Write(this Stream stream, Guid guid)
        {
            Span<byte> span = stackalloc byte[16];
            if (!guid.TryWriteBytes(span))
            {
                throw new InvalidOperationException("Failed to write GUID bytes.");
            }
            stream.Write(span);
        }

        public static unsafe void CorrectByteOrder<TType>(TType* value, Endianness endianness)
            where TType : unmanaged, IComparable, IComparable<TType>, IConvertible, IEquatable<TType>, IFormattable
        {
            // Have to flip bits if the OS uses the opposite Endian
            if ((endianness == Endianness.Little) != BitConverter.IsLittleEndian)
            {
                int half = sizeof(TType) >> 1;
                byte* bytes = (byte*)value;
                for (int i = 0, j = sizeof(TType) - 1; i < half; ++i, --j)
                {
                    (bytes[j], bytes[i]) = (bytes[i], bytes[j]);
                }
            }
        }
    }
}
</file>

<file path="Extensions/StringExtensions.cs">
using System;

namespace YARG.Core.Extensions
{
    public static class StringExtensions
    {
        private interface ICharacterTrimmer
        {
            bool ShouldBeTrimmed(char c);
        }

        private readonly struct AsciiWhitespaceTrimmer : ICharacterTrimmer
        {
            public readonly bool ShouldBeTrimmed(char c)
                => c.IsAsciiWhitespace();
        }

        private readonly struct Latin1WhitespaceTrimmer : ICharacterTrimmer
        {
            public readonly bool ShouldBeTrimmed(char c)
                => c.IsLatin1Whitespace();
        }

        /// <summary>
        /// Removes all leading and trailing ASCII whitespace characters from the string.
        /// </summary>
        public static string TrimAscii(this string str)
            => str.AsSpan().TrimAscii().ToString();

        /// <summary>
        /// Removes all leading and trailing ASCII whitespace characters from the read-only character span.
        /// </summary>
        public static ReadOnlySpan<char> TrimAscii(this ReadOnlySpan<char> buffer)
            => buffer.Trim(new AsciiWhitespaceTrimmer());

        /// <summary>
        /// Removes all leading ASCII whitespace characters from the string.
        /// </summary>
        public static string TrimStartAscii(this string str)
            => str.AsSpan().TrimStartAscii().ToString();

        /// <summary>
        /// Removes all leading ASCII whitespace characters from the read-only character span.
        /// </summary>
        public static ReadOnlySpan<char> TrimStartAscii(this ReadOnlySpan<char> buffer)
            => buffer.TrimStart(new AsciiWhitespaceTrimmer());

        /// <summary>
        /// Removes all trailing ASCII whitespace characters from the string.
        /// </summary>
        public static string TrimEndAscii(this string str)
            => str.AsSpan().TrimEndAscii().ToString();

        /// <summary>
        /// Removes all trailing ASCII whitespace characters from the read-only character span.
        /// </summary>
        public static ReadOnlySpan<char> TrimEndAscii(this ReadOnlySpan<char> buffer)
            => buffer.TrimEnd(new AsciiWhitespaceTrimmer());

        /// <summary>
        /// Removes all leading and trailing Latin-1 whitespace characters from the string.
        /// </summary>
        public static string TrimLatin1(this string str)
            => str.AsSpan().TrimLatin1().ToString();

        /// <summary>
        /// Removes all leading and trailing Latin-1 whitespace characters from the read-only character span.
        /// </summary>
        public static ReadOnlySpan<char> TrimLatin1(this ReadOnlySpan<char> buffer)
            => buffer.Trim(new Latin1WhitespaceTrimmer());

        /// <summary>
        /// Removes all leading Latin-1 whitespace characters from the string.
        /// </summary>
        public static string TrimStartLatin1(this string str)
            => str.AsSpan().TrimStartLatin1().ToString();

        /// <summary>
        /// Removes all leading Latin-1 whitespace characters from the read-only character span.
        /// </summary>
        public static ReadOnlySpan<char> TrimStartLatin1(this ReadOnlySpan<char> buffer)
            => buffer.TrimStart(new Latin1WhitespaceTrimmer());

        /// <summary>
        /// Removes all trailing Latin-1 whitespace characters from the string.
        /// </summary>
        public static string TrimEndLatin1(this string str)
            => str.AsSpan().TrimEndLatin1().ToString();

        /// <summary>
        /// Removes all trailing Latin-1 whitespace characters from the read-only character span.
        /// </summary>
        public static ReadOnlySpan<char> TrimEndLatin1(this ReadOnlySpan<char> buffer)
            => buffer.TrimEnd(new Latin1WhitespaceTrimmer());

        /// <summary>
        /// Removes all leading and trailing characters from the read-only character span, based on the given trimmer.
        /// </summary>
        private static ReadOnlySpan<char> Trim<TTrimmer>(this ReadOnlySpan<char> buffer, TTrimmer trimmer)
            where TTrimmer : ICharacterTrimmer
        {
            int start = 0;
            int end = buffer.Length;

            while (start < buffer.Length && trimmer.ShouldBeTrimmed(buffer[start]))
                start++;

            while (end > start && trimmer.ShouldBeTrimmed(buffer[end - 1]))
                end--;

            return buffer[start..end];
        }

        /// <summary>
        /// Removes all leading characters from the read-only character span, based on the given trimmer.
        /// </summary>
        private static ReadOnlySpan<char> TrimStart<TTrimmer>(this ReadOnlySpan<char> buffer, TTrimmer trimmer)
            where TTrimmer : ICharacterTrimmer
        {
            int start = 0;

            while (start < buffer.Length && trimmer.ShouldBeTrimmed(buffer[start]))
                start++;

            return buffer[start..];
        }

        /// <summary>
        /// Removes all trailing characters from the read-only character span, based on the given trimmer.
        /// </summary>
        private static ReadOnlySpan<char> TrimEnd<TTrimmer>(this ReadOnlySpan<char> buffer, TTrimmer trimmer)
            where TTrimmer : ICharacterTrimmer
        {
            int end = buffer.Length;

            while (end > 0 && trimmer.ShouldBeTrimmed(buffer[end - 1]))
                end--;

            return buffer[..end];
        }

        /// <summary>
        /// Removes up to a single leading and a single trailing occurrence of a specified character from the read-only
        /// character span.
        /// </summary>
        public static ReadOnlySpan<char> TrimOnce(this ReadOnlySpan<char> buffer, char trimChar)
        {
            if (!buffer.IsEmpty && buffer[0] == trimChar)
                buffer = buffer[1..];
            if (!buffer.IsEmpty && buffer[^1] == trimChar)
                buffer = buffer[..^1];

            return buffer;
        }

        /// <summary>
        /// Removes up to a single leading occurrence of a specified character from the read-only character span.
        /// </summary>
        public static ReadOnlySpan<char> TrimStartOnce(this ReadOnlySpan<char> buffer, char trimChar)
        {
            if (!buffer.IsEmpty && buffer[0] == trimChar)
                buffer = buffer[1..];

            return buffer;
        }

        /// <summary>
        /// Removes up to a single trailing occurrence of a specified character from the read-only character span.
        /// </summary>
        public static ReadOnlySpan<char> TrimEndOnce(this ReadOnlySpan<char> buffer, char trimChar)
        {
            if (!buffer.IsEmpty && buffer[^1] == trimChar)
                buffer = buffer[..^1];

            return buffer;
        }
    }
}
</file>

<file path="Extensions/UnsafeExtensions.cs">
using System;
using System.Runtime.CompilerServices;

namespace YARG.Core.Extensions
{
    // Not actually extensions, just backported functions from Unsafe and BitConverter
    public static class UnsafeExtensions
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TTo BitCast<TFrom, TTo>(TFrom source)
            where TFrom : struct
            where TTo : struct
        {
            if (Unsafe.SizeOf<TFrom>() != Unsafe.SizeOf<TTo>())
                throw new NotSupportedException("Cannot cast between types of different sizes.");

            return Unsafe.ReadUnaligned<TTo>(ref Unsafe.As<TFrom, byte>(ref source));
        }

        public static ulong DoubleToUInt64Bits(double value)
        {
            return BitCast<double, ulong>(value);
        }

        public static double UInt64BitsToDouble(ulong value)
        {
            return BitCast<ulong, double>(value);
        }
    }
}
</file>

<file path="Game/Presets/BasePreset.cs">
using System;
using System.Security.Cryptography;
using System.Text;
using Newtonsoft.Json;

namespace YARG.Core.Game
{
    public abstract class BasePreset
    {
        /// <summary>
        /// The display name of the preset.
        /// </summary>
        public string Name;

        /// <summary>
        /// The unique ID of the preset.
        /// </summary>
        public Guid Id;

        /// <summary>
        /// The type of the preset in string form. This is only
        /// used for checking the type when importing a preset.
        /// </summary>
        public string? Type;

        /// <summary>
        /// Determines whether or not the preset should be modifiable in the settings.
        /// </summary>
        [JsonIgnore]
        public bool DefaultPreset;

        /// <summary>
        /// The path of the preset. This is only used to determine the path when it's in class form.
        /// </summary>
        [JsonIgnore]
        public string? Path;

        protected BasePreset(string name, bool defaultPreset)
        {
            Name = name;
            DefaultPreset = defaultPreset;

            Id = defaultPreset
                ? GetGuidForBasePreset(name)
                : Guid.NewGuid();
        }

        public abstract BasePreset CopyWithNewName(string name);

        private static Guid GetGuidForBasePreset(string name)
        {
            // Make sure default presets are consistent based on names.
            // This ensures that their GUIDs will be consistent (because they are constructed in code every time).
            using var md5 = MD5.Create();
            byte[] hash = md5.ComputeHash(Encoding.UTF8.GetBytes(name));
            return new Guid(hash);
        }
    }
}
</file>

<file path="Game/Presets/CameraPreset.cs">
using YARG.Core.Game.Settings;

namespace YARG.Core.Game
{
    public partial class CameraPreset : BasePreset
    {
        [SettingType(SettingType.Slider)]
        [SettingRange(40f, 150f)]
        public float FieldOfView = 55f;

        [SettingType(SettingType.Slider)]
        [SettingRange(0f, 4f)]
        public float PositionY = 2.66f;

        [SettingType(SettingType.Slider)]
        [SettingRange(0f, 12f)]
        public float PositionZ = 1.14f;

        [SettingType(SettingType.Slider)]
        [SettingRange(0f, 180f)]
        public float Rotation  = 24.12f;

        [SettingType(SettingType.Slider)]
        [SettingRange(0f, 5f)]
        public float FadeLength = 1.25f;

        [SettingType(SettingType.Slider)]
        [SettingRange(-3f, 3f)]
        public float CurveFactor = 0.5f;

        public CameraPreset(string name, bool defaultPreset = false) : base(name, defaultPreset)
        {
        }

        public override BasePreset CopyWithNewName(string name)
        {
            return new CameraPreset(name)
            {
                FieldOfView = FieldOfView,
                PositionY = PositionY,
                PositionZ = PositionZ,
                Rotation = Rotation,
                FadeLength = FadeLength,
                CurveFactor = CurveFactor,
            };
        }
    }
}
</file>

<file path="Game/Presets/CameraPreset.Defaults.cs">
using System.Collections.Generic;

namespace YARG.Core.Game
{
    public partial class CameraPreset
    {
        public static CameraPreset Default = new("Default", true);

        public static CameraPreset CircularDefault = new("Circular", true)
        {
            FieldOfView = 60f,
            PositionY = 2.39f,
            PositionZ = 1.54f,
            Rotation = 24.12f,
            FadeLength = 1.25f,
            CurveFactor = 0f,
        };

        public static readonly List<CameraPreset> Defaults = new()
        {
            Default,
            CircularDefault,
            new CameraPreset("High FOV", true)
            {
                FieldOfView = 60f,
                PositionY   = 2.66f,
                PositionZ   = 1.27f,
                Rotation    = 24.12f,
                FadeLength  = 1.25f,
                CurveFactor = 0.5f,
            },
            new CameraPreset("The Band 1", true)
            {
                FieldOfView = 47.84f,
                PositionY   = 2.32f,
                PositionZ   = 1.35f,
                Rotation    = 26f,
                FadeLength  = 1.25f,
                CurveFactor = 0.5f,
            },
            new CameraPreset("The Band 2", true)
            {
                FieldOfView = 44.97f,
                PositionY   = 2.72f,
                PositionZ   = 0.72f,
                Rotation    = 24.12f,
                FadeLength  = 1.25f,
                CurveFactor = 0.5f,
            },
            new CameraPreset("The Band 3", true)
            {
                FieldOfView = 57.29f,
                PositionY   = 2.22f,
                PositionZ   = 1.61f,
                Rotation    = 23.65f,
                FadeLength  = 1.25f,
                CurveFactor = 0.5f,
            },
            new CameraPreset("The Band 4", true)
            {
                FieldOfView = 62.16f,
                PositionY   = 2.56f,
                PositionZ   = 1.20f,
                Rotation    = 19.43f,
                FadeLength  = 1.25f,
                CurveFactor = 0.5f,
            },
            new CameraPreset("Hero 2", true)
            {
                FieldOfView = 58.15f,
                PositionY   = 1.82f,
                PositionZ   = 1.26f,
                Rotation    = 12.40f,
                FadeLength  = 1.5f,
                CurveFactor = 0f,
            },
            new CameraPreset("Hero 3", true)
            {
                FieldOfView = 52.71f,
                PositionY   = 2.17f,
                PositionZ   = 0.97f,
                Rotation    = 15.21f,
                FadeLength  = 1.5f,
                CurveFactor = 0f,
            },
            new CameraPreset("Hero Traveling the World", true)
            {
                FieldOfView  = 53.85f,
                PositionY    = 1.97f,
                PositionZ    = 1.31f,
                Rotation     = 16.62f,
                FadeLength   = 1.5f,
                CurveFactor  = 0f,
            },
            new CameraPreset("Hero Live", true)
            {
                FieldOfView = 62.16f,
                PositionY   = 2.40f,
                PositionZ   = 1.42f,
                Rotation    = 21.31f,
                FadeLength  = 1.25f,
                CurveFactor = 0f,
            },
            new CameraPreset("Clone", true)
            {
                FieldOfView = 55f,
                PositionY   = 2.07f,
                PositionZ   = 1.27f,
                Rotation    = 17.09f,
                FadeLength  = 1.5f,
                CurveFactor = 0f,
            }
        };
    }
}
</file>

<file path="Game/Presets/ColorProfile.cs">
using System.Drawing;
using System.IO;
using Newtonsoft.Json;
using YARG.Core.Game.Settings;
using YARG.Core.Utility;

namespace YARG.Core.Game
{
    public partial class ColorProfile : BasePreset, IBinarySerializable
    {
        private const int COLOR_PROFILE_VERSION = 1;

        /// <summary>
        /// Interface that has methods that allows for generic fret color retrieval.
        /// Not all instruments have frets, so it's an interface.
        /// </summary>
        public interface IFretColorProvider
        {
            public Color GetFretColor(int index);
            public Color GetFretInnerColor(int index);
            public Color GetParticleColor(int index);
        }

        [JsonIgnore]
        public int Version = COLOR_PROFILE_VERSION;

        [SettingSubSection]
        public FiveFretGuitarColors FiveFretGuitar;
        [SettingSubSection]
        public FourLaneDrumsColors FourLaneDrums;
        [SettingSubSection]
        public FiveLaneDrumsColors FiveLaneDrums;
        [SettingSubSection]
        public ProKeysColors ProKeys;

        public ColorProfile(string name, bool defaultPreset = false) : base(name, defaultPreset)
        {
            FiveFretGuitar = new FiveFretGuitarColors();
            FourLaneDrums = new FourLaneDrumsColors();
            FiveLaneDrums = new FiveLaneDrumsColors();
            ProKeys = new ProKeysColors();
        }

        public override BasePreset CopyWithNewName(string name)
        {
            return new ColorProfile(name)
            {
                FiveFretGuitar = FiveFretGuitar.Copy(),
                FourLaneDrums = FourLaneDrums.Copy(),
                FiveLaneDrums = FiveLaneDrums.Copy(),
                ProKeys = ProKeys.Copy(),
            };
        }

        public void Serialize(BinaryWriter writer)
        {
            writer.Write(Version);
            writer.Write(Name);

            FiveFretGuitar.Serialize(writer);
            FourLaneDrums.Serialize(writer);
            FiveLaneDrums.Serialize(writer);
            ProKeys.Serialize(writer);
        }

        public void Deserialize(BinaryReader reader, int version = 0)
        {
            version = reader.ReadInt32();
            Name = reader.ReadString();

            FiveFretGuitar.Deserialize(reader, version);
            FourLaneDrums.Deserialize(reader, version);
            FiveLaneDrums.Deserialize(reader, version);
            ProKeys.Deserialize(reader, version);
        }
    }
}
</file>

<file path="Game/Presets/ColorProfile.Defaults.cs">
using System.Collections.Generic;
using System.Drawing;

namespace YARG.Core.Game
{
    public partial class ColorProfile
    {
        #region Default Colors

        private static readonly Color DefaultPurple = Color.FromArgb(0xFF, 0xC8, 0x00, 0xFF); // #C800FF
        private static readonly Color DefaultGreen  = Color.FromArgb(0xFF, 0x79, 0xD3, 0x04); // #79D304
        private static readonly Color DefaultRed    = Color.FromArgb(0xFF, 0xFF, 0x1D, 0x23); // #FF1D23
        private static readonly Color DefaultYellow = Color.FromArgb(0xFF, 0xFF, 0xE9, 0x00); // #FFE900
        private static readonly Color DefaultBlue   = Color.FromArgb(0xFF, 0x00, 0xBF, 0xFF); // #00BFFF
        private static readonly Color DefaultOrange = Color.FromArgb(0xFF, 0xFF, 0x84, 0x00); // #FF8400

        private static readonly Color DefaultStarpower = Color.White; // #FFFFFF

        #endregion

        #region Circular Colors

        private static readonly Color CircularPurple = Color.FromArgb(0xFF, 0xBE, 0x0F, 0xFF); // #BE0FFF
        private static readonly Color CircularGreen  = Color.FromArgb(0xFF, 0x00, 0xC9, 0x0E); // #00C90E
        private static readonly Color CircularRed    = Color.FromArgb(0xFF, 0xC3, 0x00, 0x00); // #C30000
        private static readonly Color CircularYellow = Color.FromArgb(0xFF, 0xF5, 0xD0, 0x00); // #F5D000
        private static readonly Color CircularBlue   = Color.FromArgb(0xFF, 0x00, 0x5C, 0xF5); // #005CF5
        private static readonly Color CircularOrange = Color.FromArgb(0xFF, 0xFF, 0x84, 0x00); // #FF8400

        private static readonly Color CircularStarpower = Color.FromArgb(0xFF, 0x13, 0xD9, 0xEA); // #13D9EA

        #endregion

        #region April Fools Colors

        private static readonly Color AprilFoolsGreen  = Color.FromArgb(0xFF, 0x24, 0xB9, 0x00); // #24B900
        private static readonly Color AprilFoolsRed    = Color.FromArgb(0xFF, 0xD1, 0x13, 0x00); // #D11300
        private static readonly Color AprilFoolsYellow = Color.FromArgb(0xFF, 0xD1, 0xA7, 0x00); // #D1A700
        private static readonly Color AprilFoolsBlue   = Color.FromArgb(0xFF, 0x00, 0x1A, 0xDC); // #001ADC
        private static readonly Color AprilFoolsPurple = Color.FromArgb(0xFF, 0xEB, 0x00, 0xD1); // #EB00D1

        #endregion

        public static ColorProfile Default = new("Default", true);

        public static ColorProfile CircularDefault = new("Circular", true)
        {
            FiveFretGuitar = new FiveFretGuitarColors
            {
                OpenFret   = CircularPurple,
                GreenFret  = CircularGreen,
                RedFret    = CircularRed,
                YellowFret = CircularYellow,
                BlueFret   = CircularBlue,
                OrangeFret = CircularOrange,

                OpenFretInner   = CircularPurple,
                GreenFretInner  = CircularGreen,
                RedFretInner    = CircularRed,
                YellowFretInner = CircularYellow,
                BlueFretInner   = CircularBlue,
                OrangeFretInner = CircularOrange,

                OpenNote   = CircularPurple,
                GreenNote  = CircularGreen,
                RedNote    = CircularRed,
                YellowNote = CircularYellow,
                BlueNote   = CircularBlue,
                OrangeNote = CircularOrange,

                OpenNoteStarPower   = CircularStarpower,
                GreenNoteStarPower  = CircularStarpower,
                RedNoteStarPower    = CircularStarpower,
                YellowNoteStarPower = CircularStarpower,
                BlueNoteStarPower   = CircularStarpower,
                OrangeNoteStarPower = CircularStarpower,
            }
        };

        public static ColorProfile AprilFoolsDefault = new("YARG on Fire", true)
        {
            FiveFretGuitar = new FiveFretGuitarColors
            {
                OpenFret   = CircularOrange,
                GreenFret  = AprilFoolsGreen,
                RedFret    = AprilFoolsRed,
                YellowFret = AprilFoolsYellow,
                BlueFret   = AprilFoolsBlue,
                OrangeFret = AprilFoolsPurple,

                OpenFretInner   = CircularOrange,
                GreenFretInner  = AprilFoolsGreen,
                RedFretInner    = AprilFoolsRed,
                YellowFretInner = AprilFoolsYellow,
                BlueFretInner   = AprilFoolsBlue,
                OrangeFretInner = AprilFoolsPurple,

                OpenNote   = CircularOrange,
                GreenNote  = AprilFoolsGreen,
                RedNote    = AprilFoolsRed,
                YellowNote = AprilFoolsYellow,
                BlueNote   = AprilFoolsBlue,
                OrangeNote = AprilFoolsPurple,

                OpenNoteStarPower   = CircularStarpower,
                GreenNoteStarPower  = CircularStarpower,
                RedNoteStarPower    = CircularStarpower,
                YellowNoteStarPower = CircularStarpower,
                BlueNoteStarPower   = CircularStarpower,
                OrangeNoteStarPower = CircularStarpower,
            },
            FourLaneDrums = new FourLaneDrumsColors
            {
                KickFret   = AprilFoolsPurple,
                RedFret    = AprilFoolsRed,
                YellowFret = AprilFoolsYellow,
                BlueFret   = AprilFoolsBlue,
                GreenFret  = AprilFoolsGreen,

                KickFretInner   = AprilFoolsPurple,
                RedFretInner    = AprilFoolsRed,
                YellowFretInner = AprilFoolsYellow,
                BlueFretInner   = AprilFoolsBlue,
                GreenFretInner  = AprilFoolsGreen,

                KickNote = AprilFoolsPurple,

                RedDrum    = AprilFoolsRed,
                YellowDrum = AprilFoolsYellow,
                BlueDrum   = AprilFoolsBlue,
                GreenDrum  = AprilFoolsGreen,

                RedCymbal    = AprilFoolsRed,
                YellowCymbal = AprilFoolsYellow,
                BlueCymbal   = AprilFoolsBlue,
                GreenCymbal  = AprilFoolsGreen,

                KickStarpower = CircularStarpower,

                RedDrumStarpower    = CircularStarpower,
                YellowDrumStarpower = CircularStarpower,
                BlueDrumStarpower   = CircularStarpower,
                GreenDrumStarpower  = CircularStarpower,

                RedCymbalStarpower    = CircularStarpower,
                YellowCymbalStarpower = CircularStarpower,
                BlueCymbalStarpower   = CircularStarpower,
                GreenCymbalStarpower  = CircularStarpower,
            },
            FiveLaneDrums = new FiveLaneDrumsColors
            {
                KickFret   = CircularOrange,
                RedFret    = AprilFoolsRed,
                YellowFret = AprilFoolsYellow,
                BlueFret   = AprilFoolsBlue,
                OrangeFret = AprilFoolsPurple,
                GreenFret  = AprilFoolsGreen,

                KickFretInner   = CircularOrange,
                RedFretInner    = AprilFoolsRed,
                YellowFretInner = AprilFoolsYellow,
                BlueFretInner   = AprilFoolsBlue,
                OrangeFretInner = AprilFoolsPurple,
                GreenFretInner  = AprilFoolsGreen,

                KickNote   = CircularOrange,
                RedNote    = AprilFoolsRed,
                YellowNote = AprilFoolsYellow,
                BlueNote   = AprilFoolsBlue,
                OrangeNote = AprilFoolsPurple,
                GreenNote  = AprilFoolsGreen,

                KickStarpower   = CircularStarpower,
                RedStarpower    = CircularStarpower,
                YellowStarpower = CircularStarpower,
                BlueStarpower   = CircularStarpower,
                OrangeStarpower = CircularStarpower,
                GreenStarpower  = CircularStarpower,
            }
        };

        public static readonly List<ColorProfile> Defaults = new()
        {
            Default,
            CircularDefault,
            AprilFoolsDefault
        };
    }
}
</file>

<file path="Game/Presets/ColorProfile.FiveFretGuitar.cs">
using System.Drawing;
using System.IO;
using YARG.Core.Chart;
using YARG.Core.Extensions;
using YARG.Core.Utility;

namespace YARG.Core.Game
{
    public partial class ColorProfile
    {
        public class FiveFretGuitarColors : IFretColorProvider, IBinarySerializable
        {
            #region Frets

            public Color OpenFret   = DefaultPurple;
            public Color GreenFret  = DefaultGreen;
            public Color RedFret    = DefaultRed;
            public Color YellowFret = DefaultYellow;
            public Color BlueFret   = DefaultBlue;
            public Color OrangeFret = DefaultOrange;

            /// <summary>
            /// Gets the fret color for a specific note index.
            /// 0 = open note, 1 = green, 5 = orange.
            /// </summary>
            public Color GetFretColor(int index)
            {
                return index switch
                {
                    1 => GreenFret,
                    2 => RedFret,
                    3 => YellowFret,
                    4 => BlueFret,
                    5 => OrangeFret,
                    (int) FiveFretGuitarFret.Open => OpenFret,
                    _ => default
                };
            }

            public Color OpenFretInner   = DefaultPurple;
            public Color GreenFretInner  = DefaultGreen;
            public Color RedFretInner    = DefaultRed;
            public Color YellowFretInner = DefaultYellow;
            public Color BlueFretInner   = DefaultBlue;
            public Color OrangeFretInner = DefaultOrange;

            /// <summary>
            /// Gets the inner fret color for a specific note index.
            /// 0 = open note, 1 = green, 5 = orange.
            /// </summary>
            public Color GetFretInnerColor(int index)
            {
                return index switch
                {
                    0 => OpenFretInner,
                    1 => GreenFretInner,
                    2 => RedFretInner,
                    3 => YellowFretInner,
                    4 => BlueFretInner,
                    5 => OrangeFretInner,
                    _ => default
                };
            }

            public Color OpenParticles   = DefaultPurple;
            public Color GreenParticles  = DefaultGreen;
            public Color RedParticles    = DefaultRed;
            public Color YellowParticles = DefaultYellow;
            public Color BlueParticles   = DefaultBlue;
            public Color OrangeParticles = DefaultOrange;

            /// <summary>
            /// Gets the particle color for a specific note index.
            /// 0 = open note, 1 = green, 5 = orange.
            /// </summary>
            public Color GetParticleColor(int index)
            {
                return index switch
                {
                    0 => OpenParticles,
                    1 => GreenParticles,
                    2 => RedParticles,
                    3 => YellowParticles,
                    4 => BlueParticles,
                    5 => OrangeParticles,
                    _ => default
                };
            }

            #endregion

            #region Notes

            public Color OpenNote   = DefaultPurple;
            public Color GreenNote  = DefaultGreen;
            public Color RedNote    = DefaultRed;
            public Color YellowNote = DefaultYellow;
            public Color BlueNote   = DefaultBlue;
            public Color OrangeNote = DefaultOrange;

            /// <summary>
            /// Gets the note color for a specific note index.
            /// 1 = green, 5 = orange.
            /// </summary>
            public Color GetNoteColor(int index)
            {
                return index switch
                {
                    1 => GreenNote,
                    2 => RedNote,
                    3 => YellowNote,
                    4 => BlueNote,
                    5 => OrangeNote,
                    (int) FiveFretGuitarFret.Open => OpenNote,
                    _ => default
                };
            }

            public Color OpenNoteStarPower   = DefaultStarpower;
            public Color GreenNoteStarPower  = DefaultStarpower;
            public Color RedNoteStarPower    = DefaultStarpower;
            public Color YellowNoteStarPower = DefaultStarpower;
            public Color BlueNoteStarPower   = DefaultStarpower;
            public Color OrangeNoteStarPower = DefaultStarpower;

            /// <summary>
            /// Gets the Star Power note color for a specific note index.
            /// 1 = green, 5 = orange.
            /// </summary>
            public Color GetNoteStarPowerColor(int index)
            {
                return index switch
                {
                    1 => GreenNoteStarPower,
                    2 => RedNoteStarPower,
                    3 => YellowNoteStarPower,
                    4 => BlueNoteStarPower,
                    5 => OrangeNoteStarPower,
                    (int) FiveFretGuitarFret.Open => OpenNoteStarPower,
                    _ => default
                };
            }

            #endregion

            #region Serialization

            public FiveFretGuitarColors Copy()
            {
                // Kinda yucky, but it's easier to maintain
                return (FiveFretGuitarColors) MemberwiseClone();
            }

            public void Serialize(BinaryWriter writer)
            {
                writer.Write(OpenFret);
                writer.Write(GreenFret);
                writer.Write(RedFret);
                writer.Write(YellowFret);
                writer.Write(BlueFret);
                writer.Write(OrangeFret);

                writer.Write(OpenFretInner);
                writer.Write(GreenFretInner);
                writer.Write(RedFretInner);
                writer.Write(YellowFretInner);
                writer.Write(BlueFretInner);
                writer.Write(OrangeFretInner);

                writer.Write(OpenParticles);
                writer.Write(GreenParticles);
                writer.Write(RedParticles);
                writer.Write(YellowParticles);
                writer.Write(BlueParticles);
                writer.Write(OrangeParticles);

                writer.Write(OpenNote);
                writer.Write(GreenNote);
                writer.Write(RedNote);
                writer.Write(YellowNote);
                writer.Write(BlueNote);
                writer.Write(OrangeNote);

                writer.Write(OpenNoteStarPower);
                writer.Write(GreenNoteStarPower);
                writer.Write(RedNoteStarPower);
                writer.Write(YellowNoteStarPower);
                writer.Write(BlueNoteStarPower);
                writer.Write(OrangeNoteStarPower);
            }

            public void Deserialize(BinaryReader reader, int version = 0)
            {
                OpenFret = reader.ReadColor();
                GreenFret = reader.ReadColor();
                RedFret = reader.ReadColor();
                YellowFret = reader.ReadColor();
                BlueFret = reader.ReadColor();
                OrangeFret = reader.ReadColor();

                OpenFretInner = reader.ReadColor();
                GreenFretInner = reader.ReadColor();
                RedFretInner = reader.ReadColor();
                YellowFretInner = reader.ReadColor();
                BlueFretInner = reader.ReadColor();
                OrangeFretInner = reader.ReadColor();

                OpenParticles = reader.ReadColor();
                GreenParticles = reader.ReadColor();
                RedParticles = reader.ReadColor();
                YellowParticles = reader.ReadColor();
                BlueParticles = reader.ReadColor();
                OrangeParticles = reader.ReadColor();

                OpenNote = reader.ReadColor();
                GreenNote = reader.ReadColor();
                RedNote = reader.ReadColor();
                YellowNote = reader.ReadColor();
                BlueNote = reader.ReadColor();
                OrangeNote = reader.ReadColor();

                OpenNoteStarPower = reader.ReadColor();
                GreenNoteStarPower = reader.ReadColor();
                RedNoteStarPower = reader.ReadColor();
                YellowNoteStarPower = reader.ReadColor();
                BlueNoteStarPower = reader.ReadColor();
                OrangeNoteStarPower = reader.ReadColor();
            }

            #endregion
        }
    }
}
</file>

<file path="Game/Presets/ColorProfile.FiveLaneDrums.cs">
using System.Drawing;
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.Utility;

namespace YARG.Core.Game
{
    public partial class ColorProfile
    {
        public class FiveLaneDrumsColors : IFretColorProvider, IBinarySerializable
        {
            #region Frets

            public Color KickFret   = Color.FromArgb(0xFF, 0xE6, 0x3F, 0xFF); // #E63FFF;
            public Color RedFret    = DefaultRed;
            public Color YellowFret = DefaultYellow;
            public Color BlueFret   = DefaultBlue;
            public Color OrangeFret = DefaultOrange;
            public Color GreenFret  = DefaultGreen;

            /// <summary>
            /// Gets the fret color for a specific note index.
            /// 0 = kick note, 1 = red, 5 = green.
            /// </summary>
            public Color GetFretColor(int index)
            {
                return index switch
                {
                    0 => KickFret,
                    1 => RedFret,
                    2 => YellowFret,
                    3 => BlueFret,
                    4 => OrangeFret,
                    5 => GreenFret,
                    _ => default
                };
            }

            public Color KickFretInner   = DefaultPurple;
            public Color RedFretInner    = DefaultRed;
            public Color YellowFretInner = DefaultYellow;
            public Color BlueFretInner   = DefaultBlue;
            public Color OrangeFretInner = DefaultOrange;
            public Color GreenFretInner  = DefaultGreen;

            /// <summary>
            /// Gets the inner fret color for a specific note index.
            /// 0 = kick note, 1 = red, 5 = green.
            /// </summary>
            public Color GetFretInnerColor(int index)
            {
                return index switch
                {
                    0 => KickFretInner,
                    1 => RedFretInner,
                    2 => YellowFretInner,
                    3 => BlueFretInner,
                    4 => OrangeFretInner,
                    5 => GreenFretInner,
                    _ => default
                };
            }

            public Color KickParticles   = Color.FromArgb(0xFF, 0xD5, 0x00, 0xFF); // #D500FF
            public Color RedParticles    = DefaultRed;
            public Color YellowParticles = DefaultYellow;
            public Color BlueParticles   = DefaultBlue;
            public Color OrangeParticles = DefaultOrange;
            public Color GreenParticles  = DefaultGreen;

            /// <summary>
            /// Gets the particle color for a specific note index.
            /// 0 = kick note, 1 = red, 5 = green.
            /// </summary>
            public Color GetParticleColor(int index)
            {
                return index switch
                {
                    0 => KickParticles,
                    1 => RedParticles,
                    2 => YellowParticles,
                    3 => BlueParticles,
                    4 => OrangeParticles,
                    5 => GreenParticles,
                    _ => default
                };
            }

            #endregion

            #region Notes

            public Color KickNote = DefaultPurple;

            public Color RedNote    = DefaultRed;
            public Color YellowNote = DefaultYellow;
            public Color BlueNote   = DefaultBlue;
            public Color OrangeNote = DefaultOrange;
            public Color GreenNote  = DefaultGreen;

            /// <summary>
            /// Gets the note color for a specific note index.
            /// 0 = kick note, 1 = red drum, 5 = green drum.
            /// </summary>
            public Color GetNoteColor(int index)
            {
                return index switch
                {
                    0 => KickNote,

                    1 => RedNote,
                    2 => YellowNote,
                    3 => BlueNote,
                    4 => OrangeNote,
                    5 => GreenNote,

                    _ => default
                };
            }

            public Color KickStarpower = DefaultStarpower;

            public Color RedStarpower    = DefaultStarpower;
            public Color YellowStarpower = DefaultStarpower;
            public Color BlueStarpower   = DefaultStarpower;
            public Color OrangeStarpower = DefaultStarpower;
            public Color GreenStarpower  = DefaultStarpower;

            /// <summary>
            /// Gets the Star Power note color for a specific note index.
            /// 0 = kick note, 1 = red drum, 5 = green drum.
            /// </summary>
            public Color GetNoteStarPowerColor(int index)
            {
                return index switch
                {
                    0 => KickStarpower,

                    1 => RedStarpower,
                    2 => YellowStarpower,
                    3 => BlueStarpower,
                    4 => OrangeStarpower,
                    5 => GreenStarpower,

                    _ => default
                };
            }

            public Color ActivationNote = DefaultPurple;

            #endregion

            #region Serialization

            public FiveLaneDrumsColors Copy()
            {
                // Kinda yucky, but it's easier to maintain
                return (FiveLaneDrumsColors) MemberwiseClone();
            }

            public void Serialize(BinaryWriter writer)
            {
                writer.Write(KickFret);
                writer.Write(RedFret);
                writer.Write(YellowFret);
                writer.Write(BlueFret);
                writer.Write(OrangeFret);
                writer.Write(GreenFret);

                writer.Write(KickFretInner);
                writer.Write(RedFretInner);
                writer.Write(YellowFretInner);
                writer.Write(BlueFretInner);
                writer.Write(OrangeFretInner);
                writer.Write(GreenFretInner);

                writer.Write(KickParticles);
                writer.Write(RedParticles);
                writer.Write(YellowParticles);
                writer.Write(BlueParticles);
                writer.Write(OrangeParticles);
                writer.Write(GreenParticles);

                writer.Write(KickNote);
                writer.Write(RedNote);
                writer.Write(YellowNote);
                writer.Write(BlueNote);
                writer.Write(OrangeNote);
                writer.Write(GreenNote);

                writer.Write(KickStarpower);
                writer.Write(RedStarpower);
                writer.Write(YellowStarpower);
                writer.Write(BlueStarpower);
                writer.Write(OrangeStarpower);
                writer.Write(GreenStarpower);

                writer.Write(ActivationNote);
            }

            public void Deserialize(BinaryReader reader, int version = 0)
            {
                KickFret = reader.ReadColor();
                RedFret = reader.ReadColor();
                YellowFret = reader.ReadColor();
                BlueFret = reader.ReadColor();
                OrangeFret = reader.ReadColor();
                GreenFret = reader.ReadColor();

                KickFretInner = reader.ReadColor();
                RedFretInner = reader.ReadColor();
                YellowFretInner = reader.ReadColor();
                BlueFretInner = reader.ReadColor();
                OrangeFretInner = reader.ReadColor();
                GreenFretInner = reader.ReadColor();

                KickParticles = reader.ReadColor();
                RedParticles = reader.ReadColor();
                YellowParticles = reader.ReadColor();
                BlueParticles = reader.ReadColor();
                OrangeParticles = reader.ReadColor();
                GreenParticles = reader.ReadColor();

                KickNote = reader.ReadColor();
                RedNote = reader.ReadColor();
                YellowNote = reader.ReadColor();
                BlueNote = reader.ReadColor();
                OrangeNote = reader.ReadColor();
                GreenNote = reader.ReadColor();

                KickStarpower = reader.ReadColor();
                RedStarpower = reader.ReadColor();
                YellowStarpower = reader.ReadColor();
                BlueStarpower = reader.ReadColor();
                OrangeStarpower = reader.ReadColor();
                GreenStarpower = reader.ReadColor();

                ActivationNote = reader.ReadColor();
            }

            #endregion
        }
    }
}
</file>

<file path="Game/Presets/ColorProfile.FourLaneDrums.cs">
using System.Drawing;
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.Utility;

namespace YARG.Core.Game
{
    public partial class ColorProfile
    {
        public class FourLaneDrumsColors : IFretColorProvider, IBinarySerializable
        {
            #region Frets

            public Color KickFret   = DefaultOrange;
            public Color RedFret    = DefaultRed;
            public Color YellowFret = DefaultYellow;
            public Color BlueFret   = DefaultBlue;
            public Color GreenFret  = DefaultGreen;

            /// <summary>
            /// Gets the fret color for a specific note index.
            /// 0 = kick note, 1 = red, 4 = green.
            /// </summary>
            public Color GetFretColor(int index)
            {
                return index switch
                {
                    0 => KickFret,
                    1 => RedFret,
                    2 => YellowFret,
                    3 => BlueFret,
                    4 => GreenFret,
                    _ => default
                };
            }

            public Color KickFretInner   = DefaultOrange;
            public Color RedFretInner    = DefaultRed;
            public Color YellowFretInner = DefaultYellow;
            public Color BlueFretInner   = DefaultBlue;
            public Color GreenFretInner  = DefaultGreen;

            /// <summary>
            /// Gets the inner fret color for a specific note index.
            /// 0 = kick note, 1 = red, 4 = green.
            /// </summary>
            public Color GetFretInnerColor(int index)
            {
                return index switch
                {
                    0 => KickFretInner,
                    1 => RedFretInner,
                    2 => YellowFretInner,
                    3 => BlueFretInner,
                    4 => GreenFretInner,
                    _ => default
                };
            }

            public Color KickParticles   = Color.FromArgb(0xFF, 0xFF, 0xB6, 0x00); // #FFB600
            public Color RedParticles    = DefaultRed;
            public Color YellowParticles = DefaultYellow;
            public Color BlueParticles   = DefaultBlue;
            public Color GreenParticles  = DefaultGreen;

            /// <summary>
            /// Gets the particle color for a specific note index.
            /// 0 = kick note, 1 = red, 4 = green.
            /// </summary>
            public Color GetParticleColor(int index)
            {
                return index switch
                {
                    0 => KickParticles,
                    1 => RedParticles,
                    2 => YellowParticles,
                    3 => BlueParticles,
                    4 => GreenParticles,
                    _ => default
                };
            }

            #endregion

            #region Notes

            public Color KickNote = DefaultOrange;

            public Color RedDrum    = DefaultRed;
            public Color YellowDrum = DefaultYellow;
            public Color BlueDrum   = DefaultBlue;
            public Color GreenDrum  = DefaultGreen;

            public Color RedCymbal    = DefaultRed;
            public Color YellowCymbal = DefaultYellow;
            public Color BlueCymbal   = DefaultBlue;
            public Color GreenCymbal  = DefaultGreen;

            /// <summary>
            /// Gets the note color for a specific note index.
            /// 0 = kick note, 1 = red drum, 4 = green drum, 5 = yellow cymbal.
            /// 8 is a special case: it is the red cymbal that is used in lefty-flip.
            /// </summary>
            public Color GetNoteColor(int index)
            {
                return index switch
                {
                    0 => KickNote,

                    1 => RedDrum,
                    2 => YellowDrum,
                    3 => BlueDrum,
                    4 => GreenDrum,

                    5 => YellowCymbal,
                    6 => BlueCymbal,
                    7 => GreenCymbal,
                    8 => RedCymbal,

                    _ => default
                };
            }

            public Color KickStarpower = DefaultStarpower;

            public Color RedDrumStarpower    = DefaultStarpower;
            public Color YellowDrumStarpower = DefaultStarpower;
            public Color BlueDrumStarpower   = DefaultStarpower;
            public Color GreenDrumStarpower  = DefaultStarpower;

            public Color RedCymbalStarpower    = DefaultStarpower;
            public Color YellowCymbalStarpower = DefaultStarpower;
            public Color BlueCymbalStarpower   = DefaultStarpower;
            public Color GreenCymbalStarpower  = DefaultStarpower;

            /// <summary>
            /// Gets the Star Power note color for a specific note index.
            /// 0 = kick note, 1 = red drum, 4 = green drum, 5 = yellow cymbal.
            /// 8 is a special case: it is the red cymbal that is used in lefty-flip.
            /// </summary>
            public Color GetNoteStarPowerColor(int index)
            {
                return index switch
                {
                    0 => KickStarpower,

                    1 => RedDrumStarpower,
                    2 => YellowDrumStarpower,
                    3 => BlueDrumStarpower,
                    4 => GreenDrumStarpower,

                    5 => YellowCymbalStarpower,
                    6 => BlueCymbalStarpower,
                    7 => GreenCymbalStarpower,
                    8 => RedCymbalStarpower,

                    _ => default
                };
            }

            public Color ActivationNote = DefaultPurple;

            #endregion

            #region Serialization

            public FourLaneDrumsColors Copy()
            {
                // Kinda yucky, but it's easier to maintain
                return (FourLaneDrumsColors) MemberwiseClone();
            }

            public void Serialize(BinaryWriter writer)
            {
                writer.Write(KickFret);
                writer.Write(RedFret);
                writer.Write(YellowFret);
                writer.Write(BlueFret);
                writer.Write(GreenFret);

                writer.Write(KickFretInner);
                writer.Write(RedFretInner);
                writer.Write(YellowFretInner);
                writer.Write(BlueFretInner);
                writer.Write(GreenFretInner);

                writer.Write(KickParticles);
                writer.Write(RedParticles);
                writer.Write(YellowParticles);
                writer.Write(BlueParticles);
                writer.Write(GreenParticles);

                writer.Write(KickNote);
                writer.Write(RedDrum);
                writer.Write(YellowDrum);
                writer.Write(BlueDrum);
                writer.Write(GreenDrum);

                writer.Write(RedCymbal);
                writer.Write(YellowCymbal);
                writer.Write(BlueCymbal);
                writer.Write(GreenCymbal);

                writer.Write(KickStarpower);
                writer.Write(RedDrumStarpower);
                writer.Write(YellowDrumStarpower);
                writer.Write(BlueDrumStarpower);
                writer.Write(GreenDrumStarpower);

                writer.Write(RedCymbalStarpower);
                writer.Write(YellowCymbalStarpower);
                writer.Write(BlueCymbalStarpower);
                writer.Write(GreenCymbalStarpower);

                writer.Write(ActivationNote);
            }

            public void Deserialize(BinaryReader reader, int version = 0)
            {
                KickFret = reader.ReadColor();
                RedFret = reader.ReadColor();
                YellowFret = reader.ReadColor();
                BlueFret = reader.ReadColor();
                GreenFret = reader.ReadColor();

                KickFretInner = reader.ReadColor();
                RedFretInner = reader.ReadColor();
                YellowFretInner = reader.ReadColor();
                BlueFretInner = reader.ReadColor();
                GreenFretInner = reader.ReadColor();

                KickParticles = reader.ReadColor();
                RedParticles = reader.ReadColor();
                YellowParticles = reader.ReadColor();
                BlueParticles = reader.ReadColor();
                GreenParticles = reader.ReadColor();

                KickNote = reader.ReadColor();
                RedDrum = reader.ReadColor();
                YellowDrum = reader.ReadColor();
                BlueDrum = reader.ReadColor();
                GreenDrum = reader.ReadColor();

                RedCymbal = reader.ReadColor();
                YellowCymbal = reader.ReadColor();
                BlueCymbal = reader.ReadColor();
                GreenCymbal = reader.ReadColor();

                KickStarpower = reader.ReadColor();
                RedDrumStarpower = reader.ReadColor();
                YellowDrumStarpower = reader.ReadColor();
                BlueDrumStarpower = reader.ReadColor();
                GreenDrumStarpower = reader.ReadColor();

                RedCymbalStarpower = reader.ReadColor();
                YellowCymbalStarpower = reader.ReadColor();
                BlueCymbalStarpower = reader.ReadColor();
                GreenCymbalStarpower = reader.ReadColor();

                ActivationNote = reader.ReadColor();
            }

            #endregion
        }
    }
}
</file>

<file path="Game/Presets/ColorProfile.ProKeys.cs">
using System.Drawing;
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.Utility;

namespace YARG.Core.Game
{
    public partial class ColorProfile
    {
        public class ProKeysColors : IBinarySerializable
        {
            #region Keys

            public Color WhiteKey = Color.White;

            public Color RedKey    = Color.FromArgb(0xFF, 0x7F, 0x0E, 0x11); // #7F0E11
            public Color YellowKey = Color.FromArgb(0xFF, 0x7F, 0x74, 0x00); // #7F7400
            public Color BlueKey   = Color.FromArgb(0xFF, 0x09, 0x5F, 0x7F); // #095F7F
            public Color GreenKey  = Color.FromArgb(0xFF, 0x3C, 0x69, 0x02); // #3C6902
            public Color OrangeKey = Color.FromArgb(0xFF, 0x7F, 0x42, 0x00); // #7F4200

            /// <summary>
            /// Gets the black key color for a specific group index.
            /// 0 = red, 4 = orange.
            /// </summary>
            public Color GetBlackKeyColor(int groupIndex)
            {
                return groupIndex switch
                {
                    0 => RedKey,
                    1 => YellowKey,
                    2 => BlueKey,
                    3 => GreenKey,
                    4 => OrangeKey,
                    _ => default
                };
            }

            #endregion

            #region Overlay

            public Color RedOverlay    = DefaultRed;
            public Color YellowOverlay = DefaultYellow;
            public Color BlueOverlay   = DefaultBlue;
            public Color GreenOverlay  = DefaultGreen;
            public Color OrangeOverlay = DefaultOrange;

            /// <summary>
            /// Gets the overlay color for a specific group index.
            /// 0 = red, 4 = orange.
            /// </summary>
            public Color GetOverlayColor(int groupIndex)
            {
                return groupIndex switch
                {
                    0 => RedOverlay,
                    1 => YellowOverlay,
                    2 => BlueOverlay,
                    3 => GreenOverlay,
                    4 => OrangeOverlay,
                    _ => default
                };
            }

            #endregion

            #region Notes

            public Color WhiteNote = Color.White;
            public Color BlackNote = Color.Black;

            public Color WhiteNoteStarPower = CircularStarpower;
            public Color BlackNoteStarPower = CircularStarpower;

            #endregion

            #region Serialization

            public ProKeysColors Copy()
            {
                // Kinda yucky, but it's easier to maintain
                return (ProKeysColors) MemberwiseClone();
            }

            public void Serialize(BinaryWriter writer)
            {
                writer.Write(WhiteKey);

                writer.Write(RedKey);
                writer.Write(YellowKey);
                writer.Write(BlueKey);
                writer.Write(GreenKey);
                writer.Write(OrangeKey);

                writer.Write(RedOverlay);
                writer.Write(YellowOverlay);
                writer.Write(BlueOverlay);
                writer.Write(GreenOverlay);
                writer.Write(OrangeOverlay);

                writer.Write(WhiteNote);
                writer.Write(BlackNote);

                writer.Write(WhiteNoteStarPower);
                writer.Write(BlackNoteStarPower);
            }

            public void Deserialize(BinaryReader reader, int version = 0)
            {
                WhiteKey = reader.ReadColor();

                RedKey = reader.ReadColor();
                YellowKey = reader.ReadColor();
                BlueKey = reader.ReadColor();
                GreenKey = reader.ReadColor();
                OrangeKey = reader.ReadColor();

                RedOverlay = reader.ReadColor();
                YellowOverlay = reader.ReadColor();
                BlueOverlay = reader.ReadColor();
                GreenOverlay = reader.ReadColor();
                OrangeOverlay = reader.ReadColor();

                WhiteNote = reader.ReadColor();
                BlackNote = reader.ReadColor();

                WhiteNoteStarPower = reader.ReadColor();
                BlackNoteStarPower = reader.ReadColor();
            }

            #endregion
        }
    }
}
</file>

<file path="Game/Presets/EnginePreset.cs">
using YARG.Core.Game.Settings;

namespace YARG.Core.Game
{
    public partial class EnginePreset : BasePreset
    {
        [SettingSubSection]
        public FiveFretGuitarPreset FiveFretGuitar;
        [SettingSubSection]
        public DrumsPreset Drums;
        [SettingSubSection]
        public VocalsPreset Vocals;
        [SettingSubSection]
        public ProKeysPreset ProKeys;

        public EnginePreset(string name, bool defaultPreset = false) : base(name, defaultPreset)
        {
            FiveFretGuitar = new FiveFretGuitarPreset();
            Drums = new DrumsPreset();
            Vocals = new VocalsPreset();
            ProKeys = new ProKeysPreset();
        }

        public override BasePreset CopyWithNewName(string name)
        {
            return new EnginePreset(name)
            {
                FiveFretGuitar = FiveFretGuitar.Copy(),
                Drums = Drums.Copy(),
                Vocals = Vocals.Copy(),
                ProKeys = ProKeys.Copy(),
            };
        }
    }
}
</file>

<file path="Game/Presets/EnginePreset.Defaults.cs">
using System.Collections.Generic;

namespace YARG.Core.Game
{
    public partial class EnginePreset
    {
        public static EnginePreset Default = new("Default", true);

        public static EnginePreset Casual = new("Casual", true)
        {
            FiveFretGuitar =
            {
                AntiGhosting = false,
                InfiniteFrontEnd = true,
                StrumLeniency = 0.06,
                StrumLeniencySmall = 0.03
            },
            Vocals =
            {
                PerfectPitchPercent = 0.85f
            }
        };

        public static EnginePreset Precision = new("Precision", true)
        {
            FiveFretGuitar =
            {
                StrumLeniency = 0.04,
                StrumLeniencySmall = 0.02,
                HitWindow =
                {
                    MaxWindow = 0.12,
                    MinWindow = 0.04,
                    IsDynamic = true,
                    DynamicScale = 1,
                    DynamicSlope = 0.93,
                    DynamicGamma = 1.5,
                }
            },
            Drums =
            {
                HitWindow =
                {
                    MaxWindow = 0.13,
                    MinWindow = 0.05,
                    IsDynamic = true,
                    DynamicScale = 1,
                    DynamicSlope = 0.60615,
                    DynamicGamma = 2
                }
            },
            Vocals =
            {
                PitchWindowE = 1.4f,
                PitchWindowM = 1.1f,
                PitchWindowH = 0.8f,
                PitchWindowX = 0.6f,
                PerfectPitchPercent = 0.55f
            }
        };

        public static readonly List<EnginePreset> Defaults = new()
        {
            Default,
            Casual,
            Precision
        };
    }
}
</file>

<file path="Game/Presets/EnginePreset.Instruments.cs">
using System;
using YARG.Core.Engine;
using YARG.Core.Engine.Drums;
using YARG.Core.Engine.Guitar;
using YARG.Core.Engine.ProKeys;
using YARG.Core.Engine.Vocals;
using YARG.Core.Game.Settings;

namespace YARG.Core.Game
{
    public partial class EnginePreset
    {
        public const double DEFAULT_WHAMMY_BUFFER = 0.25;

        public const double DEFAULT_SUSTAIN_DROP_LENIENCY = 0.025;

        public const int DEFAULT_MAX_MULTIPLIER = 4;
        public const int BASS_MAX_MULTIPLIER    = 6;

        /// <summary>
        /// A preset for a hit window. This should
        /// be used within each engine preset class.
        /// </summary>
        public class HitWindowPreset
        {
            // These should be ignored from the settings because they are handled separately.
            // Everything else will only appear when "IsDynamic" is true.
            public bool   IsDynamic = false;
            public double MaxWindow = 0.14;
            public double MinWindow = 0.14;

            [SettingType(SettingType.Slider)]
            [SettingRange(0.3f, 3f)]
            public double DynamicScale = 1.0;

            [SettingType(SettingType.Slider)]
            [SettingRange(0f, 1f)]
            public double DynamicSlope = 0.93;

            [SettingType(SettingType.Slider)]
            [SettingRange(0.1f, 10f)]
            public double DynamicGamma = 1.5;

            [SettingType(SettingType.Slider)]
            [SettingRange(0f, 2f)]
            public double FrontToBackRatio = 1.0;

            public HitWindowSettings Create()
            {
                return new HitWindowSettings(MaxWindow, MinWindow, FrontToBackRatio, IsDynamic,
                    DynamicSlope, DynamicScale, DynamicGamma);
            }

            public HitWindowPreset Copy()
            {
                return new HitWindowPreset
                {
                    IsDynamic = IsDynamic,
                    MaxWindow = MaxWindow,
                    MinWindow = MinWindow,

                    DynamicScale = DynamicScale,
                    DynamicSlope = DynamicSlope,
                    DynamicGamma = DynamicGamma,

                    FrontToBackRatio = FrontToBackRatio
                };
            }
        }

        /// <summary>
        /// The engine preset for five fret guitar.
        /// </summary>
        public class FiveFretGuitarPreset
        {
            [SettingType(SettingType.Toggle)]
            public bool AntiGhosting = true;

            [SettingType(SettingType.Toggle)]
            public bool InfiniteFrontEnd = false;

            [SettingType(SettingType.MillisecondInput)]
            [SettingRange(min: 0f)]
            public double HopoLeniency = 0.08;

            [SettingType(SettingType.MillisecondInput)]
            [SettingRange(min: 0f)]
            public double StrumLeniency = 0.05;

            [SettingType(SettingType.MillisecondInput)]
            [SettingRange(min: 0f)]
            public double StrumLeniencySmall = 0.025;

            [SettingType(SettingType.MillisecondInput)]
            [SettingRange(min: 0f, max: 0.05f)]
            public double SustainDropLeniency = DEFAULT_SUSTAIN_DROP_LENIENCY;

            [SettingType(SettingType.Special)]
            public HitWindowPreset HitWindow = new()
            {
                MaxWindow = 0.14,
                MinWindow = 0.14,
                IsDynamic = false,
                FrontToBackRatio = 1.0
            };

            public FiveFretGuitarPreset Copy()
            {
                return new FiveFretGuitarPreset
                {
                    AntiGhosting = AntiGhosting,
                    InfiniteFrontEnd = InfiniteFrontEnd,
                    HopoLeniency = HopoLeniency,
                    StrumLeniency = StrumLeniency,
                    StrumLeniencySmall = StrumLeniencySmall,
                    HitWindow = HitWindow.Copy(),
                };
            }

            public GuitarEngineParameters Create(float[] starMultiplierThresholds, bool isBass)
            {
                var hitWindow = HitWindow.Create();
                return new GuitarEngineParameters(
                    hitWindow,
                    isBass ? BASS_MAX_MULTIPLIER : DEFAULT_MAX_MULTIPLIER,
                    DEFAULT_WHAMMY_BUFFER,
                    SustainDropLeniency,
                    starMultiplierThresholds,
                    HopoLeniency,
                    StrumLeniency,
                    StrumLeniencySmall,
                    InfiniteFrontEnd,
                    AntiGhosting);
            }
        }

        /// <summary>
        /// The engine preset for four and five lane drums. These two game modes
        /// use the same engine, so there's no point in splitting them up.
        /// </summary>
        public class DrumsPreset
        {
            [SettingType(SettingType.Special)]
            public HitWindowPreset HitWindow = new()
            {
                MaxWindow = 0.14,
                MinWindow = 0.14,
                IsDynamic = false,
                FrontToBackRatio = 1.0
            };

            public DrumsPreset Copy()
            {
                return new DrumsPreset
                {
                    HitWindow = HitWindow.Copy()
                };
            }

            public DrumsEngineParameters Create(float[] starMultiplierThresholds, DrumsEngineParameters.DrumMode mode)
            {
                var hitWindow = HitWindow.Create();
                return new DrumsEngineParameters(
                    hitWindow,
                    DEFAULT_MAX_MULTIPLIER,
                    starMultiplierThresholds,
                    mode);
            }
        }

        /// <summary>
        /// The engine preset for vocals/harmonies.
        /// </summary>
        public class VocalsPreset
        {
            // Pitch window is in semitones (max. difference between correct pitch and sung pitch).

            [SettingType(SettingType.Slider)]
            [SettingRange(0f, 3f)]
            public float PitchWindowE = 1.7f;

            [SettingType(SettingType.Slider)]
            [SettingRange(0f, 3f)]
            public float PitchWindowM = 1.4f;

            [SettingType(SettingType.Slider)]
            [SettingRange(0f, 3f)]
            public float PitchWindowH = 1.1f;

            [SettingType(SettingType.Slider)]
            [SettingRange(0f, 3f)]
            public float PitchWindowX = 0.8f;

            /// <summary>
            /// The perfect pitch window is equal to the pitch window times the perfect pitch percent,
            /// for all difficulties.
            /// </summary>
            [SettingType(SettingType.Slider)]
            [SettingRange(0f, 1f)]
            public float PerfectPitchPercent = 0.6f;

            // These percentages may seem low, but accounting for delay,
            // plosives not being detected, etc., it's pretty good.

            [SettingType(SettingType.Slider)]
            [SettingRange(0f, 1f)]
            public float HitPercentE = 0.325f;

            [SettingType(SettingType.Slider)]
            [SettingRange(0f, 1f)]
            public float HitPercentM = 0.400f;

            [SettingType(SettingType.Slider)]
            [SettingRange(0f, 1f)]
            public float HitPercentH = 0.450f;

            [SettingType(SettingType.Slider)]
            [SettingRange(0f, 1f)]
            public float HitPercentX = 0.575f;

            /// <summary>
            /// The hit window of percussion notes.
            /// </summary>
            [SettingType(SettingType.MillisecondInput)]
            [SettingRange(min: 0f)]
            public double PercussionHitWindow = 0.16;

            public VocalsPreset Copy()
            {
                return new VocalsPreset
                {
                    PitchWindowE = PitchWindowE,
                    PitchWindowM = PitchWindowM,
                    PitchWindowH = PitchWindowH,
                    PitchWindowX = PitchWindowX,
                    PerfectPitchPercent = PerfectPitchPercent,
                    HitPercentE = HitPercentE,
                    HitPercentM = HitPercentM,
                    HitPercentH = HitPercentH,
                    HitPercentX = HitPercentX,
                };
            }

            public VocalsEngineParameters Create(float[] starMultiplierThresholds, Difficulty difficulty,
                float updatesPerSecond, bool singToActivateStarPower)
            {
                // Hit window is in semitones (max. difference between correct pitch and sung pitch).
                var (pitchWindow, hitPercent, pointsPerPhrase) = difficulty switch
                {
                    Difficulty.Easy   => (PitchWindowE, HitPercentE, 400),
                    Difficulty.Medium => (PitchWindowM, HitPercentM, 800),
                    Difficulty.Hard   => (PitchWindowH, HitPercentH, 1600),
                    Difficulty.Expert => (PitchWindowX, HitPercentX, 2000),
                    _                 => throw new InvalidOperationException("Unreachable")
                };

                var hitWindow = new HitWindowSettings(
                    PercussionHitWindow, PercussionHitWindow, 1, false, 0, 0, 0);

                return new VocalsEngineParameters(
                    hitWindow,
                    DEFAULT_MAX_MULTIPLIER,
                    starMultiplierThresholds,
                    pitchWindow,
                    pitchWindow * PerfectPitchPercent,
                    hitPercent,
                    updatesPerSecond,
                    singToActivateStarPower,
                    pointsPerPhrase);
            }
        }

        /// <summary>
        /// The engine preset for pro keys.
        /// </summary>
        public class ProKeysPreset
        {
            [SettingType(SettingType.MillisecondInput)]
            [SettingRange(min: 0f)]
            public double ChordStaggerWindow = 0.05;

            [SettingType(SettingType.MillisecondInput)]
            [SettingRange(min: 0f)]
            public double FatFingerWindow = 0.1;

            [SettingType(SettingType.MillisecondInput)]
            [SettingRange(min: 0f, max: 0.05f)]
            public double SustainDropLeniency = DEFAULT_SUSTAIN_DROP_LENIENCY;

            [SettingType(SettingType.Special)]
            public HitWindowPreset HitWindow = new()
            {
                MaxWindow = 0.14,
                MinWindow = 0.14,
                IsDynamic = false,
                FrontToBackRatio = 1.0
            };

            public ProKeysPreset Copy()
            {
                return new ProKeysPreset
                {
                    ChordStaggerWindow = ChordStaggerWindow,
                    FatFingerWindow = FatFingerWindow,
                    HitWindow = HitWindow.Copy(),
                };
            }

            public ProKeysEngineParameters Create(float[] starMultiplierThresholds)
            {
                var hitWindow = HitWindow.Create();
                return new ProKeysEngineParameters(
                    hitWindow,
                    DEFAULT_MAX_MULTIPLIER,
                    DEFAULT_WHAMMY_BUFFER,
                    SustainDropLeniency,
                    starMultiplierThresholds,
                    ChordStaggerWindow,
                    FatFingerWindow);
            }
        }
    }
}
</file>

<file path="Game/Presets/HighwayPreset.cs">
using System.Drawing;
using YARG.Core.Game.Settings;

namespace YARG.Core.Game
{
    public partial class HighwayPreset : BasePreset
    {
        [SettingType(SettingType.Special)]
        public Color StarPowerColor = Color.FromArgb(255, 255, 152, 0);

        [SettingType(SettingType.Special)]
        public Color BackgroundBaseColor1 = Color.FromArgb(255, 15, 15, 15);
        [SettingType(SettingType.Special)]
        public Color BackgroundBaseColor2 = Color.FromArgb(38, 75, 75, 75);

        public Color BackgroundBaseColor3 = Color.FromArgb(0, 255, 255, 255);               // Currently Unused
        [SettingType(SettingType.Special)]
        public Color BackgroundPatternColor = Color.FromArgb(255, 87, 87, 87);

        [SettingType(SettingType.Special)]
        public Color BackgroundGrooveBaseColor1 = Color.FromArgb(255, 0, 9, 51);
        [SettingType(SettingType.Special)]
        public Color BackgroundGrooveBaseColor2 = Color.FromArgb(38, 35, 51, 196);

        public Color BackgroundGrooveBaseColor3 = Color.FromArgb(0, 255, 255, 255);         // Currently Unused
        [SettingType(SettingType.Special)]
        public Color BackgroundGroovePatternColor = Color.FromArgb(255, 44, 73, 158);

        public Color[] BackgroundBaseColors => new[] { BackgroundBaseColor1, BackgroundBaseColor2, BackgroundBaseColor3, BackgroundPatternColor };
        public Color[] BackgroundGrooveBaseColors => new[] { BackgroundGrooveBaseColor1, BackgroundGrooveBaseColor2, BackgroundGrooveBaseColor3, BackgroundGroovePatternColor };

        public HighwayPreset(string name, bool defaultPreset = false) : base(name, defaultPreset)
        {
        }

        public override BasePreset CopyWithNewName(string name)
        {
            return new HighwayPreset(name)
            {
                StarPowerColor = StarPowerColor,
                BackgroundBaseColor1 = BackgroundBaseColor1,
                BackgroundBaseColor2 = BackgroundBaseColor2,
                BackgroundBaseColor3 = BackgroundBaseColor3,
                BackgroundPatternColor = BackgroundPatternColor,
                BackgroundGrooveBaseColor1 = BackgroundGrooveBaseColor1,
                BackgroundGrooveBaseColor2 = BackgroundGrooveBaseColor2,
                BackgroundGrooveBaseColor3 = BackgroundGrooveBaseColor3,
                BackgroundGroovePatternColor = BackgroundGroovePatternColor
            };
        }
    }
}
</file>

<file path="Game/Presets/HighwayPreset.Defaults.cs">
using System.Collections.Generic;
using System.Drawing;

namespace YARG.Core.Game
{
    public partial class HighwayPreset : BasePreset
    {
        public static HighwayPreset Default = new("Default", true);
        public static HighwayPreset Basic = new("Basic", true)
        {
            StarPowerColor = Color.FromArgb(0, 0, 0, 0),
            BackgroundPatternColor = Color.FromArgb(0, 0, 0, 0),
            BackgroundBaseColor2 = Color.FromArgb(0, 0, 0, 0),
            BackgroundGroovePatternColor = Color.FromArgb(0,0,0,0),
            BackgroundGrooveBaseColor1 = Color.FromArgb(255, 15, 15, 15),
            BackgroundGrooveBaseColor2 = Color.FromArgb(0, 0, 0, 0)
        };
        public static HighwayPreset NoGroove = new("No Groove", true)
        {
            BackgroundGroovePatternColor = Color.FromArgb(255, 87, 87, 87),
            BackgroundGrooveBaseColor1 = Color.FromArgb(255, 15, 15, 15),
            BackgroundGrooveBaseColor2 = Color.FromArgb(38, 75, 75, 75)
        };

        public static readonly List<HighwayPreset> Defaults = new()
        {
            Default,
            Basic,
            NoGroove
        };
    }
}
</file>

<file path="Game/Settings/SettingRangeAttribute.cs">
using System;

namespace YARG.Core.Game.Settings
{
    public class SettingRangeAttribute : Attribute
    {
        public float Min { get; }
        public float Max { get; }

        public SettingRangeAttribute(float min = float.NegativeInfinity, float max = float.PositiveInfinity)
        {
            Min = min;
            Max = max;
        }
    }
}
</file>

<file path="Game/Settings/SettingSubSectionAttribute.cs">
using System;

namespace YARG.Core.Game.Settings
{
    public class SettingSubSectionAttribute : Attribute
    {
    }
}
</file>

<file path="Game/Settings/SettingTypeAttribute.cs">
using System;

namespace YARG.Core.Game.Settings
{
    public enum SettingType
    {
        Special,

        Input,
        MillisecondInput,

        Slider,

        Toggle
    }

    public class SettingTypeAttribute : Attribute
    {
        public SettingType Type { get; }

        public SettingTypeAttribute(SettingType type)
        {
            Type = type;
        }
    }
}
</file>

<file path="Game/Modifier.cs">
using System;
using System.Collections.Generic;

namespace YARG.Core.Game
{
    [Flags]
    public enum Modifier : ulong
    {
        None          = 0,
        AllStrums     = 1 << 0,
        AllHopos      = 1 << 1,
        AllTaps       = 1 << 2,
        HoposToTaps   = 1 << 3,
        TapsToHopos   = 1 << 4,
        NoteShuffle   = 1 << 5,
        NoKicks       = 1 << 6,
        UnpitchedOnly = 1 << 7,
        NoDynamics    = 1 << 8,
        NoVocalPercussion = 1 << 9,
    }

    public static class ModifierConflicts
    {
        // We can essentially treat a set of conflicting modifiers as a group, since they
        // conflict in both ways (i.e. all strums conflicts with all HOPOs, and vice versa).
        // Returning a list of the conflicting modifiers, and simply removing them, takes
        // care of all of the possibilities. A modifier can be a part of multiple groups,
        // which is why we use a list here.
        private static readonly List<Modifier> _conflictingModifiers = new()
        {
            Modifier.AllStrums   |
            Modifier.AllHopos    |
            Modifier.AllTaps     |
            Modifier.HoposToTaps |
            Modifier.TapsToHopos,
        };

        public static Modifier PossibleModifiers(this GameMode gameMode)
        {
            return gameMode switch
            {
                GameMode.FiveFretGuitar =>
                    Modifier.AllStrums   |
                    Modifier.AllHopos    |
                    Modifier.AllTaps     |
                    Modifier.HoposToTaps |
                    Modifier.TapsToHopos,

                GameMode.FourLaneDrums or
                GameMode.FiveLaneDrums =>
                    Modifier.NoKicks    |
                    Modifier.NoDynamics,

                GameMode.Vocals =>
                    Modifier.UnpitchedOnly |
                    Modifier.NoVocalPercussion,

                GameMode.SixFretGuitar or
            //  GameMode.EliteDrums    or
                GameMode.ProGuitar     or
            //  GameMode.Dj            or
                GameMode.ProKeys       => Modifier.None,

                _  => throw new NotImplementedException($"Unhandled game mode {gameMode}!")
            };
        }

        public static Modifier FromSingleModifier(Modifier modifier)
        {
            var output = Modifier.None;

            foreach (var conflictSet in _conflictingModifiers)
            {
                if ((conflictSet & modifier) == 0) continue;

                // Set conflicts
                output |= conflictSet;

                // Make sure to get rid of the modifier itself
                output &= ~modifier;
            }

            return output;
        }
    }
}
</file>

<file path="Game/StarAmount.cs">
namespace YARG.Core.Game
{
    public enum StarAmount : byte
    {
        None = 0,

        Star1 = 1,
        Star2 = 2,
        Star3 = 3,
        Star4 = 4,
        Star5 = 5,

        StarGold,
        StarSilver,
        StarBrutal
    }

    public static class StarAmountHelper {
        public static StarAmount GetStarsFromInt(int stars)
        {
            return stars switch
            {
                >= 0 and <= 5 => (StarAmount) stars,
                6             => StarAmount.StarGold,
                _             => StarAmount.None
            };
        }

        public static int GetStarCount(this StarAmount starAmount)
        {
            return starAmount switch
            {
                <= StarAmount.Star5 => (int) starAmount,
                _                   => 5,
            };
        }
    }
}
</file>

<file path="Game/YargProfile.cs">
using System;
using System.IO;
using Newtonsoft.Json;
using YARG.Core.Chart;
using YARG.Core.Utility;
using YARG.Core.Extensions;
using System.Linq;
using YARG.Core.IO;

namespace YARG.Core.Game
{
    public class YargProfile
    {
        private const int PROFILE_VERSION = 2;

        public Guid Id;
        public string Name;

        public bool IsBot;

        public GameMode GameMode;

        public float NoteSpeed;
        public float HighwayLength;

        public bool LeftyFlip;

        public int? AutoConnectOrder;

        public long InputCalibrationMilliseconds;
        public double InputCalibrationSeconds
        {
            get => InputCalibrationMilliseconds / 1000.0;
            set => InputCalibrationMilliseconds = (long) (value * 1000);
        }

        public bool HasValidInstrument => GameMode.PossibleInstruments().Contains(CurrentInstrument);

        public Guid EnginePreset;

        public Guid ThemePreset;
        public Guid ColorProfile;
        public Guid CameraPreset;
        public Guid HighwayPreset;

        /// <summary>
        /// The selected instrument.
        /// </summary>
        public Instrument CurrentInstrument;

        /// <summary>
        /// The selected difficulty.
        /// </summary>
        public Difficulty CurrentDifficulty;

        /// <summary>
        /// The difficulty to be saved in the profile.
        /// 
        /// If a song does not contain this difficulty, so long as the player
        /// does not *explicitly* and *manually* change the difficulty, this value
        /// should remain unchanged.
        /// </summary>
        public Difficulty DifficultyFallback;

        [JsonProperty("HarmonyIndex")]
        private byte _harmonyIndex;

        /// <summary>
        /// The harmony index, used for determining what harmony part the player selected.
        /// Does nothing if <see cref="CurrentInstrument"/> is not a harmony.
        /// </summary>
        [JsonIgnore]
        public byte HarmonyIndex
        {
            // Only expose harmony index when playing harmonies, ensures consistent behavior
            // while still allowing harmony index to persist between instrument switches
            get => CurrentInstrument == Instrument.Harmony ? _harmonyIndex : (byte) 0;
            set => _harmonyIndex = value;
        }

        /// <summary>
        /// The currently selected modifiers as a flag.
        /// Use <see cref="AddSingleModifier"/> and <see cref="RemoveModifiers"/> to modify.
        /// </summary>
        [JsonProperty]
        public Modifier CurrentModifiers { get; private set; }

        public YargProfile()
        {
            Id = Guid.NewGuid();
            Name = "Default";
            GameMode = GameMode.FiveFretGuitar;
            NoteSpeed = 6;
            HighwayLength = 1;
            LeftyFlip = false;

            // Set preset IDs to default
            ColorProfile = Game.ColorProfile.Default.Id;
            CameraPreset = Game.CameraPreset.Default.Id;
            HighwayPreset = Game.HighwayPreset.Default.Id;

            CurrentModifiers = Modifier.None;
        }

        public YargProfile(Guid id) : this()
        {
            Id = id;
        }

        public YargProfile(ref FixedArrayStream stream)
        {
            int version = stream.Read<int>(Endianness.Little);

            Name = stream.ReadString();

            EnginePreset = stream.ReadGuid();

            ThemePreset = stream.ReadGuid();
            ColorProfile = stream.ReadGuid();
            CameraPreset = stream.ReadGuid();

            if (version >= 2)
            {
                HighwayPreset = stream.ReadGuid();
            }
            CurrentInstrument = (Instrument) stream.ReadByte();
            CurrentDifficulty = (Difficulty) stream.ReadByte();
            CurrentModifiers = (Modifier) stream.Read<ulong>(Endianness.Little);
            _harmonyIndex = stream.ReadByte();

            NoteSpeed = stream.Read<float>(Endianness.Little);
            HighwayLength = stream.Read<float>(Endianness.Little);
            LeftyFlip = stream.ReadBoolean();

            GameMode = CurrentInstrument.ToGameMode();
        }

        public void AddSingleModifier(Modifier modifier)
        {
            // Remove conflicting modifiers first
            RemoveModifiers(ModifierConflicts.FromSingleModifier(modifier));
            CurrentModifiers |= modifier;
        }

        public void RemoveModifiers(Modifier modifier)
        {
            CurrentModifiers &= ~modifier;
        }

        public bool IsModifierActive(Modifier modifier)
        {
            return (CurrentModifiers & modifier) == modifier;
        }

        public void CopyModifiers(YargProfile profile)
        {
            // The modifiers of the other profile are guaranteed to be correct
            CurrentModifiers = profile.CurrentModifiers;
        }

        public void ApplyModifiers<TNote>(InstrumentDifficulty<TNote> track) where TNote : Note<TNote>
        {
            switch (CurrentInstrument.ToGameMode())
            {
                case GameMode.FiveFretGuitar:
                    if (track is not InstrumentDifficulty<GuitarNote> guitarTrack)
                    {
                        throw new InvalidOperationException("Cannot apply guitar modifiers to non-guitar track " +
                            $"with notes of {typeof(TNote)}!");
                    }

                    if (IsModifierActive(Modifier.AllStrums))
                    {
                        guitarTrack.ConvertToGuitarType(GuitarNoteType.Strum);
                    }
                    else if (IsModifierActive(Modifier.AllHopos))
                    {
                        guitarTrack.ConvertToGuitarType(GuitarNoteType.Hopo);
                    }
                    else if (IsModifierActive(Modifier.AllTaps))
                    {
                        guitarTrack.ConvertToGuitarType(GuitarNoteType.Tap);
                    }
                    else if (IsModifierActive(Modifier.HoposToTaps))
                    {
                        guitarTrack.ConvertFromTypeToType(GuitarNoteType.Hopo, GuitarNoteType.Tap);
                    }
                    else if (IsModifierActive(Modifier.TapsToHopos))
                    {
                        guitarTrack.ConvertFromTypeToType(GuitarNoteType.Tap, GuitarNoteType.Hopo);
                    }

                    break;
                case GameMode.FourLaneDrums:
                case GameMode.FiveLaneDrums:
                    if (track is not InstrumentDifficulty<DrumNote> drumsTrack)
                    {
                        throw new InvalidOperationException("Cannot apply drum modifiers to non-drums track " +
                            $"with notes of {typeof(TNote)}!");
                    }

                    if (IsModifierActive(Modifier.NoKicks))
                    {
                        drumsTrack.RemoveKickDrumNotes();
                    }

                    if (IsModifierActive(Modifier.NoDynamics))
                    {
                        drumsTrack.RemoveDynamics();
                    }

                    break;
                case GameMode.Vocals:
                    throw new InvalidOperationException("For vocals, use ApplyVocalModifiers instead!");
            }
        }

        public void ApplyVocalModifiers(VocalsPart vocalsPart)
        {
            if (IsModifierActive(Modifier.UnpitchedOnly))
            {
                vocalsPart.ConvertAllToUnpitched();
            }

            if (IsModifierActive(Modifier.NoVocalPercussion))
            {
                vocalsPart.RemovePercussion();
            }
        }

        public void EnsureValidInstrument()
        {

            if (!HasValidInstrument)
            {
                CurrentInstrument = GameMode.PossibleInstruments()[0];
            }
        }

        // For replay serialization
        public void Serialize(BinaryWriter writer)
        {
            writer.Write(PROFILE_VERSION);

            writer.Write(Name);

            writer.Write(EnginePreset);

            writer.Write(ThemePreset);
            writer.Write(ColorProfile);
            writer.Write(CameraPreset);
            writer.Write(HighwayPreset);

            writer.Write((byte) CurrentInstrument);
            writer.Write((byte) CurrentDifficulty);
            writer.Write((ulong) CurrentModifiers);
            writer.Write(_harmonyIndex);

            writer.Write(NoteSpeed);
            writer.Write(HighwayLength);
            writer.Write(LeftyFlip);
        }
    }
}
</file>

<file path="Input/GameInput.cs">
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using YARG.Core.Extensions;

namespace YARG.Core.Input
{
    /// <summary>
    /// An input that the game consumes.
    /// </summary>
    /// <remarks>
    /// Although integer, axis, and button values are all exposed at once, an action can only use one of the three.
    /// Each input type shares the same memory, and reading the incorrect value for an action will result in issues!
    /// </remarks>
    [StructLayout(LayoutKind.Explicit, Pack = 1)]
    public readonly struct GameInput
    {
        /// <summary>
        /// The time at which the input occurred.
        /// </summary>
        [FieldOffset(0)]
        public readonly double Time;

        /// <summary>
        /// The mode-specific action that the input is for.
        /// </summary>
        [FieldOffset(8)]
        public readonly int Action;

        // Union emulation, each of these fields will share the same memory

        /// <summary>
        /// The integer value of the input.
        /// Only valid for actions that expect integer values.
        /// </summary>
        [FieldOffset(12)]
        public readonly int Integer;

        /// <summary>
        /// The axis value of the input.
        /// Only valid for actions that expect axis values.
        /// </summary>
        [FieldOffset(12)]
        public readonly float Axis;

        /// <summary>
        /// The button state of the input.
        /// Only valid for actions that expect button states.
        /// </summary>
        [FieldOffset(12)]
        public readonly bool Button;

        public GameInput(double time, int action, int value) : this()
        {
            Time = time;
            Action = action;
            Integer = value;
        }

        public GameInput(double time, int action, float value) : this()
        {
            Time = time;
            Action = action;
            Axis = value;
        }

        public GameInput(double time, int action, bool value) : this()
        {
            Time = time;
            Action = action;
            Button = value;
        }

        // Since constructors can't be generic:

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static GameInput Create<TAction>(double time, TAction action, int value)
            where TAction : unmanaged, Enum
        {
            return new GameInput(time, action.Convert(), value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static GameInput Create<TAction>(double time, TAction action, float value)
            where TAction : unmanaged, Enum
        {
            return new GameInput(time, action.Convert(), value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static GameInput Create<TAction>(double time, TAction action, bool value)
            where TAction : unmanaged, Enum
        {
            return new GameInput(time, action.Convert(), value);
        }

        /// <summary>
        /// Gets the action value as a specific enum type.
        /// </summary>
        /// <typeparam name="TAction">
        /// The enum type to convert the action into.
        /// </typeparam>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TAction GetAction<TAction>()
            where TAction : unmanaged, Enum
        {
            return Action.Convert<TAction>();
        }
    }
}
</file>

<file path="Input/InputActions.cs">
namespace YARG.Core.Input
{
    // !DO NOT MODIFY THE VALUES OR ORDER OF THESE ENUMS!
    // Since they are serialized in replays, they *must* remain the same across changes.

    /// <summary>
    /// The actions available for navigating menus.
    /// </summary>
    public enum MenuAction : byte
    {
        /// <summary>Green action button.</summary>
        Green = 0,
        /// <summary>Red action button.</summary>
        Red = 1,
        /// <summary>Yellow action button.</summary>
        Yellow = 2,
        /// <summary>Blue action button.</summary>
        Blue = 3,
        /// <summary>Orange action button.</summary>
        Orange = 4,

        /// <summary>Up navigation button.</summary>
        Up = 5,
        /// <summary>Down navigation button.</summary>
        Down = 6,
        /// <summary>Left navigation button.</summary>
        Left = 7,
        /// <summary>Right navigation button.</summary>
        Right = 8,

        /// <summary>Start action button.</summary>
        Start = 9,
        /// <summary>Select action button.</summary>
        Select = 10,
    }

    /// <summary>
    /// The actions available when playing guitar modes.
    /// </summary>
    public enum GuitarAction : byte
    {
        /// <summary>Generic first fret button.</summary>
        Fret1 = 0,
        /// <summary>Generic second fret button.</summary>
        Fret2 = 1,
        /// <summary>Generic third fret button.</summary>
        Fret3 = 2,
        /// <summary>Generic fourth fret button.</summary>
        Fret4 = 3,
        /// <summary>Generic fifth fret button.</summary>
        Fret5 = 4,
        /// <summary>Generic sixth fret button.</summary>
        Fret6 = 5,

        /// <summary>The up-strum button.</summary>
        StrumUp = 6,
        /// <summary>The down-strum button.</summary>
        StrumDown = 7,

        /// <summary>The whammy axis.</summary>
        Whammy = 8,
        /// <summary>The Star Power action, reported as a button.</summary>
        StarPower = 9,

        /// <summary>(5-fret) Green fret button.</summary>
        /// <remarks>Alias of <see cref="Fret1"/>.</remarks>
        GreenFret = Fret1,
        /// <summary>(5-fret) Red fret button.</summary>
        /// <remarks>Alias of <see cref="Fret2"/>.</remarks>
        RedFret = Fret2,
        /// <summary>(5-fret) Yellow fret button.</summary>
        /// <remarks>Alias of <see cref="Fret3"/>.</remarks>
        YellowFret = Fret3,
        /// <summary>(5-fret) Blue fret button.</summary>
        /// <remarks>Alias of <see cref="Fret4"/>.</remarks>
        BlueFret = Fret4,
        /// <summary>(5-fret) Orange fret button.</summary>
        /// <remarks>Alias of <see cref="Fret5"/>.</remarks>
        OrangeFret = Fret5,

        /// <summary>(6-fret) Black 1 fret button.</summary>
        /// <remarks>Alias of <see cref="Fret1"/>.</remarks>
        Black1Fret = Fret1,
        /// <summary>(6-fret) Black 2 fret button.</summary>
        /// <remarks>Alias of <see cref="Fret2"/>.</remarks>
        Black2Fret = Fret2,
        /// <summary>(6-fret) Black 3 fret button.</summary>
        /// <remarks>Alias of <see cref="Fret3"/>.</remarks>
        Black3Fret = Fret3,
        /// <summary>(6-fret) White 1 fret button.</summary>
        /// <remarks>Alias of <see cref="Fret4"/>.</remarks>
        White1Fret = Fret4,
        /// <summary>(6-fret) White 2 fret button.</summary>
        /// <remarks>Alias of <see cref="Fret5"/>.</remarks>
        White2Fret = Fret5,
        /// <summary>(6-fret) White 3 fret button.</summary>
        /// <remarks>Alias of <see cref="Fret6"/>.</remarks>
        White3Fret = Fret6,
    }

    /// <summary>
    /// The actions available when playing Pro Guitar modes.
    /// </summary>
    public enum ProGuitarAction : byte
    {
        /// <summary>First string's fret number integer.</summary>
        String1_Fret = 0,
        /// <summary>Second string's fret number integer.</summary>
        String2_Fret = 1,
        /// <summary>Third string's fret number integer.</summary>
        String3_Fret = 2,
        /// <summary>Fourth string's fret number integer.</summary>
        String4_Fret = 3,
        /// <summary>Fifth string's fret number integer.</summary>
        String5_Fret = 4,
        /// <summary>Sixth string's fret number integer.</summary>
        String6_Fret = 5,

        /// <summary>First string's strum state, reported as a button.</summary>
        String1_Strum = 6,
        /// <summary>Second string's strum state, reported as a button.</summary>
        String2_Strum = 7,
        /// <summary>Third string's strum state, reported as a button.</summary>
        String3_Strum = 8,
        /// <summary>Fourth string's strum state, reported as a button.</summary>
        String4_Strum = 9,
        /// <summary>Fifth string's strum state, reported as a button.</summary>
        String5_Strum = 10,
        /// <summary>Sixth string's strum state, reported as a button.</summary>
        String6_Strum = 11,

        /// <summary>The Star Power action, reported as a button.</summary>
        StarPower = 12,
    }

    /// <summary>
    /// The actions available when playing Pro Keys modes.
    /// </summary>
    public enum ProKeysAction : byte
    {
        /// <summary>Key 1's press state, reported as a button.</summary>
        Key1 = 0,
        /// <summary>Key 2's press state, reported as a button.</summary>
        Key2 = 1,
        /// <summary>Key 3's press state, reported as a button.</summary>
        Key3 = 2,
        /// <summary>Key 4's press state, reported as a button.</summary>
        Key4 = 3,
        /// <summary>Key 5's press state, reported as a button.</summary>
        Key5 = 4,
        /// <summary>Key 6's press state, reported as a button.</summary>
        Key6 = 5,
        /// <summary>Key 7's press state, reported as a button.</summary>
        Key7 = 6,
        /// <summary>Key 8's press state, reported as a button.</summary>
        Key8 = 7,
        /// <summary>Key 9's press state, reported as a button.</summary>
        Key9 = 8,
        /// <summary>Key 10's press state, reported as a button.</summary>
        Key10 = 9,
        /// <summary>Key 11's press state, reported as a button.</summary>
        Key11 = 10,
        /// <summary>Key 12's press state, reported as a button.</summary>
        Key12 = 11,
        /// <summary>Key 13's press state, reported as a button.</summary>
        Key13 = 12,
        /// <summary>Key 14's press state, reported as a button.</summary>
        Key14 = 13,
        /// <summary>Key 15's press state, reported as a button.</summary>
        Key15 = 14,
        /// <summary>Key 16's press state, reported as a button.</summary>
        Key16 = 15,
        /// <summary>Key 17's press state, reported as a button.</summary>
        Key17 = 16,
        /// <summary>Key 18's press state, reported as a button.</summary>
        Key18 = 17,
        /// <summary>Key 19's press state, reported as a button.</summary>
        Key19 = 18,
        /// <summary>Key 20's press state, reported as a button.</summary>
        Key20 = 19,
        /// <summary>Key 21's press state, reported as a button.</summary>
        Key21 = 20,
        /// <summary>Key 22's press state, reported as a button.</summary>
        Key22 = 21,
        /// <summary>Key 23's press state, reported as a button.</summary>
        Key23 = 22,
        /// <summary>Key 24's press state, reported as a button.</summary>
        Key24 = 23,
        /// <summary>Key 25's press state, reported as a button.</summary>
        Key25 = 24,

        /// <summary>The Star Power action, reported as a button.</summary>
        StarPower = 25,
        /// <summary>The touch effects bar, reported as an axis.</summary>
        TouchEffects = 26,
    }

    /// <summary>
    /// The actions available when playing drums modes.
    /// </summary>
    public enum DrumsAction : byte
    {
        /// <summary>Generic first drum hit velocity.</summary>
        Drum1 = 0,
        /// <summary>Generic second drum hit velocity.</summary>
        Drum2 = 1,
        /// <summary>Generic third drum hit velocity.</summary>
        Drum3 = 2,
        /// <summary>Generic fourth drum hit velocity.</summary>
        Drum4 = 3,

        /// <summary>Generic first cymbal hit velocity.</summary>
        Cymbal1 = 4,
        /// <summary>Generic second cymbal hit velocity.</summary>
        Cymbal2 = 5,
        /// <summary>Generic third cymbal hit velocity.</summary>
        Cymbal3 = 6,

        /// <summary>Kick pedal hit velocity.</summary>
        Kick = 7,

        /// <summary>(4-lane and 5-lane) red drum hit velocity.</summary>
        /// <remarks>Alias of <see cref="Drum1"/>.</remarks>
        RedDrum = Drum1,
        /// <summary>(4-lane only) yellow drum hit velocity.</summary>
        /// <remarks>Alias of <see cref="Drum2"/>.</remarks>
        YellowDrum = Drum2,
        /// <summary>(4-lane and 5-lane) blue drum hit velocity.</summary>
        /// <remarks>Alias of <see cref="Drum3"/>.</remarks>
        BlueDrum = Drum3,
        /// <summary>(4-lane and 5-lane) green drum hit velocity.</summary>
        /// <remarks>Alias of <see cref="Drum4"/>.</remarks>
        GreenDrum = Drum4,

        /// <summary>(4-lane and 5-lane) Yellow cymbal hit velocity.</summary>
        /// <remarks>Alias of <see cref="Cymbal1"/>.</remarks>
        YellowCymbal = Cymbal1,
        /// <summary>(5-lane only) Orange cymbal hit velocity.</summary>
        /// <remarks>Alias of <see cref="Cymbal2"/>.</remarks>
        OrangeCymbal = Cymbal2,
        /// <summary>(4-lane only) Blue cymbal hit velocity.</summary>
        /// <remarks>Alias of <see cref="Cymbal2"/>.</remarks>
        BlueCymbal = Cymbal2,
        /// <summary>(4-lane only) Green cymbal hit velocity. Red cymbal under lefty flip.</summary>
        /// <remarks>Alias of <see cref="Cymbal3"/>.</remarks>
        GreenCymbal = Cymbal3,
    }

    /// <summary>
    /// The actions available when playing vocals modes.
    /// </summary>
    public enum VocalsAction : byte
    {
        /// <summary>The current pitch being sung.</summary>
        Pitch = 0,
        /// <summary>Percussion hit action, reported as a button..</summary>
        Hit = 1,
        /// <summary>Star Power activation, reported as a button.</summary>
        StarPower = 2,
    }
}
</file>

<file path="IO/ConHandler/CONFile.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using YARG.Core.Logging;

namespace YARG.Core.IO
{
    public static class CONFile
    {
        private static readonly FourCC CON_TAG = new('C', 'O', 'N', ' ');
        private static readonly FourCC LIVE_TAG = new('L', 'I', 'V', 'E');
        private static readonly FourCC PIRS_TAG = new('P', 'I', 'R', 'S');

        private const int METADATA_POSITION = 0x340;
        private const int FILETABLEBLOCKCOUNT_POSITION = 0x37C;
        private const int FILETABLEFIRSTBLOCK_POSITION = 0x37E;
        private const int BYTES_32BIT = 4;
        private const int BYTES_24BIT = 3;
        private const int BYTES_16BIT = 2;

        private const int BYTES_PER_BLOCK = 0x1000;
        private const int SIZEOF_FILELISTING = 0x40;

        public static bool FindListing(this List<CONFileListing> listings, string name, out CONFileListing listing)
        {
            foreach (var file in listings)
            {
                if (file.Name == name)
                {
                    listing = file;
                    return true;
                }
            }
            listing = null!;
            return false;
        }

        public static unsafe List<CONFileListing>? TryParseListings(string filename, FileStream filestream)
        {
            if (filestream.Length <= CONFileStream.FIRSTBLOCK_OFFSET)
            {
                return null;
            }

            var tag = new FourCC(filestream);
            if (tag != CON_TAG && tag != LIVE_TAG && tag != PIRS_TAG)
            {
                return null;
            }

            Span<byte> buffer = stackalloc byte[BYTES_32BIT];
            filestream.Position = METADATA_POSITION;
            if (filestream.Read(buffer) != BYTES_32BIT)
            {
                return null;
            }

            byte shift = 0;
            int entryID = buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];

            // Docs: "If bit 12, 13 and 15 of the Entry ID are on, there are 2 hash tables every 0xAA (170) blocks"
            if ((entryID + 0xFFF & 0xF000) >> 0xC != 0xB)
            {
                shift = 1;
            }

            filestream.Position = FILETABLEBLOCKCOUNT_POSITION;
            if (filestream.Read(buffer[..BYTES_16BIT]) != BYTES_16BIT)
            {
                return null;
            }

            int length = BYTES_PER_BLOCK * (buffer[0] | buffer[1] << 8);

            filestream.Position = FILETABLEFIRSTBLOCK_POSITION;
            if (filestream.Read(buffer[..BYTES_24BIT]) != BYTES_24BIT)
            {
                return null;
            }

            try
            {
                filestream.Position = CONFileStream.CalculateBlockLocation(buffer[0] << 16 | buffer[1] << 8 | buffer[2], shift);
                using var listingBuffer = FixedArray.Read(filestream, length);

                var listings = new List<CONFileListing>();
                unsafe
                {
                    var endPtr = listingBuffer.Ptr + length;
                    for (var currPtr = listingBuffer.Ptr; currPtr + SIZEOF_FILELISTING <= endPtr && currPtr[0] != 0; currPtr += SIZEOF_FILELISTING)
                    {
                        short pathIndex = (short) (currPtr[0x32] << 8 | currPtr[0x33]);
                        string root = string.Empty;
                        if (pathIndex >= 0)
                        {
                            if (pathIndex >= listings.Count)
                            {
                                YargLogger.LogFormatError("Error while parsing {0} - Filelisting blocks constructed out of spec", filename);
                                return null;
                            }
                            root = listings[pathIndex].Name + "/";
                        }

                        var listing = new CONFileListing()
                        {
                            Name = root + Encoding.UTF8.GetString(currPtr, currPtr[0x28] & 0x3F),
                            Flags = (CONFileListing.Flag) (currPtr[0x28] & 0xC0),
                            BlockCount =  currPtr[0x2B] << 16 | currPtr[0x2A] <<  8 | currPtr[0x29],
                            BlockOffset = currPtr[0x31] << 16 | currPtr[0x30] <<  8 | currPtr[0x2F],
                            PathIndex = pathIndex,
                            Length =      currPtr[0x34] << 24 | currPtr[0x35] << 16 | currPtr[0x36] << 8 | currPtr[0x37],
                            LastWrite = FatTimeDT(currPtr[0x3B] << 24 | currPtr[0x3A] << 16 | currPtr[0x39] << 8 | currPtr[0x38]),
                            Shift = shift,
                        };
                        listings.Add(listing);
                    }
                }
                return listings;
            }
            catch (Exception ex)
            {
                YargLogger.LogException(ex, $"Error while parsing {filename}");
                return null;
            }
        }

        private static DateTime FatTimeDT(int fatTime)
        {
            int time = fatTime & 0xFFFF;
            int date = fatTime >> 16;
            if (date == 0 && time == 0)
                return DateTime.Now;

            int seconds = time & 0b11111;
            int minutes = (time >> 5) & 0b111111;
            int hour = (time >> 11) & 0b11111;

            int day = date & 0b11111;
            int month = (date >> 5) & 0b1111;
            int year = (date >> 9) & 0b1111111;

            if (day == 0)
                day = 1;

            if (month == 0)
                month = 1;

            return new DateTime(year + 1980, month, day, hour, minutes, 2 * seconds);
        }
    }
}
</file>

<file path="IO/ConHandler/CONFileListing.cs">
using System;

namespace YARG.Core.IO
{
    public sealed class CONFileListing
    {
        [Flags]
        public enum Flag
        {
            Consecutive = 0x40,
            Directory = 0x80,
        }

        public string Name = string.Empty;
        public Flag Flags;
        public int BlockCount;
        public int BlockOffset;
        public short PathIndex;
        public int Length;
        public DateTime LastWrite;
        public int Shift;

        public bool IsContiguous() { return (Flags & Flag.Consecutive) > 0; }
        public bool IsDirectory() { return (Flags & Flag.Directory) > 0; }
    }
}
</file>

<file path="IO/ConHandler/CONFileStream.cs">
using System;
using System.IO;
using System.Runtime.CompilerServices;

namespace YARG.Core.IO
{
    public sealed class CONFileStream : Stream
    {
        public const long FIRSTBLOCK_OFFSET = 0xC000;
        public const long BYTES_PER_BLOCK = 0x1000;
        public const long BLOCKS_PER_SECTION = 170;
        public const long BYTES_PER_SECTION = BLOCKS_PER_SECTION * BYTES_PER_BLOCK;
        public const long NUM_BLOCKS_SQUARED = BLOCKS_PER_SECTION * BLOCKS_PER_SECTION;

        public const long BYTES_PER_HASH_ENTRY = 0x18;
        public const long NEXT_BLOCK_HASH_OFFSET = 0x15;
        public const long HASHBLOCK_OFFSET = 4075;
        public const long DIST_PER_HASH = 4072;

        private readonly FileStream _filestream;
        private readonly long _length;
        private readonly long _initialOffset;
        private FixedArray<byte> _dataBuffer;
        private FixedArray<long> _blockLocations;

        private long _bufferPosition;
        private long _position;
        private long _bufferIndex = -1;

        public override bool CanRead => _filestream.CanRead;
        public override bool CanWrite => false;
        public override bool CanSeek => _filestream.CanSeek;
        public override long Length => _length;

        public override long Position
        {
            get => _position;
            set
            {
                if (value < 0 || value > _length)
                {
                    throw new ArgumentOutOfRangeException();
                }

                _position = value;
                long truePosition = _position + _initialOffset;
                long index = truePosition / _dataBuffer.Length;
                if (_bufferIndex != index)
                {
                    _bufferIndex = -1;
                }
                else
                {
                    _bufferPosition = truePosition % _dataBuffer.Length;
                }
            }
        }

        public override void Flush()
        {
            _filestream.Flush();
        }

        public override void SetLength(long value)
        {
            throw new InvalidOperationException("Not allowed to set stream length");
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new InvalidOperationException("Not allowed to write to stream");
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            long read = 0;
            while (read < count && _position < _length)
            {
                if (_bufferIndex == -1 || _bufferPosition == _dataBuffer.Length)
                {
                    UpdateBuffer();
                }

                long available = _dataBuffer.Length - _bufferPosition;
                long remainingInFile = _length - _position;
                if (available > remainingInFile)
                {
                    available = remainingInFile;
                }

                long amount = count - read;
                if (amount > available)
                {
                    amount = available;
                }

                Unsafe.CopyBlock(ref buffer[offset + read], ref _dataBuffer[_bufferPosition], (uint) amount);

                read += amount;
                _position += amount;
                _bufferPosition += amount;
            }
            return (int) read;
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            switch (origin)
            {
                case SeekOrigin.Begin:
                    Position = offset;
                    break;
                case SeekOrigin.Current:
                    Position += offset;
                    break;
                case SeekOrigin.End:
                    Position = _length + offset;
                    break;
            }
            return _position;
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                _filestream.Dispose();
            }
            _dataBuffer.Dispose();
            _blockLocations.Dispose();
        }

        private void UpdateBuffer()
        {
            long truePosition = _position + _initialOffset;
            long index = truePosition / _dataBuffer.Length;
            if (index == _bufferIndex)
            {
                return;
            }

            _bufferIndex = index;
            _filestream.Position = _blockLocations[index];
            _bufferPosition = truePosition % _dataBuffer.Length;

            long count = _dataBuffer.Length;
            if (index == _blockLocations.Length - 1)
            {
                count = (_length - _position) + _bufferPosition;
            }

            long offset = index == 0 ? _initialOffset : 0;
            count -= offset;

            if (_filestream.Read(_dataBuffer.Slice(offset, count)) != count)
            {
                throw new IOException("Buffer update error");
            }
        }

        private CONFileStream(FileStream stream, long length, long offset, ref FixedArray<byte> buffer, ref FixedArray<long> locations)
        {
            _filestream = stream;
            _length = length;
            _initialOffset = offset;
            _dataBuffer = buffer.TransferOwnership();
            _blockLocations = locations.TransferOwnership();
            _bufferIndex = -1;
        }

        public static long CalculateBlockLocation(long blockNum, int shift)
        {
            long blockAdjust = 0;
            if (blockNum >= BLOCKS_PER_SECTION)
            {
                blockAdjust += ((blockNum / BLOCKS_PER_SECTION) + 1) << shift;
                if (blockNum >= NUM_BLOCKS_SQUARED)
                {
                    blockAdjust += ((blockNum / NUM_BLOCKS_SQUARED) + 1) << shift;
                }
            }
            return FIRSTBLOCK_OFFSET + (blockAdjust + blockNum) * BYTES_PER_BLOCK;
        }

        public static CONFileStream CreateStream(string path, CONFileListing listing)
        {
            var stream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
            try
            {
                FixedArray<byte> dataBuffer;
                FixedArray<long> blockLocations;
                long initialOffset;

                long currentBlock = listing.BlockOffset;
                if (listing.IsContiguous())
                {
                    long blockOffset = currentBlock % BLOCKS_PER_SECTION;
                    initialOffset = blockOffset * BYTES_PER_BLOCK;

                    long totalBlocks = listing.BlockCount + blockOffset;
                    long numSections = totalBlocks / BLOCKS_PER_SECTION;
                    if (totalBlocks % BLOCKS_PER_SECTION > 0)
                    {
                        ++numSections;
                    }

                    using var contiguousLocations = FixedArray<long>.Alloc(numSections);
                    long blockMovement = BLOCKS_PER_SECTION - blockOffset;
                    long skipVal = BYTES_PER_BLOCK << listing.Shift;
                    long threshold = ((currentBlock / NUM_BLOCKS_SQUARED) + 1) * NUM_BLOCKS_SQUARED;
                    long location = CalculateBlockLocation(currentBlock, listing.Shift);

                    for (int i = 0; i < numSections; ++i)
                    {
                        contiguousLocations[i] = location;
                        if (i < numSections - 1)
                        {
                            currentBlock += blockMovement;

                            long seekCount = 1;
                            if (currentBlock == BLOCKS_PER_SECTION)
                            {
                                seekCount = 2;
                            }
                            else if (currentBlock == threshold)
                            {
                                seekCount = currentBlock == NUM_BLOCKS_SQUARED ? 3 : 2;
                                threshold += NUM_BLOCKS_SQUARED;
                            }

                            location += blockMovement * BYTES_PER_BLOCK + seekCount * skipVal;
                            blockMovement = BLOCKS_PER_SECTION;
                        }
                    }
                    blockLocations = contiguousLocations.TransferOwnership();
                    dataBuffer = FixedArray<byte>.Alloc(BYTES_PER_SECTION);
                }
                else
                {
                    initialOffset = 0;

                    using var splitLocations = FixedArray<long>.Alloc(listing.BlockCount);
                    using var hashBlock = FixedArray<byte>.Alloc(BYTES_PER_BLOCK);
                    var hashSpan = hashBlock.Span;
                    for (int i = 0; i < listing.BlockCount; ++i)
                    {
                        long location = splitLocations[i] = CalculateBlockLocation(currentBlock, listing.Shift);
                        if (i < listing.BlockCount - 1)
                        {
                            long blockOffset = currentBlock % BLOCKS_PER_SECTION;
                            long hashLocation = location - ((blockOffset + 1) * BYTES_PER_BLOCK);
                            stream.Position = hashLocation;

                            if (stream.Read(hashSpan) != BYTES_PER_BLOCK)
                            {
                                throw new IOException("Hashblock Read error");
                            }

                            long next_block_hash_index = blockOffset * BYTES_PER_HASH_ENTRY + NEXT_BLOCK_HASH_OFFSET;
                            currentBlock = (long) hashBlock[next_block_hash_index] << 16 |
                                           (long) hashBlock[next_block_hash_index + 1] << 8 |
                                                  hashBlock[next_block_hash_index + 2];
                        }
                    }
                    blockLocations = splitLocations.TransferOwnership();
                    dataBuffer = FixedArray<byte>.Alloc(BYTES_PER_BLOCK);
                }
                return new CONFileStream(stream, listing.Length, initialOffset, ref dataBuffer, ref blockLocations);
            }
            catch
            {
                stream.Dispose();
                throw;
            }
        }

        public static FixedArray<byte> LoadFile(string path, CONFileListing listing)
        {
            using var filestream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
            return LoadFile(filestream, listing);
        }

        public static FixedArray<byte> LoadFile(Stream stream, CONFileListing listing)
        {
            using var data = FixedArray<byte>.Alloc(listing.Length);
            
            long currentBlock = listing.BlockOffset;
            if (listing.IsContiguous())
            {
                long numBlocks = BLOCKS_PER_SECTION - (currentBlock % BLOCKS_PER_SECTION);
                long readSize = BYTES_PER_BLOCK * numBlocks;
                long remaining = listing.Length;
                while (remaining > 0)
                {
                    stream.Position = CalculateBlockLocation(currentBlock, listing.Shift);
                    if (readSize > remaining)
                    {
                        readSize = remaining;
                    }

                    if (stream.Read(data.Slice(listing.Length - remaining, readSize)) != readSize)
                    {
                        throw new Exception("Block read error in CON subfile - Continguous");
                    }

                    remaining -= readSize;
                    currentBlock += numBlocks;
                    numBlocks = BLOCKS_PER_SECTION;
                    readSize = BYTES_PER_SECTION;
                }
            }
            else
            {
                using var hashBlock = FixedArray<byte>.Alloc(BYTES_PER_BLOCK);
                var hashSpan = hashBlock.Span;
                unsafe
                {
                    byte* position = data.Ptr;
                    for (int i = 0; i < listing.BlockCount; ++i)
                    {
                        long blockLocation = CalculateBlockLocation(currentBlock, listing.Shift);
                        stream.Position = blockLocation;

                        long readCount = i + 1 < listing.BlockCount ? BYTES_PER_BLOCK : listing.Length % BYTES_PER_BLOCK;
                        if (stream.Read(new Span<byte>(position, (int)readCount)) != readCount)
                        {
                            throw new Exception("Block read error in CON subfile - Split");
                        }
                        position += readCount;

                        if (i + 1 < listing.BlockCount)
                        {
                            long blockOffset = currentBlock % BLOCKS_PER_SECTION;
                            long hashLocation = blockLocation - ((blockOffset + 1) * BYTES_PER_BLOCK);

                            if (hashLocation < 0)
                            {
                                throw new Exception("Ha");
                            }

                            stream.Position = hashLocation;
                            if (stream.Read(hashSpan) != BYTES_PER_BLOCK)
                            {
                                throw new Exception("Hashblock read error in CON subfile");
                            }

                            long next_block_hash_index = blockOffset * BYTES_PER_HASH_ENTRY + NEXT_BLOCK_HASH_OFFSET;
                            currentBlock = (long) hashBlock[next_block_hash_index] << 16 |
                                           (long) hashBlock[next_block_hash_index + 1] << 8 |
                                                  hashBlock[next_block_hash_index + 2];
                        }
                    }
                }
            }
            return data.TransferOwnership();
        }
    }
}
</file>

<file path="IO/DTA/DTAEntry.cs">
using System;
using System.Text;
using YARG.Core.Song;

namespace YARG.Core.IO
{
    public struct DTAEntry
    {
        public static readonly DTAEntry Empty = new()
        {
            Intensities = RBIntensities.Default,
            MetadataEncoding = YARGTextReader.UTF8Strict
        };

        public TextSpan? Name;
        public TextSpan? Artist;
        public TextSpan? Album;
        public string? Genre;
        public string? Charter;
        public string? Source;
        public string? Playlist;
        public int? YearAsNumber;

        public long? SongLength;
        public SongRating? SongRating;

        public (long Start, long End)? Preview;
        public bool? IsMaster;
        public bool? UGC;

        public int? AlbumTrack;

        public string? SongID;
        public uint? AnimTempo;
        public string? DrumBank;
        public string? VocalPercussionBank;
        public uint? VocalSongScrollSpeed;
        public VocalGender? VocalGender;
        public uint? VocalTonicNote;
        public SongTonality? SongTonality;
        public int? TuningOffsetCents;
        public uint? VenueVersion;

        public string[]? Soloes;
        public string[]? VideoVenues;

        public int[]? RealGuitarTuning;
        public int[]? RealBassTuning;

        public RBAudio<int>? Indices;
        public int[]? CrowdChannels;

        public string? Location;
        public float[]? Pans;
        public float[]? Volumes;
        public float[]? Cores;
        public long? HopoThreshold;
        public Encoding MetadataEncoding;

        public RBIntensities Intensities;
        public bool DiscUpdate;

        public void LoadData(string nodename, YARGTextContainer<byte> container)
        {
            while (YARGDTAReader.StartNode(ref container))
            {
                string name = YARGDTAReader.GetNameOfNode(ref container, false);
                switch (name)
                {
                    case "name": Name = YARGDTAReader.ExtractTextBytes(ref container); break;
                    case "artist": Artist = YARGDTAReader.ExtractTextBytes(ref container); break;
                    case "master": IsMaster = YARGDTAReader.ExtractBoolean_FlippedDefault(ref container); break;
                    case "context":
                        unsafe
                        {
                            int scopeLevel = 1;
                            while (!container.IsAtEnd())
                            {
                                int ch = container.Get();
                                if (ch == ')')
                                {
                                    --scopeLevel;
                                    break;
                                }
                                ++container.Position;

                                switch (ch)
                                {
                                    case '{': ++scopeLevel; break;
                                    case '}': --scopeLevel; break;
                                }
                            }

                            if (scopeLevel != 0)
                            {
                                throw new Exception("Invalid Context - Unbalanced brace count!");
                            }
                            break;
                        }
                    case "song":
                        while (YARGDTAReader.StartNode(ref container))
                        {
                            string descriptor = YARGDTAReader.GetNameOfNode(ref container, false);
                            switch (descriptor)
                            {
                                case "name": Location = YARGDTAReader.ExtractText(ref container); break;
                                case "tracks":
                                {
                                    var indices = RBAudio<int>.Empty;
                                    while (YARGDTAReader.StartNode(ref container))
                                    {
                                        while (YARGDTAReader.StartNode(ref container))
                                        {
                                            switch (YARGDTAReader.GetNameOfNode(ref container, false))
                                            {
                                                case "drum": indices.Drums = YARGDTAReader.ExtractIntegerArray<int>(ref container); break;
                                                case "bass": indices.Bass = YARGDTAReader.ExtractIntegerArray<int>(ref container); break;
                                                case "guitar": indices.Guitar = YARGDTAReader.ExtractIntegerArray<int>(ref container); break;
                                                case "keys": indices.Keys = YARGDTAReader.ExtractIntegerArray<int>(ref container); break;
                                                case "vocals": indices.Vocals = YARGDTAReader.ExtractIntegerArray<int>(ref container); break;
                                            }
                                            YARGDTAReader.EndNode(ref container);
                                        }
                                        YARGDTAReader.EndNode(ref container);
                                    }
                                    Indices = indices;
                                    break;
                                }
                                case "crowd_channels": CrowdChannels = YARGDTAReader.ExtractIntegerArray<int>(ref container); break;
                                //case "vocal_parts": VocalParts = YARGDTAReader.ExtractUInt16(ref container); break;
                                case "pans": Pans = YARGDTAReader.ExtractFloatArray(ref container); break;
                                case "vols": Volumes = YARGDTAReader.ExtractFloatArray(ref container); break;
                                case "cores": Cores = YARGDTAReader.ExtractFloatArray(ref container); break;
                                case "hopo_threshold": HopoThreshold = YARGDTAReader.ExtractInteger<long>(ref container); break;
                            }
                            YARGDTAReader.EndNode(ref container);
                        }
                        break;
                    case "song_vocals": while (YARGDTAReader.StartNode(ref container)) YARGDTAReader.EndNode(ref container); break;
                    case "song_scroll_speed": VocalSongScrollSpeed = YARGDTAReader.ExtractInteger<uint>(ref container); break;
                    case "tuning_offset_cents": TuningOffsetCents = YARGDTAReader.ExtractInteger<int>(ref container); break;
                    case "bank": VocalPercussionBank = YARGDTAReader.ExtractText(ref container); break;
                    case "anim_tempo":
                    {
                        string val = YARGDTAReader.ExtractText(ref container);
                        AnimTempo = val switch
                        {
                            "kTempoSlow" => 16,
                            "kTempoMedium" => 32,
                            "kTempoFast" => 64,
                            _ => uint.Parse(val)
                        };
                        break;
                    }
                    case "preview": Preview = (YARGDTAReader.ExtractInteger<long>(ref container), YARGDTAReader.ExtractInteger<long>(ref container)); break;
                    case "rank":
                        while (YARGDTAReader.StartNode(ref container))
                        {
                            string descriptor = YARGDTAReader.GetNameOfNode(ref container, false);
                            int diff = YARGDTAReader.ExtractInteger<int>(ref container);
                            switch (descriptor)
                            {
                                case "drum":
                                case "drums": Intensities.FourLaneDrums = (short) diff; break;

                                case "guitar": Intensities.FiveFretGuitar = (short) diff; break;
                                case "bass": Intensities.FiveFretBass = (short) diff; break;
                                case "vocals": Intensities.LeadVocals = (short) diff; break;
                                case "keys": Intensities.Keys = (short) diff; break;

                                case "realGuitar":
                                case "real_guitar": Intensities.ProGuitar = (short) diff; break;

                                case "realBass":
                                case "real_bass": Intensities.ProBass = (short) diff; break;

                                case "realKeys":
                                case "real_keys": Intensities.ProKeys = (short) diff; break;

                                case "realDrums":
                                case "real_drums": Intensities.ProDrums = (short) diff; break;

                                case "harmVocals":
                                case "vocal_harm": Intensities.HarmonyVocals = (short) diff; break;

                                case "band": Intensities.Band = (short) diff; break;
                            }
                            YARGDTAReader.EndNode(ref container);
                        }
                        break;
                    case "solo": Soloes = YARGDTAReader.ExtractStringArray(ref container); break;
                    case "genre": Genre = YARGDTAReader.ExtractText(ref container); break;
                    case "decade": /*Decade = YARGDTAReader.ExtractText(ref container);*/ break;
                    case "vocal_gender": VocalGender = YARGDTAReader.ExtractText(ref container) == "male" ? Song.VocalGender.Male : Song.VocalGender.Female; break;
                    case "format": /*Format = YARGDTAReader.Extract<uint>(ref container);*/ break;
                    case "version": VenueVersion = YARGDTAReader.ExtractInteger<uint>(ref container); break;
                    case "fake": /*IsFake = YARGDTAReader.ExtractText(ref container);*/ break;
                    case "downloaded": /*Downloaded = YARGDTAReader.ExtractText(ref container);*/ break;
                    case "game_origin":
                    {
                        string str = YARGDTAReader.ExtractText(ref container);
                        if (str == "#ifdef")
                        {
                            string conditional = YARGDTAReader.ExtractText(ref container);
                            if (conditional == "CUSTOMSOURCE")
                            {
                                Source = YARGDTAReader.ExtractText(ref container);
                            }
                            else
                            {
                                Source = "customs";
                            }
                        }
                        else
                        {
                            Source = str;
                        }
                        break;
                    }
                    case "song_id": SongID = YARGDTAReader.ExtractText(ref container); break;
                    case "rating": SongRating = (SongRating) YARGDTAReader.ExtractInteger<uint>(ref container); break;
                    case "short_version": /*ShortVersion = YARGDTAReader.Extract<uint>(ref container);*/ break;
                    case "album_art": /*HasAlbumArt = YARGDTAReader.ExtractBoolean(ref container);*/ break;
                    case "year_released":
                    case "year_recorded": YearAsNumber = YARGDTAReader.ExtractInteger<int>(ref container); break;
                    case "album_name": Album = YARGDTAReader.ExtractTextBytes(ref container); break;
                    case "album_track_number": AlbumTrack = YARGDTAReader.ExtractInteger<int>(ref container); break;
                    case "pack_name": Playlist = YARGDTAReader.ExtractText(ref container); break;
                    case "base_points": /*BasePoints = YARGDTAReader.Extract<uint>(ref container);*/ break;
                    case "band_fail_cue": /*BandFailCue = YARGDTAReader.ExtractText(ref container);*/ break;
                    case "drum_bank": DrumBank = YARGDTAReader.ExtractText(ref container); break;
                    case "song_length": SongLength = YARGDTAReader.ExtractInteger<long>(ref container); break;
                    case "sub_genre": /*Subgenre = YARGDTAReader.ExtractText(ref container);*/ break;
                    case "author": Charter = YARGDTAReader.ExtractText(ref container); break;
                    case "guide_pitch_volume": /*GuidePitchVolume = YARGDTAReader.Extract<float>(ref container);*/ break;
                    case "encoding":
                        MetadataEncoding = YARGDTAReader.ExtractText(ref container).ToLower() switch
                        {
                            "latin1" => YARGTextReader.Latin1,
                            "utf-8" or
                            "utf8" => YARGTextReader.UTF8Strict,
                            _ => container.Encoding
                        };
                        break;
                    case "vocal_tonic_note": VocalTonicNote = YARGDTAReader.ExtractInteger<uint>(ref container); break;
                    case "song_tonality": SongTonality = YARGDTAReader.ExtractBoolean(ref container) ? Song.SongTonality.Minor : Song.SongTonality.Major; break;
                    case "alternate_path": /*AlternatePath = YARGDTAReader.ExtractBoolean(ref container);*/ break;
                    case "real_guitar_tuning": RealGuitarTuning = YARGDTAReader.ExtractIntegerArray<int>(ref container); break;
                    case "real_bass_tuning": RealBassTuning = YARGDTAReader.ExtractIntegerArray<int>(ref container); break;
                    case "video_venues": VideoVenues = YARGDTAReader.ExtractStringArray(ref container); break;
                    case "extra_authoring":
                    {
                        StringBuilder authors = new();
                        foreach (string str in YARGDTAReader.ExtractStringArray(ref container))
                        {
                            if (str == "disc_update")
                            {
                                DiscUpdate = true;
                            }
                            else
                            {
                                if (authors.Length == 0 && Charter == SongMetadata.DEFAULT_CHARTER)
                                {
                                    authors.Append(str);
                                }
                                else
                                {
                                    if (authors.Length == 0)
                                        authors.Append(Charter);
                                    authors.Append(", " + str);
                                }
                            }
                        }

                        if (authors.Length == 0)
                        {
                            authors.Append(Charter);
                        }

                        Charter = authors.ToString();
                    }
                    break;
                }
                YARGDTAReader.EndNode(ref container);
            }
        }

        public static DTAEntry Create(string nodename, YARGTextContainer<byte> container)
        {
            var entry = Empty;
            entry.LoadData(nodename, container);
            return entry;
        }
    }
}
</file>

<file path="IO/DTA/YARGDTAReader.cs">
using System;
using System.Collections.Generic;
using System.Text;
using YARG.Core.Extensions;

namespace YARG.Core.IO
{
    public static class YARGDTAReader
    {
        public static YARGTextContainer<byte> Create(in FixedArray<byte> data)
        {
            // If it doesn't throw with `At(1)`, then 0 and 1 are valid indices.
            // We can therefore skip bounds checking
            if ((data.At(1) == 0xFE && data[0] == 0xFF) || (data[0] == 0xFE && data[1] == 0xFF))
            {
                throw new Exception("UTF-16 & UTF-32 are not supported for .dta files");
            }

            var container = new YARGTextContainer<byte>(data, YARGTextReader.Latin1);
            // Same idea as above, but with index `2` instead
            if (data.At(2) == 0xBF && data[0] == 0xEF && data[1] == 0xBB)
            {
                container.Position += 3;
                container.Encoding = Encoding.UTF8;
            }
            return container;
        }

        public static int SkipWhitespace(ref YARGTextContainer<byte> container)
        {
            while (!container.IsAtEnd())
            {
                int ch = container.Get();
                if (ch > 32 && ch != ';')
                {
                    return ch;
                }

                ++container.Position;
                if (ch == ';')
                {
                    // In comment
                    while (!container.IsAtEnd() && ch != '\n')
                    {
                        ch = container.Get();
                        ++container.Position;
                    }
                }
            }
            return (char) 0;
        }

        /// <summary>
        /// Extracts a boolean and skips the following whitespace
        /// </summary>
        /// <remarks>Throws if no value could be parsed</remarks>
        /// <returns>The boolean or `false` on failed extraction</returns>
        public static bool ExtractBoolean(ref YARGTextContainer<byte> container)
        {
            bool result = YARGTextReader.ExtractBoolean(in container);
            SkipWhitespace(ref container);
            return result;
        }

        /// <summary>
        /// Extracts a boolean and skips the following whitespace
        /// </summary>
        /// <remarks>Throws if no value could be parsed</remarks>
        /// <returns>The boolean or `true` on failed extraction</returns>
        public static bool ExtractBoolean_FlippedDefault(ref YARGTextContainer<byte> container)
        {
            bool result = container.IsAtEnd() || container.Get() switch
            {
                '0' => false,
                _ => container.Position + 5 > container.Length ||
                    (container[0] | CharacterExtensions.ASCII_LOWERCASE_FLAG) != 'f' ||
                    (container[1] | CharacterExtensions.ASCII_LOWERCASE_FLAG) != 'a' ||
                    (container[2] | CharacterExtensions.ASCII_LOWERCASE_FLAG) != 'l' ||
                    (container[3] | CharacterExtensions.ASCII_LOWERCASE_FLAG) != 's' ||
                    (container[4] | CharacterExtensions.ASCII_LOWERCASE_FLAG) != 'e',
            };
            SkipWhitespace(ref container);
            return result;
        }

        /// <summary>
        /// Extracts a numerical value of the specified type and skips the following whitespace
        /// </summary>
        /// <remarks>Throws if no value could be parsed</remarks>
        /// <returns>The short</returns>
        public static TNumber ExtractInteger<TNumber>(ref YARGTextContainer<byte> container)
            where TNumber : unmanaged, IComparable, IComparable<TNumber>, IConvertible, IEquatable<TNumber>, IFormattable
        {
            if (!YARGTextReader.TryExtract(ref container, out TNumber value))
            {
                throw new Exception("Data for " + typeof(TNumber).Name + " not present");
            }
            SkipWhitespace(ref container);
            return value;
        }

        public static float ExtractFloat(ref YARGTextContainer<byte> container)
        {
            if (!YARGTextReader.TryExtract(ref container, out float value))
            {
                throw new Exception("Data for float not present");
            }
            SkipWhitespace(ref container);
            return value;
        }

        private enum TextScopeState
        {
            None,
            Squirlies,
            Quotes,
            Apostrophes,
            Comment
        }

        public static TextSpan ExtractTextBytes(ref YARGTextContainer<byte> container)
        {
            int ch = container.GetCurrentCharacter();
            var state = ch switch
            {
                '{' => TextScopeState.Squirlies,
                '\"' => TextScopeState.Quotes,
                '\'' => TextScopeState.Apostrophes,
                _ => TextScopeState.None
            };

            if (state != TextScopeState.None)
            {
                ++container.Position;
                ch = container.GetCurrentCharacter();
            }

            TextSpan span;
            unsafe
            {
                span = new TextSpan()
                {
                    ptr = container.GetBuffer() + container.Position,
                    length = 0
                };
            }

            while (true)
            {
                if (ch == '{')
                {
                    throw new Exception("Text error - no { braces allowed");
                }

                if (ch == '}')
                {
                    if (state == TextScopeState.Squirlies)
                    {
                        break;
                    }
                    throw new Exception("Text error - no \'}\' allowed");
                }
                else if (ch == '\"')
                {
                    if (state == TextScopeState.Quotes)
                    {
                        break;
                    }

                    if (state != TextScopeState.Squirlies)
                    {
                        throw new Exception("Text error - no quotes allowed");
                    }
                }
                else if (ch == '\'')
                {
                    if (state == TextScopeState.Apostrophes)
                    {
                        break;
                    }

                    if (state == TextScopeState.None)
                    {
                        throw new Exception("Text error - no apostrophes allowed");
                    }
                }
                else if (ch <= 32 || ch == ')')
                {
                    if (state == TextScopeState.None)
                    {
                        break;
                    }
                }
                ++span.length;
                ch = container.At(span.length);
            }

            container.Position += span.length;
            if (ch != ')')
            {
                ++container.Position;
            }
            SkipWhitespace(ref container);
            return span;
        }

        public static string ExtractText(ref YARGTextContainer<byte> container)
        {
            var span = ExtractTextBytes(ref container);
            return DecodeString(in span, Encoding.UTF8);
        }

        public static string DecodeString(in TextSpan span, Encoding encoding)
        {
            string str;
            try
            {
                str = span.GetString(encoding);
            }
            catch
            {
                if (encoding != YARGTextReader.UTF8Strict)
                {
                    throw;
                }
                str = span.GetString(YARGTextReader.Latin1);
            }
            return str.Replace("\\q", "\"");
        }

        public static TNumber[] ExtractIntegerArray<TNumber>(ref YARGTextContainer<byte> container)
            where TNumber : unmanaged, IComparable, IComparable<TNumber>, IConvertible, IEquatable<TNumber>, IFormattable
        {
            bool doEnd = StartNode(ref container);
            List<TNumber> values = new();
            while (container.GetCurrentCharacter() != ')')
            {
                values.Add(ExtractInteger<TNumber>(ref container));
            }

            if (doEnd)
            {
                EndNode(ref container);
            }
            return values.ToArray();
        }

        public static float[] ExtractFloatArray(ref YARGTextContainer<byte> container)
        {
            bool doEnd = StartNode(ref container);
            List<float> values = new();
            while (container.GetCurrentCharacter() != ')')
            {
                values.Add(ExtractFloat(ref container));
            }

            if (doEnd)
            {
                EndNode(ref container);
            }
            return values.ToArray();
        }

        public static string[] ExtractStringArray(ref YARGTextContainer<byte> container)
        {
            bool doEnd = StartNode(ref container);
            List<string> strings = new();
            while (container.GetCurrentCharacter() != ')')
            {
                strings.Add(ExtractText(ref container));
            }

            if (doEnd)
            {
                EndNode(ref container);
            }
            return strings.ToArray();
        }

        public static bool StartNode(ref YARGTextContainer<byte> container)
        {
            if (container.IsAtEnd() || container.Get() != '(')
            {
                return false;
            }

            ++container.Position;
            SkipWhitespace(ref container);
            return true;
        }

        public static string GetNameOfNode(ref YARGTextContainer<byte> container, bool allowNonAlphetical)
        {
            int ch = container.GetCurrentCharacter();
            if (ch == '(')
            {
                return string.Empty;
            }

            bool hasApostrophe = ch == '\'';
            if (hasApostrophe)
            {
                ++container.Position;
                ch = container.GetCurrentCharacter();
            }

            var start = container.Position;
            int length = 0;
            while (true)
            {
                if (ch == '\'')
                {
                    if (!hasApostrophe)
                    {
                        throw new Exception("Invalid name format");
                    }
                    container.Position += length + 1;
                    break;
                }

                if (ch <= 32)
                {
                    if (!hasApostrophe)
                    {
                        container.Position += length + 1;
                        break;
                    }
                }
                else if (!allowNonAlphetical && ch != '_')
                {
                    int cased = ch | CharacterExtensions.ASCII_LOWERCASE_FLAG;
                    if (cased < 'a' || 'z' < cased)
                    {
                        container.Position += length;
                        break;
                    }
                }

                ++length;
                if (container.Position + length == container.Length)
                {
                    container.Position = container.Length;
                    break;
                }
                ch = container[length];
            }

            SkipWhitespace(ref container);
            unsafe
            {
                return Encoding.UTF8.GetString(container.GetBuffer() + start, length);
            }
        }

        public static void EndNode(ref YARGTextContainer<byte> container)
        {
            int scopeLevel = 0;
            int squirlyCount = 0;
            var textState = TextScopeState.None;
            while (!container.IsAtEnd() && scopeLevel >= 0)
            {
                int curr = container.Get();
                ++container.Position;
                if (textState == TextScopeState.Comment)
                {
                    if (curr == '\n')
                    {
                        textState = TextScopeState.None;
                    }
                }
                else if (curr == '{')
                {
                    if (textState != TextScopeState.None && textState != TextScopeState.Squirlies)
                    {
                        throw new Exception("Invalid open-squirly found!");
                    }
                    textState = TextScopeState.Squirlies;
                    ++squirlyCount;
                }
                else if (curr == '}')
                {
                    if (textState != TextScopeState.Squirlies)
                    {
                        throw new Exception("Invalid close-squirly found!");
                    }
                    --squirlyCount;
                    if (squirlyCount == 0)
                    {
                        textState = TextScopeState.None;
                    }
                }
                else if (curr == '\"')
                {
                    switch (textState)
                    {
                        case TextScopeState.Apostrophes:
                            throw new Exception("Invalid quotation mark found!");
                        case TextScopeState.None:
                            textState = TextScopeState.Quotes;
                            break;
                        case TextScopeState.Quotes:
                            textState = TextScopeState.None;
                            break;
                    }
                }
                else if (textState == TextScopeState.None)
                {
                    switch (curr)
                    {
                        case '(': ++scopeLevel; break;
                        case ')': --scopeLevel; break;
                        case '\'': textState = TextScopeState.Apostrophes; break;
                        case ';': textState = TextScopeState.Comment; break;
                    }
                }
                else if (textState == TextScopeState.Apostrophes && curr == '\'')
                {
                    textState = TextScopeState.None;
                }
            }
            SkipWhitespace(ref container);
        }
    };
}
</file>

<file path="IO/FixedArray/FixedArray.cs">
using System;
using System.Diagnostics;
using System.IO;
using System.Numerics;
using System.Runtime.InteropServices;

namespace YARG.Core.IO
{
    public static class FixedArray
    {
        /// <summary>
        /// Loads all the given file's data into a FixedArray buffer
        /// </summary>
        /// <param name="filename">The path to the file</param>
        /// <returns>The instance carrying the loaded data</returns>
        public static FixedArray<byte> LoadFile(string filename)
        {
            using var stream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
            return Read(stream, stream.Length);
        }

        /// <summary>
        /// Loads all the data remaining in the stream into a FixedArray buffer
        /// </summary>
        /// <param name="stream">Stream with leftover data</param>
        /// <returns>The instance carrying the loaded data</returns>
        public static FixedArray<byte> ReadRemainder(Stream stream)
        {
            return Read(stream, stream.Length - stream.Position);
        }

        /// <summary>
        /// Loads the given amount of data from the stream into a FixedArray buffer
        /// </summary>
        /// <param name="stream">Stream with leftover data</param>
        /// <param name="numElements">Number of bytes to read from the stream</param>
        /// <param name="vectorize">Flags whether to allocate the buffer with vector alignment</param>
        /// <returns>The instance carrying the loaded data</returns>
        public static FixedArray<byte> Read(Stream stream, long numElements, bool vectorize = false)
        {
            long byteCount = numElements;
            if (stream.Position > stream.Length - byteCount)
            {
                throw new ArgumentException("Length extends past end of stream");
            }

            var buffer = !vectorize
                ? FixedArray<byte>.Alloc(numElements)
                : FixedArray<byte>.AllocVectorAligned(numElements);

            unsafe
            {
                if (stream.Read(new Span<byte>(buffer.Ptr, (int) byteCount)) != byteCount)
                {
                    buffer.Dispose();
                    throw new IOException("Could not read data from file");
                }
            }
            return buffer;
        }

        public static FixedArrayStream ToValueStream(in this FixedArray<byte> arr)
        {
            return new FixedArrayStream(in arr);
        }

        public static UnmanagedMemoryStream ToReferenceStream(in this FixedArray<byte> arr)
        {
            unsafe
            {
                return new UnmanagedMemoryStream(arr.Ptr, arr.Length);
            }
        }
    }

    /// <summary>
    /// A wrapper interface over a fixed area of unmanaged memory.
    /// Provides functions to create spans and span slices alongside
    /// basic indexing and enumeration.<br></br><br></br>
    ///
    /// For serious performance-critical code, the raw pointer to
    /// the start of the memory block is also provided.<br></br>
    /// However, code that uses the value directly should first check
    /// for valid boundaries.
    /// </summary>
    /// <remarks>
    /// 1. DO NOT USE THIS AS AN ALTERNATIVE TO STACK-BASED ARRAYS!<br></br>
    /// 2. YOU MUST MANUALLY DISPOSE OF ANY INSTANCE YOU CREATE! IT WILL NOT DO IT FOR YOU!
    /// </remarks>
    /// <typeparam name="T">The unmanaged type contained in the block of memory</typeparam>
    [DebuggerDisplay("Length = {Length}")]
    public unsafe struct FixedArray<T> : IDisposable
        where T : unmanaged
    {
        /// <summary>
        /// A indisposable default instance with a null pointer
        /// </summary>
        public static readonly FixedArray<T> Null = new()
        {
            _handle = IntPtr.Zero,
            _ptr = null,
            _length = 0,
        };

        /// <summary>
        /// Allocates a uninitialized buffer of data
        /// </summary>
        /// <param name="numElements">Number of the elements to hold in the buffer</param>
        /// <returns>The instance carrying the empty buffer</returns>
        public static FixedArray<T> Alloc(long numElements)
        {
            var handle = Marshal.AllocHGlobal((IntPtr) (numElements * sizeof(T)));
            return new FixedArray<T>
            (
                handle,
                (T*) handle,
                numElements,
                false
            );
        }

        private static readonly int OVER_ALLOCATION = sizeof(Vector<byte>) - 1;
        public static FixedArray<T> AllocVectorAligned(long numElements)
        {
            var handle = Marshal.AllocHGlobal((IntPtr) (numElements * sizeof(T) + OVER_ALLOCATION));
            long adjustment = handle.ToInt64() & OVER_ALLOCATION;
            if (adjustment > 0)
            {
                adjustment = sizeof(Vector<byte>) - adjustment;
            }

            return new FixedArray<T>
            (
                handle,
                (T*) ((byte*)handle + adjustment),
                numElements,
                true
            );
        }

        /// <summary>
        /// Creates an instance of FixedArray that solely functions as an cast over the current buffer
        /// </summary>
        /// <remarks>The casted copy will not dispose of the original data, so any callers must maintain the original buffer instance.</remarks>
        /// <param name="source">The source buffer to cast</param>
        /// <param name="offset">The index in the source buffer to start the cast from</param>
        /// <param name="numElements">The number of elements to cast to</param>
        /// <returns>The buffer casted to the new type</returns>
        public static FixedArray<T> Cast<U>(in FixedArray<U> source, long offset, long numElements)
            where U : unmanaged
        {
            if (source._vectorized)
            {
                throw new InvalidOperationException("Do not cast from a vectorized source");
            }

            if (offset < 0)
            {
                throw new IndexOutOfRangeException();
            }

            if ((source.Length - offset) * sizeof(U) < numElements * sizeof(T))
            {
                throw new ArgumentOutOfRangeException(nameof(numElements));
            }

            return new FixedArray<T>
            (
                IntPtr.Zero,
                (T*) (source.Ptr + offset),
                numElements,
                false
            );
        }

        private          IntPtr _handle;
        private          T*     _ptr;
        private          long   _length;
        private readonly bool   _vectorized;

        /// <summary>
        /// Pointer to the beginning of the memory block.<br></br>
        /// DO NOT TOUCH UNLESS YOU ENSURE YOU'RE WITHIN BOUNDS
        /// </summary>
        public readonly T* Ptr => _ptr;

        /// <summary>
        /// Number of elements within the block
        /// </summary>
        public readonly long Length => _length;

        /// <summary>
        /// Returns whether the instance points to actual data
        /// </summary>
        public readonly bool IsAllocated => Ptr != null;

        /// <summary>
        /// Provides the pointer to the block of memory in IntPtr form
        /// </summary>
        public readonly IntPtr IntPtr => (IntPtr) Ptr;

        /// <summary>
        /// Provides a ReadOnlySpan over the block of memory
        /// </summary>
        public readonly ReadOnlySpan<T> ReadOnlySpan => new(Ptr, (int) Length);

        public readonly Span<T> Span => new(Ptr, (int) Length);

        private FixedArray(IntPtr handle, T* ptr, long length, bool vectorized)
        {
            _handle = handle;
            _ptr = ptr;
            _length = length;
            _vectorized = vectorized;
        }

        public readonly Span<T> Slice(long offset, long count)
        {
            if (offset < 0 || offset + count > _length)
            {
                throw new IndexOutOfRangeException();
            }
            return new Span<T>(_ptr + offset, (int) count);
        }

        public readonly ReadOnlySpan<T> ReadonlySlice(long offset, long count)
        {
            if (offset < 0 || offset + count > _length)
            {
                throw new IndexOutOfRangeException();
            }
            return new ReadOnlySpan<T>(_ptr + offset, (int) count);
        }

        /// <summary>
        /// Copies the pointer and length to a new instance of FixedArray, leaving the current one
        /// in a limbo state - no longer responsible for disposing of the data.
        /// </summary>
        /// <remarks>Useful for cleanly handling exception safety</remarks>
        /// <returns>The instance that takes responsibility over disposing of the buffer</returns>
        public FixedArray<T> TransferOwnership()
        {
            var handle = _handle;
            _handle = IntPtr.Zero;
            return new FixedArray<T>
            (
                handle,
                _ptr,
                _length,
                _vectorized
            );
        }

        /// <summary>
        /// Indexer into the fixed block of memory
        /// </summary>
        /// <param name="index"></param>
        /// <exception cref="IndexOutOfRangeException"></exception>
        public readonly ref T this[long index] => ref _ptr[index];

        /// <summary>
        /// Returns a reference to the value at the provided index, so long as the index lies within bounds.
        /// Indices out of bounds will throw an excpetion.
        /// </summary>
        /// <param name="index"></param>
        /// <exception cref="IndexOutOfRangeException"></exception>
        public readonly ref T At(long index)
        {
            if (index < 0 || _length <= index)
            {
                throw new IndexOutOfRangeException();
            }
            return ref _ptr[index];
        }

        public void Resize(int numElements)
        {
            if (_handle == IntPtr.Zero)
            {
                throw new InvalidOperationException("Can not resize an unowned array");
            }

            if (_vectorized)
            {
                // Reasoning: if the array is used for simd operations, that entails that
                // the data is either a file read buffer OR the whole file itself.
                // Resizing would therefore be illogical.
                throw new InvalidOperationException("Do not resize an array when vectorized");
            }

            if (numElements == _length)
            {
                return;
            }

            _handle = Marshal.ReAllocHGlobal(_handle, (IntPtr) (numElements * sizeof(T)));
            _ptr = (T*)_handle;
            _length = numElements;
        }

        public void Dispose()
        {
            if (_handle != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(_handle);
                _handle = IntPtr.Zero;
            }
        }
    }
}
</file>

<file path="IO/FixedArray/FixedArrayStream.cs">
using System;
using System.Runtime.CompilerServices;
using System.Text;
using YARG.Core.Extensions;

namespace YARG.Core.IO
{
    public struct FixedArrayStream
    {
        private readonly unsafe byte* _data;
        private readonly long _length;
        private long _position;

        public long Position
        {
            readonly get { return _position; }
            set
            {
                if (value < 0 || value > _length)
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                _position = value;
            }
        }

        public unsafe byte* PositionPointer
        {
            readonly get { return _data + _position; }
            set
            {
                if (value < _data || value > _data + _length)
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                _position = value - _data;
            }
        }

        public readonly long Length => _length;

        public byte ReadByte()
        {
            if (_position >= _length)
            {
                throw new InvalidOperationException();
            }

            unsafe
            {
                return _data[_position++];
            }
        }

        public bool ReadBoolean()
        {
            return ReadByte() != 0;
        }

        public T Read<T>(Endianness endianness)
            where T : unmanaged, IComparable, IComparable<T>, IConvertible, IEquatable<T>, IFormattable
        {
            unsafe
            {
                if (_position + sizeof(T) >_length)
                {
                    throw new InvalidOperationException();
                }

                var value = *(T*)(_data + _position);
                _position += sizeof(T);
                StreamExtensions.CorrectByteOrder(&value, endianness);
                return value;
            }
        }

        public unsafe void Read(void* pos, long count)
        {
            if (count < 0 || _position + count > _length)
            {
                throw new ArgumentOutOfRangeException("count");
            }
            Unsafe.CopyBlock(pos, _data + _position, (uint)count);
            _position += count;
        }

        public string ReadString()
        {
            int length = Read7BitEncodedInt();
            string str;
            unsafe
            {
                str = Encoding.UTF8.GetString(_data + _position, length); 
            }
            _position += length;
            return str;
        }

        public int Read7BitEncodedInt()
        {
            uint result = 0;
            byte byteReadJustNow;

            const int MaxBytesWithoutOverflow = 4;
            for (int shift = 0; shift < MaxBytesWithoutOverflow * 7; shift += 7)
            {
                byteReadJustNow = ReadByte();
                result |= (byteReadJustNow & 0x7Fu) << shift;
                if (byteReadJustNow <= 0x7Fu)
                {
                    return (int) result;
                }
            }

            byteReadJustNow = ReadByte();
            if (byteReadJustNow > 0b_1111u)
            {
                throw new Exception("LEB value exceeds max allowed");
            }

            result |= (uint) byteReadJustNow << MaxBytesWithoutOverflow * 7;
            return (int) result;
        }

        public Guid ReadGuid()
        {
            unsafe
            {
                var bytes = stackalloc byte[16];
                Read(bytes, 16);
                return new Guid(new ReadOnlySpan<byte>(bytes, 16));
            }
        }

        public FixedArrayStream Slice(long length)
        {
            if (length < 0 || _position + length > _length)
            {
                throw new ArgumentOutOfRangeException("length");
            }

            var slice = _position;
            _position += length;
            unsafe
            {
                return new FixedArrayStream(_data + slice, length);
            }
        }

        public FixedArrayStream(in FixedArray<byte> data)
        {
            unsafe
            {
                _data = data.Ptr; 
            }
            _length = data.Length;
            _position = 0;
        }

        private unsafe FixedArrayStream(byte* ptr, long length)
        {
            unsafe
            {
                _data = ptr;
            }
            _length = length;
            _position = 0;
        }
    }
}
</file>

<file path="IO/Images/YARGImage.cs">
using System;
using System.Runtime.InteropServices;

namespace YARG.Core.IO
{
    public enum ImageFormat
    {
        Grayscale = 1,
        GrayScale_Alpha = 2,
        RGB = 3,
        RGBA = 4,
        DXT1,
        DXT5,
    }

    public struct YARGImage : IDisposable
    {
        public static readonly YARGImage Null = new()
        {
            _handle = FixedArray<byte>.Null,
            _data = null,
            _width = 0,
            _height = 0,
            _format = 0,
        };

        private FixedArray<byte> _handle;

        private unsafe byte* _data;
        private int _width;
        private int _height;
        private ImageFormat _format;

        public readonly unsafe byte* Data => _data;
        public readonly int Width => _width;
        public readonly int Height => _height;
        public readonly ImageFormat Format => _format;
        public readonly unsafe bool IsAllocated => _data != null;

        public static YARGImage Load(string path)
        {
            using var bytes = FixedArray.LoadFile(path);
            return Load(in bytes);
        }

        public static unsafe YARGImage Load(in FixedArray<byte> file)
        {
            var result = LoadNative(file.Ptr, (int) file.Length, out int width, out int height, out int components);
            if (result == null)
            {
                return Null;
            }
            return new YARGImage()
            {
                _data = result,
                _width = width,
                _height = height,
                _format = (ImageFormat) components
            };
        }

        public static YARGImage LoadDXT(string path)
        {
            var data = FixedArray.LoadFile(path);
            return TransferDXT(ref data);
        }

        public static unsafe YARGImage TransferDXT(ref FixedArray<byte> file)
        {
            byte bitsPerPixel = file[1];
            int format = *(int*) (file.Ptr + 2);
            bool isDXT1 = bitsPerPixel == 0x04 && format == 0x08;
            return new YARGImage()
            {
                _handle = file.TransferOwnership(),
                _data = file.Ptr + 32,
                _width = *(short*) (file.Ptr + 7),
                _height = *(short*) (file.Ptr + 9),
                _format = isDXT1 ? ImageFormat.DXT1 : ImageFormat.DXT5
            };
        }

        public void Dispose()
        {
            unsafe
            {
                if (_data != null)
                {
                    if (_handle.IsAllocated)
                    {
                        _handle.Dispose();
                    }
                    else
                    {
                        FreeNative(_data);
                    }
                    _data = null;
                }
            }
        }

        [DllImport("STB2CSharp", EntryPoint = "load_image_from_memory")]
        private static extern unsafe byte* LoadNative(byte* data, int length, out int width, out int height, out int components);

        [DllImport("STB2CSharp", EntryPoint = "free_image")]
        private static extern unsafe void FreeNative(byte* image);
    }
}
</file>

<file path="IO/Ini/IniModifierCollection.cs">
using System;
using System.Collections.Generic;
using System.Text;
using YARG.Core.Utility;

namespace YARG.Core.IO.Ini
{
    public enum ModifierType
    {
        None,
        String,
        UInt64,
        Int64,
        UInt32,
        Int32,
        UInt16,
        Int16,
        Bool,
        Float,
        Double,
        Int64Array,
    };

    public readonly struct IniModifierOutline
    {
        public readonly string Output;
        public readonly ModifierType Type;

        public IniModifierOutline(string output, ModifierType type)
        {
            Output = output;
            Type = type;
        }
    };

    public class IniModifierCollection
    {
        private Dictionary<string, string>? _strings; 
        private Dictionary<string, ulong>? _uint64s; 
        private Dictionary<string, long>? _int64s; 
        private Dictionary<string, uint>? _uint32s; 
        private Dictionary<string, int>? _int32s; 
        private Dictionary<string, ushort>? _uint16s; 
        private Dictionary<string, short>? _int16s; 
        private Dictionary<string, bool>? _booleans; 
        private Dictionary<string, float>? _floats; 
        private Dictionary<string, double>? _doubles; 
        private Dictionary<string, (long, long)>? _int64Arrays; 

        public bool Contains(string key)
        {
            static bool DictContains<T>(Dictionary<string, T>? dict, string key)
            {
                return dict != null && dict.ContainsKey(key);
            }

            return DictContains(_strings, key)
                || DictContains(_uint64s, key)
                || DictContains(_int64s, key)
                || DictContains(_uint32s, key)
                || DictContains(_int32s, key)
                || DictContains(_uint16s, key)
                || DictContains(_int16s, key)
                || DictContains(_booleans, key)
                || DictContains(_floats, key)
                || DictContains(_doubles, key)
                || DictContains(_int64Arrays, key);
        }

        public void Add<TChar>(ref YARGTextContainer<TChar> container, in IniModifierOutline outline, bool isChartFile)
            where TChar : unmanaged, IConvertible
        {
            switch (outline.Type)
            {
                case ModifierType.String:
                    _strings ??= new Dictionary<string, string>();
                    _strings[outline.Output] = RichTextUtils.ReplaceColorNames(YARGTextReader.ExtractText(ref container, isChartFile));
                    break;
                case ModifierType.UInt64:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out ulong value))
                        {
                            value = 0;
                        }
                        _uint64s ??= new Dictionary<string, ulong>();
                        _uint64s[outline.Output] = value;
                        break;
                    }
                case ModifierType.Int64:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out long value))
                        {
                            value = 0;
                        }
                        _int64s ??= new Dictionary<string, long>();
                        _int64s[outline.Output] = value;
                        break;
                    }
                case ModifierType.UInt32:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out uint value))
                        {
                            value = 0;
                        }
                        _uint32s ??= new Dictionary<string, uint>();
                        _uint32s[outline.Output] = value;
                        break;
                    }
                case ModifierType.Int32:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out int value))
                        {
                            value = 0;
                        }
                        _int32s ??= new Dictionary<string, int>();
                        _int32s[outline.Output] = value;
                        break;
                    }
                case ModifierType.UInt16:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out ushort value))
                        {
                            value = 0;
                        }
                        _uint16s ??= new Dictionary<string, ushort>();
                        _uint16s[outline.Output] = value;
                        break;
                    }
                case ModifierType.Int16:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out short value))
                        {
                            value = 0;
                        }
                        _int16s ??= new Dictionary<string, short>();
                        _int16s[outline.Output] = value;
                        break;
                    }
                case ModifierType.Bool:
                    _booleans ??= new Dictionary<string, bool>();
                    _booleans[outline.Output] = YARGTextReader.ExtractBoolean(in container);
                    break;
                case ModifierType.Float:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out float value))
                        {
                            value = 0;
                        }
                        _floats ??= new Dictionary<string, float>();
                        _floats[outline.Output] = value;
                        break;
                    }
                case ModifierType.Double:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out double value))
                        {
                            value = 0;
                        }
                        _doubles ??= new Dictionary<string, double>();
                        _doubles[outline.Output] = value;
                        break;
                    }
                case ModifierType.Int64Array:
                    long i641, i642;
                    if (YARGTextReader.TryExtract(ref container, out i641))
                    {
                        YARGTextReader.SkipWhitespaceAndEquals(ref container);
                        if (!YARGTextReader.TryExtract(ref container, out i642))
                        {
                            i642 = -1;
                        }
                    }
                    else
                    {
                        i641 = -1;
                        i642 = -1;
                    }
                    _int64Arrays ??= new Dictionary<string, (long, long)>();
                    _int64Arrays[outline.Output] = (i641, i642);
                    break;
            }
        }

        public void AddSng(ref YARGTextContainer<byte> container, int length, in IniModifierOutline outline)
        {
            switch (outline.Type)
            {
                case ModifierType.String:
                    unsafe
                    {
                        _strings ??= new Dictionary<string, string>();
                        _strings[outline.Output] = RichTextUtils.ReplaceColorNames(Encoding.UTF8.GetString(container.PositionPointer, length));
                    }
                    break;
                case ModifierType.UInt64:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out ulong value))
                        {
                            value = 0;
                        }
                        _uint64s ??= new Dictionary<string, ulong>();
                        _uint64s[outline.Output] = value;
                        break;
                    }
                case ModifierType.Int64:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out long value))
                        {
                            value = 0;
                        }
                        _int64s ??= new Dictionary<string, long>();
                        _int64s[outline.Output] = value;
                        break;
                    }
                case ModifierType.UInt32:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out uint value))
                        {
                            value = 0;
                        }
                        _uint32s ??= new Dictionary<string, uint>();
                        _uint32s[outline.Output] = value;
                        break;
                    }
                case ModifierType.Int32:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out int value))
                        {
                            value = 0;
                        }
                        _int32s ??= new Dictionary<string, int>();
                        _int32s[outline.Output] = value;
                        break;
                    }
                case ModifierType.UInt16:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out ushort value))
                        {
                            value = 0;
                        }
                        _uint16s ??= new Dictionary<string, ushort>();
                        _uint16s[outline.Output] = value;
                        break;
                    }
                case ModifierType.Int16:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out short value))
                        {
                            value = 0;
                        }
                        _int16s ??= new Dictionary<string, short>();
                        _int16s[outline.Output] = value;
                        break;
                    }
                case ModifierType.Bool:
                    _booleans ??= new Dictionary<string, bool>();
                    _booleans[outline.Output] = YARGTextReader.ExtractBoolean(in container);
                    break;
                case ModifierType.Float:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out float value))
                        {
                            value = 0;
                        }
                        _floats ??= new Dictionary<string, float>();
                        _floats[outline.Output] = value;
                        break;
                    }
                case ModifierType.Double:
                    {
                        if (!YARGTextReader.TryExtract(ref container, out double value))
                        {
                            value = 0;
                        }
                        _doubles ??= new Dictionary<string, double>();
                        _doubles[outline.Output] = value;
                        break;
                    }
                case ModifierType.Int64Array:
                    long i641, i642;
                    if (!YARGTextReader.TryExtractWithWhitespace(ref container, out i641))
                    {
                        i641 = -1;
                        i642 = -1;
                    }
                    else if (!YARGTextReader.TryExtract(ref container, out i642))
                    {
                        i642 = -1;
                    }
                    _int64Arrays ??= new Dictionary<string, (long, long)>();
                    _int64Arrays[outline.Output] = (i641, i642);
                    break;
            }
        }

        public void Union(IniModifierCollection source)
        {
            if (source._strings != null)
            {
                _strings ??= new Dictionary<string, string>();
                foreach (var node in source._strings)
                {
                    if (!_strings.TryGetValue(node.Key, out string str) || string.IsNullOrEmpty(str))
                    {
                        _strings[node.Key] = node.Value;
                    }
                }
            }

            Union(ref _uint64s, source._uint64s);
            Union(ref _int64s, source._int64s);
            Union(ref _uint32s, source._uint32s);
            Union(ref _int32s, source._int32s);
            Union(ref _uint16s, source._uint16s);
            Union(ref _int16s, source._int16s);
            Union(ref _booleans, source._booleans);
            Union(ref _floats, source._floats);
            Union(ref _doubles, source._doubles);
            Union(ref _int64Arrays, source._int64Arrays);
        }

        public bool IsEmpty()
        {
            static bool DictEmpty<T>(Dictionary<string, T>? dict)
            {
                return dict == null || dict.Count == 0;
            }

            return DictEmpty(_strings)
                && DictEmpty(_uint64s)
                && DictEmpty(_int64s)
                && DictEmpty(_uint32s)
                && DictEmpty(_int32s)
                && DictEmpty(_uint16s)
                && DictEmpty(_int16s)
                && DictEmpty(_booleans)
                && DictEmpty(_floats)
                && DictEmpty(_doubles)
                && DictEmpty(_int64Arrays);
        }

        public bool Extract(string key, out string value)
        {
#if DEBUG
            ThrowIfMismatch(key, ModifierType.String, "Mismatched modifier types - String requested");
#endif
            value = default!;
            return _strings != null && _strings.Remove(key, out value);
        }

        public bool Extract(string key, out ulong value)
        {
#if DEBUG
            ThrowIfMismatch(key, ModifierType.UInt64, "Mismatched modifier types - UInt64 requested");
#endif
            value = default!;
            return _uint64s != null && _uint64s.Remove(key, out value);
        }

        public bool Extract(string key, out long value)
        {
#if DEBUG
            ThrowIfMismatch(key, ModifierType.Int64, "Mismatched modifier types - Int64 requested");
#endif
            value = default!;
            return _int64s != null && _int64s.Remove(key, out value);
        }

        public bool Extract(string key, out uint value)
        {
#if DEBUG
            ThrowIfMismatch(key, ModifierType.UInt32, "Mismatched modifier types - UInt32 requested");
#endif
            value = default!;
            return _uint32s != null && _uint32s.Remove(key, out value);
        }

        public bool Extract(string key, out int value)
        {
#if DEBUG
            ThrowIfMismatch(key, ModifierType.Int32, "Mismatched modifier types - Int32 requested");
#endif
            value = default!;
            return _int32s != null && _int32s.Remove(key, out value);
        }

        public bool Extract(string key, out ushort value)
        {
#if DEBUG
            ThrowIfMismatch(key, ModifierType.UInt16, "Mismatched modifier types - UInt16 requested");
#endif
            value = default!;
            return _uint16s != null && _uint16s.Remove(key, out value);
        }

        public bool Extract(string key, out short value)
        {
#if DEBUG
            ThrowIfMismatch(key, ModifierType.Int16, "Mismatched modifier types - Int16 requested");
#endif
            value = default!;
            return _int16s != null && _int16s.Remove(key, out value);
        }

        public bool Extract(string key, out bool value)
        {
#if DEBUG
            ThrowIfMismatch(key, ModifierType.Bool, "Mismatched modifier types - Boolean requested");
#endif
            value = default!;
            return _booleans != null && _booleans.Remove(key, out value);
        }

        public bool Extract(string key, out float value)
        {
#if DEBUG
            ThrowIfMismatch(key, ModifierType.Float, "Mismatched modifier types - Float requested");
#endif
            value = default!;
            return _floats != null && _floats.Remove(key, out value);
        }

        public bool Extract(string key, out double value)
        {
#if DEBUG
            ThrowIfMismatch(key, ModifierType.Double, "Mismatched modifier types - Double requested");
#endif
            value = default!;
            return _doubles != null && _doubles.Remove(key, out value);
        }

        public bool Extract(string key, out (long, long) values)
        {
#if DEBUG
            ThrowIfMismatch(key, ModifierType.Int64Array, "Mismatched modifier types - Int64Array requested");
#endif
            values = default!;
            return _int64Arrays != null && _int64Arrays.Remove(key, out values);
        }

        private static void Union<TValue>(ref Dictionary<string, TValue>? dest, Dictionary<string, TValue>? source)
            where TValue : unmanaged, IEquatable<TValue>
        {
            if (source != null)
            {
                dest ??= new Dictionary<string, TValue>();
                foreach (var node in source)
                {
                    if (!dest.TryGetValue(node.Key, out var value) || value.Equals(default))
                    {
                        dest[node.Key] = node.Value;
                    }
                }
            }
        }

#if DEBUG
        private static Dictionary<string, ModifierType> _debugValidation = new();
        private static void ThrowIfMismatch(string key, ModifierType type, string error)
        {
            lock (_debugValidation)
            {
                if (_debugValidation.TryGetValue(key, out var value) && value != type)
                {
                    throw new InvalidOperationException(error);
                }
                _debugValidation[key] = type;
            }
        }
#endif
    }
}
</file>

<file path="IO/Ini/SongIniHandler.cs">
using System.Collections.Generic;

namespace YARG.Core.IO.Ini
{
    public static class SongIniHandler
    {
        public static IniModifierCollection ReadSongIniFile(string iniPath)
        {
            var modifiers = YARGIniReader.ReadIniFile(iniPath, SONG_INI_LOOKUP_MAP);
            if (!modifiers.TryGetValue("[song]", out var collection))
            {
                collection = new IniModifierCollection();
            }
            return collection;
        }

        private static readonly Dictionary<string, Dictionary<string, IniModifierOutline>> SONG_INI_LOOKUP_MAP;
        public static readonly Dictionary<string, IniModifierOutline> SONG_INI_OUTLINES;

        static SongIniHandler()
        {
            SONG_INI_OUTLINES = new()
            {
                { "album",                                new("album", ModifierType.String ) },
                { "album_track",                          new("album_track", ModifierType.Int32) },
                { "artist",                               new("artist", ModifierType.String) },

                { "background",                           new("background", ModifierType.String) },
                //{ "banner_link_a",                        new("banner_link_a", ModifierType.String) },
                //{ "banner_link_b",                        new("banner_link_b", ModifierType.String) },
                { "bass_type",                            new("bass_type", ModifierType.UInt32) },
                //{ "boss_battle",                          new("boss_battle", ModifierType.Bool) },

                //{ "cassettecolor",                        new("cassettecolor", ModifierType.UInt32) },
                { "charter",                              new("charter", ModifierType.String) },
                { "charter_bass",                         new("charter_bass", ModifierType.String) },
                { "charter_drums",                        new("charter_drums", ModifierType.String) },
                { "charter_elite_drums",                  new("charter_elite_drums", ModifierType.String) },
                { "charter_guitar",                       new("charter_guitar", ModifierType.String) },
                { "charter_keys",                         new("charter_keys", ModifierType.String) },
                { "charter_lower_diff",                   new("charter_lower_diff", ModifierType.String) },
                { "charter_pro_bass",                     new("charter_pro_bass", ModifierType.String) },
                { "charter_pro_keys",                     new("charter_pro_keys", ModifierType.String) },
                { "charter_pro_guitar",                   new("charter_pro_guitar", ModifierType.String) },
                { "charter_vocals",                       new("charter_vocals", ModifierType.String) },
                { "count",                                new("count", ModifierType.UInt32) },
                { "cover",                                new("cover", ModifierType.String) },
                { "credit_album_art_by",                  new("credit_album_art_designed_by", ModifierType.String) },
                { "credit_album_art_designed_by",         new("credit_album_art_designed_by", ModifierType.String) },
                { "credit_album_cover",                   new("credit_album_art_designed_by", ModifierType.String) },
                { "credit_arranged_by",                   new("credit_arranged_by", ModifierType.String) },
                { "credit_composed_by",                   new("credit_composed_by", ModifierType.String) },
                { "credit_courtesy_of",                   new("credit_courtesy_of", ModifierType.String) },
                { "credit_engineered_by",                 new("credit_engineered_by", ModifierType.String) },
                { "credit_license",                       new("credit_license", ModifierType.String) },
                { "credit_mastered_by",                   new("credit_mastered_by", ModifierType.String) },
                { "credit_mixed_by",                      new("credit_mixed_by", ModifierType.String) },
                { "credit_other",                         new("credit_other", ModifierType.String) },
                { "credit_performed_by",                  new("credit_performed_by", ModifierType.String) },
                { "credit_produced_by",                   new("credit_produced_by", ModifierType.String) },
                { "credit_published_by",                  new("credit_published_by", ModifierType.String) },
                { "credit_written_by",                    new("credit_written_by", ModifierType.String) },

                { "dance_type",                           new("dance_type", ModifierType.UInt32) },
                { "delay",                                new("delay", ModifierType.Int64) },
                { "diff_band",                            new("diff_band", ModifierType.Int32) },
                { "diff_bass",                            new("diff_bass", ModifierType.Int32) },
                { "diff_bass_real",                       new("diff_bass_real", ModifierType.Int32) },
                { "diff_bass_real_22",                    new("diff_bass_real_22", ModifierType.Int32) },
                { "diff_bassghl",                         new("diff_bassghl", ModifierType.Int32) },
                { "diff_dance",                           new("diff_dance", ModifierType.Int32) },
                { "diff_drums",                           new("diff_drums", ModifierType.Int32) },
                { "diff_drums_real",                      new("diff_drums_real", ModifierType.Int32) },
                { "diff_drums_real_ps",                   new("diff_drums_real_ps", ModifierType.Int32) },
                { "diff_guitar",                          new("diff_guitar", ModifierType.Int32) },
                { "diff_guitar_coop",                     new("diff_guitar_coop", ModifierType.Int32) },
                { "diff_guitar_coop_ghl",                 new("diff_guitar_coop_ghl", ModifierType.Int32) },
                { "diff_guitar_real",                     new("diff_guitar_real", ModifierType.Int32) },
                { "diff_guitar_real_22",                  new("diff_guitar_real_22", ModifierType.Int32) },
                { "diff_guitarghl",                       new("diff_guitarghl", ModifierType.Int32) },
                { "diff_keys",                            new("diff_keys", ModifierType.Int32) },
                { "diff_keys_real",                       new("diff_keys_real", ModifierType.Int32) },
                { "diff_keys_real_ps",                    new("diff_keys_real_ps", ModifierType.Int32) },
                { "diff_rhythm",                          new("diff_rhythm", ModifierType.Int32) },
                { "diff_rhythm_ghl",                      new("diff_rhythm_ghl", ModifierType.Int32) },
                { "diff_vocals",                          new("diff_vocals", ModifierType.Int32) },
                { "diff_vocals_harm",                     new("diff_vocals_harm", ModifierType.Int32) },
                { "drum_fallback_blue",                   new("drum_fallback_blue", ModifierType.Bool) },

                //{ "early_hit_window_size",                new("early_hit_window_size", ModifierType.String) },
                { "eighthnote_hopo",                      new("eighthnote_hopo", ModifierType.Bool) },
                { "end_events",                           new("end_events", ModifierType.Bool) },
                //{ "eof_midi_import_drum_accent_velocity", new("eof_midi_import_drum_accent_velocity", ModifierType.UInt16) },
                //{ "eof_midi_import_drum_ghost_velocity",  new("eof_midi_import_drum_ghost_velocity", ModifierType.UInt16) },

                { "five_lane_drums",                      new("five_lane_drums", ModifierType.Bool) },
                { "frets",                                new("frets", ModifierType.String) },

                { "genre",                                new("genre", ModifierType.String) },
                { "guitar_type",                          new("guitar_type", ModifierType.UInt32) },

                { "hopo_frequency",                       new("hopo_frequency", ModifierType.Int64) },
                { "hopofreq",                             new("hopofreq", ModifierType.Int32) },

                { "icon",                                 new("icon", ModifierType.String) },

                { "keys_type",                            new("keys_type", ModifierType.UInt32) },
                { "kit_type",                             new("kit_type", ModifierType.UInt32) },

                //{ "link_name_a",                          new("link_name_a", ModifierType.String) },
                //{ "link_name_b",                          new("link_name_b", ModifierType.String) },
                { "link_bandcamp",                        new("link_bandcamp", ModifierType.String) },
                { "link_bluesky",                         new("link_bluesky", ModifierType.String) },
                { "link_facebook",                        new("link_facebook", ModifierType.String) },
                { "link_instagram",                       new("link_instagram", ModifierType.String) },
                { "link_spotify",                         new("link_spotify", ModifierType.String) },
                { "link_twitter",                         new("link_twitter", ModifierType.String) },
                { "link_other",                           new("link_other", ModifierType.String) },
                { "link_youtube",                         new("link_youtube", ModifierType.String) },
                { "loading_phrase",                       new("loading_phrase", ModifierType.String) },
                { "location",                             new("location", ModifierType.String) },
                { "lyrics",                               new("lyrics", ModifierType.Bool) },

                { "modchart",                             new("modchart", ModifierType.Bool) },
                { "multiplier_note",                      new("multiplier_note", ModifierType.Int32) },

                { "name",                                 new("name", ModifierType.String) },

                { "playlist",                             new("playlist", ModifierType.String) },
                { "playlist_track",                       new("playlist_track", ModifierType.Int32) },
                { "preview",                              new("preview", ModifierType.Int64Array) },
                { "preview_end_time",                     new("preview_end_time", ModifierType.Int64) },
                { "preview_start_time",                   new("preview_start_time", ModifierType.Int64) },

                { "pro_drum",                             new("pro_drums", ModifierType.Bool) },
                { "pro_drums",                            new("pro_drums", ModifierType.Bool) },

                { "rating",                               new("rating", ModifierType.UInt32) },
                { "real_bass_22_tuning",                  new("real_bass_22_tuning", ModifierType.UInt32) },
                { "real_bass_tuning",                     new("real_bass_tuning", ModifierType.UInt32) },
                { "real_guitar_22_tuning",                new("real_guitar_22_tuning", ModifierType.UInt32) },
                { "real_guitar_tuning",                   new("real_guitar_tuning", ModifierType.UInt32) },
                { "real_keys_lane_count_left",            new("real_keys_lane_count_left", ModifierType.UInt32) },
                { "real_keys_lane_count_right",           new("real_keys_lane_count_right", ModifierType.UInt32) },

                //{ "scores",                               new("scores", ModifierType.String) },
                //{ "scores_ext",                           new("scores_ext", ModifierType.String) },
                { "song_length",                          new("song_length", ModifierType.Int64) },
                { "star_power_note",                      new("multiplier_note", ModifierType.Int32) },
                { "sub_genre",                            new("sub_genre", ModifierType.String) },
                { "sub_playlist",                         new("sub_playlist", ModifierType.String) },
                { "sustain_cutoff_threshold",             new("sustain_cutoff_threshold", ModifierType.Int64) },
                //{ "sysex_high_hat_ctrl",                  new("sysex_high_hat_ctrl", ModifierType.Bool) },
                //{ "sysex_open_bass",                      new("sysex_open_bass", ModifierType.Bool) },
                //{ "sysex_pro_slide",                      new("sysex_pro_slide", ModifierType.Bool) },
                //{ "sysex_rimshot",                        new("sysex_rimshot", ModifierType.Bool) },
                //{ "sysex_slider",                         new("sysex_slider", ModifierType.Bool) },

                { "tags",                                 new("tags", ModifierType.String) },
                { "track",                                new("album_track", ModifierType.Int32) },
                { "tutorial",                             new("tutorial", ModifierType.Bool) },

                { "unlock_completed",                     new("unlock_completed", ModifierType.UInt32) },
                { "unlock_id",                            new("unlock_id", ModifierType.String) },
                { "unlock_require",                       new("unlock_require", ModifierType.String) },
                { "unlock_text",                          new("unlock_text", ModifierType.String) },

                { "version",                              new("version", ModifierType.UInt32) },
                { "video",                                new("video", ModifierType.String) },
                { "video_end_time",                       new("video_end_time", ModifierType.Int64) },
                { "video_loop",                           new("video_loop", ModifierType.Bool) },
                { "video_start_time",                     new("video_start_time", ModifierType.Int64) },
                { "vocal_gender",                         new("vocal_gender", ModifierType.UInt32) },

                { "year",                                 new("year", ModifierType.String) },
            };

            SONG_INI_LOOKUP_MAP = new()
            {
                { "[song]", SONG_INI_OUTLINES }
            };
        }
    }
}
</file>

<file path="IO/Ini/YARGIniReader.cs">
using System;
using System.Collections.Generic;
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.Logging;

namespace YARG.Core.IO.Ini
{
    public static class YARGIniReader
    {
        public static Dictionary<string, IniModifierCollection> ReadIniFile(string iniPath, Dictionary<string, Dictionary<string, IniModifierOutline>> lookups)
        {
            try
            {
                using var bytes = FixedArray.LoadFile(iniPath);
                if (YARGTextReader.TryUTF8(in bytes, out var byteContainer))
                {
                    return ProcessIni(ref byteContainer, lookups);
                }

                using var chars = YARGTextReader.TryUTF16Cast(in bytes);
                if (chars.IsAllocated)
                {
                    var charContainer = YARGTextReader.CreateUTF16Container(in chars);
                    return ProcessIni(ref charContainer, lookups);
                }

                using var ints = YARGTextReader.CastUTF32(in bytes);
                var intContainer = YARGTextReader.CreateUTF32Container(in ints);
                return ProcessIni(ref intContainer, lookups);

            }
            catch (Exception ex)
            {
                YargLogger.LogException(ex, ex.Message);
                return new();
            }
        }

        private static Dictionary<string, IniModifierCollection> ProcessIni<TChar>(ref YARGTextContainer<TChar> container, Dictionary<string, Dictionary<string, IniModifierOutline>> lookups)
            where TChar : unmanaged, IConvertible, IEquatable<TChar>
        {
            Dictionary<string, IniModifierCollection> collections = new();
            while (TrySection(ref container, out string section))
            {
                if (lookups.TryGetValue(section, out var nodes))
                {
                    collections[section] = ExtractModifiers(ref container, ref nodes);
                }
                else
                {
                    YARGTextReader.SkipLinesUntil(ref container, TextConstants<TChar>.OPEN_BRACKET);
                }
            }
            return collections;
        }

        private static bool TrySection<TChar>(ref YARGTextContainer<TChar> container, out string section)
            where TChar : unmanaged, IConvertible, IEquatable<TChar>
        {
            if (container.IsAtEnd() || (container.Get() != '[' && !YARGTextReader.SkipLinesUntil(ref container, TextConstants<TChar>.OPEN_BRACKET)))
            {
                section = string.Empty;
                return false;
            }
            section = YARGTextReader.PeekLine(ref container).ToLower();
            return true;
        }

        private static IniModifierCollection ExtractModifiers<TChar>(ref YARGTextContainer<TChar> container, ref Dictionary<string, IniModifierOutline> outlines)
            where TChar : unmanaged, IConvertible, IEquatable<TChar>
        {
            IniModifierCollection collection = new();
            while (IsStillCurrentSection(ref container))
            {
                string name = YARGTextReader.ExtractModifierName(ref container).ToLower();
                if (outlines.TryGetValue(name, out var outline))
                {
                    collection.Add(ref container, in outline, false);
                }
            }
            return collection;
        }

        private static bool IsStillCurrentSection<TChar>(ref YARGTextContainer<TChar> container)
            where TChar : unmanaged, IConvertible, IEquatable<TChar>
        {
            YARGTextReader.GotoNextLine(ref container);
            return !container.IsAtEnd() && container.Get() != '[';
        }
    }
}
</file>

<file path="IO/Midi/YARGMidiFile.cs">
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;

namespace YARG.Core.IO
{
    public ref struct YARGMidiFile
    {
        private const           int    TAG_SIZE             = sizeof(uint);
        private const           int    SIZEOF_HEADER        = 6;
        private const           int    DATA_OFFSET          = TAG_SIZE + sizeof(int);
        private const           int    FIRST_TRACK_POSITION = DATA_OFFSET + SIZEOF_HEADER;
        private static readonly FourCC HEADER_TAG           = new('M', 'T', 'h', 'd');
        private static readonly FourCC TRACK_TAG            = new('M', 'T', 'r', 'k');

        private FixedArray<byte> _data;
        private ushort _format;
        private ushort _numTracks;
        private ushort _resolution;

        private long _position;
        private ushort _trackNumber;

        public readonly ushort Format => _format;
        public readonly ushort NumTracks => _numTracks;
        public readonly ushort Resolution => _resolution;

        public static YARGMidiFile Load(in FixedArray<byte> data)
        {
            if (TAG_SIZE > data.Length
            || !HEADER_TAG.Matches(data.ReadonlySlice(0, TAG_SIZE)))
            {
                throw new Exception("Midi header Tag 'MThd' mismatch");
            }

            if (FIRST_TRACK_POSITION > data.Length)
            {
                throw new EndOfStreamException("Data ends within midi header");
            }

            // Track lengths are in big endian
            int headerSize =
                (data[TAG_SIZE] << 24) |
                (data[TAG_SIZE + 1] << 16) |
                (data[TAG_SIZE + 2] << 8) |
                 data[TAG_SIZE + 3];
            if (headerSize != SIZEOF_HEADER)
            {
                throw new Exception("Midi header of an unsupported length");
            }

            // These values reside at pre-defined offsets, so we can just use those offsets directly
            return new YARGMidiFile
            {
                _format = (ushort) ((data[DATA_OFFSET] << 8) | data[DATA_OFFSET + 1]),
                _numTracks = (ushort) ((data[DATA_OFFSET + 2] << 8) | data[DATA_OFFSET + 3]),
                _resolution = (ushort) ((data[DATA_OFFSET + 4] << 8) | data[DATA_OFFSET + 5]),
                _data = data,
                _position = FIRST_TRACK_POSITION,
                _trackNumber = 0,
            };
        }

        public bool GetNextTrack(out ushort trackNumber, out YARGMidiTrack track)
        {
            if (_trackNumber == _numTracks || _position == _data.Length)
            {
                trackNumber = _trackNumber;
                track = default;
                return false;
            }

            ++_trackNumber;
            if (_position + TAG_SIZE > _data.Length
                || !TRACK_TAG.Matches(_data.ReadonlySlice(_position, TAG_SIZE)))
            {
                throw new Exception("Midi Track Tag 'MTrk' mismatch");
            }
            _position += TAG_SIZE;

            if (_position + sizeof(int) > _data.Length)
            {
                throw new EndOfStreamException("End of stream found within midi track");
            }

            // Track lengths are in big endian
            int length =
                (_data[_position] << 24) |
                (_data[_position + 1] << 16) |
                (_data[_position + 2] << 8) |
                 _data[_position + 3];
            _position += sizeof(int);
            unsafe
            {
                track = new YARGMidiTrack(_data.Ptr + _position, length);
            }
            _position += length;
            trackNumber = _trackNumber;
            return true;
        }

        public void Reset()
        {
            _trackNumber = 0;
            _position = FIRST_TRACK_POSITION;
        }
    }
}
</file>

<file path="IO/Midi/YARGMidiTrack.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;

namespace YARG.Core.IO
{
    public struct YARGMidiTrack
    {
        public static readonly Dictionary<string, MidiTrackType> TRACKNAMES = new()
        {
            {"EVENTS",               MidiTrackType.Events},
            {"PART GUITAR",          MidiTrackType.Guitar_5},
            {"T1 GEMS",              MidiTrackType.Guitar_5},
            {"PART GUITAR GHL",      MidiTrackType.Guitar_6},
            {"PART BASS",            MidiTrackType.Bass_5},
            {"PART BASS GHL",        MidiTrackType.Bass_6},
            {"PART RHYTHM",          MidiTrackType.Rhythm_5},
            {"PART RHYTHM GHL",      MidiTrackType.Rhythm_6},
            {"PART GUITAR COOP",     MidiTrackType.Coop_5},
            {"PART GUITAR COOP GHL", MidiTrackType.Coop_6},
            {"PART KEYS",            MidiTrackType.Keys},
            {"PART DRUMS",           MidiTrackType.Drums},
            {"PART ELITE_DRUMS",     MidiTrackType.EliteDrums},
            {"PART VOCALS",          MidiTrackType.Vocals},
            {"PART HARM1",           MidiTrackType.Harm1},
            {"PART HARM2",           MidiTrackType.Harm2},
            {"PART HARM3",           MidiTrackType.Harm3},
            {"HARM1",                MidiTrackType.Harm1},
            {"HARM2",                MidiTrackType.Harm2},
            {"HARM3",                MidiTrackType.Harm3},
            {"PART REAL_GUITAR",     MidiTrackType.Pro_Guitar_17},
            {"PART REAL_GUITAR_22",  MidiTrackType.Pro_Guitar_22},
            {"PART REAL_BASS",       MidiTrackType.Pro_Bass_17},
            {"PART REAL_BASS_22",    MidiTrackType.Pro_Bass_22},
            {"PART REAL_KEYS_X",     MidiTrackType.Pro_Keys_X},
            {"PART REAL_KEYS_H",     MidiTrackType.Pro_Keys_H},
            {"PART REAL_KEYS_M",     MidiTrackType.Pro_Keys_M},
            {"PART REAL_KEYS_E",     MidiTrackType.Pro_Keys_E},
            {"BEAT",                 MidiTrackType.Beat},
        };

        private struct RunningEvent
        {
            public static readonly RunningEvent Default = new()
            {
                Type = MidiEventType.Reset_Or_Meta,
                Length = 0
            };

            public MidiEventType Type;
            public long Length;
        }

        private readonly unsafe byte* _data;
        private readonly long _length;
        private long _trackPosition;
        private long _eventPosition;
        
        private long _tickPosition;
        private long _eventLength;
        private RunningEvent _running;

        public readonly unsafe TextSpan ExtractTextOrSysEx()
        {
            return new TextSpan()
            {
                ptr = _data + _eventPosition,
                length = _eventLength,
            };
        }

        public readonly void ExtractMidiNote(ref MidiNote note)
        {
            unsafe
            {
                note = *(MidiNote*) (_data + _eventPosition);
            }
        }

        public unsafe YARGMidiTrack(byte* data, long length)
        {
            _data = data;
            _length = length;
            _trackPosition = 0;
            _eventPosition = 0;
            _tickPosition = 0;
            _eventLength = 0;
            _running = RunningEvent.Default;
        }

        public bool FindTrackName(out TextSpan trackname)
        {
            trackname = TextSpan.Empty;
            var stats = default(Stats);
            while (ParseEvent(ref stats) && _tickPosition == 0)
            {
                if (stats.Type == MidiEventType.Text_TrackName)
                {
                    var ev = ExtractTextOrSysEx();
                    if (!trackname.IsEmpty && !trackname.SequenceEqual(in ev))
                    {
                        return false;
                    }
                    trackname = ev;
                }
            }

            _trackPosition = 0;
            _tickPosition = 0;
            _running.Type = MidiEventType.Reset_Or_Meta;
            return true;
        }

        private const int CHANNEL_MASK = 0x0F;
        private const int EVENTTYPE_MASK = 0xF0;

        public struct Stats
        {
            public long Position;
            public MidiEventType Type;
            public int Channel;
        }

        public bool ParseEvent(ref Stats stats)
        {
            _tickPosition += ReadVLQ();
            if (_trackPosition == _length)
            {
                throw new EndOfStreamException("End of midi track reached after VLQ");
            }
            stats.Position = _tickPosition;

            byte tmp;
            unsafe
            {
                tmp = _data[_trackPosition];
            }

            stats.Type = (MidiEventType) tmp;
            if (stats.Type < MidiEventType.Note_Off)
            {
                if (_running.Type == MidiEventType.Reset_Or_Meta)
                {
                    throw new Exception("Invalid running event");
                }
                stats.Type = _running.Type;
                _eventLength = _running.Length;
            }
            else
            {
                ++_trackPosition;
                if (stats.Type < MidiEventType.SysEx)
                {
                    stats.Channel = (byte) (tmp & CHANNEL_MASK);
                    stats.Type   = _running.Type    = (MidiEventType) (tmp & EVENTTYPE_MASK);
                    _eventLength = _running.Length  = _running.Type switch
                    {
                        MidiEventType.Note_On or
                        MidiEventType.Note_Off or
                        MidiEventType.Control_Change or
                        MidiEventType.Key_Pressure or
                        MidiEventType.Pitch_Wheel => 2,
                        _ => 1
                    };
                }
                else
                {
                    switch (stats.Type)
                    {
                        case MidiEventType.Reset_Or_Meta:
                            if (_trackPosition == _length)
                            {
                                throw new EndOfStreamException("End of track reached during meta event parse");
                            }

                            unsafe
                            {
                                stats.Type = (MidiEventType) _data[_trackPosition++];
                            }
                            goto case MidiEventType.SysEx_End;
                        case MidiEventType.SysEx:
                        case MidiEventType.SysEx_End:
                            _eventLength = (int) ReadVLQ();
                            break;
                        case MidiEventType.Song_Position:
                            _eventLength = 2;
                            break;
                        case MidiEventType.Song_Select:
                            _eventLength = 1;
                            break;
                        default:
                            _eventLength = 0;
                            break;
                    }
                }
            }

            _eventPosition = _trackPosition;
            _trackPosition += _eventLength;
            if (_trackPosition > _length)
            {
                throw new EndOfStreamException("Midi event stretches past end of track");
            }
            return stats.Type != MidiEventType.End_Of_Track;
        }

        private const uint EXTENDED_VLQ_FLAG = 0x80;
        private const uint VLQ_MASK = 0x7F;
        private const int  VLQ_SHIFT = 7;
        private const int  MAX_SHIFTCOUNT = 3;
        /// <summary>
        /// Represents the minimum value where a VLQ shift would be illegal
        /// </summary>
        private const uint VLQ_SHIFTLIMIT = VLQ_MASK << (VLQ_SHIFT * MAX_SHIFTCOUNT);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private uint ReadVLQ()
        {
            uint value = 0;
            while (true)
            {
                if (_trackPosition >= _length)
                {
                    throw new EndOfStreamException();
                }

                uint curr;
                unsafe
                {
                    curr = _data[_trackPosition++];
                }

                value |= curr & VLQ_MASK;
                if (curr < EXTENDED_VLQ_FLAG)
                {
                    break;
                }

                if ((value & VLQ_SHIFTLIMIT) > 0)
                {
                    throw new Exception("Invalid variable length quantity");
                }
                value <<= VLQ_SHIFT;
            }
            return value;
        }
    }

    public enum MidiTrackType
    {
        Events,
        Guitar_5,
        Guitar_6,
        Bass_5,
        Bass_6,
        Rhythm_5,
        Rhythm_6,
        Coop_5,
        Coop_6,
        Keys,
        Drums,
        EliteDrums,
        Vocals,
        Harm1,
        Harm2,
        Harm3,
        Pro_Guitar_17,
        Pro_Guitar_22,
        Pro_Bass_17,
        Pro_Bass_22,
        Pro_Keys_E,
        Pro_Keys_M,
        Pro_Keys_H,
        Pro_Keys_X,
        Beat,
        Unknown
    }

    public enum MidiEventType : byte
    {
        Sequence_Number = 0x00,
        Text = 0x01,
        Text_Copyright = 0x02,
        Text_TrackName = 0x03,
        Text_InstrumentName = 0x04,
        Text_Lyric = 0x05,
        Text_Marker = 0x06,
        Text_CuePoint = 0x07,
        Text_EnumLimit = 0x0F,
        MIDI_Channel_Prefix = 0x20,
        End_Of_Track = 0x2F,
        Tempo = 0x51,
        SMPTE_Offset = 0x54,
        Time_Sig = 0x58,
        Key_Sig = 0x59,
        Sequencer_Specific_Meta_Event = 0x7F,

        Note_Off = 0x80,
        Note_On = 0x90,
        Key_Pressure = 0xA0,
        Control_Change = 0xB0,
        Program_Change = 0xC0,
        Channel_Pressure = 0xD0,
        Pitch_Wheel = 0xE0,

        SysEx = 0xF0,
        Undefined = 0xF1,
        Song_Position = 0xF2,
        Song_Select = 0xF3,
        Undefined_2 = 0xF4,
        Undefined_3 = 0xF5,
        Tune_Request = 0xF6,
        SysEx_End = 0xF7,
        Timing_Clock = 0xF8,
        Undefined_4 = 0xF9,
        Start_Sequence = 0xFA,
        Continue_Sequence = 0xFB,
        Stop_Sequence = 0xFC,
        Undefined_5 = 0xFD,
        Active_Sensing = 0xFE,
        Reset_Or_Meta = 0xFF,
    };

    public struct MidiNote
    {
        public byte value;
        public byte velocity;
    };
}
</file>

<file path="IO/SngHandler/SngFile.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using YARG.Core.Extensions;
using YARG.Core.IO.Ini;

namespace YARG.Core.IO
{
    public struct SngFileListing
    {
        public long Position;
        public long Length;
    }

    public class SngTracker : IDisposable
    {
        private int _count = 1;

        public Stream Stream = null!;
        public SngMask Mask;

        public SngTracker AddOwner()
        {
            lock (this)
            {
                if (_count == 0)
                {
                    throw new ObjectDisposedException("");
                }
                ++_count;
            }
            return this;
        }

        public void Dispose()
        {
            lock (this)
            {
                if (_count == 0)
                {
                    throw new ObjectDisposedException("");
                }

                if (--_count == 0)
                {
                    Stream?.Dispose();
                }
            }
        }
    }

    /// <summary>
    /// <see href="https://github.com/mdsitton/SngFileFormat">Documentation of SNG file type</see>
    /// </summary>
    public struct SngFile : IDisposable
    {
        private SngTracker _tracker;

        private uint _version;
        private IniModifierCollection _modifiers;
        private Dictionary<string, SngFileListing> _listings;

        public readonly uint Version => _version;
        public readonly IniModifierCollection Modifiers => _modifiers;
        public readonly Dictionary<string, SngFileListing> Listings => _listings;

        public readonly bool IsLoaded => _tracker != null;

        public readonly bool TryGetListing(string name, out SngFileListing listing)
        {
            return _listings.TryGetValue(name, out listing);
        }

        public readonly FixedArray<byte> LoadAllBytes(in SngFileListing listing)
        {
            FixedArray<byte> data;
            lock (_tracker.Stream)
            {
                _tracker.Stream.Position = listing.Position;
                data = FixedArray.Read(_tracker.Stream, listing.Length, true);
            }

            unsafe
            {
                SngFileStream.DecryptVectorized(data.Ptr, _tracker.Mask, data.Ptr + listing.Length);
            }
            return data;
        }

        public readonly SngFileStream CreateStream(string name, in SngFileListing listing)
        {
            return new SngFileStream(name, in listing, _tracker);
        }

        public readonly void Dispose()
        {
            _tracker.Dispose();
        }

        private static readonly byte[] SNGPKG = { (byte) 'S', (byte) 'N', (byte) 'G', (byte) 'P', (byte) 'K', (byte) 'G' };
        public static SngFile TryLoadFromFile(string filename, bool loadMetadata)
        {
            using var tracker = new SngTracker();
            var filestream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
            if (YARGSongFileStream.TryLoad(filestream, out var yargStream))
            {
                yargStream.Position = SNGPKG.Length;
                tracker.Stream = yargStream;
            }
            else
            {
                filestream.Position = 0;
                Span<byte> tag = stackalloc byte[SNGPKG.Length];
                if (filestream.Read(tag) < tag.Length || !tag.SequenceEqual(SNGPKG))
                {
                    return default;
                }
                tracker.Stream = filestream;
            }

            SngFile sng = new()
            {
                _version = tracker.Stream.Read<uint>(Endianness.Little)
            };

            tracker.Mask = SngMask.LoadMask(tracker.Stream);
            if (loadMetadata)
            {
                sng._modifiers = new IniModifierCollection();
                LoadMetadata(sng._modifiers, tracker.Stream);
            }
            else
            {
                long length = tracker.Stream.Read<long>(Endianness.Little);
                tracker.Stream.Position += length;
            }

            sng._listings = new Dictionary<string, SngFileListing>();
            LoadListings(sng._listings, tracker.Stream);
            // Allow the SngFile instance to own the tracker after the `using` call
            sng._tracker = tracker.AddOwner();
            return sng;
        }

        public static bool ValidateMatch(string filename, uint versionToMatch)
        {
            using var filestream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
            Stream basestream;
            if (YARGSongFileStream.TryLoad(filestream, out var yargStream))
            {
                yargStream.Position = SNGPKG.Length;
                basestream = yargStream;
            }
            else
            {
                filestream.Position = 0;
                Span<byte> tag = stackalloc byte[SNGPKG.Length];
                if (filestream.Read(tag) < tag.Length || !tag.SequenceEqual(SNGPKG))
                {
                    return false;
                }
                basestream = filestream;
            }

            using (basestream)
            {
                return basestream.Read<uint>(Endianness.Little) == versionToMatch;
            }
        }

        private static void LoadMetadata(IniModifierCollection modifiers, Stream stream)
        {
            long length = stream.Read<long>(Endianness.Little) - sizeof(ulong);
            ulong numPairs = stream.Read<ulong>(Endianness.Little);

            using var bytes = FixedArray.Read(stream, length);
            YARGTextContainer<byte> container;
            unsafe
            {
                container = new YARGTextContainer<byte>(in bytes, null!);
            }

            for (ulong i = 0; i < numPairs; ++i)
            {
                int strLength = GetLength(ref container);
                string key;
                unsafe
                {
                    key = Encoding.UTF8.GetString(container.PositionPointer, strLength);
                }
                container.Position += strLength;

                strLength = GetLength(ref container);
                long next = container.Position + strLength;
                if (SongIniHandler.SONG_INI_OUTLINES.TryGetValue(key, out var outline))
                {
                    modifiers.AddSng(ref container, strLength, outline);
                }
                container.Position = next;
            }
        }

        private static void LoadListings(Dictionary<string, SngFileListing> listings, Stream stream)
        {
            long length = stream.Read<long>(Endianness.Little) - sizeof(ulong);
            ulong numListings = stream.Read<ulong>(Endianness.Little);

            using var bytes = FixedArray.Read(stream, length);
            listings.EnsureCapacity((int)numListings);

            ulong listingIndex = 0;
            long buffPosition = 0;
            while (listingIndex < numListings)
            {
                if (buffPosition == bytes.Length)
                {
                    throw new EndOfStreamException();
                }

                int strlen = bytes[buffPosition++];
                if (buffPosition + strlen + 2 * sizeof(long) > bytes.Length)
                {
                    throw new EndOfStreamException();
                }

                string filename;
                SngFileListing listing;
                unsafe
                {
                    filename = Encoding.UTF8.GetString(bytes.Ptr + buffPosition, strlen);
                    buffPosition += strlen;
                    listing.Length = *(long*)&bytes.Ptr[buffPosition];
                    buffPosition += sizeof(long);
                    listing.Position = *(long*) &bytes.Ptr[buffPosition];
                    buffPosition += sizeof(long);
                }
                listings.Add(filename.ToLower(), listing);
                ++listingIndex;
            }
        }

        private static int GetLength(ref YARGTextContainer<byte> container)
        {
            if (container.Position + sizeof(int) > container.Length)
            {
                throw new EndOfStreamException();
            }

            int length;
            unsafe
            {
                length = *(int*) container.PositionPointer;
            }

            container.Position += sizeof(int);
            if (container.Position + length > container.Length)
            {
                throw new EndOfStreamException();
            }
            return length;
        }
    }
}
</file>

<file path="IO/SngHandler/SngFileStream.cs">
using System;
using System.IO;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

namespace YARG.Core.IO
{
    public class SngFileStream : Stream
    {
        //                1MB
        private const int BUFFER_SIZE = 1024 * 1024;
        private const int SEEK_MODULUS = BUFFER_SIZE - 1;
        private const int SEEK_MODULUS_MINUS = ~SEEK_MODULUS;

        private readonly SngTracker _tracker;
        private readonly string _filename;
        private readonly SngFileListing _listing;
        private FixedArray<byte> _dataBuffer = FixedArray<byte>.AllocVectorAligned(BUFFER_SIZE);

        private long _bufferIndex = 0;
        private long _bufferPosition = 0;
        private long _position = 0;
        private bool _disposed = false;

        public override bool CanRead => _tracker.Stream.CanRead;
        public override bool CanWrite => false;
        public override bool CanSeek => _tracker.Stream.CanSeek;
        public override long Length => _listing.Length;

        public override long Position
        {
            get => _position;
            set
            {
                if (value < 0 || value > _listing.Length)
                {
                    throw new ArgumentOutOfRangeException();
                }

                _position = value;
                long index = _position / BUFFER_SIZE;
                if (_bufferIndex != index)
                {
                    _bufferIndex = -1;
                }
                else
                {
                    _bufferPosition = _position % BUFFER_SIZE;
                }
            }
        }

        public string Name => _filename;

        public SngFileStream(string name, in SngFileListing listing, SngTracker tracker)
        {
            _filename = name;
            _listing = listing;
            _tracker = tracker.AddOwner();
            _bufferIndex = -1;
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            if (offset < 0 || count < 0)
            {
                throw new ArgumentOutOfRangeException();
            }

            if (buffer == null)
            {
                throw new ArgumentNullException();
            }

            if (buffer.Length < offset + count)
            {
                throw new ArgumentException();
            }

            if (_position == _listing.Length)
            {
                return 0;
            }

            long read = 0;
            while (read < count && _position < _listing.Length)
            {
                if (_bufferIndex == -1 ||_bufferPosition == BUFFER_SIZE)
                {
                    UpdateBuffer();
                }

                long available = BUFFER_SIZE - _bufferPosition;
                long remainingInFile = _listing.Length - _position;
                if (available > remainingInFile)
                {
                    available = remainingInFile;
                }

                long amount = count - read;
                if (amount > available)
                {
                    amount = available;
                }

                Unsafe.CopyBlock(ref buffer[offset + read], ref _dataBuffer[_bufferPosition], (uint) amount);
                read += amount;
                _position += amount;
                _bufferPosition += amount;
            }
            return (int)read;
        }


        public override long Seek(long offset, SeekOrigin origin)
        {
            switch (origin)
            {
                case SeekOrigin.Begin:
                    Position = offset;
                    break;
                case SeekOrigin.Current:
                    Position += offset;
                    break;
                case SeekOrigin.End:
                    Position = _listing.Length + offset;
                    break;
            }
            return _position;
        }

        public override void Flush()
        {
            lock (_tracker.Stream)
            {
                _tracker.Stream.Flush();
            }
        }

        public override void SetLength(long value)
        {
            throw new NotImplementedException();
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotImplementedException();
        }

        protected override void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                _dataBuffer.Dispose();
                _tracker.Dispose();
                _disposed = true;
            }
        }

        // We make a local copy to grant direct access to the Keys pointer
        // without having to make a `fixed` call
        private unsafe void UpdateBuffer()
        {
            _bufferPosition = _position % BUFFER_SIZE;
            long index = _position / BUFFER_SIZE;
            if (index == _bufferIndex)
            {
                return;
            }
            _bufferIndex = index;

            long readCount = BUFFER_SIZE;
            long readPosition = _position - _bufferPosition;
            if (readCount > _listing.Length - readPosition)
            {
                readCount = _listing.Length - readPosition;
            }

            lock (_tracker.Stream)
            {
                _tracker.Stream.Position = readPosition + _listing.Position;
                if (_tracker.Stream.Read(_dataBuffer.Slice(0, readCount)) != readCount)
                {
                    throw new IOException("Read error in SNGPKG subfile");
                }
            }
            DecryptVectorized(_dataBuffer.Ptr, _tracker.Mask, _dataBuffer.Ptr + readCount);
        }

        public static unsafe void DecryptVectorized(byte* position, SngMask mask, byte* end)
        {
            byte* key_position = mask.Ptr;
            Parallel.For(0, SngMask.NUM_VECTORS, i =>
            {
                var xor = *((Vector<byte>*) key_position + i);
                for (var loc = (Vector<byte>*) position + i; loc + 1 <= end; loc += SngMask.NUM_VECTORS)
                {
                    *loc ^= xor;
                }
            });

            long numVecs = (end - position) / sizeof(Vector<byte>);
            position += numVecs * sizeof(Vector<byte>);
            key_position += (numVecs % SngMask.NUM_VECTORS) * sizeof(Vector<byte>);

            while (position < end)
            {
                *position++ ^= *key_position++;
            }
        }
    }
}
</file>

<file path="IO/SngHandler/SngMask.cs">
using System;
using System.IO;
using System.Numerics;
using System.Runtime.InteropServices;

namespace YARG.Core.IO
{
    /// <summary>
    /// Handles the buffer of decryption keys, while also providing easy access
    /// to SIMD vector operations through pointers and fixed array behavior.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 32)]
    public unsafe struct SngMask
    {
        public const int MASK_SIZE = 256;
        public static readonly int NUM_VECTORS = MASK_SIZE / sizeof(Vector<byte>);

        public fixed byte Ptr[MASK_SIZE];
        public static SngMask LoadMask(Stream stream)
        {
            const int NUM_KEYS = 16;
            Span<byte> keys = stackalloc byte[NUM_KEYS];
            if (stream.Read(keys) < keys.Length)
            {
                throw new EndOfStreamException("Unable to read SNG mask");
            }

            var mask = default(SngMask);
            for (int i = 0; i < MASK_SIZE; ++i)
            {
                mask.Ptr[i] = (byte) (keys[i % NUM_KEYS] ^ i);
            }
            return mask;
        }
    }
}
</file>

<file path="IO/TextReader/YARGTextContainer.cs">
using System;
using System.Runtime.CompilerServices;
using System.Text;

namespace YARG.Core.IO
{
    public struct YARGTextContainer<TChar>
        where TChar : unmanaged, IConvertible
    {
        private readonly unsafe TChar* _data;
        private readonly long _length;
        private Encoding _encoding;
        private long _position;

        public long Position
        {
            readonly get { return _position; }
            set { _position = value; }
        }

        public Encoding Encoding
        {
            readonly get { return _encoding; }
            set { _encoding = value; }
        }

        public readonly long Length => _length;

        public readonly unsafe TChar* PositionPointer => _data + _position;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly unsafe TChar* GetBuffer() { return _data; }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ReadOnlySpan<TChar> GetSpanOfRemainder()
        {
            unsafe
            {
                return new ReadOnlySpan<TChar>(_data + _position, (int) (_length - _position));
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly int GetCurrentCharacter()
        {
            if (_position >= _length)
            {
                throw new InvalidOperationException();
            }

            unsafe
            {
                return _data[_position].ToInt32(null);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly int Get()
        {
            unsafe
            {
                return _data[_position].ToInt32(null);
            }
        }

        public readonly int this[long index]
        {
            get
            {
                unsafe
                {
                   return _data[_position + index].ToInt32(null);
                }
            }
        }

        public readonly int At(long index)
        {
            long pos = _position + index;
            if (pos < 0 || pos >= _length)
            {
                throw new InvalidOperationException();
            }

            unsafe
            {
                return _data[pos].ToInt32(null);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool IsAtEnd() { return _position >= _length; }

        public YARGTextContainer(in FixedArray<TChar> data, Encoding encoding)
        {
            unsafe
            {
                _data = data.Ptr;
            }
            _length = data.Length;
            _encoding = encoding;
            _position = 0;
        }
    }
}
</file>

<file path="IO/TextReader/YARGTextReader.cs">
using System;
using System.Text;
using YARG.Core.Extensions;

namespace YARG.Core.IO
{
    public static class TextConstants<TChar>
            where TChar : unmanaged
    {
        public static readonly TChar NEWLINE;
        public static readonly TChar OPEN_BRACKET;
        public static readonly TChar CLOSE_BRACE;

        static unsafe TextConstants()
        {
            int newline = '\n';
            int openBracket = '[';
            int closeBrace = '}';
            NEWLINE = *(TChar*) &newline;
            OPEN_BRACKET = *(TChar*) &openBracket;
            CLOSE_BRACE = *(TChar*) &closeBrace;
        }
    }

    public static class YARGTextReader
    {
        public static readonly Encoding Latin1 = Encoding.GetEncoding(28591);
        public static readonly Encoding UTF8Strict = new UTF8Encoding(false, true);
        public const int WHITESPACE_LIMIT = 32;

        public static bool TryUTF8(in FixedArray<byte> data, out YARGTextContainer<byte> container)
        {
            // If it doesn't throw with `At(1)`, then 0 and 1 are valid indices.
            // We can therefore skip bounds checking
            if ((data.At(1) == 0xFE && data[0] == 0xFF) || (data[0] == 0xFE && data[1] == 0xFF))
            {
                container = default;
                return false;
            }

            container = new YARGTextContainer<byte>(data, UTF8Strict);
            // Same idea as above, but with index `2` instead
            if (data.At(2) == 0xBF && data[0] == 0xEF && data[1] == 0xBB)
            {
                container.Position += 3;
            }
            SkipPureWhitespace(ref container);
            return true;
        }

        public static FixedArray<char> TryUTF16Cast(in FixedArray<byte> data)
        {
            var buffer = FixedArray<char>.Null;
            if (data.At(2) != 0)
            {
                const int UTF16BOM_OFFSET = 2;
                long length = (data.Length - UTF16BOM_OFFSET) / sizeof(char);
                if ((data[0] == 0xFF) != BitConverter.IsLittleEndian)
                {
                    // We have to swap the endian of the data so string conversion works properly
                    // but we can't just use the original buffer as we create a hash off it.
                    buffer = FixedArray<char>.Alloc(length);
                    for (int i = 0, j = UTF16BOM_OFFSET; i < buffer.Length; ++i, j += sizeof(char))
                    {
                        buffer[i] = (char) (data[j] << 8 | data[j + 1]);
                    }
                }
                else
                {
                    buffer = FixedArray<char>.Cast(in data, UTF16BOM_OFFSET, length);
                }
            }
            return buffer;
        }

        public static YARGTextContainer<char> CreateUTF16Container(in FixedArray<char> data)
        {
            var container = new YARGTextContainer<char>(in data, Encoding.Unicode);
            SkipPureWhitespace(ref container);
            return container;
        }

        public static FixedArray<int> CastUTF32(in FixedArray<byte> data)
        {
            const int UTF32BOM_OFFSET = 3;

            FixedArray<int> buffer;
            long length = (data.Length - UTF32BOM_OFFSET) / sizeof(int);
            // We already know by this point that index `0` is valid
            if ((data[0] == 0xFF) != BitConverter.IsLittleEndian)
            {
                // We have to swap the endian of the data so string conversion works properly
                // but we can't just use the original buffer as we create a hash off it.
                buffer = FixedArray<int>.Alloc(length);
                for (int i = 0, j = UTF32BOM_OFFSET; i < buffer.Length; ++i, j += sizeof(int))
                {
                    buffer[i] = data[j] << 24 |
                                data[j + 1] << 16 |
                                data[j + 2] << 16 |
                                data[j + 3];
                }
            }
            else
            {
                buffer = FixedArray<int>.Cast(in data, UTF32BOM_OFFSET, length);
            }
            return buffer;
        }

        public static YARGTextContainer<int> CreateUTF32Container(in FixedArray<int> data)
        {
            var container = new YARGTextContainer<int>(in data, Encoding.UTF32);
            SkipPureWhitespace(ref container);
            return container;
        }

        public static void SkipPureWhitespace<TChar>(ref YARGTextContainer<TChar> container)
            where TChar : unmanaged, IConvertible
        {
            // Unity/Mono has a bug on the commented-out code here, where the JIT generates a useless
            // `cmp dword ptr [rax], 0` before actually performing ToInt32(null).
            // This causes an access violation (which translates to a NullReferenceException here) on
            // memory-mapped files whose size on disk is 2 or less bytes greater than the actual file contents,
            // due to the `cmp` above over-reading data from `rax` (which contains Position in that moment).
            //
            // Explicitly dereferencing the pointer into a value first avoids this issue. The useless `cmp`
            // is still generated, but now `rax` points to the stack, and so the over-read is always done in
            // a valid memory space.
            //
            // 9/28 Edit: However, now that fixedArray removed memorymappedfile functionality, the overread is a non-issue
            // in terms of causing any actual access violation errors
            while (!container.IsAtEnd() && container.Get() <= WHITESPACE_LIMIT)
            {
                ++container.Position;
            }
        }

        /// <summary>
        /// Skips all whitespace starting at the current position of the provided container,
        /// until the end of the current line.
        /// </summary>
        /// <remarks>"\n" is not included as whitespace in this version</remarks>
        /// <typeparam name="TChar">Type of data contained</typeparam>
        /// <param name="container">Buffer of data</param>
        /// <returns>The current character that halted skipping, or 0 if at EoF</returns>
        public static int SkipWhitespace<TChar>(ref YARGTextContainer<TChar> container)
            where TChar : unmanaged, IConvertible
        {
            while (!container.IsAtEnd())
            {
                int ch = container.Get();
                if (ch > WHITESPACE_LIMIT || ch == '\n')
                {
                    return ch;
                }
                ++container.Position;
            }
            return 0;
        }

        public static void SkipWhitespaceAndEquals<TChar>(ref YARGTextContainer<TChar> container)
            where TChar : unmanaged, IConvertible
        {
            while (!container.IsAtEnd())
            {
                int ch = container.Get();
                if (ch <= WHITESPACE_LIMIT)
                {
                    if (ch == '\n')
                    {
                        break;
                    }
                }
                else if (ch != '=')
                {
                    break;
                }
                ++container.Position;
            }
        }

        public static void GotoNextLine<TChar>(ref YARGTextContainer<TChar> container)
            where TChar : unmanaged, IConvertible, IEquatable<TChar>
        {
            int index = container.GetSpanOfRemainder().IndexOf(TextConstants<TChar>.NEWLINE);
            if (index >= 0)
            {
                container.Position += index;
                SkipPureWhitespace(ref container);
            }
            else
            {
                container.Position = container.Length;
            }
        }

        public static bool SkipLinesUntil<TChar>(ref YARGTextContainer<TChar> container, TChar stopCharacter)
            where TChar : unmanaged, IConvertible, IEquatable<TChar>
        {
            GotoNextLine(ref container);
            while (true)
            {
                int i = container.GetSpanOfRemainder().IndexOf(stopCharacter);
                if (i == -1)
                {
                    container.Position = container.Length;
                    return false;
                }

                container.Position += i;

                int limit = -i;
                for (int test = -1; test >= limit; --test)
                {
                    int val = container[test];
                    if (val == '\n')
                    {
                        return true;
                    }

                    if (val > WHITESPACE_LIMIT)
                    {
                        break;
                    }
                }
                ++container.Position;
            }
        }

        public static unsafe string ExtractModifierName<TChar>(ref YARGTextContainer<TChar> container)
            where TChar : unmanaged, IConvertible
        {
            int length = 0;
            while (container.Position + length < container.Length)
            {
                int val = container[length];
                if (val <= WHITESPACE_LIMIT || val == '=')
                {
                    break;
                }
                ++length;
            }

            string name = Decode(container.PositionPointer, length, ref container);
            container.Position += length;
            SkipWhitespaceAndEquals(ref container);
            return name;
        }

        public static unsafe string PeekLine<TChar>(ref YARGTextContainer<TChar> container)
            where TChar : unmanaged, IConvertible, IEquatable<TChar>
        {
            var span = container.GetSpanOfRemainder();
            long length = span.IndexOf(TextConstants<TChar>.NEWLINE);
            if (length == -1)
            {
                length = span.Length;
            }

            while (length > 0 && span[(int)(length - 1)].ToInt32(null) <= WHITESPACE_LIMIT)
            {
                --length;
            }
            return Decode(container.PositionPointer, length, ref container).TrimEnd();
        }

        public static unsafe string ExtractText<TChar>(ref YARGTextContainer<TChar> container, bool isChartFile)
            where TChar : unmanaged, IConvertible
        {
            long stringBegin = container.Position;
            long stringEnd = -1;
            if (isChartFile && !container.IsAtEnd() && container.Get() == '\"')
            {
                while (true)
                {
                    ++container.Position;
                    if (container.IsAtEnd())
                    {
                        break;
                    }

                    int ch = container.Get();
                    if (ch == '\n')
                    {
                        break;
                    }

                    if (stringEnd == -1)
                    {
                        if (ch == '\"' && container.PositionPointer[-1].ToInt32(null) != '\\')
                        {
                            ++stringBegin;
                            stringEnd = container.Position;
                        }
                        else if (ch == '\r')
                        {
                            stringEnd = container.Position;
                        }
                    }
                }
            }
            else
            {
                while (!container.IsAtEnd())
                {
                    int ch = container.Get();
                    if (ch == '\n')
                    {
                        break;
                    }

                    if (ch == '\r' && stringEnd == -1)
                    {
                        stringEnd = container.Position;
                    }
                    ++container.Position;
                }
            }

            if (stringEnd == -1)
            {
                stringEnd = container.Position;
            }

            while (stringEnd > stringBegin && container.GetBuffer()[stringEnd - 1].ToInt32(null) <= WHITESPACE_LIMIT)
            {
                --stringEnd;
            }

            return Decode(container.GetBuffer() + stringBegin, stringEnd - stringBegin, ref container);
        }

        public static bool ExtractBoolean<TChar>(in YARGTextContainer<TChar> text)
            where TChar : unmanaged, IConvertible
        {
            return !text.IsAtEnd() && text.Get() switch
            {
                '1' => true,
                _ => text.Position + 4 <= text.Length &&
                    (text[0] | CharacterExtensions.ASCII_LOWERCASE_FLAG) is 't' &&
                    (text[1] | CharacterExtensions.ASCII_LOWERCASE_FLAG) is 'r' &&
                    (text[2] | CharacterExtensions.ASCII_LOWERCASE_FLAG) is 'u' &&
                    (text[3] | CharacterExtensions.ASCII_LOWERCASE_FLAG) is 'e',
            };
        }

        public static bool TryExtract<TChar, TNumber>(ref YARGTextContainer<TChar> text, out TNumber value)
            where TChar : unmanaged, IConvertible
            where TNumber : unmanaged, IComparable, IComparable<TNumber>, IConvertible, IEquatable<TNumber>, IFormattable
        {
            value = default;
            if (text.IsAtEnd())
            {
                return false;
            }

            int ch = text.Get();
            long sign = 1;

            switch (ch)
            {
                case '-':
                    if (!NumericalLimits<TNumber>.IS_SIGNED)
                    {
                        return false;
                    }
                    sign = -1;
                    goto case '+';
                case '+':
                    ++text.Position;
                    if (text.IsAtEnd())
                    {
                        return false;
                    }
                    ch = text.Get();
                    break;
            }

            if (ch < '0' || '9' < ch)
            {
                return false;
            }

            ulong tmp = 0;
            while (true)
            {
                tmp += (ulong) ch - '0';

                ++text.Position;
                if (text.IsAtEnd())
                {
                    break;
                }

                ch = text.Get();
                if (ch < '0' || '9' < ch)
                {
                    break;
                }

                if (!NumericalLimits<TNumber>.IS_SIGNED)
                {
                    const char LAST_DIGIT_UNSIGNED = '5';
                    if (tmp < NumericalLimits<TNumber>.UNSIGNED_SOFT_MAX || tmp == NumericalLimits<TNumber>.UNSIGNED_SOFT_MAX && ch <= LAST_DIGIT_UNSIGNED)
                    {
                        tmp *= 10;
                        continue;
                    }

                    while (!text.IsAtEnd())
                    {
                        ch = text.Get();
                        if (ch < '0' || '9' < ch)
                        {
                            break;
                        }
                        ++text.Position;
                    }
                    value = NumericalLimits<TNumber>.UNSIGNED_MAX;
                    return true;
                }
                else
                {
                    const char LAST_DIGIT_SIGNED = '7';
                    if (tmp < NumericalLimits<TNumber>.SIGNED_SOFT_MAX || tmp == NumericalLimits<TNumber>.SIGNED_SOFT_MAX && ch <= LAST_DIGIT_SIGNED)
                    {
                        tmp *= 10;
                        continue;
                    }

                    while (!text.IsAtEnd())
                    {
                        ch = text.Get();
                        if (ch < '0' || '9' < ch)
                        {
                            break;
                        }
                        ++text.Position;
                    }
                    value = sign == -1 ? NumericalLimits<TNumber>.SIGNED_MIN : NumericalLimits<TNumber>.SIGNED_MAX;
                    return true;
                }
            }

            unsafe
            {
                if (NumericalLimits<TNumber>.IS_SIGNED)
                {
                    long signed = (long) tmp * sign;
                    value = *(TNumber*) &signed;
                }
                else
                {
                    value = *(TNumber*) &tmp;
                }
            }
            return true;
        }

        public static bool TryExtract<TChar>(ref YARGTextContainer<TChar> text, out float value)
            where TChar : unmanaged, IConvertible
        {
            bool result = TryExtract(ref text, out double tmp);
            value = (float) tmp;
            return result;
        }

        public static bool TryExtract<TChar>(ref YARGTextContainer<TChar> text, out double value)
            where TChar : unmanaged, IConvertible
        {
            value = 0;
            if (text.IsAtEnd())
            {
                return false;
            }

            int ch = text.Get();
            double sign = ch == '-' ? -1 : 1;

            if (ch == '-' || ch == '+')
            {
                ++text.Position;
                if (text.IsAtEnd())
                {
                    return false;
                }
                ch = text.Get();
            }

            if (ch < '0' || '9' < ch && ch != '.')
            {
                return false;
            }

            while ('0' <= ch && ch <= '9')
            {
                value *= 10;
                value += ch - '0';
                ++text.Position;
                if (text.IsAtEnd())
                {
                    break;
                }
                ch = text.Get();
            }

            if (ch == '.')
            {
                ++text.Position;
                if (!text.IsAtEnd())
                {
                    double divisor = 1;
                    ch = text.Get();
                    while ('0' <= ch && ch <= '9')
                    {
                        divisor *= 10;
                        value += (ch - '0') / divisor;

                        ++text.Position;
                        if (text.IsAtEnd())
                        {
                            break;
                        }
                        ch = text.Get();
                    }
                }
            }

            value *= sign;
            return true;
        }

        public static bool TryExtractWithWhitespace<TChar, TNumber>(ref YARGTextContainer<TChar> text, out TNumber value)
            where TChar : unmanaged, IConvertible
            where TNumber : unmanaged, IComparable, IComparable<TNumber>, IConvertible, IEquatable<TNumber>, IFormattable
        {
            if (!TryExtract(ref text, out value))
            {
                return false;
            }
            SkipWhitespace(ref text);
            return true;
        }

        public static bool TryExtractWithWhitespace<TChar>(ref YARGTextContainer<TChar> text, out float value)
            where TChar : unmanaged, IConvertible
        {
            if (!TryExtract(ref text, out value))
            {
                return false;
            }
            SkipWhitespace(ref text);
            return true;
        }

        public static bool TryExtractWithWhitespace<TChar>(ref YARGTextContainer<TChar> text, out double value)
            where TChar : unmanaged, IConvertible
        {
            if (!TryExtract(ref text, out value))
            {
                return false;
            }
            SkipWhitespace(ref text);
            return true;
        }

        private static unsafe string Decode<TChar>(TChar* data, long count, ref YARGTextContainer<TChar> text)
            where TChar : unmanaged, IConvertible
        {
            while (true)
            {
                try
                {
                    return text.Encoding.GetString((byte*) data, (int) (count * sizeof(TChar)));
                }
                catch
                {
                    if (text.Encoding != UTF8Strict)
                    {
                        throw;
                    }
                    text.Encoding = Latin1;
                }
            }
        }

        private static class NumericalLimits<TNumber>
            where TNumber : unmanaged, IComparable, IComparable<TNumber>, IConvertible, IEquatable<TNumber>, IFormattable
        {
            public static readonly TNumber SIGNED_MAX;
            public static readonly ulong SIGNED_SOFT_MAX;
            public static readonly TNumber SIGNED_MIN;
            public static readonly TNumber UNSIGNED_MAX;
            public static readonly ulong UNSIGNED_SOFT_MAX;

            public static readonly bool IS_SIGNED;

            static unsafe NumericalLimits()
            {
                ulong ZERO = 0;
                ulong MAX = ulong.MaxValue >> ((8 - sizeof(TNumber)) * 8);
                UNSIGNED_MAX = *(TNumber*) &MAX;
                if (IS_SIGNED = UNSIGNED_MAX.CompareTo(*(TNumber*)&ZERO) < 0)
                {
                    ulong sMAX = (ulong)long.MaxValue >> ((8 - sizeof(TNumber)) * 8);
                    SIGNED_MAX = *(TNumber*) &sMAX;
                    sMAX /= 10;
                    SIGNED_SOFT_MAX = sMAX;

                    long sMin = long.MinValue >> ((8 - sizeof(TNumber)) * 8);
                    SIGNED_MIN = *(TNumber*) &sMin;
                }
                else
                {
                    MAX /= 10;
                    UNSIGNED_SOFT_MAX = MAX;
                }
            }
        }
    }
}
</file>

<file path="IO/AbridgedFileInfo.cs">
using System;
using System.IO;
using YARG.Core.Extensions;

namespace YARG.Core.IO
{
    /// <summary>
    /// A FileInfo structure that only contains the filename and time last added
    /// </summary>
    public readonly struct AbridgedFileInfo
    {
        /// <summary>
        /// The file path
        /// </summary>
        public readonly string FullName;

        /// <summary>
        /// The time the file was last written or created on OS - whichever came later
        /// </summary>
        public readonly DateTime LastWriteTime;

        public AbridgedFileInfo(string file)
            : this(new FileInfo(file)) {}

        public AbridgedFileInfo(FileInfo info)
        {
            FullName = info.FullName;
            LastWriteTime = NormalizedLastWrite(info);
        }

        /// <summary>
        /// Only used when validation of the underlying file is not required
        /// </summary>
        public AbridgedFileInfo(ref FixedArrayStream stream)
        {
            FullName = stream.ReadString();
            LastWriteTime = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
        }

        /// <summary>
        /// Only used when validation of the underlying file is not required
        /// </summary>
        public AbridgedFileInfo(string filename, ref FixedArrayStream stream)
        {
            FullName = filename;
            LastWriteTime = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
        }

        public AbridgedFileInfo(string filename, in DateTime lastUpdatedTime)
        {
            FullName = filename;
            LastWriteTime = lastUpdatedTime;
        }

        public void Serialize(MemoryStream stream)
        {
            stream.Write(FullName);
            stream.Write(LastWriteTime.ToBinary(), Endianness.Little);
        }

        public bool Exists()
        {
            return File.Exists(FullName);
        }

        public bool IsStillValid()
        {
            return Validate(FullName, in LastWriteTime);
        }

        public static DateTime NormalizedLastWrite(FileInfo info)
        {
            return info.LastWriteTime > info.CreationTime ? info.LastWriteTime : info.CreationTime;
        }

        /// <summary>
        /// Used for cache validation
        /// </summary>
        public static bool TryParseInfo(ref FixedArrayStream stream, out AbridgedFileInfo abridged)
        {
            return TryParseInfo(stream.ReadString(), ref stream, out abridged);
        }

        /// <summary>
        /// Used for cache validation
        /// </summary>
        public static bool TryParseInfo(string file, ref FixedArrayStream stream, out AbridgedFileInfo abridged)
        {
            var info = new FileInfo(file);
            if (!info.Exists)
            {
                stream.Position += sizeof(long);
                abridged = default;
                return false;
            }

            abridged = new AbridgedFileInfo(info);
            return abridged.LastWriteTime == DateTime.FromBinary(stream.Read<long>(Endianness.Little));
        }

        public static bool Validate(string file, in DateTime lastWrite)
        {
            var info = new FileInfo(file);
            return info.Exists && NormalizedLastWrite(info) == lastWrite;
        }
    }
}
</file>

<file path="IO/CharacterCodes.cs">
using System;
using System.Buffers.Binary;
using System.IO;
using System.Runtime.CompilerServices;
using YARG.Core.Extensions;

namespace YARG.Core.IO
{
    /// <summary>
    /// A four-byte identifier ("four-character code") used to identify data formats.
    /// </summary>
    /// <remarks>
    /// These are read and written in big-endian, so that the characters used are
    /// human-readable in a hex editor, for example.
    /// </remarks>
    public readonly struct FourCC
    {
        private readonly uint _code;

        public FourCC(char a, char b, char c, char d)
        {
            _code = ((uint)(byte) d << 24) | ((uint)(byte) c << 16) | ((uint)(byte) b << 8) | a;
        }

        public FourCC(ReadOnlySpan<byte> data)
        {
            _code = BinaryPrimitives.ReadUInt32LittleEndian(data);
        }

        public FourCC(Stream stream)
        {
            _code = stream.Read<uint>(Endianness.Little);
        }

        public void Serialize(BinaryWriter writer)
        {
            writer.BaseStream.Write(_code, Endianness.Little);
        }

        public bool Matches(Stream stream)
        {
            return stream.Read<uint>(Endianness.Little) == _code;
        }

        public bool Matches(ref FixedArrayStream stream)
        {
            return stream.Read<uint>(Endianness.Little) == _code;
        }

        public bool Matches(ReadOnlySpan<byte> data)
        {
            return BinaryPrimitives.ReadUInt32LittleEndian(data) == _code;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(FourCC left, FourCC right) => left._code == right._code;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(FourCC left, FourCC right) => left._code != right._code;

        public bool Equals(FourCC other) => this == other;
        public override bool Equals(object obj) => obj is FourCC cc && Equals(cc);
        public override int GetHashCode() => _code.GetHashCode();

        public override string ToString()
        {
            char d = (char) ((_code >> 24) & 0xFF);
            char c = (char) ((_code >> 16) & 0xFF);
            char b = (char) ((_code >> 8) & 0xFF);
            char a = (char) (_code & 0xFF);
            return $"{a}{b}{c}{d}";
        }
    }

    /// <summary>
    /// An eight-byte identifier ("eight-character code") used to identify data formats.
    /// </summary>
    /// <remarks>
    /// These are read and written in big-endian, so that the characters used are
    /// human-readable in a hex editor, for example.
    /// </remarks>
    public readonly struct EightCC
    {
        private readonly ulong _code;

        public EightCC(char a, char b, char c, char d, char e, char f, char g, char h)
        {
            _code = ((ulong) (byte) h << 56) | ((ulong) (byte) g << 48) | ((ulong) (byte) f << 40) | ((ulong) (byte) e << 32) |
                    ((ulong) (byte) d << 24) | ((ulong) (byte) c << 16) | ((ulong) (byte) b << 8)  | a;
        }

        public EightCC(ReadOnlySpan<byte> data)
        {
            _code = BinaryPrimitives.ReadUInt64LittleEndian(data);
        }

        public EightCC(Stream stream)
        {
            _code = stream.Read<ulong>(Endianness.Little);
        }

        public void Serialize(BinaryWriter writer)
        {
            writer.BaseStream.Write(_code, Endianness.Little);
        }

        public bool Matches(Stream stream)
        {
            return stream.Read<ulong>(Endianness.Little) == _code;
        }

        public bool Matches(ref FixedArrayStream stream)
        {
            return stream.Read<ulong>(Endianness.Little) == _code;
        }

        public bool Matches(ReadOnlySpan<byte> data)
        {
            return BinaryPrimitives.ReadUInt64LittleEndian(data) == _code;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(EightCC left, EightCC right) => left._code == right._code;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(EightCC left, EightCC right) => left._code != right._code;

        public bool Equals(EightCC other) => this == other;
        public override bool Equals(object obj) => obj is EightCC cc && Equals(cc);
        public override int GetHashCode() => _code.GetHashCode();

        public override string ToString()
        {
            char h = (char) ((_code >> 56) & 0xFF);
            char g = (char) ((_code >> 48) & 0xFF);
            char f = (char) ((_code >> 40) & 0xFF);
            char e = (char) ((_code >> 32) & 0xFF);
            char d = (char) ((_code >> 24) & 0xFF);
            char c = (char) ((_code >> 16) & 0xFF);
            char b = (char) ((_code >> 8) & 0xFF);
            char a = (char) (_code & 0xFF);
            return $"{a}{b}{c}{d}{e}{f}{g}{h}";
        }
    }
}
</file>

<file path="IO/TextSpan.cs">
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;

namespace YARG.Core.IO
{
    public unsafe struct TextSpan
    {
        public static readonly TextSpan Empty = new()
        {
            ptr = null,
            length = 0
        };

        public byte* ptr;
        public long length;

        public readonly bool IsEmpty => ptr == null || length == 0;

        public readonly ReadOnlySpan<byte> Span => new Span<byte>(ptr, (int)length);

        public readonly byte this[int index]
        {
            get
            {
                if (index < 0 || index >= length)
                {
                    throw new ArgumentOutOfRangeException("index");
                }
                return ptr[index];
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool SequenceEqual(in TextSpan str)
        {
            return Span.SequenceEqual(str.Span);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool SequenceEqual(in ReadOnlySpan<byte> str)
        {
            return Span.SequenceEqual(str);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly string GetString(Encoding encoding)
        {
            return ptr != null ? encoding.GetString(ptr, (int)length) : string.Empty;
        }

        public readonly bool StartsWith(in ReadOnlySpan<byte> str)
        {
            return Span.StartsWith(str);
        }
    }
}
</file>

<file path="IO/YARGChartFileReader.cs">
using System;
using System.Collections.Generic;
using YARG.Core.Extensions;
using YARG.Core.IO.Ini;

namespace YARG.Core.IO
{
    public enum ChartEventType
    {
        Bpm,
        Time_Sig,
        Anchor,
        Text,
        Note,
        Special,
        Unknown = 255,
    }

    public enum NoteTracks_Chart
    {
        Single,
        DoubleGuitar,
        DoubleBass,
        DoubleRhythm,
        Drums,
        Keys,
        GHLGuitar,
        GHLBass,
        GHLRhythm,
        GHLCoop,
        Invalid,
    };

    public struct DotChartEvent
    {
        public long Position;
        public ChartEventType Type;
    }

    public static class YARGChartFileReader
    {
        public const string HEADERTRACK = "[Song]";
        public const string SYNCTRACK = "[SyncTrack]";
        public const string EVENTTRACK = "[Events]";

        internal static readonly (string name, Difficulty difficulty)[] DIFFICULTIES =
        {
            ("[Easy", Difficulty.Easy),
            ("[Medium", Difficulty.Medium),
            ("[Hard", Difficulty.Hard),
            ("[Expert", Difficulty.Expert),
        };

        internal static readonly (string, Instrument)[] NOTETRACKS =
        {
            new("Single]",       Instrument.FiveFretGuitar),
            new("DoubleGuitar]", Instrument.FiveFretCoopGuitar),
            new("DoubleBass]",   Instrument.FiveFretBass),
            new("DoubleRhythm]", Instrument.FiveFretRhythm),
            new("Drums]",        Instrument.FourLaneDrums),
            new("Keyboard]",     Instrument.Keys),
            new("GHLGuitar]",    Instrument.SixFretGuitar),
            new("GHLBass]",      Instrument.SixFretBass),
            new("GHLRhythm]",    Instrument.SixFretRhythm),
            new("GHLCoop]",      Instrument.SixFretCoopGuitar),
        };

        internal static readonly (string Descriptor, ChartEventType Type)[] EVENTS =
        {
            new("B",  ChartEventType.Bpm),
            new("TS", ChartEventType.Time_Sig),
            new("A",  ChartEventType.Anchor),
            new("E",  ChartEventType.Text),
            new("N",  ChartEventType.Note),
            new("S",  ChartEventType.Special),
        };

        public static bool IsStartOfTrack<TChar>(in YARGTextContainer<TChar> container)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            return !container.IsAtEnd() && container.Get() == '[';
        }

        public static bool IsStillCurrentTrack<TChar>(ref YARGTextContainer<TChar> container)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            YARGTextReader.GotoNextLine(ref container);
            if (container.IsAtEnd())
            {
                return false;
            }

            if (container.Get() == '}')
            {
                YARGTextReader.GotoNextLine(ref container);
                return false;
            }
            return true;
        }

        public static void SkipToNextTrack<TChar>(ref YARGTextContainer<TChar> container)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            if (YARGTextReader.SkipLinesUntil(ref container, TextConstants<TChar>.CLOSE_BRACE))
            {
                YARGTextReader.GotoNextLine(ref container);
            }
        }

        public static bool ValidateTrack<TChar>(ref YARGTextContainer<TChar> container, string track)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            if (!DoesStringMatch(ref container, track))
            {
                return false;
            }
            YARGTextReader.GotoNextLine(ref container);
            return true;
        }

        public static bool ValidateInstrument<TChar>(ref YARGTextContainer<TChar> container, out Instrument instrument, out Difficulty difficulty)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            if (ValidateDifficulty(ref container, out difficulty))
            {
                foreach (var (name, inst) in NOTETRACKS)
                {
                    if (ValidateTrack(ref container, name))
                    {
                        instrument = inst;
                        return true;
                    }
                }
            }
            instrument = default;
            return false;
        }

        public static bool TryParseEvent<TChar>(ref YARGTextContainer<TChar> container, ref DotChartEvent ev)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            if (!IsStillCurrentTrack(ref container))
            {
                return false;
            }

            if (!YARGTextReader.TryExtract(ref container, out long position))
            {
                throw new Exception("Could not parse event position");
            }

            if (position < ev.Position)
            {
                throw new Exception($".chart position out of order (previous: {ev.Position})");
            }

            ev.Position = position;
            YARGTextReader.SkipWhitespaceAndEquals(ref container);

            int length = 0;
            while (container.Position + length < container.Length)
            {
                int c = container[length];
                if (c < 'A' || 'Z' < c)
                {
                    break;
                }
                ++length;
            }

            ev.Type = ChartEventType.Unknown;
            foreach (var (descriptor, type) in EVENTS)
            {
                if (length == descriptor.Length)
                {
                    int index = 0;
                    while (index < length && container[index] == descriptor[index])
                    {
                        ++index;
                    }

                    if (index == descriptor.Length)
                    {
                        ev.Type = type;
                        break;
                    }
                }
            }

            container.Position += length;
            if (ev.Type != ChartEventType.Unknown)
            {
                YARGTextReader.SkipWhitespace(ref container);
            }
            return true;
        }

        public static TNumber Extract<TChar, TNumber>(ref YARGTextContainer<TChar> text)
            where TChar : unmanaged, IConvertible
            where TNumber : unmanaged, IComparable, IComparable<TNumber>, IConvertible, IEquatable<TNumber>, IFormattable
        {
            if (!YARGTextReader.TryExtract(ref text, out TNumber value))
            {
                throw new Exception("Could not extract " + typeof(TNumber).Name);
            }
            return value;
        }

        public static TNumber ExtractWithWhitespace<TChar, TNumber>(ref YARGTextContainer<TChar> text)
            where TChar : unmanaged, IConvertible
            where TNumber : unmanaged, IComparable, IComparable<TNumber>, IConvertible, IEquatable<TNumber>, IFormattable
        {
            if (!YARGTextReader.TryExtractWithWhitespace(ref text, out TNumber value))
            {
                throw new Exception("Could not extract " + typeof(TNumber).Name);
            }
            return value;
        }

        public static readonly Dictionary<string, IniModifierOutline> CHART_MODIFIERS = new()
        {
            { "Album",        new("album", ModifierType.String) },
            { "Artist",       new("artist", ModifierType.String) },
            { "Charter",      new("charter", ModifierType.String) },
            { "Difficulty",   new("diff_band", ModifierType.Int32) },
            { "Genre",        new("genre", ModifierType.String) },
            { "Name",         new("name", ModifierType.String) },
            { "Offset",       new("delay_seconds", ModifierType.Double) },
            { "PreviewEnd",   new("preview_end_seconds", ModifierType.Double) },
            { "PreviewStart", new("preview_start_seconds", ModifierType.Double) },
            { "Resolution",   new("Resolution", ModifierType.Int64) },
            { "Year",         new("year_chart", ModifierType.String) },
        };

        public static IniModifierCollection ExtractModifiers<TChar>(ref YARGTextContainer<TChar> container)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            IniModifierCollection collection = new();
            while (IsStillCurrentTrack(ref container))
            {
                string name = YARGTextReader.ExtractModifierName(ref container);
                if (CHART_MODIFIERS.TryGetValue(name, out var outline))
                {
                    collection.Add(ref container, outline, true);
                }
            }
            return collection;
        }

        private static bool ValidateDifficulty<TChar>(ref YARGTextContainer<TChar> container, out Difficulty difficulty)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            for (int diffIndex = 3; diffIndex >= 0; --diffIndex)
            {
                var (name, diff) = DIFFICULTIES[diffIndex];
                if (DoesStringMatch(ref container, name))
                {
                    difficulty = diff;
                    container.Position += name.Length;
                    return true;
                }
            }
            difficulty = default;
            return false;
        }

        private static bool DoesStringMatch<TChar>(ref YARGTextContainer<TChar> container, string str)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            if (container.Length - container.Position < str.Length)
            {
                return false;
            }

            int index = 0;
            while (index < str.Length && container[index] == str[index])
            {
                ++index;
            }
            return index == str.Length;
        }
    }
}
</file>

<file path="IO/YARGMoggStream.cs">
using System;
using System.IO;

namespace YARG.Core.IO
{
    public sealed class YargMoggReadStream : Stream
    {
        private const int MATRIXSIZE = 16;
        private readonly FileStream _fileStream;
        private readonly long _length;

        private readonly byte[] _baseEncryptionMatrix = new byte[MATRIXSIZE];
        private readonly byte[] _encryptionMatrix = new byte[MATRIXSIZE];
        private int _currentRow;

        public override bool CanRead => _fileStream.CanRead;
        public override bool CanSeek => _fileStream.CanSeek;
        public override long Length => _length;

        public override long Position
        {
            get => _fileStream.Position - MATRIXSIZE;
            set
            {
                long newPos = value + MATRIXSIZE;
                if (newPos < _fileStream.Position)
                {
                    // Yes this is inefficient, but it must be done
                    ResetEncryptionMatrix();
                    for (long i = 0; i < value; i++)
                    {
                        RollEncryptionMatrix();
                    }
                }
                else if (_fileStream.Position < newPos)
                {
                    // No need to reset so long as we're still going forwards
                    for (long i = _fileStream.Position; i < newPos; i++)
                    {
                        RollEncryptionMatrix();
                    }
                }
                _fileStream.Position = newPos;
            }
        }

        public override bool CanWrite => false;

        public YargMoggReadStream(string path)
        {
            _fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
            _length = _fileStream.Length - MATRIXSIZE;

            // Get the encryption matrix
            _fileStream.Read(_baseEncryptionMatrix);

            // Using `value % 255`, a value of 255 at index 0 would become zero
            if (_baseEncryptionMatrix[0] == 255)
                _baseEncryptionMatrix[0] = 0;

            for (int i = 1; i < MATRIXSIZE; i++)
            {
                int j = _baseEncryptionMatrix[i] - i * 12;
                // Ensures value rests within byte range
                if (j < 0)
                    j += 255;
                _baseEncryptionMatrix[i] = (byte)j;
            }
            ResetEncryptionMatrix();
        }

        private void ResetEncryptionMatrix()
        {
            _currentRow = 0;
            for (int i = 0; i < MATRIXSIZE; i++)
            {
                _encryptionMatrix[i] = _baseEncryptionMatrix[i];
            }
        }

        private void RollEncryptionMatrix()
        {
            int nextRow = _currentRow + 1;
            if (nextRow == 4)
                nextRow = 0;

            // Get the current and next matrix index
            int currentIndex = GetIndexInMatrix(_currentRow, _currentRow * 4);
            int nextIndex = GetIndexInMatrix(nextRow, nextRow * 4);

            // Roll the previous row
            int val = _encryptionMatrix[currentIndex] + _encryptionMatrix[nextIndex];
            if (val >= 255)
                val -= 255;
            _encryptionMatrix[currentIndex] = (byte) val;
            _currentRow = nextRow;
        }

        public override void Flush()
        {
            _fileStream.Flush();
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            int read = _fileStream.Read(buffer, offset, count);
            var span = new Span<byte>(buffer, offset, read);

            // Decrypt
            for (int i = 0; i < read; i++)
            {
                // Parker-brown encryption window matrix
                int w = GetIndexInMatrix(_currentRow, i);

                span[i] ^= _encryptionMatrix[w];
                RollEncryptionMatrix();
            }

            return read;
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            switch (origin)
            {
                case SeekOrigin.Begin:
                    Position = offset;
                    break;
                case SeekOrigin.Current:
                    Position += offset;
                    break;
                case SeekOrigin.End:
                    Position = _length + offset;
                    break;
            }

            return Position;
        }

        public override void SetLength(long value)
        {
            throw new System.NotImplementedException();
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new System.NotImplementedException();
        }

        private static int GetIndexInMatrix(int x, int phi)
        {
            // Parker-brown encryption window matrix
            int y = x * x + 1 + phi;
            int z = x * 3 - phi;
            int w = y + z - x;
            return w < MATRIXSIZE ? w : 15;
        }
    }
}
</file>

<file path="IO/YARGSongFileStream.cs">
using System;
using System.IO;

namespace YARG.Core.IO
{
    public class YARGSongFileStream : Stream
    {
        private const int HEADER_SIZE = 24;
        private const int SET_LENGTH  = 15;

        private static readonly byte[] FILE_SIGNATURE =
        {
            (byte) 'Y', (byte) 'A', (byte) 'R', (byte) 'G',
            (byte) 'S', (byte) 'O', (byte) 'N', (byte) 'G'
        };

        private readonly FileStream _stream;
        // These are very important values required to properly
        // decrypt the first layer of encryption (Crawford multi-
        // value cipher).
        private readonly int[] _values;

        public override long Position
        {
            get => _stream.Position - HEADER_SIZE;
            set => _stream.Position = value + HEADER_SIZE;
        }

        public override long Length => _stream.Length - HEADER_SIZE;

        public override bool CanRead => _stream.CanRead;

        public override bool CanSeek => _stream.CanSeek;

        public override bool CanWrite => false;

        public static bool TryLoad(FileStream filestream, out YARGSongFileStream yargStream)
        {
            yargStream = null!;
            Span<byte> signature = stackalloc byte[FILE_SIGNATURE.Length];
            if (filestream.Read(signature) != FILE_SIGNATURE.Length)
            {
                return false;
            }

            if (!signature.SequenceEqual(FILE_SIGNATURE))
            {
                return false;
            }

            // Get the Crawford special number

            // The main part
            int z = filestream.ReadByte();
            z += 1679;                  // A large-ish prime
            int w = (z ^ 4) - z * 2;    // Exponent W value
            int n = 25 * w - 5;         // Aleph value
            int x = (w + (z << 1)) ^ 4; // Use some bit shifting to our advantage

            // Approximate infinite summation (we're using bytes so it works)
            int l = (n + 73) * (n + 23);
            l -= n * n + 96 * n;
            x = -l + n + x - w * (5 * 5);

            // We are using a SET_LENGTH-long Euler cipher set (I think?) for this

            Span<byte> set = stackalloc byte[SET_LENGTH];
            if (filestream.Read(set) != SET_LENGTH)
            {
                filestream.Close();
                throw new EndOfStreamException("YARGSong incomplete");
            }

            // Get the values using X

            x = (x + 5) % 255; // Convert to byte again

            int[] values = new int[4];
            unchecked
            {
                for (int i = 0, j = 0; i < 24; i++, j += x)
                {
                    // Just use the standard numbers for this
                    values[0] += (byte) (set[j % 15] + i * 3298 + 88903);
                    values[1] -= set[(j + 7001) % 15];
                    values[2] += set[j % 15];
                    values[3] += j << 2;
                }
            }
            yargStream = new YARGSongFileStream(filestream.Name, values);
            return true;
        }

        public YARGSongFileStream(string filename, int[] values)
        {
            _values = values;
            _stream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read, 1)
            {
                Position = HEADER_SIZE
            };
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            int pos = (int) Position;
            int read = _stream.Read(buffer, offset, count);
            var span = new Span<byte>(buffer, offset, read);

            unchecked
            {
                int a = _values[0];
                int b = _values[1];
                int c = _values[2];

                for (int i = 0; i < read; i++)
                {
                    // This is a super dumbed down version of the algorithm.
                    // If problems are encountered with this, use the full
                    // cipher roller.
                    span[i] = (byte) ((span[i] - (i + pos) * c - b) ^ a);
                }
            }

            return read;
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            if (origin != SeekOrigin.Current)
                offset += HEADER_SIZE;
            return _stream.Seek(offset, origin) - HEADER_SIZE;
        }

        public override void SetLength(long value)
        {
            throw new InvalidOperationException();
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new InvalidOperationException();
        }

        public override void Flush()
        {
            _stream.Flush();
        }

        public YARGSongFileStream Clone()
        {
            return new YARGSongFileStream(_stream.Name, _values);
        }
    }
}
</file>

<file path="Logging/Formatters/BasicYargLogFormatter.cs">
using System;
using Cysharp.Text;

namespace YARG.Core.Logging
{
    /// <summary>
    /// A log formatter which includes minimal little information in the output.
    /// Suitable for console/debug outputs, where too much information just makes things cluttered.
    /// </summary>
    public class BasicYargLogFormatter : IYargLogFormatter
    {
        public void FormatLogItem(ref Utf16ValueStringBuilder output, LogItem item)
        {
            output.AppendFormat("[{0}] ", item.Level.AsLevelString());

            switch (item.Level)
            {
                case LogLevel.Exception:
                case LogLevel.Failure:
                    // Append File
                    var source = item.Source.AsSpan();
                    int lastSeparatorIndex = source.LastIndexOfAny('\\', '/');
                    var fileName = source[(lastSeparatorIndex + 1)..];

                    output.Append("[");
                    output.Append(fileName);
                    output.AppendFormat(":{0}:{1}] ", item.Method, item.Line);
                    break;
            }

            item.FormatMessage(ref output);
        }
    }
}
</file>

<file path="Logging/Formatters/DetailedYargLogFormatter.cs">
using System;
using Cysharp.Text;

namespace YARG.Core.Logging
{
    /// <summary>
    /// A log formatter which includes as much information as possible in the log output.
    /// Suitable for file logs, where available information is prioritized above all else.
    /// </summary>
    public class DetailedYargLogFormatter : IYargLogFormatter
    {
        public void FormatLogItem(ref Utf16ValueStringBuilder output, LogItem item)
        {
            AppendPrologue(ref output, item);

            item.FormatMessage(ref output);

            AppendEpilogue(ref output, item);
        }

        private void AppendPrologue(ref Utf16ValueStringBuilder output, LogItem item)
        {
            // Get the file name for this log item
            var source = item.Source.AsSpan();
            int lastSeparatorIndex = source.LastIndexOfAny('\\', '/');
            var fileName = source[(lastSeparatorIndex + 1)..];

            switch (item.Level)
            {
                case LogLevel.Exception:
                    output.Append("--------------- EXCEPTION ---------------\nat ");

                    // Append File
                    output.Append(fileName);

                    output.AppendFormat(":{0}:{1}\n", item.Method, item.Line);
                    break;

                case LogLevel.Failure:
                    output.Append("--------------- FAILURE ---------------\nat ");

                    // Append File
                    output.Append(fileName);

                    output.AppendFormat(":{0}:{1}\n", item.Method, item.Line);
                    break;

                default:
                    // "[Level] [Year-Month-Day HH:MM:SS File:Method:Line] Message"
                    output.Append("[");

                    // Append Level
                    output.AppendFormat("{0}] [", item.Level.AsLevelString());

                    // Append DateTime in format "Year-Month-Day Hour:Minute:Second"
                    output.AppendFormat("{0:0000}-{1:00}-{2:00} {3:00}:{4:00}:{5:00} ",
                        item.Time.Year,
                        item.Time.Month,
                        item.Time.Day,
                        item.Time.Hour,
                        item.Time.Minute,
                        item.Time.Second);

                    // Append File
                    output.Append(fileName);

                    // Append :Method:Line
                    output.AppendFormat(":{0}:{1}] ", item.Method, item.Line);
                    break;
            }
        }

        private void AppendEpilogue(ref Utf16ValueStringBuilder output, LogItem item)
        {
            switch (item.Level)
            {
                case LogLevel.Exception:
                case LogLevel.Failure:
                    output.AppendLine("\n-----------------------------------------");
                    break;
            }
        }
    }
}
</file>

<file path="Logging/Formatters/IYargLogFormatter.cs">
using Cysharp.Text;

namespace YARG.Core.Logging
{
    public interface IYargLogFormatter
    {
        void FormatLogItem(ref Utf16ValueStringBuilder output, LogItem item);
    }
}
</file>

<file path="Logging/Formatters/MessageOnlyYargLogFormatter.cs">
using Cysharp.Text;

namespace YARG.Core.Logging
{
    /// <summary>
    /// A log formatter which includes only the message in the output.
    /// </summary>
    public class MessageOnlyYargLogFormatter : IYargLogFormatter
    {
        public void FormatLogItem(ref Utf16ValueStringBuilder output, LogItem item)
        {
            item.FormatMessage(ref output);
        }
    }
}
</file>

<file path="Logging/FormatWrappers/HexBytesFormat.cs">
using System;
using Cysharp.Text;
using YARG.Core.Extensions;

namespace YARG.Core.Logging
{
    /// <summary>
    /// A wrapper around a byte array which formats the array as a hex string.
    /// </summary>
    public struct HexBytesFormat
    {
        private byte[] _data;
        private bool _dashes;

        static HexBytesFormat()
        {
            Utf16ValueStringBuilder.RegisterTryFormat<HexBytesFormat>(TryFormat);
        }

        public HexBytesFormat(byte[] data, bool dashes = true)
        {
            _data = data;
            _dashes = dashes;
        }

        private static bool TryFormat(HexBytesFormat value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format)
            => value.TryFormat(destination, out charsWritten);

        public readonly bool TryFormat(Span<char> destination, out int charsWritten) //, ReadOnlySpan<char> format = default, IFormatProvider provider = null)
            => _data.TryFormatHex(destination, out charsWritten, _dashes);

        public readonly override string ToString()
            => _data.ToHexString(_dashes);
    }
}
</file>

<file path="Logging/Listeners/BaseYargLogListener.cs">
using System;
using Cysharp.Text;

namespace YARG.Core.Logging
{
    public abstract class BaseYargLogListener : IDisposable
    {
        private readonly IYargLogFormatter _formatter;

        protected BaseYargLogListener(IYargLogFormatter formatter)
        {
            _formatter = formatter;
        }

        public abstract void WriteLogItem(ref Utf16ValueStringBuilder output, LogItem item);

        public void FormatLogItem(ref Utf16ValueStringBuilder builder, LogItem item)
        {
            _formatter.FormatLogItem(ref builder, item);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                // Release any managed resources here
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
    }
}
</file>

<file path="Logging/Listeners/ConsoleYargLogListener.cs">
using System;
using Cysharp.Text;

namespace YARG.Core.Logging
{
    public class ConsoleYargLogListener : BaseYargLogListener
    {
        public ConsoleYargLogListener() : this(new BasicYargLogFormatter())
        {
        }

        public ConsoleYargLogListener(IYargLogFormatter formatter) : base(formatter)
        {
        }

        public override void WriteLogItem(ref Utf16ValueStringBuilder output, LogItem item)
        {
            // Creates a new (stack allocated) array segment of the buffer
            // This can be passed to Console.WriteLine as a char[] overload (as Console doesn't have span writeline!?!?)
            // Avoids allocating a string

            var segment = output.AsArraySegment();
            Console.WriteLine(segment.Array!, segment.Offset, segment.Count);
        }
    }
}
</file>

<file path="Logging/Listeners/DebugYargLogListener.cs">
using System.Diagnostics;
using Cysharp.Text;

namespace YARG.Core.Logging
{
    public class DebugYargLogListener : BaseYargLogListener
    {
        public DebugYargLogListener() : this(new BasicYargLogFormatter())
        {
        }

        public DebugYargLogListener(IYargLogFormatter formatter) : base(formatter)
        {
        }

        public override void WriteLogItem(ref Utf16ValueStringBuilder output, LogItem item)
        {
            // Unfortunately we have no choice but to take the allocation here :(
            // Debug.WriteLine only takes `object` or `string`
            Debug.WriteLine(output.ToString());
        }
    }
}
</file>

<file path="Logging/Listeners/FileYargLogListener.cs">
using System.IO;
using Cysharp.Text;

namespace YARG.Core.Logging
{
    public class FileYargLogListener : BaseYargLogListener
    {
        private readonly string       _file;

        private readonly FileStream   _fileStream;
        private readonly StreamWriter _writer;

        public FileYargLogListener(string file) : this(file, new DetailedYargLogFormatter())
        {
        }

        public FileYargLogListener(string file, IYargLogFormatter formatter) : base(formatter)
        {
            _file = file;

            _fileStream = new FileStream(file, FileMode.Append, FileAccess.Write, FileShare.Read);
            _writer = new StreamWriter(_fileStream);
        }

        public override void WriteLogItem(ref Utf16ValueStringBuilder output, LogItem item)
        {
            lock (_writer)
            {
                _writer.WriteLine(output.AsSpan());
                _writer.Flush();
            }
        }

        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            if (disposing)
            {
                lock (_writer)
                {
                    _writer.Dispose();
                    _fileStream.Dispose();
                }
            }
        }
    }
}
</file>

<file path="Logging/LogItems/FormatLogItem.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Collections.Concurrent;
using Cysharp.Text;

#nullable enable

namespace YARG.Core.Logging
{
    public class FormatLogItem<T1> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1>> _instancePool = new();

        private string Format = "";

        private T1? arg1;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1> MakeItem(
            string format, T1? arg1)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    public static partial class FormatLogItem
    {
        public static FormatLogItem<T1> MakeItem<T1>(
            string format, T1? arg1)
        {
            return FormatLogItem<T1>.MakeItem(
                format, arg1);
        }
    }

    public class FormatLogItem<T1, T2> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2> MakeItem(
            string format, T1? arg1, T2? arg2)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    public static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2> MakeItem<T1, T2>(
            string format, T1? arg1, T2? arg2)
        {
            return FormatLogItem<T1, T2>.MakeItem(
                format, arg1, arg2);
        }
    }

    public class FormatLogItem<T1, T2, T3> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    public static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3> MakeItem<T1, T2, T3>(
            string format, T1? arg1, T2? arg2, T3? arg3)
        {
            return FormatLogItem<T1, T2, T3>.MakeItem(
                format, arg1, arg2, arg3);
        }
    }

    public class FormatLogItem<T1, T2, T3, T4> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    public static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4> MakeItem<T1, T2, T3, T4>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4)
        {
            return FormatLogItem<T1, T2, T3, T4>.MakeItem(
                format, arg1, arg2, arg3, arg4);
        }
    }

    public class FormatLogItem<T1, T2, T3, T4, T5> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4, T5>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;
        private T5? arg5;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4, T5> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            item.arg5 = arg5;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4, arg5);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    public static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4, T5> MakeItem<T1, T2, T3, T4, T5>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5)
        {
            return FormatLogItem<T1, T2, T3, T4, T5>.MakeItem(
                format, arg1, arg2, arg3, arg4, arg5);
        }
    }

    public class FormatLogItem<T1, T2, T3, T4, T5, T6> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4, T5, T6>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;
        private T5? arg5;
        private T6? arg6;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4, T5, T6> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            item.arg5 = arg5;
            item.arg6 = arg6;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4, arg5, arg6);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    public static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4, T5, T6> MakeItem<T1, T2, T3, T4, T5, T6>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6)
        {
            return FormatLogItem<T1, T2, T3, T4, T5, T6>.MakeItem(
                format, arg1, arg2, arg3, arg4, arg5, arg6);
        }
    }

    public class FormatLogItem<T1, T2, T3, T4, T5, T6, T7> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4, T5, T6, T7>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;
        private T5? arg5;
        private T6? arg6;
        private T7? arg7;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            item.arg5 = arg5;
            item.arg6 = arg6;
            item.arg7 = arg7;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    public static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7> MakeItem<T1, T2, T3, T4, T5, T6, T7>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7)
        {
            return FormatLogItem<T1, T2, T3, T4, T5, T6, T7>.MakeItem(
                format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        }
    }

    public class FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;
        private T5? arg5;
        private T6? arg6;
        private T7? arg7;
        private T8? arg8;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7, T8? arg8)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            item.arg5 = arg5;
            item.arg6 = arg6;
            item.arg7 = arg7;
            item.arg8 = arg8;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    public static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8> MakeItem<T1, T2, T3, T4, T5, T6, T7, T8>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7, T8? arg8)
        {
            return FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8>.MakeItem(
                format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        }
    }

    public class FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;
        private T5? arg5;
        private T6? arg6;
        private T7? arg7;
        private T8? arg8;
        private T9? arg9;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7, T8? arg8, T9? arg9)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            item.arg5 = arg5;
            item.arg6 = arg6;
            item.arg7 = arg7;
            item.arg8 = arg8;
            item.arg9 = arg9;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    public static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9> MakeItem<T1, T2, T3, T4, T5, T6, T7, T8, T9>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7, T8? arg8, T9? arg9)
        {
            return FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9>.MakeItem(
                format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        }
    }

    public class FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;
        private T5? arg5;
        private T6? arg6;
        private T7? arg7;
        private T8? arg8;
        private T9? arg9;
        private T10? arg10;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7, T8? arg8, T9? arg9, T10? arg10)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            item.arg5 = arg5;
            item.arg6 = arg6;
            item.arg7 = arg7;
            item.arg8 = arg8;
            item.arg9 = arg9;
            item.arg10 = arg10;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    public static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> MakeItem<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7, T8? arg8, T9? arg9, T10? arg10)
        {
            return FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.MakeItem(
                format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
        }
    }

}
</file>

<file path="Logging/LogItems/FormatLogItem.t4">
<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Linq" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Collections.Concurrent;
using Cysharp.Text;

#nullable enable

namespace YARG.Core.Logging
{
<#
const int maxGenericArguments = 10;

for (int i = 0; i < maxGenericArguments; i++)
{
    var countRange= Enumerable.Range(1, i + 1);

    var genericTypes = countRange.Select((j) => "T" + j);
    var nullableTypes = genericTypes.Select((j) => j + "?");
    var functionArgs = countRange.Select((j) => "arg" + j);
    var functionParams = nullableTypes.Zip(functionArgs, (type, arg) => type + " " + arg);

    var genericSignature = string.Join(", ", genericTypes);
    var functionSignature = string.Join(", ", functionParams);
    var functionArguments = string.Join(", ", functionArgs);
#>
    public class FormatLogItem<<#= genericSignature #>> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<<#= genericSignature #>>> _instancePool = new();

        private string Format = "";

<#
    foreach (var (type, name) in genericTypes.Zip(functionArgs, (x, y) => (x, y)))
    {
#>
        private <#= type #>? <#= name #>;
<#
    }
#>

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<<#= genericSignature #>> MakeItem(
            string format, <#= functionSignature #>)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
<#
    foreach (var arg in functionArgs)
    {
#>
            item.<#= arg #> = <#= arg #>;
<#
    }
#>
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, <#= functionArguments #>);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    public static partial class FormatLogItem
    {
        public static FormatLogItem<<#= genericSignature #>> MakeItem<<#= genericSignature #>>(
            string format, <#= functionSignature #>)
        {
            return FormatLogItem<<#= genericSignature #>>.MakeItem(
                format, <#= functionArguments #>);
        }
    }

<#
}
#>
}
</file>

<file path="Logging/LogItems/LogItem.cs">
using System;
using Cysharp.Text;

namespace YARG.Core.Logging
{
    public abstract class LogItem : IDisposable
    {
        public LogLevel Level;

        public string Source = "";
        public string Method = "";

        public int Line = -1;

        public DateTime Time;

        public abstract void FormatMessage(ref Utf16ValueStringBuilder output);
        protected abstract void ReturnToPool();

        public void Dispose()
        {
            ReturnToPool();
        }
    }
}
</file>

<file path="Logging/LogItems/MessageLogItem.cs">
using System.Collections.Concurrent;
using Cysharp.Text;

namespace YARG.Core.Logging
{
    public class MessageLogItem : LogItem
    {
        private const int STARTING_INSTANCES = 5;

        private static ConcurrentBag<MessageLogItem> _instancePool = new();

        public string Message = "";

        static MessageLogItem()
        {
            for (int i = 0; i < STARTING_INSTANCES; i++)
            {
                _instancePool.Add(new());
            }
        }

        private MessageLogItem() {}

        ~MessageLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static MessageLogItem MakeItem(string message)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Message = message;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.Append(Message);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }
}
</file>

<file path="Logging/LogLevel.cs">
namespace YARG.Core.Logging
{
    public enum LogLevel
    {
        Trace,
        Debug,
        Info,
        Warning,
        Error,
        Exception,
        Failure,
    }

    public static class LogLevelExtensions
    {
        public static string AsLevelString(this LogLevel level)
        {
            return level switch
            {
                LogLevel.Trace     => "Trace",
                LogLevel.Debug     => "Debug",
                LogLevel.Info      => "Info",
                LogLevel.Warning   => "Warning",
                LogLevel.Error     => "Error",
                LogLevel.Exception => "Exception",
                LogLevel.Failure   => "Failure",
                _                  => "UNKNOWN",
            };
        }
    }
}
</file>

<file path="Logging/YargLogger.Assertions.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace YARG.Core.Logging
{
    public static partial class YargLogger
    {
        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AssertFormat<T1>(bool condition, string format, T1 item1, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                FailFormat(format, item1, source, line, member);
        }

        [DebuggerStepThrough]
        public static void FailFormat<T1>(string format, T1 item1, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = FormatLogItem.MakeItem(format, item1);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }

        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AssertFormat<T1, T2>(bool condition, string format, T1 item1, T2 item2, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                FailFormat(format, item1, item2, source, line, member);
        }

        [DebuggerStepThrough]
        public static void FailFormat<T1, T2>(string format, T1 item1, T2 item2, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = FormatLogItem.MakeItem(format, item1, item2);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }

        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AssertFormat<T1, T2, T3>(bool condition, string format, T1 item1, T2 item2, T3 item3, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                FailFormat(format, item1, item2, item3, source, line, member);
        }

        [DebuggerStepThrough]
        public static void FailFormat<T1, T2, T3>(string format, T1 item1, T2 item2, T3 item3, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }

        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AssertFormat<T1, T2, T3, T4>(bool condition, string format, T1 item1, T2 item2, T3 item3, T4 item4, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                FailFormat(format, item1, item2, item3, item4, source, line, member);
        }

        [DebuggerStepThrough]
        public static void FailFormat<T1, T2, T3, T4>(string format, T1 item1, T2 item2, T3 item3, T4 item4, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }

        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AssertFormat<T1, T2, T3, T4, T5>(bool condition, string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                FailFormat(format, item1, item2, item3, item4, item5, source, line, member);
        }

        [DebuggerStepThrough]
        public static void FailFormat<T1, T2, T3, T4, T5>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }

        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AssertFormat<T1, T2, T3, T4, T5, T6>(bool condition, string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                FailFormat(format, item1, item2, item3, item4, item5, item6, source, line, member);
        }

        [DebuggerStepThrough]
        public static void FailFormat<T1, T2, T3, T4, T5, T6>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }

        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AssertFormat<T1, T2, T3, T4, T5, T6, T7>(bool condition, string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                FailFormat(format, item1, item2, item3, item4, item5, item6, item7, source, line, member);
        }

        [DebuggerStepThrough]
        public static void FailFormat<T1, T2, T3, T4, T5, T6, T7>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }

        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AssertFormat<T1, T2, T3, T4, T5, T6, T7, T8>(bool condition, string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                FailFormat(format, item1, item2, item3, item4, item5, item6, item7, item8, source, line, member);
        }

        [DebuggerStepThrough]
        public static void FailFormat<T1, T2, T3, T4, T5, T6, T7, T8>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }

        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AssertFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>(bool condition, string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                FailFormat(format, item1, item2, item3, item4, item5, item6, item7, item8, item9, source, line, member);
        }

        [DebuggerStepThrough]
        public static void FailFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }

        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AssertFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(bool condition, string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                FailFormat(format, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10, source, line, member);
        }

        [DebuggerStepThrough]
        public static void FailFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }

        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        // [CallerLineNumber] is swapped compared to everything else to prevent an ambiguous overload
        public static void Assert(bool condition, [CallerLineNumber] int line = -1, [CallerFilePath] string source = "", [CallerMemberName] string member = "", [CallerArgumentExpression(nameof(condition))] string expression = "")
        {
            if (!condition)
                FailFormat("Assertion failed: {0}", expression, source, line, member);
        }

        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Assert(bool condition, string message, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                Fail(message, source, line, member);
        }

        [DebuggerStepThrough]
        public static void Fail(string message, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = MessageLogItem.MakeItem(message);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }
    }
}
</file>

<file path="Logging/YargLogger.Assertions.t4">
<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Linq" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.Runtime.CompilerServices;

<#
const int maxGenericArguments = 10;

var genericArguments = new string[maxGenericArguments];
var functionSignatures = new string[maxGenericArguments];
var functionParameters = new string[maxGenericArguments];
var functionArguments = new string[maxGenericArguments];

for (int i = 1; i <= maxGenericArguments; i++)
{
    genericArguments[i - 1] = "T" + i;
    functionSignatures[i - 1] = "<" + string.Join(", ", genericArguments.Take(i)) + ">";
    functionParameters[i - 1] = string.Join(", ", genericArguments.Take(i).Select((x, j) => x + " item" + (j + 1)));
    functionArguments[i - 1] = string.Join(", ", genericArguments.Take(i).Select((x, j) => "item" + (j + 1)));
}
#>
namespace YARG.Core.Logging
{
    public static partial class YargLogger
    {
<#
for(int i = 0; i < maxGenericArguments; i++)
{
        var functionSignature = functionSignatures[i];
        var functionParameter = functionParameters[i];
        var functionArgument = functionArguments[i];
#>
        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AssertFormat<#= functionSignature #>(bool condition, string format, <#= functionParameter #>, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                FailFormat(format, <#= functionArgument #>, source, line, member);
        }

        [DebuggerStepThrough]
        public static void FailFormat<#= functionSignature #>(string format, <#= functionParameter #>, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = FormatLogItem.MakeItem(format, <#= functionArgument #>);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }

<#
}
#>
        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        // [CallerLineNumber] is swapped compared to everything else to prevent an ambiguous overload
        public static void Assert(bool condition, [CallerLineNumber] int line = -1, [CallerFilePath] string source = "", [CallerMemberName] string member = "", [CallerArgumentExpression(nameof(condition))] string expression = "")
        {
            if (!condition)
                FailFormat("Assertion failed: {0}", expression, source, line, member);
        }

        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Assert(bool condition, string message, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                Fail(message, source, line, member);
        }

        [DebuggerStepThrough]
        public static void Fail(string message, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = MessageLogItem.MakeItem(message);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }
    }
}
</file>

<file path="Logging/YargLogger.cs">
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Text;

namespace YARG.Core.Logging
{
    public static partial class YargLogger
    {
        // How often the logging thread should output logs (milliseconds)
        private const int LOG_INTERVAL = 10;

        private static readonly List<BaseYargLogListener> Listeners = new();

        // Queue for log items. Maybe we should use a concurrent queue? Depends on how many threads will log at the same time
        private static readonly Queue<LogItem> LogQueue = new();

        /// <summary>
        /// The minimum level required for a <see cref="LogItem"/> to be logged.
        /// </summary>
        public static LogLevel MinimumLogLevel = LogLevel.Info;

        private static Utf16ValueStringBuilder _logBuilder;

        private static bool _isLoggingEnabled = true;

        static YargLogger()
        {
            _logBuilder = ZString.CreateStringBuilder();

            var logOutputterThread = new Thread(LogOutputter)
            {
                Name = "YargLogger Thread",
            };
            logOutputterThread.Start();
        }

        /// <summary>
        /// Add a new listener to the logger. This listener will receive all log items.
        /// </summary>
        public static void AddLogListener(BaseYargLogListener listener)
        {
            lock (Listeners)
            {
                Listeners.Add(listener);
            }
        }

        /// <summary>
        /// Remove a listener from the logger. This listener will no longer receive log items.
        /// </summary>
        public static void RemoveLogListener(BaseYargLogListener listener)
        {
            lock (Listeners)
            {
                Listeners.Remove(listener);
            }

            listener.Dispose();
        }

        /// <summary>
        /// This method will stop the logging thread and prevent any further log items from being queued.
        /// </summary>
        /// <remarks>
        /// This should be called when the application is shutting down to prevent any log items from being lost.
        /// </remarks>
        public static void KillLogger()
        {
            _isLoggingEnabled = false;
            FlushLogQueue();

            // Dispose of all listeners
            lock (Listeners)
            {
                foreach (var listener in Listeners)
                {
                    listener.Dispose();
                }
                Listeners.Clear();
            }
        }

        private static void LogOutputter()
        {
            // Keep thread running until logging is disabled and the queue is empty
            // In the event logging is disabled, we still want to process all remaining log items
            while (_isLoggingEnabled || LogQueue.Count > 0)
            {
                FlushLogQueue();

                // Sleep for a short time. Logs will process at most every LOG_INTERVAL milliseconds
                Thread.Sleep(LOG_INTERVAL);
            }
        }

        private static void FlushLogQueue()
        {
            lock (LogQueue)
            {
                lock (Listeners)
                {
                    while (LogQueue.TryDequeue(out var item))
                    {
                        using (item)
                        {
                            WriteLogItemToListeners(item);
                        }
                    }
                }
            }
        }

        private static void WriteLogItemToListeners(LogItem item)
        {
            // Send it to all listeners that are currently registered
            foreach (var listener in Listeners)
            {
                try
                {
                    _logBuilder.Clear();
                    listener.FormatLogItem(ref _logBuilder, item);
                    listener.WriteLogItem(ref _logBuilder, item);
                }
                catch (Exception e)
                {
                    // In the event formatting the log fails, print an error message with the exception
                    try
                    {
                        using var exceptionLog = FormatLogItem.MakeItem(
                            "Failed to format the log on this line! Refer to the exception below.\n{0}", e);
                        exceptionLog.Level = LogLevel.Error;

                        // Make sure to pass down the source information so the position
                        // of the original log is known.
                        exceptionLog.Source = item.Source;
                        exceptionLog.Method = item.Method;
                        exceptionLog.Line = item.Line;
                        exceptionLog.Time = item.Time;

                        _logBuilder.Clear();
                        listener.FormatLogItem(ref _logBuilder, exceptionLog);
                        listener.WriteLogItem(ref _logBuilder, exceptionLog);
                    }
                    catch
                    {
                        // If that fails too, just skip this log
                    }
                }
            }
        }

        private static void AddLogItemToQueue(LogLevel level, string source, int line, string method, LogItem item)
        {
            // If logging is disabled, don't queue anymore log items
            // This will usually happen when the application is shutting down
            if (!_isLoggingEnabled)
            {
                return;
            }

            item.Level = level;
            item.Source = source;
            item.Method = method;
            item.Line = line;
            item.Time = DateTime.Now;

            // Lock while enqueuing. This prevents the log outputter from processing the queue while we're adding to it
            lock (LogQueue)
            {
                LogQueue.Enqueue(item);
            }
        }
    }
}
</file>

<file path="Logging/YargLogger.Logging.cs">
using System;
using System.Runtime.CompilerServices;

namespace YARG.Core.Logging
{
    public static partial class YargLogger
    {
        public static void LogException(Exception ex, string? message = "", [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            LogItem logItem = !string.IsNullOrEmpty(message)
                ? FormatLogItem.MakeItem("{0}\n{1}", message, ex)
                : FormatLogItem.MakeItem("{0}", ex);

            AddLogItemToQueue(LogLevel.Exception, source, line, member, logItem);
        }
    }
}
</file>

<file path="Logging/YargLogger.Methods.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Runtime.CompilerServices;

namespace YARG.Core.Logging
{
    public static partial class YargLogger
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<T1>(LogLevel level, string format, T1 item1, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(level < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1);
            AddLogItemToQueue(level, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<T1, T2>(LogLevel level, string format, T1 item1, T2 item2, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(level < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2);
            AddLogItemToQueue(level, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<T1, T2, T3>(LogLevel level, string format, T1 item1, T2 item2, T3 item3, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(level < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3);
            AddLogItemToQueue(level, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<T1, T2, T3, T4>(LogLevel level, string format, T1 item1, T2 item2, T3 item3, T4 item4, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(level < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4);
            AddLogItemToQueue(level, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<T1, T2, T3, T4, T5>(LogLevel level, string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(level < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5);
            AddLogItemToQueue(level, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<T1, T2, T3, T4, T5, T6>(LogLevel level, string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(level < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6);
            AddLogItemToQueue(level, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<T1, T2, T3, T4, T5, T6, T7>(LogLevel level, string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(level < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7);
            AddLogItemToQueue(level, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<T1, T2, T3, T4, T5, T6, T7, T8>(LogLevel level, string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(level < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8);
            AddLogItemToQueue(level, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>(LogLevel level, string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(level < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9);
            AddLogItemToQueue(level, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(LogLevel level, string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(level < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);
            AddLogItemToQueue(level, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogTrace(string message, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Trace < MinimumLogLevel)
            {
                return;
            }

            var logItem = MessageLogItem.MakeItem(message);
            AddLogItemToQueue(LogLevel.Trace, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatTrace<T1>(string format, T1 item1, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Trace < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1);
            AddLogItemToQueue(LogLevel.Trace, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatTrace<T1, T2>(string format, T1 item1, T2 item2, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Trace < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2);
            AddLogItemToQueue(LogLevel.Trace, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatTrace<T1, T2, T3>(string format, T1 item1, T2 item2, T3 item3, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Trace < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3);
            AddLogItemToQueue(LogLevel.Trace, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatTrace<T1, T2, T3, T4>(string format, T1 item1, T2 item2, T3 item3, T4 item4, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Trace < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4);
            AddLogItemToQueue(LogLevel.Trace, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatTrace<T1, T2, T3, T4, T5>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Trace < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5);
            AddLogItemToQueue(LogLevel.Trace, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatTrace<T1, T2, T3, T4, T5, T6>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Trace < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6);
            AddLogItemToQueue(LogLevel.Trace, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatTrace<T1, T2, T3, T4, T5, T6, T7>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Trace < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7);
            AddLogItemToQueue(LogLevel.Trace, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatTrace<T1, T2, T3, T4, T5, T6, T7, T8>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Trace < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8);
            AddLogItemToQueue(LogLevel.Trace, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatTrace<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Trace < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9);
            AddLogItemToQueue(LogLevel.Trace, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatTrace<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Trace < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);
            AddLogItemToQueue(LogLevel.Trace, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogDebug(string message, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Debug < MinimumLogLevel)
            {
                return;
            }

            var logItem = MessageLogItem.MakeItem(message);
            AddLogItemToQueue(LogLevel.Debug, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatDebug<T1>(string format, T1 item1, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Debug < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1);
            AddLogItemToQueue(LogLevel.Debug, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatDebug<T1, T2>(string format, T1 item1, T2 item2, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Debug < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2);
            AddLogItemToQueue(LogLevel.Debug, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatDebug<T1, T2, T3>(string format, T1 item1, T2 item2, T3 item3, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Debug < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3);
            AddLogItemToQueue(LogLevel.Debug, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatDebug<T1, T2, T3, T4>(string format, T1 item1, T2 item2, T3 item3, T4 item4, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Debug < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4);
            AddLogItemToQueue(LogLevel.Debug, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatDebug<T1, T2, T3, T4, T5>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Debug < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5);
            AddLogItemToQueue(LogLevel.Debug, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatDebug<T1, T2, T3, T4, T5, T6>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Debug < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6);
            AddLogItemToQueue(LogLevel.Debug, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatDebug<T1, T2, T3, T4, T5, T6, T7>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Debug < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7);
            AddLogItemToQueue(LogLevel.Debug, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatDebug<T1, T2, T3, T4, T5, T6, T7, T8>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Debug < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8);
            AddLogItemToQueue(LogLevel.Debug, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatDebug<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Debug < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9);
            AddLogItemToQueue(LogLevel.Debug, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatDebug<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Debug < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);
            AddLogItemToQueue(LogLevel.Debug, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogInfo(string message, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Info < MinimumLogLevel)
            {
                return;
            }

            var logItem = MessageLogItem.MakeItem(message);
            AddLogItemToQueue(LogLevel.Info, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatInfo<T1>(string format, T1 item1, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Info < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1);
            AddLogItemToQueue(LogLevel.Info, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatInfo<T1, T2>(string format, T1 item1, T2 item2, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Info < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2);
            AddLogItemToQueue(LogLevel.Info, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatInfo<T1, T2, T3>(string format, T1 item1, T2 item2, T3 item3, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Info < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3);
            AddLogItemToQueue(LogLevel.Info, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatInfo<T1, T2, T3, T4>(string format, T1 item1, T2 item2, T3 item3, T4 item4, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Info < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4);
            AddLogItemToQueue(LogLevel.Info, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatInfo<T1, T2, T3, T4, T5>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Info < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5);
            AddLogItemToQueue(LogLevel.Info, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatInfo<T1, T2, T3, T4, T5, T6>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Info < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6);
            AddLogItemToQueue(LogLevel.Info, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatInfo<T1, T2, T3, T4, T5, T6, T7>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Info < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7);
            AddLogItemToQueue(LogLevel.Info, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatInfo<T1, T2, T3, T4, T5, T6, T7, T8>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Info < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8);
            AddLogItemToQueue(LogLevel.Info, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatInfo<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Info < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9);
            AddLogItemToQueue(LogLevel.Info, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatInfo<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Info < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);
            AddLogItemToQueue(LogLevel.Info, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogWarning(string message, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Warning < MinimumLogLevel)
            {
                return;
            }

            var logItem = MessageLogItem.MakeItem(message);
            AddLogItemToQueue(LogLevel.Warning, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatWarning<T1>(string format, T1 item1, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Warning < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1);
            AddLogItemToQueue(LogLevel.Warning, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatWarning<T1, T2>(string format, T1 item1, T2 item2, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Warning < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2);
            AddLogItemToQueue(LogLevel.Warning, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatWarning<T1, T2, T3>(string format, T1 item1, T2 item2, T3 item3, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Warning < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3);
            AddLogItemToQueue(LogLevel.Warning, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatWarning<T1, T2, T3, T4>(string format, T1 item1, T2 item2, T3 item3, T4 item4, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Warning < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4);
            AddLogItemToQueue(LogLevel.Warning, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatWarning<T1, T2, T3, T4, T5>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Warning < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5);
            AddLogItemToQueue(LogLevel.Warning, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatWarning<T1, T2, T3, T4, T5, T6>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Warning < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6);
            AddLogItemToQueue(LogLevel.Warning, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatWarning<T1, T2, T3, T4, T5, T6, T7>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Warning < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7);
            AddLogItemToQueue(LogLevel.Warning, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatWarning<T1, T2, T3, T4, T5, T6, T7, T8>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Warning < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8);
            AddLogItemToQueue(LogLevel.Warning, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatWarning<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Warning < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9);
            AddLogItemToQueue(LogLevel.Warning, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatWarning<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Warning < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);
            AddLogItemToQueue(LogLevel.Warning, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogError(string message, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Error < MinimumLogLevel)
            {
                return;
            }

            var logItem = MessageLogItem.MakeItem(message);
            AddLogItemToQueue(LogLevel.Error, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatError<T1>(string format, T1 item1, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Error < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1);
            AddLogItemToQueue(LogLevel.Error, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatError<T1, T2>(string format, T1 item1, T2 item2, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Error < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2);
            AddLogItemToQueue(LogLevel.Error, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatError<T1, T2, T3>(string format, T1 item1, T2 item2, T3 item3, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Error < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3);
            AddLogItemToQueue(LogLevel.Error, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatError<T1, T2, T3, T4>(string format, T1 item1, T2 item2, T3 item3, T4 item4, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Error < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4);
            AddLogItemToQueue(LogLevel.Error, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatError<T1, T2, T3, T4, T5>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Error < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5);
            AddLogItemToQueue(LogLevel.Error, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatError<T1, T2, T3, T4, T5, T6>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Error < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6);
            AddLogItemToQueue(LogLevel.Error, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatError<T1, T2, T3, T4, T5, T6, T7>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Error < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7);
            AddLogItemToQueue(LogLevel.Error, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatError<T1, T2, T3, T4, T5, T6, T7, T8>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Error < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8);
            AddLogItemToQueue(LogLevel.Error, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatError<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Error < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9);
            AddLogItemToQueue(LogLevel.Error, source, line, member, logItem);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormatError<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.Error < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);
            AddLogItemToQueue(LogLevel.Error, source, line, member, logItem);
        }

    }
}
</file>

<file path="Logging/YargLogger.Methods.t4">
<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Linq" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Runtime.CompilerServices;

<#
const int maxGenericArguments = 10;

var genericArguments = new string[maxGenericArguments];
var functionSignatures = new string[maxGenericArguments];
var functionParameters = new string[maxGenericArguments];
var functionArguments = new string[maxGenericArguments];

for (int i = 1; i <= maxGenericArguments; i++)
{
    genericArguments[i - 1] = "T" + i;
    functionSignatures[i - 1] = "<" + string.Join(", ", genericArguments.Take(i)) + ">";
    functionParameters[i - 1] = string.Join(", ", genericArguments.Take(i).Select((x, j) => x + " item" + (j + 1)));
    functionArguments[i - 1] = string.Join(", ", genericArguments.Take(i).Select((x, j) => "item" + (j + 1)));
}

var logTypes = new[]
{
    "Trace",
    "Debug",
    "Info",
    "Warning",
    "Error",
    //"Exception",
    //"Failure",
};


#>
namespace YARG.Core.Logging
{
    public static partial class YargLogger
    {
<#
for(int i = 0; i < maxGenericArguments; i++)
{
        var functionSignature = functionSignatures[i];
        var functionParameter = functionParameters[i];
        var functionArgument = functionArguments[i];
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<#= functionSignature #>(LogLevel level, string format, <#= functionParameter #>, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(level < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, <#= functionArgument #>);
            AddLogItemToQueue(level, source, line, member, logItem);
        }

<#
}
foreach (var type in logTypes)
{
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Log<#= type #>(string message, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.<#= type #> < MinimumLogLevel)
            {
                return;
            }

            var logItem = MessageLogItem.MakeItem(message);
            AddLogItemToQueue(LogLevel.<#= type #>, source, line, member, logItem);
        }

<#
    for(int i = 0; i < maxGenericArguments; i++)
    {
        var functionSignature = functionSignatures[i];
        var functionParameter = functionParameters[i];
        var functionArgument = functionArguments[i];
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<#= type #><#= functionSignature #>(string format, <#= functionParameter #>, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.<#= type #> < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, <#= functionArgument #>);
            AddLogItemToQueue(LogLevel.<#= type #>, source, line, member, logItem);
        }

<#
    }
}
#>
    }
}
</file>

<file path="MoonscraperChartParser/Events/MoonNote.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System;
using System.Collections;
using System.Collections.Generic;

namespace MoonscraperChartEditor.Song
{
    [Serializable]
    internal class MoonNote : MoonObject
    {
        public enum GuitarFret
        {
            Open,
            Green,
            Red,
            Yellow,
            Blue,
            Orange,
        }

        public enum DrumPad
        {
            Kick,
            Red,
            Yellow,
            Blue,
            Orange,
            Green,
        }

        public enum GHLiveGuitarFret
        {
            Open,
            Black1,
            Black2,
            Black3,
            White1,
            White2,
            White3,
        }

        public enum ProGuitarString
        {
            Red,
            Green,
            Orange,
            Blue,
            Yellow,
            Purple
        }

        private const int PRO_GUITAR_FRET_OFFSET = 0;
        private const int PRO_GUITAR_FRET_MASK = 0x1F << PRO_GUITAR_FRET_OFFSET;
        private const int PRO_GUITAR_STRING_OFFSET = 5;
        private const int PRO_GUITAR_STRING_MASK = 0x07 << PRO_GUITAR_STRING_OFFSET;

        public enum MoonNoteType
        {
            Natural,
            Strum,
            Hopo,
            Tap,
            Cymbal,
        }

        [Flags]
        // TODO: These need to be organized a little better down the line
        public enum Flags
        {
            None = 0,

            // Guitar
            Forced = 1 << 0,
            Forced_Strum = 1 << 1,
            Forced_Hopo = 1 << 2,
            Tap = 1 << 3,

            // Pro Drums
            ProDrums_Cymbal = 1 << 4,
            ProDrums_Accent = 1 << 5,
            ProDrums_Ghost = 1 << 6,

            // Generic flag that mainly represents mechanics from Guitar Hero's Expert+ filtered drum notes such as Double Kick. This may apply to any difficulty now though.
            InstrumentPlus = 1 << 7,
            DoubleKick = InstrumentPlus,

            // Pro Guitar
            ProGuitar_Muted = 1 << 8,

            // Vocals
            Vocals_Percussion = 1 << 9,
        }

        public uint length;
        public int rawNote;

        public GuitarFret guitarFret
        {
            get => (GuitarFret)rawNote;
            set => rawNote = (int)value;
        }

        public DrumPad drumPad
        {
            get => (DrumPad)rawNote;
            set => rawNote = (int)value;
        }

        public GHLiveGuitarFret ghliveGuitarFret
        {
            get => (GHLiveGuitarFret)rawNote;
            set => rawNote = (int)value;
        }

        public int proGuitarFret
        {
            get => (rawNote & PRO_GUITAR_FRET_MASK) >> PRO_GUITAR_FRET_OFFSET;
            set => rawNote = MakeProGuitarRawNote(proGuitarString, value);
        }

        public ProGuitarString proGuitarString
        {
            get => (ProGuitarString)((rawNote & PRO_GUITAR_STRING_MASK) >> PRO_GUITAR_STRING_OFFSET);
            set => rawNote = MakeProGuitarRawNote(value, proGuitarFret);
        }

        public int proKeysKey
        {
            get => rawNote;
            set => rawNote = Math.Clamp(value, 0, 24);
        }

        /// <summary>
        /// MIDI note of the vocals pitch, typically ranging from C2 (36) to C6 (84).
        /// </summary>
        public int vocalsPitch
        {
            get => rawNote;
            set => rawNote = Math.Clamp(value, 0, 127);
        }

        /// <summary>
        /// Properties, such as forced or taps, are stored here in a bitwise format.
        /// </summary>
        public Flags flags;

        /// <summary>
        /// The previous note in the linked-list.
        /// </summary>
        public MoonNote? previous;
        /// <summary>
        /// The next note in the linked-list.
        /// </summary>
        public MoonNote? next;

        public Chord chord => new(this);

        public MoonNote(uint _position, int _rawNote, uint _sustain = 0, Flags _flags = Flags.None)
            : base(ID.Note, _position)
        {
            length = _sustain;
            flags = _flags;
            rawNote = _rawNote;

            previous = null;
            next = null;
        }

        public bool forced
        {
            get
            {
                return (flags & Flags.Forced) == Flags.Forced;
            }
            set
            {
                if (value)
                    flags |= Flags.Forced;
                else
                    flags &= ~Flags.Forced;
            }
        }

        /// <summary>
        /// Gets the next note in the linked-list that's not part of this note's chord.
        /// </summary>
        public MoonNote? NextSeperateMoonNote
        {
            get
            {
                var nextMoonNote = next;
                while (nextMoonNote != null && nextMoonNote.tick == tick)
                    nextMoonNote = nextMoonNote.next;
                return nextMoonNote;
            }
        }

        /// <summary>
        /// Gets the previous note in the linked-list that's not part of this note's chord.
        /// </summary>
        public MoonNote? PreviousSeperateMoonNote
        {
            get
            {
                var previousMoonNote = previous;
                while (previousMoonNote != null && previousMoonNote.tick == tick)
                    previousMoonNote = previousMoonNote.previous;
                return previousMoonNote;
            }
        }

        public override bool ValueEquals(MoonObject obj)
        {
            bool baseEq = base.ValueEquals(obj);
            if (!baseEq || obj is not MoonNote note)
                return baseEq;

            return rawNote == note.rawNote &&
                length == note.length &&
                flags == note.flags;
        }

        public override int InsertionCompareTo(MoonObject obj)
        {
            int baseComp = base.InsertionCompareTo(obj);
            if (baseComp != 0 || obj is not MoonNote note)
                return baseComp;

            return rawNote.CompareTo(note.rawNote);
        }

        public bool isChord => (previous != null && previous.tick == tick) || (next != null && next.tick == tick);

        /// <summary>
        /// Ignores the note's forced flag when determining whether it would be a hopo or not
        /// </summary>
        public bool IsNaturalHopo(float hopoThreshold)
        {
            // Checking state in this order is important
            return !isChord &&
                previous != null &&
                (previous.isChord || rawNote != previous.rawNote) &&
                tick - previous.tick <= hopoThreshold;
        }

        /// <summary>
        /// Would this note be a hopo or not? (Ignores whether the note's tap flag is set or not.)
        /// </summary>
        public bool IsHopo(float hopoThreshold)
        {
            // F + F || T + T = strum
            return IsNaturalHopo(hopoThreshold) != forced;
        }

        /// <summary>
        /// Returns a bit mask representing the whole note's chord. For example, a green, red and blue chord would have a mask of 0000 1011. A yellow and orange chord would have a mask of 0001 0100.
        /// Shifting occurs accoring the values of the Fret_Type enum, so open notes currently output with a mask of 0010 0000.
        /// </summary>
        public int mask
        {
            get
            {
                // Don't interate using chord, as chord will get messed up for the tool notes which override their linked list references.
                int mask = 1 << rawNote;

                var note = this;
                while (note.previous != null && note.previous.tick == tick)
                {
                    note = note.previous;
                    mask |= (1 << note.rawNote);
                }

                note = this;
                while (note.next != null && note.tick == note.next.tick)
                {
                    note = note.next;
                    mask |= (1 << note.rawNote);
                }

                return mask;
            }
        }

        public int GetMaskWithRequiredFlags(Flags flags)
        {
            int mask = 0;

            foreach (var note in chord)
            {
                if (note.flags == flags)
                    mask |= 1 << note.rawNote;
            }

            return mask;
        }

        /// <summary>
        /// Live calculation of what Note_Type this note would currently be.
        /// </summary>
        public MoonNoteType GetGuitarNoteType(float hopoThreshold)
        {
            if ((flags & Flags.Tap) != 0)
            {
                return MoonNoteType.Tap;
            }
            return IsHopo(hopoThreshold) ? MoonNoteType.Hopo : MoonNoteType.Strum;
        }

        public MoonNoteType GetDrumsNoteType()
        {
            if (drumPad is DrumPad.Yellow or DrumPad.Blue or DrumPad.Orange &&
                (flags & Flags.ProDrums_Cymbal) != 0)
            {
                return MoonNoteType.Cymbal;
            }
            return MoonNoteType.Strum;
        }

        public class Chord : IEnumerable<MoonNote>
        {
            private readonly MoonNote _baseMoonNote;
            public Chord(MoonNote note) : base()
            {
                _baseMoonNote = note;
            }

            public IEnumerator<MoonNote> GetEnumerator()
            {
                var note = _baseMoonNote;

                while (note.previous != null && note.previous.tick == note.tick)
                {
                    note = note.previous;
                }

                yield return note;

                while (note.next != null && note.tick == note.next.tick)
                {
                    note = note.next;
                    yield return note;
                }
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }
        }

        public bool IsOpenNote(MoonChart.GameMode gameMode)
        {
            return gameMode switch
            {
                MoonChart.GameMode.Guitar => guitarFret == GuitarFret.Open,
                MoonChart.GameMode.GHLGuitar => ghliveGuitarFret == GHLiveGuitarFret.Open,
                MoonChart.GameMode.ProGuitar => proGuitarFret == 0,
                MoonChart.GameMode.Drums => drumPad == DrumPad.Kick,
                _ => false
            };
        }

        public static int MakeProGuitarRawNote(ProGuitarString proString, int fret)
        {
            fret = Math.Clamp(fret, 0, 22);
            int rawNote = (fret << PRO_GUITAR_FRET_OFFSET) & PRO_GUITAR_FRET_MASK;
            rawNote |= ((int)proString << PRO_GUITAR_STRING_OFFSET) & PRO_GUITAR_STRING_MASK;
            return rawNote;
        }

        protected override MoonObject CloneImpl() => Clone();

        public new MoonNote Clone()
        {
            return new MoonNote(tick, rawNote, length, flags);
        }

        public override string ToString()
        {
            return $"Note at tick {tick} with value {rawNote}, length {length}, flags {flags}";
        }
    }
}
</file>

<file path="MoonscraperChartParser/Events/MoonObject.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System;

namespace MoonscraperChartEditor.Song
{
    [Serializable]
    internal abstract class MoonObject
    {
        /// <summary>
        /// The tick position of the object
        /// </summary>
        public uint tick;

        public readonly ID classID;
        
        public MoonObject(ID id, uint _tick)
        {
            classID = id;
            tick = _tick;
        }

        // Clone needs to be hideable so it can return a different type in derived classes
        protected abstract MoonObject CloneImpl();
        public MoonObject Clone() => CloneImpl();

        public override bool Equals(object obj)
        {
            return ReferenceEquals(this, obj) || (obj is MoonObject songObj && ValueEquals(songObj));
        }

        public virtual bool ValueEquals(MoonObject obj)
        {
            return tick == obj.tick && classID == obj.classID;
        }

        public bool InsertionEquals(MoonObject obj)
        {
            return InsertionCompareTo(obj) == 0;
        }

        public virtual int InsertionCompareTo(MoonObject obj)
        {
            int tickComp = tick.CompareTo(obj.tick);
            if (tickComp != 0)
                return tickComp;

            int idComp = ((int)classID).CompareTo((int)obj.classID);
            if (idComp != 0)
                return idComp;

            return 0;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override string ToString()
        {
            return $"{classID} at tick {tick}";
        }

        /// <summary>
        /// Allows different classes to be sorted and grouped together in arrays by giving each class a comparable numeric value that is greater or less than other classes.
        /// </summary>
        public enum ID
        {
            TimeSignature,
            BPM,
            Anchor,
            Beat,
            Text,
            Venue,
            Note,
            Phrase,
        }
    }
}
</file>

<file path="MoonscraperChartParser/Events/MoonPhrase.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System;

namespace MoonscraperChartEditor.Song
{
    [Serializable]
    internal class MoonPhrase : MoonObject
    {
        public enum Type
        {
            Starpower,
            Solo,

            Versus_Player1,
            Versus_Player2,

            TremoloLane,
            TrillLane,

            // RB Pro Drums

            ProDrums_Activation,

            // Vocals

            Vocals_LyricPhrase,
            Vocals_PercussionPhrase,
            Vocals_RangeShift,
            Vocals_LyricShift,

            // Pro keys

            ProKeys_RangeShift0,
            ProKeys_RangeShift1,
            ProKeys_RangeShift2,
            ProKeys_RangeShift3,
            ProKeys_RangeShift4,
            ProKeys_RangeShift5,

            ProKeys_Glissando,
        }

        public uint length;
        public Type type;

        public MoonPhrase(uint _position, uint _length, Type _type)
            : base(ID.Phrase, _position)
        {
            length = _length;
            type = _type;
        }

        public override bool ValueEquals(MoonObject obj)
        {
            bool baseEq = base.ValueEquals(obj);
            if (!baseEq || obj is not MoonPhrase phrase)
                return baseEq;

            return type == phrase.type;
        }

        public override int InsertionCompareTo(MoonObject obj)
        {
            int baseComp = base.InsertionCompareTo(obj);
            if (baseComp != 0 || obj is not MoonPhrase phrase)
                return baseComp;

            return ((int) type).CompareTo((int) phrase.type);
        }

        public uint GetCappedLengthForPos(uint pos, MoonChart? chart)
        {
            uint newLength;
            if (pos > tick)
                newLength = pos - tick;
            else
                newLength = 0;

            MoonPhrase? nextSp = null;
            if (chart != null)
            {
                int arrayPos = MoonObjectHelper.FindClosestPosition(this, chart.specialPhrases);
                if (arrayPos == MoonObjectHelper.NOTFOUND)
                    return newLength;

                while (arrayPos < chart.specialPhrases.Count - 1 && chart.specialPhrases[arrayPos].tick <= tick)
                {
                    ++arrayPos;
                }

                if (chart.specialPhrases[arrayPos].tick > tick)
                    nextSp = chart.specialPhrases[arrayPos];

                if (nextSp != null)
                {
                    // Cap sustain length
                    if (nextSp.tick < tick)
                        newLength = 0;
                    else if (pos > nextSp.tick)
                        // Cap sustain
                        newLength = nextSp.tick - tick;
                }
                // else it's the last or only special phrase
            }

            return newLength;
        }

        protected override MoonObject CloneImpl() => Clone();

        public new MoonPhrase Clone()
        {
            return new MoonPhrase(tick, length, type);
        }

        public override string ToString()
        {
            return $"Special phrase at tick {tick} with type {type}, length {length}";
        }
    }
}
</file>

<file path="MoonscraperChartParser/Events/MoonText.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System;

namespace MoonscraperChartEditor.Song
{
    [Serializable]
    internal class MoonText : MoonObject
    {
        public string text;

        public MoonText(string _title, uint _position)
            : this(ID.Text, _title, _position)
        {
        }

        protected MoonText(ID id, string _title, uint _position)
            : base(id, _position)
        {
            text = _title;
        }

        public override bool ValueEquals(MoonObject obj)
        {
            bool baseEq = base.ValueEquals(obj);
            if (!baseEq || obj is not MoonText textEv)
                return baseEq;

            return text == textEv.text;
        }

        public override int InsertionCompareTo(MoonObject obj)
        {
            int baseComp = base.InsertionCompareTo(obj);
            if (baseComp != 0 || obj is not MoonText textEv)
                return baseComp;

            return string.Compare(text, textEv.text);
        }

        protected override MoonObject CloneImpl() => Clone();

        public new MoonText Clone()
        {
            return new MoonText(text, tick);
        }

        public override string ToString()
        {
            return $"Text event '{text}' at tick {tick}";
        }
    }
}
</file>

<file path="MoonscraperChartParser/Events/MoonVenue.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System;
using YARG.Core.Chart;

namespace MoonscraperChartEditor.Song
{
    [Serializable]
    internal class MoonVenue : MoonText
    {
        public VenueLookup.Type type;
        public uint length;

        public MoonVenue(VenueLookup.Type _type, string _text, uint _position, uint _length = 0)
            : base(ID.Venue, _text, _position)
        {
            type = _type;
            length = _length;
        }

        public override bool ValueEquals(MoonObject obj)
        {
            bool baseEq = base.ValueEquals(obj);
            if (!baseEq || obj is not MoonVenue venueEv)
                return baseEq;

            return type == venueEv.type || length == venueEv.length;
        }

        public override int InsertionCompareTo(MoonObject obj)
        {
            int baseComp = base.InsertionCompareTo(obj);
            if (baseComp != 0 || obj is not MoonVenue venueEv)
                return baseComp;

            return ((int) type).CompareTo((int) venueEv.type);
        }

        protected override MoonObject CloneImpl() => Clone();

        public new MoonVenue Clone()
        {
            return new MoonVenue(type, text, tick, length);
        }

        public override string ToString()
        {
            return $"Venue event '{text}' at tick {tick} with type {type}, length {length}";
        }
    }
}
</file>

<file path="MoonscraperChartParser/IO/Chart/ChartIOHelper.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System.Collections.Generic;
using YARG.Core.Chart;

namespace MoonscraperChartEditor.Song.IO
{
    internal static class ChartIOHelper
    {
        public const string SECTION_SONG = "Song";
        public const string SECTION_SYNC_TRACK = "SyncTrack";
        public const string SECTION_EVENTS = "Events";


        public const int NOTE_OFFSET_PRO_DRUMS = 64;
        public const int NOTE_OFFSET_INSTRUMENT_PLUS = 32;
        public const int NOTE_OFFSET_DRUMS_ACCENT = 33;
        public const int NOTE_OFFSET_DRUMS_GHOST = 39;

        public const int PHRASE_VERSUS_PLAYER_1 = 0;
        public const int PHRASE_VERSUS_PLAYER_2 = 1;
        public const int PHRASE_STARPOWER = 2;
        public const int PHRASE_DRUM_FILL = 64;
        public const int PHRASE_TREMOLO_LANE = 65;
        public const int PHRASE_TRILL_LANE = 66;

        public static readonly Dictionary<int, int> GuitarNoteNumLookup = new()
        {
            { 0, (int)MoonNote.GuitarFret.Green     },
            { 1, (int)MoonNote.GuitarFret.Red       },
            { 2, (int)MoonNote.GuitarFret.Yellow    },
            { 3, (int)MoonNote.GuitarFret.Blue      },
            { 4, (int)MoonNote.GuitarFret.Orange    },
            { 7, (int)MoonNote.GuitarFret.Open      },
        };

        public static readonly Dictionary<int, MoonNote.Flags> GuitarFlagNumLookup = new()
        {
            { 5      , MoonNote.Flags.Forced },
            { 6      , MoonNote.Flags.Tap },
        };

        public static readonly Dictionary<int, int> DrumNoteNumLookup = new()
        {
            { 0, (int)MoonNote.DrumPad.Kick      },
            { 1, (int)MoonNote.DrumPad.Red       },
            { 2, (int)MoonNote.DrumPad.Yellow    },
            { 3, (int)MoonNote.DrumPad.Blue      },
            { 4, (int)MoonNote.DrumPad.Orange    },
            { 5, (int)MoonNote.DrumPad.Green     },
        };

        // Default flags for drums notes
        public static readonly Dictionary<int, MoonNote.Flags> DrumNoteDefaultFlagsLookup = new()
        {
            { (int)MoonNote.DrumPad.Kick      , MoonNote.Flags.None },
            { (int)MoonNote.DrumPad.Red       , MoonNote.Flags.None },
            { (int)MoonNote.DrumPad.Yellow    , MoonNote.Flags.None },
            { (int)MoonNote.DrumPad.Blue      , MoonNote.Flags.None },
            { (int)MoonNote.DrumPad.Orange    , MoonNote.Flags.None },   // Orange becomes green during 4-lane
            { (int)MoonNote.DrumPad.Green     , MoonNote.Flags.None },
        };

        public static readonly Dictionary<int, int> GhlNoteNumLookup = new()
        {
            { 0, (int)MoonNote.GHLiveGuitarFret.White1    },
            { 1, (int)MoonNote.GHLiveGuitarFret.White2    },
            { 2, (int)MoonNote.GHLiveGuitarFret.White3    },
            { 3, (int)MoonNote.GHLiveGuitarFret.Black1    },
            { 4, (int)MoonNote.GHLiveGuitarFret.Black2    },
            { 8, (int)MoonNote.GHLiveGuitarFret.Black3    },
            { 7, (int)MoonNote.GHLiveGuitarFret.Open      },
        };

        public static readonly Dictionary<int, MoonNote.Flags> GhlFlagNumLookup = GuitarFlagNumLookup;

        public static readonly Dictionary<string, MoonSong.Difficulty> TrackNameToTrackDifficultyLookup = new()
        {
            { "Easy",   MoonSong.Difficulty.Easy    },
            { "Medium", MoonSong.Difficulty.Medium  },
            { "Hard",   MoonSong.Difficulty.Hard    },
            { "Expert", MoonSong.Difficulty.Expert  },
        };

        public static readonly Dictionary<string, MoonSong.MoonInstrument> InstrumentStrToEnumLookup = new()
        {
            { "Single",         MoonSong.MoonInstrument.Guitar },
            { "DoubleGuitar",   MoonSong.MoonInstrument.GuitarCoop },
            { "DoubleBass",     MoonSong.MoonInstrument.Bass },
            { "DoubleRhythm",   MoonSong.MoonInstrument.Rhythm },
            { "Drums",          MoonSong.MoonInstrument.Drums },
            { "Keyboard",       MoonSong.MoonInstrument.Keys },
            { "GHLGuitar",      MoonSong.MoonInstrument.GHLiveGuitar },
            { "GHLBass",        MoonSong.MoonInstrument.GHLiveBass },
            { "GHLRhythm",      MoonSong.MoonInstrument.GHLiveRhythm },
            { "GHLCoop",        MoonSong.MoonInstrument.GHLiveCoop },
        };
    }
}
</file>

<file path="MoonscraperChartParser/IO/Chart/ChartReader.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

// Chart file format specifications- https://docs.google.com/document/d/1v2v0U-9HQ5qHeccpExDOLJ5CMPZZ3QytPmAG5WF0Kzs/edit?usp=sharing

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using YARG.Core.Chart;
using YARG.Core.Extensions;
using YARG.Core.Logging;
using YARG.Core.Parsing;
using YARG.Core.Utility;

namespace MoonscraperChartEditor.Song.IO
{
    using AsciiTrimSplitter = SpanSplitter<char, AsciiTrimSplitProcessor>;

    internal static partial class ChartReader
    {
        private struct NoteFlag
        {
            public uint           tick;
            public MoonNote.Flags flag;
            public int            noteNumber;

            public NoteFlag(uint tick, MoonNote.Flags flag, int noteNumber)
            {
                this.tick = tick;
                this.flag = flag;
                this.noteNumber = noteNumber;
            }
        }

        private struct NoteEvent
        {
            public uint tick;
            public int  noteNumber;
            public uint length;
        }

        private struct NoteProcessParams
        {
            public MoonChart                chart;
            public ParseSettings            settings;
            public NoteEvent                noteEvent;
            public List<NoteEventProcessFn> postNotesAddedProcessList;
        }

        #region Utility

        // https://cc.davelozinski.com/c-sharp/fastest-way-to-convert-a-string-to-an-int
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int FastInt32Parse(ReadOnlySpan<char> text)
        {
            int value = 0;
            foreach (char character in text) value = value * 10 + (character - '0');

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ulong FastUint64Parse(ReadOnlySpan<char> text)
        {
            ulong value = 0;
            foreach (char character in text) value = value * 10 + (ulong) (character - '0');

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ReadOnlySpan<char>
            GetNextWord(this ReadOnlySpan<char> buffer, out ReadOnlySpan<char> remaining) =>
            buffer.SplitOnceTrimmed(' ', out remaining);

        #endregion

        public static MoonSong ReadFromFile(string filepath)
        {
            var settings = ParseSettings.Default_Chart;
            return ReadFromFile(ref settings, filepath);
        }

        public static MoonSong ReadFromText(ReadOnlySpan<char> chartText)
        {
            var settings = ParseSettings.Default_Chart;
            return ReadFromText(ref settings, chartText);
        }

        public static MoonSong ReadFromFile(ref ParseSettings settings, string filepath)
        {
            try
            {
                if (!File.Exists(filepath)) throw new Exception("File does not exist");

                string extension = Path.GetExtension(filepath);

                if (extension != ".chart") throw new Exception("Bad file type");

                string text = File.ReadAllText(filepath);
                return ReadFromText(ref settings, text);
            }
            catch (Exception e)
            {
                throw new Exception("Could not open file!", e);
            }
        }

        private const uint DEFAULT_RESOLUTION = 192;
        public static MoonSong ReadFromText(ref ParseSettings settings, ReadOnlySpan<char> chartText)
        {
            int textIndex = 0;

            static void ExpectSection(ReadOnlySpan<char> chartText, ref int textIndex,
                string name, out AsciiTrimSplitter sectionBody)
            {
                if (!GetNextSection(chartText, ref textIndex, out var sectionName, out sectionBody))
                    throw new InvalidDataException($"Required section [{name}] is missing!");

                if (!sectionName.Equals(name, StringComparison.Ordinal))
                    throw new InvalidDataException($"Invalid section ordering! Expected [{name}], found [{sectionName.ToString()}]");
            }

            // Check for the [Song] section first explicitly, need the Resolution property up-front
            ExpectSection(chartText, ref textIndex, ChartIOHelper.SECTION_SONG, out var sectionBody);
            var song = SubmitDataSong(sectionBody);

            // With a 192 resolution, .chart has a HOPO threshold of 65 ticks, not 64,
            // so we need to scale this factor to different resolutions (480 res = 162.5 threshold)
            // This extra tick is meant for some slight leniency; .mid has it too, but it's applied
            // after factoring in the resolution there, not before.
            const uint THRESHOLD_AT_DEFAULT = 65;
            song.hopoThreshold = settings.HopoThreshold > ParseSettings.SETTING_DEFAULT
                ? (uint) settings.HopoThreshold
                : (song.resolution * THRESHOLD_AT_DEFAULT) / DEFAULT_RESOLUTION;

            // Check for [SyncTrack] next, we need it for time conversions
            ExpectSection(chartText, ref textIndex, ChartIOHelper.SECTION_SYNC_TRACK, out sectionBody);
            SubmitDataSync(song, sectionBody);

            // Parse instrument tracks
            while (GetNextSection(chartText, ref textIndex, out var sectionName, out sectionBody))
            {
                SubmitChartData(ref settings, song, sectionName, sectionBody);
            }

            return song;
        }

        private static bool GetNextSection(ReadOnlySpan<char> chartText, ref int index,
            out ReadOnlySpan<char> sectionName, out AsciiTrimSplitter sectionBody)
        {
            static int GetLineCount(ReadOnlySpan<char> chartText, int startIndex, int relativeIndex)
            {
                var searchSpace = chartText[..(startIndex + relativeIndex)];

                int count = 0;
                int index;
                while ((index = searchSpace.IndexOf('\n')) >= 0)
                {
                    count++;
                    searchSpace = searchSpace[++index..];
                }

                return count;
            }

            sectionName = default;
            sectionBody = default;
            if (index >= chartText.Length)
                // No more sections present
                return false;

            var search = chartText[index..];

            int nameStartIndex;
            while (true)
            {
                nameStartIndex = search.IndexOf('[');
                if (nameStartIndex < 0)
                {
                    // No more sections present
                    return false;
                }

                int test = nameStartIndex++;
                while (test > 0)
                {
                    --test;
                    if (search[test] > 32 || search[test] == '\n')
                    {
                        break;
                    }
                }

                index += nameStartIndex;

                var curr = search[test];
                search = search[nameStartIndex..];
                if (test == 0 || curr == '\n')
                {
                    break;
                }
            }

            int nameEndIndex = search.IndexOf(']');
            if (nameEndIndex < 0)
            {
                int startLine = GetLineCount(chartText, index, nameStartIndex);
                throw new Exception($"Missing end bracket for section name on line {startLine}!");
            }

            sectionName = search[..nameEndIndex++];
            search = search[nameEndIndex..];
            index += nameEndIndex;

            if (sectionName.IndexOfAny('\r', '\n') >= 0)
            {
                int startLine = GetLineCount(chartText, index, nameStartIndex);
                throw new Exception($"Section name on {startLine} spans across multiple lines!");
            }

            // Find section body
            int sectionStartIndex = search.IndexOf('{');
            if (sectionStartIndex < 0)
            {
                int startLine = GetLineCount(chartText, index, nameStartIndex);
                throw new Exception($"Missing section body for section [{sectionName.ToString()}]! (starting on line {startLine})");
            }
            ++sectionStartIndex;
            search = search[sectionStartIndex..];
            index += sectionStartIndex;

            int sectionEndIndex = 0;
            while (true)
            {
                int sectionEndOffset = search[sectionEndIndex..].IndexOf('}');
                if (sectionEndOffset < 0)
                {
                    int startLine = GetLineCount(chartText, index + sectionEndIndex, nameStartIndex);
                    throw new Exception($"Missing body end bracket for section [{sectionName.ToString()}]! (starting on line {startLine})");
                }

                int test = sectionEndIndex + sectionEndOffset;
                while (test > sectionEndIndex)
                {
                    --test;
                    if (search[test] > 32 || search[test] == '\n')
                    {
                        break;
                    }
                }

                sectionEndIndex += sectionEndOffset;
                if (test == 0 || search[test] == '\n')
                {
                    break;
                }
                ++sectionEndIndex;
            }

            sectionBody = search[..sectionEndIndex].SplitTrimmedAscii('\n');
            index += sectionEndIndex + 1;
            return true;
        }

        private static void SubmitChartData(ref ParseSettings settings, MoonSong song, ReadOnlySpan<char> sectionName,
            AsciiTrimSplitter sectionLines)
        {
            if (sectionName.Equals(ChartIOHelper.SECTION_EVENTS, StringComparison.Ordinal))
            {
                YargLogger.LogTrace("Loading events data");
                SubmitDataGlobals(song, sectionLines);
                return;
            }

            // Determine what difficulty
            foreach (var (diffName, difficulty) in ChartIOHelper.TrackNameToTrackDifficultyLookup)
            {
                if (!sectionName.StartsWith(diffName, StringComparison.Ordinal)) continue;

                foreach (var (instrumentName, instrument) in ChartIOHelper.InstrumentStrToEnumLookup)
                {
                    if (!sectionName.EndsWith(instrumentName, StringComparison.Ordinal)) continue;

                    YargLogger.LogFormatDebug("Loading data for {0} {1}", difficulty, instrument);
                    LoadChart(ref settings, song, sectionLines, instrument, difficulty);
                    break;
                }

                break;
            }
        }

        private static MoonSong SubmitDataSong(AsciiTrimSplitter sectionLines)
        {
            uint resolution = DEFAULT_RESOLUTION;
            foreach (var line in sectionLines)
            {
                var key = line.SplitOnceTrimmed('=', out var value);
                value = value.Trim('"'); // Strip off any quotation marks

                if (key.Equals("Resolution", StringComparison.Ordinal))
                {
                    resolution = (uint)FastInt32Parse(value);
                    break;
                }
            }
            return new MoonSong(resolution);
        }

        private static void SubmitDataSync(MoonSong song, AsciiTrimSplitter sectionLines)
        {
            uint prevTick = 0;

            // This is valid since we are guaranteed to have at least one tempo event at all times
            var tempoTracker = new ChartEventTickTracker<TempoChange>(song.syncTrack.Tempos);
            foreach (var _line in sectionLines)
            {
                var line = _line.Trim();
                if (line.IsEmpty) continue;

                try
                {
                    // Split on the equals sign
                    var tickText = line.SplitOnceTrimmed('=', out var remaining);

                    // Get tick
                    uint tick = (uint) FastInt32Parse(tickText);

                    if (prevTick > tick) throw new Exception("Tick value not in ascending order");
                    prevTick = tick;

                    tempoTracker.Update(tick);

                    // Get event type
                    var typeCode = remaining.GetNextWord(out remaining);
                    if (typeCode.Equals("B", StringComparison.Ordinal))
                    {
                        // Get tempo value
                        var tempoText = remaining.GetNextWord(out remaining);
                        uint tempo = (uint) FastInt32Parse(tempoText);

                        song.Add(new TempoChange(tempo / 1000f, song.TickToTime(tick, tempoTracker.Current!), tick));
                    }
                    else if (typeCode.Equals("TS", StringComparison.Ordinal))
                    {
                        // Get numerator
                        var numeratorText = remaining.GetNextWord(out remaining);
                        uint numerator = (uint) FastInt32Parse(numeratorText);

                        // Get denominator
                        var denominatorText = remaining.GetNextWord(out remaining);
                        uint denominator = denominatorText.IsEmpty ? 2 : (uint) FastInt32Parse(denominatorText);
                        song.Add(new TimeSignatureChange(numerator, (uint) Math.Pow(2, denominator),
                            song.TickToTime(tick, tempoTracker.Current!), tick));
                    }
                    else if (typeCode.Equals("A", StringComparison.Ordinal))
                    {
                        // Ignored for now, we don't need anchors
                    }
                    else
                    {
                        YargLogger.LogFormatWarning("Unrecognized type code '{0}'!", typeCode.ToString());
                    }
                }
                catch (Exception e)
                {
                    YargLogger.LogException(e, $"Error parsing .chart line '{line.ToString()}'!");
                }
            }
        }

        private static void SubmitDataGlobals(MoonSong song, AsciiTrimSplitter sectionLines)
        {
            uint prevTick = 0;
            foreach (var _line in sectionLines)
            {
                var line = _line.Trim();
                if (line.IsEmpty) continue;

                try
                {
                    // Split on the equals sign
                    var tickText = line.SplitOnceTrimmed('=', out var remaining);

                    // Get tick
                    uint tick = (uint) FastInt32Parse(tickText);

                    if (prevTick > tick) throw new Exception("Tick value not in ascending order");
                    prevTick = tick;

                    // Get event type
                    var typeCodeText = remaining.GetNextWord(out remaining);
                    if (typeCodeText[0] == 'E')
                    {
                        // Get event text
                        var eventText = TextEvents.NormalizeTextEvent(remaining.TrimOnce('"').Trim());

                        // Check for section events
                        if (TextEvents.TryParseSectionEvent(eventText, out var sectionName))
                        {
                            song.sections.Add(new MoonText(sectionName.ToString(), tick));
                        }
                        else
                        {
                            song.events.Add(new MoonText(eventText.ToString(), tick));
                        }
                    }
                    else
                    {
                        YargLogger.LogFormatWarning("Unrecognized type code '{0}'!", typeCodeText[0]);
                    }
                }
                catch (Exception e)
                {
                    YargLogger.LogException(e, $"Error parsing .chart line '{line.ToString()}'!");
                }
            }
        }

        #region Utility

        #endregion

        private static void LoadChart(ref ParseSettings settings, MoonSong song, AsciiTrimSplitter sectionLines,
            MoonSong.MoonInstrument instrument, MoonSong.Difficulty difficulty)
        {
            var chart = song.GetChart(instrument, difficulty);
            var gameMode = chart.gameMode;

            var flags = new List<NoteFlag>();
            var postNotesAddedProcessList = GetInitialPostProcessList(gameMode);

            var processParams = new NoteProcessParams()
            {
                chart = chart,
                settings = settings,
                postNotesAddedProcessList = postNotesAddedProcessList
            };

            chart.notes.Capacity = 5000;

            var noteProcessDict = GetNoteProcessDict(gameMode);
            var specialPhraseProcessDict = GetSpecialPhraseProcessDict(gameMode);

            try
            {
                uint prevTick = 0;
                // Load notes, collect flags
                foreach (var line in sectionLines)
                {
                    try
                    {
                        // Split on the equals sign
                        var tickText = line.SplitOnceTrimmed('=', out var remaining);

                        // Get tick
                        uint tick = (uint) FastInt32Parse(tickText);

                        if (prevTick > tick) throw new Exception("Tick value not in ascending order");
                        prevTick = tick;

                        // Get event type
                        char typeCode = remaining.GetNextWord(out remaining)[0];
                        switch (
                            typeCode) // Note this will need to be changed if keys are ever greater than 1 character long
                        {
                            case 'N':
                            {
                                // Get note data
                                var noteTypeText = remaining.GetNextWord(out remaining);
                                int noteType = FastInt32Parse(noteTypeText);

                                var noteLengthText = remaining.GetNextWord(out remaining);
                                uint noteLength = (uint) FastInt32Parse(noteLengthText);

                                // Process the note
                                if (noteProcessDict.TryGetValue(noteType, out var processFn))
                                {
                                    var noteEvent = new NoteEvent()
                                    {
                                        tick = tick,
                                        noteNumber = noteType,
                                        length = noteLength
                                    };
                                    processParams.noteEvent = noteEvent;
                                    processFn(ref processParams);
                                }

                                break;
                            }

                            case 'S':
                            {
                                // Get phrase data
                                var phraseTypeText = remaining.GetNextWord(out remaining);
                                int phraseType = FastInt32Parse(phraseTypeText);

                                var phraseLengthText = remaining.GetNextWord(out remaining);
                                uint phraseLength = (uint) FastInt32Parse(phraseLengthText);

                                if (specialPhraseProcessDict.TryGetValue(phraseType, out var processFn))
                                {
                                    var noteEvent = new NoteEvent()
                                    {
                                        tick = tick,
                                        noteNumber = phraseType,
                                        length = phraseLength
                                    };
                                    processParams.noteEvent = noteEvent;
                                    processFn(ref processParams);
                                }

                                break;
                            }
                            case 'E':
                            {
                                var eventText = TextEvents.NormalizeTextEvent(remaining.TrimOnce('"'));
                                chart.events.Add(new MoonText(eventText.ToString(), tick));
                                break;
                            }

                            default:
                                YargLogger.LogFormatWarning("Unrecognized type code '{0}'!", typeCode);
                                break;
                        }
                    }
                    catch (Exception e)
                    {
                        YargLogger.LogException(e, $"Error parsing .chart line '{line.ToString()}'!");
                    }
                }

                foreach (var fn in postNotesAddedProcessList)
                {
                    fn(ref processParams);
                }

                chart.notes.TrimExcess();
                settings = processParams.settings;
            }
            catch (Exception e)
            {
                // Bad load, most likely a parsing error
                YargLogger.LogException(e, $"Error parsing .chart section for {difficulty} {instrument}!");
                chart.Clear();
            }
        }

        private static void ProcessNoteOnEventAsNote(ref NoteProcessParams noteProcessParams, int ingameFret,
            MoonNote.Flags defaultFlags = MoonNote.Flags.None)
        {
            var chart = noteProcessParams.chart;

            var noteEvent = noteProcessParams.noteEvent;
            uint tick = noteEvent.tick;
            uint sus = noteEvent.length;
            if (sus < noteProcessParams.settings.SustainCutoffThreshold) sus = 0;

            var newMoonNote = new MoonNote(tick, ingameFret, sus, defaultFlags);
            MoonObjectHelper.PushNote(newMoonNote, chart.notes);
        }

        private static void ProcessNoteOnEventAsSpecialPhrase(ref NoteProcessParams noteProcessParams,
            MoonPhrase.Type type)
        {
            var chart = noteProcessParams.chart;

            var noteEvent = noteProcessParams.noteEvent;
            uint tick = noteEvent.tick;
            uint sus = noteEvent.length;

            var newPhrase = new MoonPhrase(tick, sus, type);
            chart.specialPhrases.Add(newPhrase);
        }

        private static void ProcessNoteOnEventAsChordFlag(ref NoteProcessParams noteProcessParams,
            NoteFlagPriority flagData)
        {
            var flagEvent = noteProcessParams.noteEvent;

            // Delay the actual processing once all the notes are actually in
            noteProcessParams.postNotesAddedProcessList.Add((ref NoteProcessParams processParams) =>
            {
                ProcessNoteOnEventAsChordFlagPostDelay(ref processParams, flagEvent, flagData);
            });
        }

        private static void ProcessNoteOnEventAsChordFlagPostDelay(ref NoteProcessParams noteProcessParams,
            NoteEvent noteEvent, NoteFlagPriority flagData)
        {
            var chart = noteProcessParams.chart;
            MoonObjectHelper.FindObjectsAtPosition(noteEvent.tick, chart.notes, out int index, out int length);
            if (length > 0)
            {
                GroupAddFlags(chart.notes, flagData, index, length);
            }
        }

        private static void ProcessNoteOnEventAsNoteFlagToggle(ref NoteProcessParams noteProcessParams, int rawNote,
            NoteFlagPriority flagData)
        {
            var flagEvent = noteProcessParams.noteEvent;

            // Delay the actual processing once all the notes are actually in
            noteProcessParams.postNotesAddedProcessList.Add((ref NoteProcessParams processParams) =>
            {
                ProcessNoteOnEventAsNoteFlagTogglePostDelay(ref processParams, rawNote, flagEvent, flagData);
            });
        }

        private static void ProcessNoteOnEventAsNoteFlagTogglePostDelay(ref NoteProcessParams noteProcessParams,
            int rawNote, NoteEvent noteEvent, NoteFlagPriority flagData)
        {
            var chart = noteProcessParams.chart;
            MoonObjectHelper.FindObjectsAtPosition(noteEvent.tick, chart.notes, out int index, out int length);
            if (length > 0)
            {
                for (int i = index; i < index + length; ++i)
                {
                    var note = chart.notes[i];
                    if (note.rawNote == rawNote)
                    {
                        TryAddNoteFlags(note, flagData);
                    }
                }
            }
        }

        private static void GroupAddFlags(IList<MoonNote> notes, NoteFlagPriority flagData, int index, int length)
        {
            for (int i = index; i < index + length; ++i)
            {
                TryAddNoteFlags(notes[i], flagData);
            }
        }

        private static void TryAddNoteFlags(MoonNote note, NoteFlagPriority flagData)
        {
            if (!flagData.TryApplyToNote(note))
            {
                YargLogger.LogFormatDebug("Could not apply flag {0} to a note. It was blocked by existing flag {1}.",
                    flagData.flagToAdd, flagData.blockingFlag);
            }
        }
    }
}
</file>

<file path="MoonscraperChartParser/IO/Chart/ChartReader.ProcessLists.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

// Chart file format specifications- https://docs.google.com/document/d/1v2v0U-9HQ5qHeccpExDOLJ5CMPZZ3QytPmAG5WF0Kzs/edit?usp=sharing

using System;
using System.Collections.Generic;
using System.Linq;
using YARG.Core.Chart;
using YARG.Core.Parsing;

namespace MoonscraperChartEditor.Song.IO
{
    internal static partial class ChartReader
    {
        private delegate void NoteEventProcessFn(ref NoteProcessParams noteProcessParams);

        // These dictionaries map the number of a note event to a specific function of how to process them
        private static readonly Dictionary<int, NoteEventProcessFn> GuitarChartNoteNumberToProcessFnMap = new()
        {
            { 0, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.GuitarFret.Green); }},
            { 1, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.GuitarFret.Red); }},
            { 2, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.GuitarFret.Yellow); }},
            { 3, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.GuitarFret.Blue); }},
            { 4, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.GuitarFret.Orange); }},
            { 7, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.GuitarFret.Open); }},

            { 5, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsChordFlag(ref noteProcessParams, NoteFlagPriority.Forced); }},
            { 6, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsChordFlag(ref noteProcessParams, NoteFlagPriority.Tap); }},
        };

        private static readonly Dictionary<int, NoteEventProcessFn> DrumsChartNoteNumberToProcessFnMap = new()
        {
            { 0, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.DrumPad.Kick); }},
            { 1, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.DrumPad.Red); }},
            { 2, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.DrumPad.Yellow); }},
            { 3, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.DrumPad.Blue); }},
            { 4, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.DrumPad.Orange); }},
            { 5, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.DrumPad.Green); }},

            { ChartIOHelper.NOTE_OFFSET_INSTRUMENT_PLUS, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.DrumPad.Kick, MoonNote.Flags.DoubleKick);
            } },

            { ChartIOHelper.NOTE_OFFSET_PRO_DRUMS + 2, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNoteFlagToggle(ref noteProcessParams, (int)MoonNote.DrumPad.Yellow, NoteFlagPriority.Cymbal);
            } },
            { ChartIOHelper.NOTE_OFFSET_PRO_DRUMS + 3, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNoteFlagToggle(ref noteProcessParams, (int)MoonNote.DrumPad.Blue, NoteFlagPriority.Cymbal);
            } },
            { ChartIOHelper.NOTE_OFFSET_PRO_DRUMS + 4, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNoteFlagToggle(ref noteProcessParams, (int)MoonNote.DrumPad.Orange, NoteFlagPriority.Cymbal);
            } },

            // { ChartIOHelper.NOTE_OFFSET_DRUMS_ACCENT + 0, ... }  // Reserved for kick accents, if they should ever be a thing
            { ChartIOHelper.NOTE_OFFSET_DRUMS_ACCENT + 1, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNoteFlagToggle(ref noteProcessParams, (int)MoonNote.DrumPad.Red, NoteFlagPriority.Accent);
            } },
            { ChartIOHelper.NOTE_OFFSET_DRUMS_ACCENT + 2, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNoteFlagToggle(ref noteProcessParams, (int)MoonNote.DrumPad.Yellow, NoteFlagPriority.Accent);
            } },
            { ChartIOHelper.NOTE_OFFSET_DRUMS_ACCENT + 3, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNoteFlagToggle(ref noteProcessParams, (int)MoonNote.DrumPad.Blue, NoteFlagPriority.Accent);
            } },
            { ChartIOHelper.NOTE_OFFSET_DRUMS_ACCENT + 4, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNoteFlagToggle(ref noteProcessParams, (int)MoonNote.DrumPad.Orange, NoteFlagPriority.Accent);
            } },
            { ChartIOHelper.NOTE_OFFSET_DRUMS_ACCENT + 5, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNoteFlagToggle(ref noteProcessParams, (int)MoonNote.DrumPad.Green, NoteFlagPriority.Accent);
            } },

            // { ChartIOHelper.NOTE_OFFSET_DRUMS_GHOST + 0, ... }  // Reserved for kick ghosts, if they should ever be a thing
            { ChartIOHelper.NOTE_OFFSET_DRUMS_GHOST + 1, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNoteFlagToggle(ref noteProcessParams, (int)MoonNote.DrumPad.Red, NoteFlagPriority.Ghost);
            } },
            { ChartIOHelper.NOTE_OFFSET_DRUMS_GHOST + 2, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNoteFlagToggle(ref noteProcessParams, (int)MoonNote.DrumPad.Yellow, NoteFlagPriority.Ghost);
            } },
            { ChartIOHelper.NOTE_OFFSET_DRUMS_GHOST + 3, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNoteFlagToggle(ref noteProcessParams, (int)MoonNote.DrumPad.Blue, NoteFlagPriority.Ghost);
            } },
            { ChartIOHelper.NOTE_OFFSET_DRUMS_GHOST + 4, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNoteFlagToggle(ref noteProcessParams, (int)MoonNote.DrumPad.Orange, NoteFlagPriority.Ghost);
            } },
            { ChartIOHelper.NOTE_OFFSET_DRUMS_GHOST + 5, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsNoteFlagToggle(ref noteProcessParams, (int)MoonNote.DrumPad.Green, NoteFlagPriority.Ghost);
            } },
        };

        private static readonly Dictionary<int, NoteEventProcessFn> GhlChartNoteNumberToProcessFnMap = new()
        {
            { 0, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.GHLiveGuitarFret.White1); }},
            { 1, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.GHLiveGuitarFret.White2); }},
            { 2, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.GHLiveGuitarFret.White3); }},
            { 3, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.GHLiveGuitarFret.Black1); }},
            { 4, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.GHLiveGuitarFret.Black2); }},
            { 8, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.GHLiveGuitarFret.Black3); }},
            { 7, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsNote(ref noteProcessParams, (int)MoonNote.GHLiveGuitarFret.Open); }},

            { 5, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsChordFlag(ref noteProcessParams, NoteFlagPriority.Forced); }},
            { 6, (ref NoteProcessParams noteProcessParams) => { ProcessNoteOnEventAsChordFlag(ref noteProcessParams, NoteFlagPriority.Tap); }},
        };

        // These dictionaries map the number of a special phrase event to a specific function of how to process them
        // Not all tracks support the same phrases, so this is done for flexibility
        private static readonly Dictionary<int, NoteEventProcessFn> GuitarChartSpecialPhraseNumberToProcessFnMap = new()
        {
            { ChartIOHelper.PHRASE_VERSUS_PLAYER_1, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsSpecialPhrase(ref noteProcessParams, MoonPhrase.Type.Versus_Player1);
            }},
            { ChartIOHelper.PHRASE_VERSUS_PLAYER_2, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsSpecialPhrase(ref noteProcessParams, MoonPhrase.Type.Versus_Player2);
            }},
            { ChartIOHelper.PHRASE_STARPOWER, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsSpecialPhrase(ref noteProcessParams, MoonPhrase.Type.Starpower);
            }},
        };

        private static readonly Dictionary<int, NoteEventProcessFn> DrumsChartSpecialPhraseNumberToProcessFnMap = new()
        {
            { ChartIOHelper.PHRASE_VERSUS_PLAYER_1, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsSpecialPhrase(ref noteProcessParams, MoonPhrase.Type.Versus_Player1);
            }},
            { ChartIOHelper.PHRASE_VERSUS_PLAYER_2, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsSpecialPhrase(ref noteProcessParams, MoonPhrase.Type.Versus_Player2);
            }},
            { ChartIOHelper.PHRASE_STARPOWER, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsSpecialPhrase(ref noteProcessParams, MoonPhrase.Type.Starpower);
            }},
            { ChartIOHelper.PHRASE_DRUM_FILL, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsSpecialPhrase(ref noteProcessParams, MoonPhrase.Type.ProDrums_Activation);
            }},
            { ChartIOHelper.PHRASE_TREMOLO_LANE, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsSpecialPhrase(ref noteProcessParams, MoonPhrase.Type.TremoloLane);
            }},
            { ChartIOHelper.PHRASE_TRILL_LANE, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsSpecialPhrase(ref noteProcessParams, MoonPhrase.Type.TrillLane);
            }},
        };

        private static readonly Dictionary<int, NoteEventProcessFn> GhlChartSpecialPhraseNumberToProcessFnMap = new()
        {
            { ChartIOHelper.PHRASE_VERSUS_PLAYER_1, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsSpecialPhrase(ref noteProcessParams, MoonPhrase.Type.Versus_Player1);
            }},
            { ChartIOHelper.PHRASE_VERSUS_PLAYER_2, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsSpecialPhrase(ref noteProcessParams, MoonPhrase.Type.Versus_Player2);
            }},
            { ChartIOHelper.PHRASE_STARPOWER, (ref NoteProcessParams noteProcessParams) => {
                ProcessNoteOnEventAsSpecialPhrase(ref noteProcessParams, MoonPhrase.Type.Starpower);
            }},
        };

        // Initial post-processing list
        private static readonly List<NoteEventProcessFn> GuitarInitialPostProcessList = new()
        {
            ConvertSoloEvents,
        };

        private static readonly List<NoteEventProcessFn> DrumsInitialPostProcessList = new()
        {
            ConvertSoloEvents,
            DisambiguateDrumsType,
        };

        private static readonly List<NoteEventProcessFn> GhlGuitarInitialPostProcessList = new()
        {
            ConvertSoloEvents,
        };

        private static Dictionary<int, NoteEventProcessFn> GetNoteProcessDict(MoonChart.GameMode gameMode)
        {
            return gameMode switch
            {
                MoonChart.GameMode.Guitar => GuitarChartNoteNumberToProcessFnMap,
                MoonChart.GameMode.GHLGuitar => GhlChartNoteNumberToProcessFnMap,
                MoonChart.GameMode.Drums => DrumsChartNoteNumberToProcessFnMap,
                _ => throw new NotImplementedException($"No process map for game mode {gameMode}!")
            };
        }

        private static Dictionary<int, NoteEventProcessFn> GetSpecialPhraseProcessDict(MoonChart.GameMode gameMode)
        {
            return gameMode switch
            {
                MoonChart.GameMode.Guitar => GuitarChartSpecialPhraseNumberToProcessFnMap,
                MoonChart.GameMode.GHLGuitar => GhlChartSpecialPhraseNumberToProcessFnMap,
                MoonChart.GameMode.Drums => DrumsChartSpecialPhraseNumberToProcessFnMap,
                _ => throw new NotImplementedException($"No process map for game mode {gameMode}!")
            };
        }

        private static List<NoteEventProcessFn> GetInitialPostProcessList(MoonChart.GameMode gameMode)
        {
            return gameMode switch
            {
                MoonChart.GameMode.Guitar => new(GuitarInitialPostProcessList),
                MoonChart.GameMode.GHLGuitar => new(GhlGuitarInitialPostProcessList),
                MoonChart.GameMode.Drums => new(DrumsInitialPostProcessList),
                _ => throw new NotImplementedException($"No process list for game mode {gameMode}!")
            };
        }

        private static void ConvertSoloEvents(ref NoteProcessParams noteProcessParams)
        {
            var chart = noteProcessParams.chart;
            // Keeps tracks of soloes that start on the same tick when another solo ends
            uint startTick = uint.MaxValue;
            uint nextStartTick = uint.MaxValue;
            for (int i = 0; i < chart.events.Count; ++i)
            {
                var ev = chart.events[i];
                if (ev.text == TextEvents.SOLO_START)
                {
                    if (startTick == uint.MaxValue)
                    {
                        startTick = ev.tick;
                    }
                    else
                    {
                        nextStartTick = ev.tick;
                    }
                }
                else if (ev.text == TextEvents.SOLO_END)
                {
                    if (startTick != uint.MaxValue)
                    {
                        // .chart handles solo phrases with *inclusive ends*, so we have to add one tick.
                        // The only exception will be if another solo starts on the same exact tick.
                        //
                        // Comparing to the current tick instead of against uint.MaxValue ensures
                        // that the we don't allow overlaps
                        if (nextStartTick != ev.tick)
                        {
                            chart.Add(new MoonPhrase(startTick, ev.tick + 1 - startTick, MoonPhrase.Type.Solo));
                            startTick = uint.MaxValue;
                        }
                        else
                        {
                            chart.Add(new MoonPhrase(startTick, ev.tick - startTick, MoonPhrase.Type.Solo));
                            startTick = nextStartTick;
                            nextStartTick = uint.MaxValue;
                        }
                    }
                }
            }
        }

        private static void DisambiguateDrumsType(ref NoteProcessParams processParams)
        {
            if (processParams.settings.DrumsType is not DrumsType.Unknown)
                return;

            foreach (var note in processParams.chart.notes)
            {
                // Cymbal markers indicate 4-lane
                if ((note.flags & MoonNote.Flags.ProDrums_Cymbal) != 0)
                {
                    processParams.settings.DrumsType = DrumsType.FourLane;
                    return;
                }

                // 5-lane green indicates 5-lane
                if (note.drumPad is MoonNote.DrumPad.Green)
                {
                    processParams.settings.DrumsType = DrumsType.FiveLane;
                    return;
                }
            }

            // Assume 4-lane if otherwise undetermined
            processParams.settings.DrumsType = DrumsType.FourLane;
        }
    }
}
</file>

<file path="MoonscraperChartParser/IO/Midi/MidFileLoader.cs">
using Melanchall.DryWetMidi.Core;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using YARG.Core;
using YARG.Core.Chart;
using YARG.Core.Logging;

namespace MoonscraperChartEditor.Song.IO
{
    public static class MidFileLoader
    {
        public static MidiFile LoadMidiFile(string file)
        {
            using var stream = new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.Read);
            return LoadMidiFile(stream);
        }

        public static MidiFile LoadMidiFile(Stream stream)
        {
            try
            {
                try
                {
                    YargLogger.LogTrace("Attempting to load midi in UTF-8");
                    return MidiFile.Read(stream, MidiSettings.Instance);

                }
                catch (DecoderFallbackException)
                {
                    stream.Position = 0;
                    YargLogger.LogTrace("Attempting to load midi in Latin-1");
                    return MidiFile.Read(stream, MidiSettingsLatin1.Instance);
                }
            }
            catch (Exception e)
            {
                throw new Exception("Bad or corrupted midi file!", e);
            }
        }
    }
}
</file>

<file path="MoonscraperChartParser/IO/Midi/MidIOHelper.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text.RegularExpressions;
using Melanchall.DryWetMidi.Core;
using YARG.Core.Chart;

namespace MoonscraperChartEditor.Song.IO
{
    using static VenueLookup;

    internal static class MidIOHelper
    {
        // Track names
        public const string BEAT_TRACK = "BEAT";
        public const string EVENTS_TRACK = "EVENTS";
        public const string VENUE_TRACK = "VENUE";
        public const string GUITAR_TRACK = "PART GUITAR";
        public const string GH1_GUITAR_TRACK = "T1 GEMS";
        public const string GUITAR_COOP_TRACK = "PART GUITAR COOP";
        public const string BASS_TRACK = "PART BASS";
        public const string RHYTHM_TRACK = "PART RHYTHM";
        public const string KEYS_TRACK = "PART KEYS";
        public const string PRO_GUITAR_17_FRET_TRACK = "PART REAL_GUITAR";
        public const string PRO_GUITAR_22_FRET_TRACK = "PART REAL_GUITAR_22";
        public const string PRO_BASS_17_FRET_TRACK = "PART REAL_BASS";
        public const string PRO_BASS_22_FRET_TRACK = "PART REAL_BASS_22";
        public const string DRUMS_TRACK = "PART DRUMS";
        public const string DRUMS_TRACK_2 = "PART DRUM";
        public const string DRUMS_REAL_TRACK = "PART REAL_DRUMS_PS";
        public const string GHL_GUITAR_TRACK = "PART GUITAR GHL";
        public const string GHL_BASS_TRACK = "PART BASS GHL";
        public const string GHL_RHYTHM_TRACK = "PART RHYTHM GHL";
        public const string GHL_GUITAR_COOP_TRACK = "PART GUITAR COOP GHL";
        public const string VOCALS_TRACK = "PART VOCALS";
        public const string HARMONY_1_TRACK = "HARM1";
        public const string HARMONY_2_TRACK = "HARM2";
        public const string HARMONY_3_TRACK = "HARM3";
        // The Beatles: Rock Band uses these instead for its harmony tracks
        public const string HARMONY_1_TRACK_2 = "PART HARM1";
        public const string HARMONY_2_TRACK_2 = "PART HARM2";
        public const string HARMONY_3_TRACK_2 = "PART HARM3";
        public const string PRO_KEYS_EXPERT = "PART REAL_KEYS_X";
        public const string PRO_KEYS_HARD = "PART REAL_KEYS_H";
        public const string PRO_KEYS_MEDIUM = "PART REAL_KEYS_M";
        public const string PRO_KEYS_EASY = "PART REAL_KEYS_E";


        // Matches venue lighting events and groups the text inside (parentheses), not including the parentheses
        // 'lighting (verse)' -> 'verse'
        // 'lighting (flare_fast)' -> 'flare_fast'
        // 'lighting ()' -> ''
        public static readonly Regex LightingRegex = new(@"lighting\s+\((.*)\)", RegexOptions.Compiled | RegexOptions.Singleline);

        // Note numbers
        public const byte DOUBLE_KICK_NOTE = 95;
        public const byte SOLO_NOTE = 103;                 // http://docs.c3universe.com/rbndocs/index.php?title=Guitar_and_Bass_Authoring#Solo_Sections
        public const byte TAP_NOTE_CH = 104;               // https://github.com/TheNathannator/GuitarGame_ChartFormats/blob/main/doc/FileFormats/.mid/Standard/5-Fret Guitar.md
        public const byte VERSUS_PHRASE_PLAYER_1 = 105;    // Guitar Hero 2 and Rock Band 1/2 use these to mark phrases for face-off
        public const byte VERSUS_PHRASE_PLAYER_2 = 106;    // and other competitive modes where the players trade off phrases of notes
        public const byte LYRICS_PHRASE_1 = VERSUS_PHRASE_PLAYER_1; // These are also used to mark phrases on vocals
        public const byte LYRICS_PHRASE_2 = VERSUS_PHRASE_PLAYER_2; // Rock Band 3 dropped these versus phrases however, and on vocals just uses note 105
        public const byte FLAM_MARKER = 109;
        public const byte STARPOWER_NOTE = 116;            // http://docs.c3universe.com/rbndocs/index.php?title=Overdrive_and_Big_Rock_Endings

        // http://docs.c3universe.com/rbndocs/index.php?title=Drum_Authoring#Drum_Fills
        public const byte DRUM_FILL_NOTE_0 = 120;
        public const byte DRUM_FILL_NOTE_1 = 121;
        public const byte DRUM_FILL_NOTE_2 = 122;
        public const byte DRUM_FILL_NOTE_3 = 123;
        public const byte DRUM_FILL_NOTE_4 = 124;

        // Drum rolls - http://docs.c3universe.com/rbndocs/index.php?title=Drum_Authoring#Drum_Rolls
        public const byte TREMOLO_LANE_NOTE = 126;
        public const byte TRILL_LANE_NOTE = 127;

        // Pro Guitar notes
        public const byte SOLO_NOTE_PRO_GUITAR = 115;

        // Vocals notes
        public const byte RANGE_SHIFT_NOTE = 0;
        public const byte LYRIC_SHIFT_NOTE = 1;
        public const byte VOCALS_RANGE_START = 36;
        public const byte VOCALS_RANGE_END = 84;
        public const byte PERCUSSION_NOTE = 96;
        public const byte NONPLAYED_PERCUSSION_NOTE = 97;

        // Pro Keys notes
        public const byte SOLO_NOTE_PRO_KEYS = 115;
        public const byte PRO_KEYS_RANGE_START = 48;
        public const byte PRO_KEYS_RANGE_END = 72;
        public const byte PRO_KEYS_SHIFT_0 = 0;
        public const byte PRO_KEYS_SHIFT_1 = 2;
        public const byte PRO_KEYS_SHIFT_2 = 4;
        public const byte PRO_KEYS_SHIFT_3 = 5;
        public const byte PRO_KEYS_SHIFT_4 = 7;
        public const byte PRO_KEYS_SHIFT_5 = 9;
        public const byte PRO_KEYS_GLISSANDO = 126;

        // Pro Guitar channels
        public const byte PRO_GUITAR_CHANNEL_NORMAL = 0;
        public const byte PRO_GUITAR_CHANNEL_GHOST = 1;
        public const byte PRO_GUITAR_CHANNEL_BEND = 2;
        public const byte PRO_GUITAR_CHANNEL_MUTED = 3;
        public const byte PRO_GUITAR_CHANNEL_TAP = 4;
        public const byte PRO_GUITAR_CHANNEL_HARMONIC = 5;
        public const byte PRO_GUITAR_CHANNEL_PINCH_HARMONIC = 6;

        // Beat track notes
        public const byte BEAT_STRONG = 12;
        public const byte BEAT_WEAK = 13;

        // These events are valid both with and without brackets.
        // The bracketed versions follow the style of other existing .mid text events.
        public const string CHART_DYNAMICS_TEXT = "ENABLE_CHART_DYNAMICS";
        public const string ENHANCED_OPENS_TEXT = "ENHANCED_OPENS";

        // Note velocities
        public const byte VELOCITY = 100;             // default note velocity for exporting
        public const byte VELOCITY_ACCENT = 127;      // fof/ps
        public const byte VELOCITY_GHOST = 1;         // fof/ps

        // Lookup tables
        public static readonly HashSet<MidiEventType> DisallowedTextEventTypes = new()
        {
            // The track name must never be used for anything other than identifying which track is which
            MidiEventType.SequenceTrackName,

            // Some charters put copyright notices, these need to be ignored for parsing purposes
            MidiEventType.CopyrightNotice,

            // For now, there is no need to ignore any of these
            // MidiEventType.CuePoint,
            // MidiEventType.InstrumentName,
            // MidiEventType.Marker,
        };

        public static readonly Dictionary<string, MoonSong.MoonInstrument> TrackNameToInstrumentMap = new()
        {
            { GUITAR_TRACK,        MoonSong.MoonInstrument.Guitar },
            { GH1_GUITAR_TRACK,    MoonSong.MoonInstrument.Guitar },
            { GUITAR_COOP_TRACK,   MoonSong.MoonInstrument.GuitarCoop },
            { BASS_TRACK,          MoonSong.MoonInstrument.Bass },
            { RHYTHM_TRACK,        MoonSong.MoonInstrument.Rhythm },
            { KEYS_TRACK,          MoonSong.MoonInstrument.Keys },

            { DRUMS_TRACK,         MoonSong.MoonInstrument.Drums },
            { DRUMS_REAL_TRACK,    MoonSong.MoonInstrument.Drums },

            { GHL_GUITAR_TRACK,    MoonSong.MoonInstrument.GHLiveGuitar },
            { GHL_BASS_TRACK,      MoonSong.MoonInstrument.GHLiveBass },
            { GHL_RHYTHM_TRACK,    MoonSong.MoonInstrument.GHLiveRhythm },
            { GHL_GUITAR_COOP_TRACK, MoonSong.MoonInstrument.GHLiveCoop },

            { PRO_GUITAR_17_FRET_TRACK, MoonSong.MoonInstrument.ProGuitar_17Fret },
            { PRO_GUITAR_22_FRET_TRACK, MoonSong.MoonInstrument.ProGuitar_22Fret },
            { PRO_BASS_17_FRET_TRACK,   MoonSong.MoonInstrument.ProBass_17Fret },
            { PRO_BASS_22_FRET_TRACK,   MoonSong.MoonInstrument.ProBass_22Fret },

            { VOCALS_TRACK,        MoonSong.MoonInstrument.Vocals },
            { HARMONY_1_TRACK,     MoonSong.MoonInstrument.Harmony1 },
            { HARMONY_2_TRACK,     MoonSong.MoonInstrument.Harmony2 },
            { HARMONY_3_TRACK,     MoonSong.MoonInstrument.Harmony3 },
            { HARMONY_1_TRACK_2,   MoonSong.MoonInstrument.Harmony1 },
            { HARMONY_2_TRACK_2,   MoonSong.MoonInstrument.Harmony2 },
            { HARMONY_3_TRACK_2,   MoonSong.MoonInstrument.Harmony3 },
        };

        public static readonly Dictionary<MoonSong.Difficulty, int> GUITAR_DIFF_START_LOOKUP = new()
        {
            { MoonSong.Difficulty.Easy, 60 },
            { MoonSong.Difficulty.Medium, 72 },
            { MoonSong.Difficulty.Hard, 84 },
            { MoonSong.Difficulty.Expert, 96 }
        };

        public static readonly Dictionary<MoonSong.Difficulty, int> GHL_GUITAR_DIFF_START_LOOKUP = new()
        {
            { MoonSong.Difficulty.Easy, 58 },
            { MoonSong.Difficulty.Medium, 70 },
            { MoonSong.Difficulty.Hard, 82 },
            { MoonSong.Difficulty.Expert, 94 }
        };

        public static readonly Dictionary<MoonSong.Difficulty, int> PRO_GUITAR_DIFF_START_LOOKUP = new()
        {
            { MoonSong.Difficulty.Easy, 24 },
            { MoonSong.Difficulty.Medium, 48 },
            { MoonSong.Difficulty.Hard, 72 },
            { MoonSong.Difficulty.Expert, 96 }
        };

        public static readonly Dictionary<MoonSong.Difficulty, int> DRUMS_DIFF_START_LOOKUP = new()
        {
            { MoonSong.Difficulty.Easy, 60 },
            { MoonSong.Difficulty.Medium, 72 },
            { MoonSong.Difficulty.Hard, 84 },
            { MoonSong.Difficulty.Expert, 96 }
        };

        // http://docs.c3universe.com/rbndocs/index.php?title=Drum_Authoring
        public static readonly Dictionary<MoonNote.DrumPad, int> PAD_TO_CYMBAL_LOOKUP = new()
        {
            { MoonNote.DrumPad.Yellow, 110 },
            { MoonNote.DrumPad.Blue, 111 },
            { MoonNote.DrumPad.Orange, 112 },
        };

        public static readonly Dictionary<int, MoonNote.DrumPad> CYMBAL_TO_PAD_LOOKUP = PAD_TO_CYMBAL_LOOKUP.ToDictionary((i) => i.Value, (i) => i.Key);

        public static readonly Dictionary<byte, MoonNote.Flags> PRO_GUITAR_CHANNEL_FLAG_LOOKUP = new()
        {
            // Not all flags are implemented yet
            { PRO_GUITAR_CHANNEL_NORMAL,         MoonNote.Flags.None },
            // { PRO_GUITAR_CHANNEL_GHOST,          MoonNote.Flags. },
            // { PRO_GUITAR_CHANNEL_BEND,           MoonNote.Flags. },
            { PRO_GUITAR_CHANNEL_MUTED,          MoonNote.Flags.ProGuitar_Muted },
            // { PRO_GUITAR_CHANNEL_TAP,            MoonNote.Flags. },
            // { PRO_GUITAR_CHANNEL_HARMONIC,       MoonNote.Flags. },
            // { PRO_GUITAR_CHANNEL_PINCH_HARMONIC, MoonNote.Flags. },
        };

        public static readonly Dictionary<int, (VenueLookup.Type type, string text)> VENUE_NOTE_LOOKUP = new()
        {
            #region Post-processing events
            { 110, (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_TRAILS_LONG) },           // Trails
            { 109, (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_SCANLINES_SECURITY) },    // Security camera
            { 108, (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_SCANLINES_BLACK_WHITE) }, // Black and white
            { 107, (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_SCANLINES) },             // Scanlines
            { 106, (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_SCANLINES_BLUE) },        // Blue tint
            { 105, (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_MIRROR) },                // Mirror
            { 104, (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_DESATURATED_RED) },       // Bloom B
            { 103, (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_BLOOM) },                 // Bloom A
            { 102, (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_CHOPPY_BLACK_WHITE) },    // Photocopy
            { 101, (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_PHOTONEGATIVE) },         // Negative
            { 100, (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_SILVERTONE) },            // Silvertone
            { 99,  (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_SEPIATONE) },             // Sepia
            { 98,  (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_GRAINY_FILM) },           // 16mm
            { 97,  (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_POLARIZED_BLACK_WHITE) }, // Contrast A
            { 96,  (VenueLookup.Type.PostProcessing, VENUE_POSTPROCESS_DEFAULT) },               // Default
            #endregion

            #region Performer singalongs
            { 87, (VenueLookup.Type.Singalong, VENUE_PERFORMER_GUITAR) },
            { 86, (VenueLookup.Type.Singalong, VENUE_PERFORMER_DRUMS) },
            { 85, (VenueLookup.Type.Singalong, VENUE_PERFORMER_BASS) },
            #endregion

            #region Lighting keyframes
            { 50, (VenueLookup.Type.Lighting, VENUE_LIGHTING_FIRST) },
            { 49, (VenueLookup.Type.Lighting, VENUE_LIGHTING_PREVIOUS) },
            { 48, (VenueLookup.Type.Lighting, VENUE_LIGHTING_NEXT) },
            #endregion

            #region Performer spotlights
            { 41, (VenueLookup.Type.Spotlight, VENUE_PERFORMER_KEYS) },
            { 40, (VenueLookup.Type.Spotlight, VENUE_PERFORMER_VOCALS) },
            { 39, (VenueLookup.Type.Spotlight, VENUE_PERFORMER_GUITAR) },
            { 38, (VenueLookup.Type.Spotlight, VENUE_PERFORMER_DRUMS) },
            { 37, (VenueLookup.Type.Spotlight, VENUE_PERFORMER_BASS) },
            #endregion
        };

        public static readonly Dictionary<Regex, (Dictionary<string, string> lookup, VenueLookup.Type type, string defaultValue)> VENUE_EVENT_REGEX_TO_LOOKUP = new()
        {
            { LightingRegex,    (VENUE_LIGHTING_CONVERSION_LOOKUP, VenueLookup.Type.Lighting, VENUE_LIGHTING_DEFAULT) },
        };

        public static bool IsTextEvent(MidiEvent trackEvent, [NotNullWhen(true)] out BaseTextEvent? text)
        {
            text = null;
            if (DisallowedTextEventTypes.Contains(trackEvent.EventType))
                return false;

            if (trackEvent is BaseTextEvent txt)
            {
                text = txt;
                return true;
            }

            return false;
        }
    }
}
</file>

<file path="MoonscraperChartParser/IO/Midi/MidReader.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using Melanchall.DryWetMidi.Core;
using Melanchall.DryWetMidi.Interaction;
using YARG.Core;
using YARG.Core.Chart;
using YARG.Core.Extensions;
using YARG.Core.Logging;
using YARG.Core.Parsing;

namespace MoonscraperChartEditor.Song.IO
{
    using NoteEventQueue = List<(NoteEvent note, long tick)>;
    using SysExEventQueue = List<(PhaseShiftSysEx sysex, long tick)>;

    internal static partial class MidReader
    {
        private const int SOLO_END_CORRECTION_OFFSET = -1;

        // true == override existing track, false == discard if already exists
        private static readonly Dictionary<string, bool> TrackOverrides = new()
        {
            { MidIOHelper.GUITAR_TRACK,     true },
            { MidIOHelper.GH1_GUITAR_TRACK, false },

            { MidIOHelper.DRUMS_TRACK,      true },
            { MidIOHelper.DRUMS_TRACK_2,    false },
            { MidIOHelper.DRUMS_REAL_TRACK, false },

            { MidIOHelper.HARMONY_1_TRACK, true },
            { MidIOHelper.HARMONY_2_TRACK, true },
            { MidIOHelper.HARMONY_3_TRACK, true },
            { MidIOHelper.HARMONY_1_TRACK_2, false },
            { MidIOHelper.HARMONY_2_TRACK_2, false },
            { MidIOHelper.HARMONY_3_TRACK_2, false },
        };

        private struct TimedMidiEvent
        {
            public MidiEvent midiEvent;
            public long startTick;
            public long endTick;

            public long length => endTick - startTick;
        }

        private struct EventProcessParams
        {
            public MoonSong song;
            public MoonSong.MoonInstrument instrument;

            public MoonSong.Difficulty? trackDifficulty;

            public ParseSettings settings;
            public TimedMidiEvent timedEvent;

            public Dictionary<int, EventProcessFn> noteProcessMap;
            public Dictionary<int, EventProcessFn> phraseProcessMap;
            public Dictionary<string, ProcessModificationProcessFn> textProcessMap;
            public Dictionary<PhaseShiftSysEx.PhraseCode, EventProcessFn> sysexProcessMap;

            public List<EventProcessFn> forcingProcessList;
            public List<EventProcessFn> sysexProcessList;
            public IReadOnlyList<EventProcessFn> postProcessList;
        }

        public static MoonSong ReadMidi(string path)
        {
            var settings = ParseSettings.Default_Midi;
            return ReadMidi(ref settings, path);
        }

        public static MoonSong ReadMidi(Stream stream)
        {
            var settings = ParseSettings.Default_Midi;
            return ReadMidi(ref settings, stream);
        }

        public static MoonSong ReadMidi(MidiFile midi)
        {
            var settings = ParseSettings.Default_Midi;
            return ReadMidi(ref settings, midi);
        }

        public static MoonSong ReadMidi(ref ParseSettings settings, string path)
        {
            return ReadMidi(ref settings, MidFileLoader.LoadMidiFile(path));
        }

        public static MoonSong ReadMidi(ref ParseSettings settings, Stream stream)
        {
            return ReadMidi(ref settings, MidFileLoader.LoadMidiFile(stream));
        }

        public static MoonSong ReadMidi(ref ParseSettings settings, MidiFile midi)
        {
            if (midi.Chunks == null || midi.Chunks.Count < 1)
                throw new InvalidOperationException("MIDI file has no tracks, unable to parse.");

            if (midi.TimeDivision is not TicksPerQuarterNoteTimeDivision ticks)
                throw new InvalidOperationException("MIDI file has no beat resolution set!");

            var song = new MoonSong((uint)ticks.TicksPerQuarterNote);

            // Apply settings
            song.hopoThreshold = settings.HopoThreshold > ParseSettings.SETTING_DEFAULT
                // +1 for a small bit of leniency
                ? (uint)settings.HopoThreshold + 1 
                : (song.resolution / 3) + 1;

            if (settings.SustainCutoffThreshold <= ParseSettings.SETTING_DEFAULT)
            {
                settings.SustainCutoffThreshold = (song.resolution / 3) + 1;
            }
            else if (settings.SustainCutoffThreshold == 0)
            {
                // Limit minimum cutoff to 1 tick, non - sustain notes created by charting programs are 1 tick
                settings.SustainCutoffThreshold = 1;
            }

            // Read all bpm data in first. This will also allow song.TimeToTick to function properly.
            ReadSync(midi.GetTempoMap(), song);

            foreach (var track in midi.GetTrackChunks())
            {
                if (track == null || track.Events.Count < 1)
                {
                    YargLogger.LogTrace("Encountered an empty MIDI track!");
                    continue;
                }

                string trackName = track.GetTrackName();
                switch (trackName)
                {
                    case MidIOHelper.BEAT_TRACK:
                        ReadSongBeats(track, song);
                        break;

                    case MidIOHelper.EVENTS_TRACK:
                        ReadSongGlobalEvents(track, song);
                        break;

                    case MidIOHelper.VENUE_TRACK:
                        ReadVenueEvents(track, song);
                        break;

                    case MidIOHelper.PRO_KEYS_EXPERT:
                        ReadNotes(ref settings, track, song, MoonSong.MoonInstrument.ProKeys, MoonSong.Difficulty.Expert);
                        break;
                    case MidIOHelper.PRO_KEYS_HARD:
                        ReadNotes(ref settings, track, song, MoonSong.MoonInstrument.ProKeys, MoonSong.Difficulty.Hard);
                        break;
                    case MidIOHelper.PRO_KEYS_MEDIUM:
                        ReadNotes(ref settings, track, song, MoonSong.MoonInstrument.ProKeys, MoonSong.Difficulty.Medium);
                        break;
                    case MidIOHelper.PRO_KEYS_EASY:
                        ReadNotes(ref settings, track, song, MoonSong.MoonInstrument.ProKeys, MoonSong.Difficulty.Easy);
                        break;

                    case MidIOHelper.VOCALS_TRACK:
                        // Parse lyrics to global track, and then parse as an instrument
                        ReadTextEventsIntoGlobalEventsAsLyrics(track, song);
                        goto default;

                    default:
                        MoonSong.MoonInstrument instrument;
                        if (!MidIOHelper.TrackNameToInstrumentMap.TryGetValue(trackName, out instrument))
                        {
                            // Ignore unrecognized tracks
                            YargLogger.LogFormatTrace("Skipping unrecognized track {0}", trackName);
                            continue;
                        }
                        else if (song.ChartExistsForInstrument(instrument))
                        {
                            if (!TrackOverrides.TryGetValue(trackName, out bool overwrite) || !overwrite)
                                continue;

                            // Overwrite existing track
                            foreach (var difficulty in EnumExtensions<MoonSong.Difficulty>.Values)
                            {
                                var chart = song.GetChart(instrument, difficulty);
                                chart.Clear();
                            }
                        }

                        YargLogger.LogFormatTrace("Loading MIDI track {0}", trackName);
                        ReadNotes(ref settings, track, song, instrument);
                        break;
                }
            }

            return song;
        }

        private static void ReadSync(TempoMap tempoMap, MoonSong song)
        {
            YargLogger.LogTrace("Reading sync track");

            foreach (var tempo in tempoMap.GetTempoChanges())
            {
                uint tempoTick = (uint) tempo.Time;
                song.Add(new TempoChange((float) tempo.Value.BeatsPerMinute,
                    // This is valid since we are guaranteed to have at least one tempo event at all times
                    song.TickToTime(tempoTick, song.syncTrack.Tempos[^1]), tempoTick));
            }

            var tempoTracker = new ChartEventTickTracker<TempoChange>(song.syncTrack.Tempos);
            foreach (var timesig in tempoMap.GetTimeSignatureChanges())
            {
                uint tsTick = (uint) timesig.Time;
                tempoTracker.Update(tsTick);
                song.Add(new TimeSignatureChange((uint) timesig.Value.Numerator, (uint) timesig.Value.Denominator,
                    song.TickToTime(tsTick, tempoTracker.Current!), tsTick));
            }
        }

        private static void ReadSongBeats(TrackChunk track, MoonSong song)
        {
            if (track.Events.Count < 1)
                return;

            YargLogger.LogTrace("Reading beat track");
            long absoluteTime = track.Events[0].DeltaTime;
            for (int i = 1; i < track.Events.Count; i++)
            {
                var trackEvent = track.Events[i];
                absoluteTime += trackEvent.DeltaTime;

                if (trackEvent is NoteEvent note && note.EventType == MidiEventType.NoteOn)
                {
                    BeatlineType beatType;
                    switch ((byte)note.NoteNumber)
                    {
                        case MidIOHelper.BEAT_STRONG:
                            beatType = BeatlineType.Measure;
                            break;
                        case MidIOHelper.BEAT_WEAK:
                            beatType = BeatlineType.Strong;
                            break;
                        default:
                            continue;
                    }

                    song.Add(new Beatline(beatType, song.TickToTime((uint) absoluteTime), (uint)absoluteTime));
                }
            }
        }

        private static void ReadSongGlobalEvents(TrackChunk track, MoonSong song)
        {
            if (track.Events.Count < 1)
                return;

            YargLogger.LogTrace("Reading global events");
            long absoluteTime = track.Events[0].DeltaTime;
            for (int i = 1; i < track.Events.Count; i++)
            {
                var trackEvent = track.Events[i];
                absoluteTime += trackEvent.DeltaTime;

                if (MidIOHelper.IsTextEvent(trackEvent, out var text))
                {
                    // Get event text
                    var eventText = TextEvents.NormalizeTextEvent(text.Text);

                    // Check for section events
                    if (TextEvents.TryParseSectionEvent(eventText, out var sectionName))
                    {
                        song.sections.Add(new MoonText(sectionName.ToString(), (uint)absoluteTime));
                    }
                    else
                    {
                        song.events.Add(new MoonText(eventText.ToString(), (uint)absoluteTime));
                    }
                }
            }
        }

        private static void ReadTextEventsIntoGlobalEventsAsLyrics(TrackChunk track, MoonSong song)
        {
            if (track.Events.Count < 1)
                return;

            YargLogger.LogTrace("Reading global lyrics");
            long absoluteTime = track.Events[0].DeltaTime;
            for (int i = 1; i < track.Events.Count; i++)
            {
                var trackEvent = track.Events[i];
                absoluteTime += trackEvent.DeltaTime;

                if (MidIOHelper.IsTextEvent(trackEvent, out var text) && !text.Text.Contains('['))
                {
                    string lyricEvent = TextEvents.LYRIC_PREFIX_WITH_SPACE + text.Text;
                    song.events.Add(new MoonText(lyricEvent, (uint)absoluteTime));
                }
                else if (trackEvent is NoteEvent note && (byte)note.NoteNumber is MidIOHelper.LYRICS_PHRASE_1 or MidIOHelper.LYRICS_PHRASE_2)
                {
                    if (note.EventType == MidiEventType.NoteOn)
                        song.events.Add(new MoonText(TextEvents.LYRIC_PHRASE_START, (uint)absoluteTime));
                    else if (note.EventType == MidiEventType.NoteOff)
                        song.events.Add(new MoonText(TextEvents.LYRIC_PHRASE_END, (uint)absoluteTime));
                }
            }
        }

        private static void ReadVenueEvents(TrackChunk track, MoonSong song)
        {
            if (track.Events.Count < 1)
                return;

            YargLogger.LogTrace("Reading venue track");

            var unpairedNoteQueue = new NoteEventQueue();

            long absoluteTime = track.Events[0].DeltaTime;
            for (int i = 1; i < track.Events.Count; i++)
            {
                var trackEvent = track.Events[i];
                absoluteTime += trackEvent.DeltaTime;

                if (trackEvent is NoteEvent note)
                {
                    if (note.EventType == MidiEventType.NoteOn)
                    {
                        // Check for duplicates
                        if (TryFindMatchingNote(unpairedNoteQueue, note, out _, out _, out _))
                            YargLogger.LogFormatWarning("Found duplicate note on at tick {0}!", absoluteTime);
                        else
                            unpairedNoteQueue.Add((note, absoluteTime));
                    }
                    else if (note.EventType == MidiEventType.NoteOff)
                    {
                        // Find starting note
                        if (!TryFindMatchingNote(unpairedNoteQueue, note, out var noteStart, out long startTick, out int startIndex))
                        {
                            YargLogger.LogFormatWarning("Found note off with no corresponding note on at tick {0}!", absoluteTime);
                            return;
                        }
                        unpairedNoteQueue.RemoveAt(startIndex);

                        // Turn note into event data
                        if (!MidIOHelper.VENUE_NOTE_LOOKUP.TryGetValue((byte)noteStart.NoteNumber, out var eventData))
                            continue;

                        // Add the event
                        song.venue.Add(new MoonVenue(eventData.type, eventData.text, (uint)startTick, (uint)(startTick - absoluteTime)));
                    }
                }
                else if (MidIOHelper.IsTextEvent(trackEvent, out var text))
                {
                    string eventText = TextEvents.NormalizeTextEvent(text.Text).ToString();

                    // Get new representation of the event
                    if (VenueLookup.VENUE_TEXT_CONVERSION_LOOKUP.TryGetValue(eventText, out var eventData))
                    {
                        song.venue.Add(new MoonVenue(eventData.type, eventData.text, (uint)absoluteTime));
                    }
                    else
                    {
                        // Events that need special matching
                        bool matched = false;
                        foreach (var (regex, (lookup, type, defaultValue)) in MidIOHelper.VENUE_EVENT_REGEX_TO_LOOKUP)
                        {
                            if (regex.Match(eventText) is not { Success: true } match)
                                continue;

                            // Get new representation of the event
                            if (!lookup.TryGetValue(match.Groups[1].Value, out string converted))
                            {
                                if (string.IsNullOrEmpty(defaultValue))
                                    continue;
                                converted = defaultValue;
                            }

                            matched = true;
                            song.venue.Add(new MoonVenue(type, converted, (uint)absoluteTime));
                            break;
                        }

                        // Unknown events
                        if (!matched)
                            song.venue.Add(new MoonVenue(VenueLookup.Type.Unknown, eventText, (uint)absoluteTime));
                    }
                }
            }
        }

        private static void ReadNotes(ref ParseSettings settings, TrackChunk track, MoonSong song,
            MoonSong.MoonInstrument instrument, MoonSong.Difficulty? trackDifficulty = null)
        {
            if (track == null || track.Events.Count < 1)
            {
                if (trackDifficulty is {} difficulty)
                    YargLogger.LogFormatTrace("Skipping empty track for {0} {1}", difficulty, instrument);
                else
                    YargLogger.LogFormatTrace("Skipping empty track for instrument {0}", instrument);
                return;
            }

            var unpairedNoteQueue = new NoteEventQueue();
            var unpairedSysexQueue = new SysExEventQueue();

            var gameMode = MoonSong.InstrumentToChartGameMode(instrument);

            var processParams = new EventProcessParams()
            {
                song = song,
                instrument = instrument,
                trackDifficulty = trackDifficulty,
                settings = settings,
                noteProcessMap = GetNoteProcessDict(gameMode),
                phraseProcessMap = GetPhraseProcessDict(settings.StarPowerNote, gameMode),
                textProcessMap = GetTextEventProcessDict(gameMode),
                sysexProcessMap = GetSysExEventProcessDict(gameMode),
                forcingProcessList = new(),
                sysexProcessList = new(),
                postProcessList = GetPostProcessList(gameMode),
            };

            // Load all the notes
            long absoluteTick = track.Events[0].DeltaTime;
            for (int i = 1; i < track.Events.Count; i++)
            {
                var trackEvent = track.Events[i];
                absoluteTick += trackEvent.DeltaTime;

                processParams.timedEvent = new TimedMidiEvent()
                {
                    midiEvent = trackEvent,
                    startTick = absoluteTick
                };

                if (trackEvent is NoteEvent note)
                {
                    ProcessNoteEvent(ref processParams, unpairedNoteQueue, note, absoluteTick);
                }
                else if (MidIOHelper.IsTextEvent(trackEvent, out var text))
                {
                    ProcessTextEvent(ref processParams, text, absoluteTick);
                }
                else if (trackEvent is SysExEvent sysex)
                {
                    ProcessSysExEvent(ref processParams, unpairedSysexQueue, sysex, absoluteTick);
                }
            }

            YargLogger.Assert(unpairedNoteQueue.Count == 0);
            YargLogger.Assert(unpairedSysexQueue.Count == 0);

            // Apply SysEx events first
            // These are separate to prevent forcing issues on open notes marked via SysEx
            foreach (var process in processParams.sysexProcessList)
            {
                process(ref processParams);
            }

            // Apply forcing events
            foreach (var process in processParams.forcingProcessList)
            {
                process(ref processParams);
            }

            // Apply post-processing
            // Also separate, to ensure that everything is in before post-processing
            foreach (var process in processParams.postProcessList)
            {
                process(ref processParams);
            }

            // If this specific track does not have a difficulty assigned to it, clear all difficulties
            if (trackDifficulty is null)
            {
                foreach (var difficulty in EnumExtensions<MoonSong.Difficulty>.Values)
                {
                    song.GetChart(instrument, difficulty).notes.TrimExcess();
                }
            }
            else
            {
                song.GetChart(instrument, trackDifficulty.Value).notes.TrimExcess();
            }

            settings = processParams.settings;
        }

        private static void ProcessNoteEvent(ref EventProcessParams processParams, NoteEventQueue unpairedNotes,
            NoteEvent note, long absoluteTick)
        {
            if (note.EventType == MidiEventType.NoteOn)
            {
                // Check for duplicates
                if (TryFindMatchingNote(unpairedNotes, note, out _, out _, out _))
                    YargLogger.LogFormatWarning("Found duplicate note on at tick {0}!", absoluteTick);
                else
                    unpairedNotes.Add((note, absoluteTick));
            }
            else if (note.EventType == MidiEventType.NoteOff)
            {
                if (!TryFindMatchingNote(unpairedNotes, note, out var noteStart, out long startTick, out int startIndex))
                {
                    YargLogger.LogFormatWarning("Found note off with no corresponding note on at tick {0}!", absoluteTick);
                    return;
                }
                unpairedNotes.RemoveAt(startIndex);

                processParams.timedEvent.midiEvent = noteStart;
                processParams.timedEvent.startTick = startTick;
                processParams.timedEvent.endTick = absoluteTick;

                if (processParams.noteProcessMap.TryGetValue(noteStart.NoteNumber, out var processFn) ||
                    processParams.phraseProcessMap.TryGetValue(noteStart.NoteNumber, out processFn))
                {
                    processFn(ref processParams);
                }
            }
        }

        private static void ProcessTextEvent(ref EventProcessParams processParams, BaseTextEvent text, long absoluteTick)
        {
            uint tick = (uint)absoluteTick;

            string eventText = TextEvents.NormalizeTextEvent(text.Text, out bool strippedBrackets).ToString();
            if (processParams.textProcessMap.TryGetValue(eventText, out var processFn))
            {
                // This text event affects parsing of the .mid file, run its function and don't parse it into the chart
                processFn(ref processParams);
                return;
            }
            // No brackets to strip off, on vocals this is most likely a lyric event
            else if (!strippedBrackets && MoonSong.InstrumentToChartGameMode(processParams.instrument) is MoonChart.GameMode.Vocals)
            {
                eventText = TextEvents.LYRIC_PREFIX_WITH_SPACE + eventText;
            }

            // Copy text event to all difficulties
            foreach (var difficulty in EnumExtensions<MoonSong.Difficulty>.Values)
            {
                processParams.song.GetChart(processParams.instrument, difficulty).events.Add(new MoonText(eventText, tick));
            }
        }

        private static void ProcessSysExEvent(ref EventProcessParams processParams, SysExEventQueue unpairedSysex,
            SysExEvent sysex, long absoluteTick)
        {
            if (!PhaseShiftSysEx.TryParse(sysex, out var psEvent))
            {
                // SysEx event is not a Phase Shift SysEx event
                YargLogger.LogFormatWarning("Encountered unknown SysEx event at tick {0}: {1}",
                    absoluteTick, new HexBytesFormat(sysex.Data));
                return;
            }

            if (psEvent.type != PhaseShiftSysEx.Type.Phrase)
            {
                YargLogger.LogFormatWarning("Encountered unknown Phase Shift SysEx event type {0} at tick {1}!",
                    psEvent.type, absoluteTick);
                return;
            }

            if (psEvent.phraseValue == PhaseShiftSysEx.PhraseValue.Start)
            {
                // Check for duplicates
                if (TryFindMatchingSysEx(unpairedSysex, psEvent, out _, out _, out _))
                    YargLogger.LogFormatWarning("Found duplicate SysEx start event at tick {0}!", absoluteTick);
                else
                    unpairedSysex.Add((psEvent, absoluteTick));
            }
            else if (psEvent.phraseValue == PhaseShiftSysEx.PhraseValue.End)
            {
                if (!TryFindMatchingSysEx(unpairedSysex, psEvent, out var sysexStart, out long startTick, out int startIndex))
                {
                    YargLogger.LogFormatWarning("Found PS SysEx end with no corresponding start at tick {0}!", absoluteTick);
                    return;
                }
                unpairedSysex.RemoveAt(startIndex);

                processParams.timedEvent.midiEvent = sysexStart;
                processParams.timedEvent.startTick = startTick;
                processParams.timedEvent.endTick = absoluteTick;

                if (processParams.sysexProcessMap.TryGetValue(psEvent.phraseCode, out var processFn))
                {
                    processFn(ref processParams);
                }
            }
        }

        private static bool TryFindMatchingNote(NoteEventQueue unpairedNotes, NoteEvent noteToMatch,
            [NotNullWhen(true)] out NoteEvent? matchingNote, out long matchTick, out int matchIndex)
        {
            for (int i = 0; i < unpairedNotes.Count; i++)
            {
                var queued = unpairedNotes[i];
                if (queued.note.NoteNumber == noteToMatch.NoteNumber && queued.note.Channel == noteToMatch.Channel)
                {
                    (matchingNote, matchTick) = queued;
                    matchIndex = i;
                    return true;
                }
            }

            matchingNote = null;
            matchTick = -1;
            matchIndex = -1;
            return false;
        }

        private static bool TryFindMatchingSysEx(SysExEventQueue unpairedSysex, PhaseShiftSysEx sysexToMatch,
            [NotNullWhen(true)] out PhaseShiftSysEx? matchingSysex, out long matchTick, out int matchIndex)
        {
            for (int i = 0; i < unpairedSysex.Count; i++)
            {
                var queued = unpairedSysex[i];
                if (queued.sysex.MatchesWith(sysexToMatch))
                {
                    (matchingSysex, matchTick) = queued;
                    matchIndex = i;
                    return true;
                }
            }

            matchingSysex = null;
            matchTick = -1;
            matchIndex = -1;
            return false;
        }

        private static bool ContainsTextEvent(List<MoonText> events, string text)
        {
            foreach (var textEvent in events)
            {
                if (textEvent.text == text)
                {
                    return true;
                }
            }

            return false;
        }

        private static void ProcessNoteOnEventAsNote(ref EventProcessParams eventProcessParams, MoonSong.Difficulty diff,
            int ingameFret, MoonNote.Flags defaultFlags = MoonNote.Flags.None, bool sustainCutoff = true)
        {
            var chart = eventProcessParams.song.GetChart(eventProcessParams.instrument, diff);

            var timedEvent = eventProcessParams.timedEvent;
            uint tick = (uint)timedEvent.startTick;
            uint sus = (uint)timedEvent.length;
            if (sustainCutoff && sus < eventProcessParams.settings.SustainCutoffThreshold)
            {
                sus = 0;
            }

            var newMoonNote = new MoonNote(tick, ingameFret, sus, defaultFlags);
            if (chart.notes.Capacity == 0)
                chart.notes.Capacity = 5000;

            MoonObjectHelper.OrderedInsertFromBack(newMoonNote, chart.notes);
        }

        private static void ProcessNoteOnEventAsSpecialPhrase(ref EventProcessParams eventProcessParams,
            MoonPhrase.Type type, MoonSong.Difficulty? difficulty = null)
        {
            var song = eventProcessParams.song;
            var instrument = eventProcessParams.instrument;

            var timedEvent = eventProcessParams.timedEvent;
            uint tick = (uint)timedEvent.startTick;
            uint sus = (uint)timedEvent.length;

            if (difficulty is null)
            {
                foreach (var diff in EnumExtensions<MoonSong.Difficulty>.Values)
                {
                    MoonObjectHelper.OrderedInsertFromBack(new MoonPhrase(tick, sus, type),
                        song.GetChart(instrument, diff).specialPhrases);
                }
            }
            else
            {
                MoonObjectHelper.OrderedInsertFromBack(new MoonPhrase(tick, sus, type),
                    song.GetChart(instrument, difficulty.Value).specialPhrases);
            }
        }

        private static void ProcessNoteOnEventAsGuitarForcedType(ref EventProcessParams eventProcessParams, MoonNote.MoonNoteType noteType)
        {
            foreach (var diff in EnumExtensions<MoonSong.Difficulty>.Values)
            {
                ProcessNoteOnEventAsGuitarForcedType(ref eventProcessParams, diff, noteType);
            }
        }

        private static void ProcessNoteOnEventAsGuitarForcedType(ref EventProcessParams eventProcessParams, MoonSong.Difficulty difficulty, MoonNote.MoonNoteType noteType)
        {
            var timedEvent = eventProcessParams.timedEvent;
            uint startTick = (uint)timedEvent.startTick;
            uint endTick = (uint)timedEvent.endTick;
            // Exclude the last tick of the phrase
            if (endTick > startTick)
                --endTick;

            // Delay the actual processing once all the notes are actually in
            eventProcessParams.forcingProcessList.Add((ref EventProcessParams processParams) =>
            {
                ProcessEventAsGuitarForcedTypePostDelay(ref processParams, startTick, endTick, difficulty, noteType);
            });
        }

        private static void ProcessEventAsGuitarForcedTypePostDelay(ref EventProcessParams eventProcessParams, uint startTick, uint endTick, MoonSong.Difficulty difficulty, MoonNote.MoonNoteType noteType)
        {
            var song = eventProcessParams.song;
            var instrument = eventProcessParams.instrument;
            var chart = song.GetChart(instrument, difficulty);
            var gameMode = chart.gameMode;

            // Drums force notes are handled by ProcessNoteOnEventAsFlagToggle
            if (gameMode is MoonChart.GameMode.Drums)
                return;

            MoonObjectHelper.GetRange(chart.notes, startTick, endTick, out int index, out int length);

            for (int i = index; i < index + length; ++i)
            {
                var note = chart.notes[i];
                var newType = noteType; // The requested type might not be able to be marked for this note

                // Tap marking overrides all other forcing
                if ((note.flags & MoonNote.Flags.Tap) != 0)
                    continue;

                switch (newType)
                {
                    case MoonNote.MoonNoteType.Strum:
                        note.flags |= MoonNote.Flags.Forced_Strum;
                        note.flags &= ~MoonNote.Flags.Forced_Hopo;
                        if (!note.isChord && note.IsNaturalHopo(song.hopoThreshold))
                            note.flags |= MoonNote.Flags.Forced;
                        else
                            note.flags &= ~MoonNote.Flags.Forced;
                        break;

                    case MoonNote.MoonNoteType.Hopo:
                        note.flags |= MoonNote.Flags.Forced_Hopo;
                        note.flags &= ~MoonNote.Flags.Forced_Strum;
                        if (note.isChord || !note.IsNaturalHopo(song.hopoThreshold))
                            note.flags |= MoonNote.Flags.Forced;
                        else
                            note.flags &= ~MoonNote.Flags.Forced;
                        break;

                    case MoonNote.MoonNoteType.Tap:
                        note.flags |= MoonNote.Flags.Tap;
                        note.flags &= ~MoonNote.Flags.Forced;
                        break;

                    default:
                        YargLogger.FailFormat("Unhandled note type {0} in .mid forced type processing!", newType);
                        continue;
                }

                var finalType = note.GetGuitarNoteType(song.hopoThreshold);
                YargLogger.Assert(finalType == newType);
            }
        }

        private static void ProcessNoteOnEventAsFlagToggle(ref EventProcessParams eventProcessParams, MoonNote.Flags flags, int individualNoteSpecifier)
        {
            var timedEvent = eventProcessParams.timedEvent;
            uint startTick = (uint)timedEvent.startTick;
            uint endTick = (uint)timedEvent.endTick;
            // Exclude the last tick of the phrase
            if (endTick > startTick)
                --endTick;

            // Delay the actual processing once all the notes are actually in
            eventProcessParams.forcingProcessList.Add((ref EventProcessParams processParams) =>
            {
                ProcessNoteOnEventAsFlagTogglePostDelay(ref processParams, startTick, endTick, flags, individualNoteSpecifier);
            });
        }

        private static void ProcessNoteOnEventAsFlagTogglePostDelay(ref EventProcessParams eventProcessParams, uint startTick, uint endTick, MoonNote.Flags flags, int individualNoteSpecifier)   // individualNoteSpecifier as -1 to apply to the whole chord
        {
            var song = eventProcessParams.song;
            var instrument = eventProcessParams.instrument;

            foreach (var difficulty in EnumExtensions<MoonSong.Difficulty>.Values)
            {
                var chart = song.GetChart(instrument, difficulty);

                MoonObjectHelper.GetRange(chart.notes, startTick, endTick, out int index, out int length);

                for (int i = index; i < index + length; ++i)
                {
                    var note = chart.notes[i];

                    if (individualNoteSpecifier < 0 || note.rawNote == individualNoteSpecifier)
                    {
                        // Toggle flag
                        note.flags ^= flags;
                    }
                }
            }
        }

        private static void ProcessSysExEventPairAsGuitarForcedType(ref EventProcessParams eventProcessParams, MoonNote.MoonNoteType noteType)
        {
            var timedEvent = eventProcessParams.timedEvent;
            if (eventProcessParams.timedEvent.midiEvent is not PhaseShiftSysEx startEvent)
            {
                YargLogger.FailFormat("Wrong note event type! Expected: {0}, Actual: {1}",
                    typeof(PhaseShiftSysEx), eventProcessParams.timedEvent.midiEvent.GetType());
                return;
            }

            uint startTick = (uint)timedEvent.startTick;
            uint endTick = (uint)timedEvent.endTick;
            // Tap note phrases do *not* exclude the last tick, based on both Phase Shift and Clone Hero
            // if (endTick > startTick)
            //     --endTick;

            if (startEvent.difficulty == PhaseShiftSysEx.Difficulty.All)
            {
                foreach (var diff in EnumExtensions<MoonSong.Difficulty>.Values)
                {
                    eventProcessParams.sysexProcessList.Add((ref EventProcessParams processParams) =>
                    {
                        ProcessEventAsGuitarForcedTypePostDelay(ref processParams, startTick, endTick, diff, noteType);
                    });
                }
            }
            else
            {
                var diff = PhaseShiftSysEx.SysExDiffToMsDiff[startEvent.difficulty];
                eventProcessParams.sysexProcessList.Add((ref EventProcessParams processParams) =>
                {
                    ProcessEventAsGuitarForcedTypePostDelay(ref processParams, startTick, endTick, diff, noteType);
                });
            }
        }

        private static void ProcessSysExEventPairAsOpenNoteModifier(ref EventProcessParams eventProcessParams)
        {
            var timedEvent = eventProcessParams.timedEvent;
            if (eventProcessParams.timedEvent.midiEvent is not PhaseShiftSysEx startEvent)
            {
                YargLogger.FailFormat("Wrong note event type! Expected: {0}, Actual: {1}",
                    typeof(PhaseShiftSysEx), eventProcessParams.timedEvent.midiEvent.GetType());
                return;
            }

            uint startTick = (uint)timedEvent.startTick;
            uint endTick = (uint)timedEvent.endTick;
            // Open note phrases *do* exclude the last tick, based on both Phase Shift and Clone Hero
            if (endTick > startTick)
                --endTick;

            if (startEvent.difficulty == PhaseShiftSysEx.Difficulty.All)
            {
                foreach (var diff in EnumExtensions<MoonSong.Difficulty>.Values)
                {
                    eventProcessParams.sysexProcessList.Add((ref EventProcessParams processParams) =>
                    {
                        ProcessEventAsOpenNoteModifierPostDelay(ref processParams, startTick, endTick, diff);
                    });
                }
            }
            else
            {
                var diff = PhaseShiftSysEx.SysExDiffToMsDiff[startEvent.difficulty];
                eventProcessParams.sysexProcessList.Add((ref EventProcessParams processParams) =>
                {
                    ProcessEventAsOpenNoteModifierPostDelay(ref processParams, startTick, endTick, diff);
                });
            }
        }

        private static void ProcessEventAsOpenNoteModifierPostDelay(ref EventProcessParams processParams, uint startTick, uint endTick, MoonSong.Difficulty difficulty)
        {
            var instrument = processParams.instrument;
            var song = processParams.song;
            var chart = song.GetChart(instrument, difficulty);
            var gameMode = chart.gameMode;

            MoonObjectHelper.GetRange(chart.notes, startTick, endTick, out int index, out int length);
            for (int i = index; i < index + length; ++i)
            {
                switch (gameMode)
                {
                    case MoonChart.GameMode.Guitar:
                        chart.notes[i].guitarFret = MoonNote.GuitarFret.Open;
                        break;

                    // Usually not used, but in the case that it is it should work properly
                    case MoonChart.GameMode.GHLGuitar:
                        chart.notes[i].ghliveGuitarFret = MoonNote.GHLiveGuitarFret.Open;
                        break;

                    default:
                        YargLogger.FailFormat("Unhandled game mode {0} (instrument: {1}) for open note modifier!)",
                            gameMode, instrument);
                        break;
                }
            }
        }
    }
}
</file>

<file path="MoonscraperChartParser/IO/Midi/MidReader.ProcessLists.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Melanchall.DryWetMidi.Core;
using YARG.Core;
using YARG.Core.Chart;
using YARG.Core.Extensions;
using YARG.Core.Logging;

namespace MoonscraperChartEditor.Song.IO
{
    internal static partial class MidReader
    {
        private static readonly List<MoonSong.MoonInstrument> LegacyStarPowerFixupWhitelist = new()
        {
            MoonSong.MoonInstrument.Guitar,
            MoonSong.MoonInstrument.GuitarCoop,
            MoonSong.MoonInstrument.Bass,
            MoonSong.MoonInstrument.Rhythm,
        };

        // Delegate for functions that parse something into the chart
        private delegate void EventProcessFn(ref EventProcessParams eventProcessParams);
        // Delegate for functions that modify how the chart should be parsed
        private delegate void ProcessModificationProcessFn(ref EventProcessParams eventProcessParams);

        private struct CommonPhraseSettings
        {
            public int starPowerNote;
            public int soloNote;
            public bool versusPhrases;
            public bool lanePhrases;
        }

        // These dictionaries map the NoteNumber of each midi note event to a specific function of how to process them
        private static readonly Dictionary<int, EventProcessFn> GuitarNoteProcessMap = BuildGuitarNoteProcessDict(enhancedOpens: false);
        private static readonly Dictionary<int, EventProcessFn> GuitarNoteProcessMap_EnhancedOpens = BuildGuitarNoteProcessDict(enhancedOpens: true);
        private static readonly Dictionary<int, EventProcessFn> GhlGuitarNoteProcessMap = BuildGhlGuitarNoteProcessDict();
        private static readonly Dictionary<int, EventProcessFn> ProGuitarNoteProcessMap = BuildProGuitarNoteProcessDict();
        private static readonly Dictionary<int, EventProcessFn> DrumsNoteProcessMap = BuildDrumsNoteProcessDict(enableVelocity: false);
        private static readonly Dictionary<int, EventProcessFn> DrumsNoteProcessMap_Velocity = BuildDrumsNoteProcessDict(enableVelocity: true);
        private static readonly Dictionary<int, EventProcessFn> VocalsNoteProcessMap = BuildVocalsNoteProcessDict();
        private static readonly Dictionary<int, EventProcessFn> ProKeysNoteProcessMap = BuildProKeysNoteProcessDict();

        private static readonly CommonPhraseSettings GuitarPhraseSettings = new()
        {
            soloNote = MidIOHelper.SOLO_NOTE,
            versusPhrases = true,
            lanePhrases = true,
        };

        private static readonly CommonPhraseSettings GhlGuitarPhraseSettings = new()
        {
            soloNote = MidIOHelper.SOLO_NOTE,
            versusPhrases = false,
            lanePhrases = false,
        };

        private static readonly CommonPhraseSettings ProGuitarPhraseSettings = new()
        {
            soloNote = MidIOHelper.SOLO_NOTE_PRO_GUITAR,
            versusPhrases = false,
            lanePhrases = true,
        };

        private static readonly CommonPhraseSettings DrumsPhraseSettings = new()
        {
            soloNote = MidIOHelper.SOLO_NOTE,
            versusPhrases = true,
            lanePhrases = true,
        };

        private static readonly CommonPhraseSettings VocalsPhraseSettings = new()
        {
            soloNote = -1,
            versusPhrases = false,
            lanePhrases = false,
        };

        private static readonly CommonPhraseSettings ProKeysPhraseSettings = new()
        {
            soloNote = MidIOHelper.SOLO_NOTE_PRO_KEYS,
            versusPhrases = false,
            // lanePhrases = true, // Handled manually due to per-difficulty tracks
        };

        // These dictionaries map the text of a MIDI text event to a specific function that processes them
        private static readonly Dictionary<string, ProcessModificationProcessFn> GuitarTextProcessMap = new()
        {
            { MidIOHelper.ENHANCED_OPENS_TEXT, SwitchToGuitarEnhancedOpensProcessMap },
        };

        private static readonly Dictionary<string, ProcessModificationProcessFn> GhlGuitarTextProcessMap = new()
        {
        };

        private static readonly Dictionary<string, ProcessModificationProcessFn> ProGuitarTextProcessMap = new()
        {
        };

        private static readonly Dictionary<string, ProcessModificationProcessFn> DrumsTextProcessMap = new()
        {
            { MidIOHelper.CHART_DYNAMICS_TEXT, SwitchToDrumsVelocityProcessMap },
        };

        private static readonly Dictionary<string, ProcessModificationProcessFn> VocalsTextProcessMap = new()
        {
        };

        private static readonly Dictionary<string, ProcessModificationProcessFn> ProKeysTextProcessMap = new()
        {
        };

        // These dictionaries map the phrase code of a SysEx event to a specific function that processes them
        private static readonly Dictionary<PhaseShiftSysEx.PhraseCode, EventProcessFn> GuitarSysExProcessMap = new()
        {
            { PhaseShiftSysEx.PhraseCode.Guitar_Open, ProcessSysExEventPairAsOpenNoteModifier },
            { PhaseShiftSysEx.PhraseCode.Guitar_Tap, (ref EventProcessParams eventProcessParams) => {
                ProcessSysExEventPairAsGuitarForcedType(ref eventProcessParams, MoonNote.MoonNoteType.Tap);
            }},
        };

        private static readonly Dictionary<PhaseShiftSysEx.PhraseCode, EventProcessFn> GhlGuitarSysExProcessMap = new()
        {
            { PhaseShiftSysEx.PhraseCode.Guitar_Open, ProcessSysExEventPairAsOpenNoteModifier },
            { PhaseShiftSysEx.PhraseCode.Guitar_Tap, (ref EventProcessParams eventProcessParams) => {
                ProcessSysExEventPairAsGuitarForcedType(ref eventProcessParams, MoonNote.MoonNoteType.Tap);
            }},
        };

        private static readonly Dictionary<PhaseShiftSysEx.PhraseCode, EventProcessFn> ProGuitarSysExProcessMap = new()
        {
        };

        private static readonly Dictionary<PhaseShiftSysEx.PhraseCode, EventProcessFn> DrumsSysExProcessMap = new()
        {
        };

        private static readonly Dictionary<PhaseShiftSysEx.PhraseCode, EventProcessFn> VocalsSysExProcessMap = new()
        {
        };

        private static readonly Dictionary<PhaseShiftSysEx.PhraseCode, EventProcessFn> ProKeysSysExProcessMap = new()
        {
        };

        // Some post-processing events should always be carried out on certain tracks
        private static readonly List<EventProcessFn> GuitarPostProcessList = new()
        {
            FixupStarPowerIfNeeded,
        };

        private static readonly List<EventProcessFn> GhlGuitarPostProcessList = new()
        {
        };

        private static readonly List<EventProcessFn> ProGuitarPostProcessList = new()
        {
        };

        private static readonly List<EventProcessFn> DrumsPostProcessList = new()
        {
            DisambiguateDrumsType,
        };

        private static readonly List<EventProcessFn> VocalsPostProcessList = new()
        {
            CopyDownHarmonyPhrases,
        };

        private static readonly List<EventProcessFn> ProKeysPostProcessList = new()
        {
        };

        private static Dictionary<int, EventProcessFn> GetNoteProcessDict(MoonChart.GameMode gameMode)
        {
            return gameMode switch
            {
                MoonChart.GameMode.Guitar => GuitarNoteProcessMap,
                MoonChart.GameMode.GHLGuitar => GhlGuitarNoteProcessMap,
                MoonChart.GameMode.ProGuitar => ProGuitarNoteProcessMap,
                MoonChart.GameMode.Drums => DrumsNoteProcessMap,
                MoonChart.GameMode.Vocals => VocalsNoteProcessMap,
                MoonChart.GameMode.ProKeys => ProKeysNoteProcessMap,
                _ => throw new NotImplementedException($"No process map for game mode {gameMode}!")
            };
        }

        private static Dictionary<int, EventProcessFn> GetPhraseProcessDict(int spNote, MoonChart.GameMode gameMode)
        {
            // Set default if no override given
            if (spNote < 0)
                spNote = MidIOHelper.STARPOWER_NOTE;

            var phraseSettings = gameMode switch
            {
                MoonChart.GameMode.Guitar => GuitarPhraseSettings,
                MoonChart.GameMode.GHLGuitar => GhlGuitarPhraseSettings,
                MoonChart.GameMode.ProGuitar => ProGuitarPhraseSettings,
                MoonChart.GameMode.Drums => DrumsPhraseSettings,
                MoonChart.GameMode.Vocals => VocalsPhraseSettings,
                MoonChart.GameMode.ProKeys => ProKeysPhraseSettings,
                _ => throw new NotImplementedException($"No process map for game mode {gameMode}!")
            };
            phraseSettings.starPowerNote = spNote;

            // Don't add solos when SP is overridden to the legacy SP note
            if (phraseSettings.soloNote == spNote)
                phraseSettings.soloNote = -1;

            return BuildCommonPhraseProcessMap(phraseSettings);
        }

        private static Dictionary<string, ProcessModificationProcessFn> GetTextEventProcessDict(MoonChart.GameMode gameMode)
        {
            return gameMode switch
            {
                MoonChart.GameMode.Guitar => GuitarTextProcessMap,
                MoonChart.GameMode.GHLGuitar => GhlGuitarTextProcessMap,
                MoonChart.GameMode.ProGuitar => ProGuitarTextProcessMap,
                MoonChart.GameMode.Drums => DrumsTextProcessMap,
                MoonChart.GameMode.Vocals => VocalsTextProcessMap,
                MoonChart.GameMode.ProKeys => ProKeysTextProcessMap,
                _ => throw new NotImplementedException($"No process map for game mode {gameMode}!")
            };
        }

        private static Dictionary<PhaseShiftSysEx.PhraseCode, EventProcessFn> GetSysExEventProcessDict(MoonChart.GameMode gameMode)
        {
            return gameMode switch
            {
                MoonChart.GameMode.Guitar => GuitarSysExProcessMap,
                MoonChart.GameMode.GHLGuitar => GhlGuitarSysExProcessMap,
                MoonChart.GameMode.ProGuitar => ProGuitarSysExProcessMap,
                MoonChart.GameMode.Drums => DrumsSysExProcessMap,
                MoonChart.GameMode.Vocals => VocalsSysExProcessMap,
                MoonChart.GameMode.ProKeys => ProKeysSysExProcessMap,
                _ => throw new NotImplementedException($"No process map for game mode {gameMode}!")
            };
        }

        private static IReadOnlyList<EventProcessFn> GetPostProcessList(MoonChart.GameMode gameMode)
        {
            return gameMode switch
            {
                MoonChart.GameMode.Guitar => GuitarPostProcessList,
                MoonChart.GameMode.GHLGuitar => GhlGuitarPostProcessList,
                MoonChart.GameMode.ProGuitar => ProGuitarPostProcessList,
                MoonChart.GameMode.Drums => DrumsPostProcessList,
                MoonChart.GameMode.Vocals => VocalsPostProcessList,
                MoonChart.GameMode.ProKeys => ProKeysPostProcessList,
                _ => throw new NotImplementedException($"No process map for game mode {gameMode}!")
            };
        }

        private static void FixupStarPowerIfNeeded(ref EventProcessParams processParams)
        {
            // Ignore if SP override is specified
            if (processParams.settings.StarPowerNote >= 0)
                return;

            // Check if instrument is allowed to be fixed up
            if (!LegacyStarPowerFixupWhitelist.Contains(processParams.instrument))
                return;

            // Only need to check one difficulty since phrases get copied to all difficulties
            var chart = processParams.song.GetChart(processParams.instrument, MoonSong.Difficulty.Expert);
            if (chart.specialPhrases.Any((sp) => sp.type == MoonPhrase.Type.Starpower)
                || !chart.specialPhrases.Any((sp) => sp.type == MoonPhrase.Type.Solo))
            {
                return;
            }

            foreach (var diff in EnumExtensions<MoonSong.Difficulty>.Values)
            {
                chart = processParams.song.GetChart(processParams.instrument, diff);
                foreach (var phrase in chart.specialPhrases)
                {
                    if (phrase.type == MoonPhrase.Type.Solo)
                        phrase.type = MoonPhrase.Type.Starpower;
                }
            }
        }

        private static void DisambiguateDrumsType(ref EventProcessParams processParams)
        {
            if (processParams.settings.DrumsType is not DrumsType.Unknown)
                return;

            foreach (var difficulty in EnumExtensions<MoonSong.Difficulty>.Values)
            {
                var chart = processParams.song.GetChart(processParams.instrument, difficulty);
                foreach (var note in chart.notes)
                {
                    // Tom markers indicate 4-lane
                    if (note.drumPad is not MoonNote.DrumPad.Red &&
                        (note.flags & MoonNote.Flags.ProDrums_Cymbal) == 0)
                    {
                        processParams.settings.DrumsType = DrumsType.FourLane;
                        return;
                    }

                    // 5-lane green indicates 5-lane
                    if (note.drumPad is MoonNote.DrumPad.Green)
                    {
                        processParams.settings.DrumsType = DrumsType.FiveLane;
                        return;
                    }
                }
            }

            // Assume 4-lane if otherwise undetermined
            processParams.settings.DrumsType = DrumsType.FourLane;
        }

        private static void CopyDownHarmonyPhrases(ref EventProcessParams processParams)
        {
            if (processParams.instrument is not (MoonSong.MoonInstrument.Harmony2 or MoonSong.MoonInstrument.Harmony3))
                return;

            // Remove any existing phrases
            // TODO: HARM2 phrases are used to mark when lyrics shift in static lyrics, this needs to be preserved in some way
            // TODO: Determine if there are any phrases that shouldn't be removed/copied down
            var chart = processParams.song.GetChart(processParams.instrument, MoonSong.Difficulty.Expert);
            chart.specialPhrases.Clear();

            // Add in phrases from HARM1
            var harm1 = processParams.song.GetChart(MoonSong.MoonInstrument.Harmony1, MoonSong.Difficulty.Expert);
            foreach (var phrase in harm1.specialPhrases)
            {
                // Make a new copy instead of adding the original reference
                chart.specialPhrases.Add(phrase.Clone());
            }
        }

        private static void SwitchToGuitarEnhancedOpensProcessMap(ref EventProcessParams processParams)
        {
            var gameMode = MoonSong.InstrumentToChartGameMode(processParams.instrument);
            if (gameMode != MoonChart.GameMode.Guitar)
            {
                YargLogger.LogFormatWarning("Attempted to apply guitar enhanced opens process map to non-guitar instrument: {0}", processParams.instrument);
                return;
            }

            // Switch process map to guitar enhanced opens process map
            processParams.noteProcessMap = GuitarNoteProcessMap_EnhancedOpens;
        }

        private static void SwitchToDrumsVelocityProcessMap(ref EventProcessParams processParams)
        {
            var gameMode = MoonSong.InstrumentToChartGameMode(processParams.instrument);
            if (gameMode != MoonChart.GameMode.Drums)
            {
                YargLogger.LogFormatWarning("Attempted to apply drums velocity process map to non-drums instrument: {0}", processParams.instrument);
                return;
            }

            // Switch process map to drums velocity process map
            processParams.noteProcessMap = DrumsNoteProcessMap_Velocity;
        }

        private static Dictionary<int, EventProcessFn> BuildCommonPhraseProcessMap(CommonPhraseSettings settings)
        {
            var processMap = new Dictionary<int, EventProcessFn>();

            if (settings.starPowerNote >= 0)
            {
                processMap.Add(settings.starPowerNote, (ref EventProcessParams eventProcessParams) => {
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.Starpower);
                });
            }

            if (settings.soloNote >= 0)
            {
                processMap.Add(settings.soloNote, (ref EventProcessParams eventProcessParams) => {
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.Solo);
                });
            }

            if (settings.versusPhrases)
            {
                processMap.Add(MidIOHelper.VERSUS_PHRASE_PLAYER_1, (ref EventProcessParams eventProcessParams) => {
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.Versus_Player1);
                });
                processMap.Add(MidIOHelper.VERSUS_PHRASE_PLAYER_2, (ref EventProcessParams eventProcessParams) => {
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.Versus_Player2);
                });
            }

            if (settings.lanePhrases)
            {
                static void ProcessLanePhrase(ref EventProcessParams processParams, MoonPhrase.Type phraseType)
                {
                    if (processParams.timedEvent.midiEvent is not NoteEvent noteEvent)
                    {
                        YargLogger.FailFormat("Wrong note event type! Expected: {0}, Actual: {1}",
                            typeof(NoteEvent), processParams.timedEvent.midiEvent.GetType());
                        return;
                    }

                    ProcessNoteOnEventAsSpecialPhrase(ref processParams, phraseType, MoonSong.Difficulty.Expert);
                    if ((int)noteEvent.Velocity is >= 41 and <= 50)
                    {
                        ProcessNoteOnEventAsSpecialPhrase(ref processParams, phraseType, MoonSong.Difficulty.Hard);
                    }
                }

                processMap.Add(MidIOHelper.TREMOLO_LANE_NOTE, (ref EventProcessParams eventProcessParams) => {
                    ProcessLanePhrase(ref eventProcessParams, MoonPhrase.Type.TremoloLane);
                });
                processMap.Add(MidIOHelper.TRILL_LANE_NOTE, (ref EventProcessParams eventProcessParams) => {
                    ProcessLanePhrase(ref eventProcessParams, MoonPhrase.Type.TrillLane);
                });
            }

            return processMap;
        }

        private static Dictionary<int, EventProcessFn> BuildGuitarNoteProcessDict(bool enhancedOpens = false)
        {
            var processFnDict = new Dictionary<int, EventProcessFn>()
            {
                { MidIOHelper.TAP_NOTE_CH, (ref EventProcessParams eventProcessParams) => {
                    ProcessNoteOnEventAsGuitarForcedType(ref eventProcessParams, MoonNote.MoonNoteType.Tap);
                }},
            };

            var FretToMidiKey = new Dictionary<MoonNote.GuitarFret, int>()
            {
                { MoonNote.GuitarFret.Green, 0 },
                { MoonNote.GuitarFret.Red, 1 },
                { MoonNote.GuitarFret.Yellow, 2 },
                { MoonNote.GuitarFret.Blue, 3 },
                { MoonNote.GuitarFret.Orange, 4 },
            };

            if (enhancedOpens)
                FretToMidiKey.Add(MoonNote.GuitarFret.Open, -1);

            foreach (var difficulty in EnumExtensions<MoonSong.Difficulty>.Values)
            {
                int difficultyStartRange = MidIOHelper.GUITAR_DIFF_START_LOOKUP[difficulty];
                foreach (var guitarFret in EnumExtensions<MoonNote.GuitarFret>.Values)
                {
                    if (FretToMidiKey.TryGetValue(guitarFret, out int fretOffset))
                    {
                        int key = fretOffset + difficultyStartRange;
                        int fret = (int)guitarFret;

                        processFnDict.Add(key, (ref EventProcessParams eventProcessParams) =>
                        {
                            ProcessNoteOnEventAsNote(ref eventProcessParams, difficulty, fret);
                        });
                    }
                }

                // Process forced hopo or forced strum
                {
                    int flagKey = difficultyStartRange + 5;
                    processFnDict.Add(flagKey, (ref EventProcessParams eventProcessParams) =>
                    {
                        ProcessNoteOnEventAsGuitarForcedType(ref eventProcessParams, difficulty, MoonNote.MoonNoteType.Hopo);
                    });
                }
                {
                    int flagKey = difficultyStartRange + 6;
                    processFnDict.Add(flagKey, (ref EventProcessParams eventProcessParams) =>
                    {
                        ProcessNoteOnEventAsGuitarForcedType(ref eventProcessParams, difficulty, MoonNote.MoonNoteType.Strum);
                    });
                }
            };

            return processFnDict;
        }

        private static Dictionary<int, EventProcessFn> BuildGhlGuitarNoteProcessDict()
        {
            var processFnDict = new Dictionary<int, EventProcessFn>()
            {
                { MidIOHelper.TAP_NOTE_CH, (ref EventProcessParams eventProcessParams) => {
                    ProcessNoteOnEventAsGuitarForcedType(ref eventProcessParams, MoonNote.MoonNoteType.Tap);
                }},
            };

            var FretToMidiKey = new Dictionary<MoonNote.GHLiveGuitarFret, int>()
            {
                { MoonNote.GHLiveGuitarFret.Open, 0 },
                { MoonNote.GHLiveGuitarFret.White1, 1 },
                { MoonNote.GHLiveGuitarFret.White2, 2 },
                { MoonNote.GHLiveGuitarFret.White3, 3 },
                { MoonNote.GHLiveGuitarFret.Black1, 4 },
                { MoonNote.GHLiveGuitarFret.Black2, 5 },
                { MoonNote.GHLiveGuitarFret.Black3, 6 },
            };

            foreach (var difficulty in EnumExtensions<MoonSong.Difficulty>.Values)
            {
                int difficultyStartRange = MidIOHelper.GHL_GUITAR_DIFF_START_LOOKUP[difficulty];
                foreach (var guitarFret in EnumExtensions<MoonNote.GHLiveGuitarFret>.Values)
                {
                    if (FretToMidiKey.TryGetValue(guitarFret, out int fretOffset))
                    {
                        int key = fretOffset + difficultyStartRange;
                        int fret = (int)guitarFret;

                        processFnDict.Add(key, (ref EventProcessParams eventProcessParams) =>
                        {
                            ProcessNoteOnEventAsNote(ref eventProcessParams, difficulty, fret);
                        });
                    }
                }

                // Process forced hopo or forced strum
                {
                    int flagKey = difficultyStartRange + 7;
                    processFnDict.Add(flagKey, (ref EventProcessParams eventProcessParams) =>
                    {
                        ProcessNoteOnEventAsGuitarForcedType(ref eventProcessParams, difficulty, MoonNote.MoonNoteType.Hopo);
                    });
                }
                {
                    int flagKey = difficultyStartRange + 8;
                    processFnDict.Add(flagKey, (ref EventProcessParams eventProcessParams) =>
                    {
                        ProcessNoteOnEventAsGuitarForcedType(ref eventProcessParams, difficulty, MoonNote.MoonNoteType.Strum);
                    });
                }
            };

            return processFnDict;
        }

        private static Dictionary<int, EventProcessFn> BuildProGuitarNoteProcessDict()
        {
            var processFnDict = new Dictionary<int, EventProcessFn>()
            {
            };

            foreach (var difficulty in EnumExtensions<MoonSong.Difficulty>.Values)
            {
                int difficultyStartRange = MidIOHelper.PRO_GUITAR_DIFF_START_LOOKUP[difficulty];
                foreach (var proString in EnumExtensions<MoonNote.ProGuitarString>.Values)
                {
                    int key = (int)proString + difficultyStartRange;
                    processFnDict.Add(key, (ref EventProcessParams eventProcessParams) =>
                    {
                        if (eventProcessParams.timedEvent.midiEvent is not NoteEvent noteEvent)
                        {
                            YargLogger.FailFormat("Wrong note event type! Expected: {0}, Actual: {1}",
                                typeof(NoteEvent), eventProcessParams.timedEvent.midiEvent.GetType());
                            return;
                        }

                        if (noteEvent.Velocity < 100)
                        {
                            YargLogger.LogFormatWarning("Encountered Pro Guitar note with invalid fret velocity {0}! Must be at least 100", noteEvent.Velocity);
                            return;
                        }

                        int fret = noteEvent.Velocity - 100;
                        int rawNote = MoonNote.MakeProGuitarRawNote(proString, fret);
                        if (!MidIOHelper.PRO_GUITAR_CHANNEL_FLAG_LOOKUP.TryGetValue(noteEvent.Channel, out var flags))
                            flags = MoonNote.Flags.None;

                        ProcessNoteOnEventAsNote(ref eventProcessParams, difficulty, rawNote, flags);
                    });
                }

                // Process forced hopo
                processFnDict.Add(difficultyStartRange + 6, (ref EventProcessParams eventProcessParams) =>
                {
                    ProcessNoteOnEventAsGuitarForcedType(ref eventProcessParams, difficulty, MoonNote.MoonNoteType.Hopo);
                });
            };

            return processFnDict;
        }

        private static Dictionary<int, EventProcessFn> BuildDrumsNoteProcessDict(bool enableVelocity = false)
        {
            var processFnDict = new Dictionary<int, EventProcessFn>()
            {
                { MidIOHelper.DRUM_FILL_NOTE_0, (ref EventProcessParams eventProcessParams) => {
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.ProDrums_Activation);
                }},
                { MidIOHelper.DRUM_FILL_NOTE_1, (ref EventProcessParams eventProcessParams) => {
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.ProDrums_Activation);
                }},
                { MidIOHelper.DRUM_FILL_NOTE_2, (ref EventProcessParams eventProcessParams) => {
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.ProDrums_Activation);
                }},
                { MidIOHelper.DRUM_FILL_NOTE_3, (ref EventProcessParams eventProcessParams) => {
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.ProDrums_Activation);
                }},
                { MidIOHelper.DRUM_FILL_NOTE_4, (ref EventProcessParams eventProcessParams) => {
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.ProDrums_Activation);
                }},
            };

            var DrumPadToMidiKey = new Dictionary<MoonNote.DrumPad, int>()
            {
                { MoonNote.DrumPad.Kick, 0 },
                { MoonNote.DrumPad.Red, 1 },
                { MoonNote.DrumPad.Yellow, 2 },
                { MoonNote.DrumPad.Blue, 3 },
                { MoonNote.DrumPad.Orange, 4 },
                { MoonNote.DrumPad.Green, 5 },
            };

            var DrumPadDefaultFlags = new Dictionary<MoonNote.DrumPad, MoonNote.Flags>()
            {
                { MoonNote.DrumPad.Yellow, MoonNote.Flags.ProDrums_Cymbal },
                { MoonNote.DrumPad.Blue, MoonNote.Flags.ProDrums_Cymbal },
                { MoonNote.DrumPad.Orange, MoonNote.Flags.ProDrums_Cymbal },
            };

            foreach (var difficulty in EnumExtensions<MoonSong.Difficulty>.Values)
            {
                int difficultyStartRange = MidIOHelper.DRUMS_DIFF_START_LOOKUP[difficulty];
                foreach (var pad in EnumExtensions<MoonNote.DrumPad>.Values)
                {
                    if (DrumPadToMidiKey.TryGetValue(pad, out int padOffset))
                    {
                        int key = padOffset + difficultyStartRange;
                        int fret = (int)pad;
                        var defaultFlags = MoonNote.Flags.None;
                        DrumPadDefaultFlags.TryGetValue(pad, out defaultFlags);

                        if (enableVelocity && pad != MoonNote.DrumPad.Kick)
                        {
                            processFnDict.Add(key, (ref EventProcessParams eventProcessParams) =>
                            {
                                if (eventProcessParams.timedEvent.midiEvent is not NoteEvent noteEvent)
                                {
                                    YargLogger.FailFormat("Wrong note event type! Expected: {0}, Actual: {1}",
                                        typeof(NoteEvent), eventProcessParams.timedEvent.midiEvent.GetType());
                                    return;
                                }

                                var flags = defaultFlags;
                                switch (noteEvent.Velocity)
                                {
                                    case MidIOHelper.VELOCITY_ACCENT:
                                        flags |= MoonNote.Flags.ProDrums_Accent;
                                        break;
                                    case MidIOHelper.VELOCITY_GHOST:
                                        flags |= MoonNote.Flags.ProDrums_Ghost;
                                        break;
                                    default:
                                        break;
                                }

                                ProcessNoteOnEventAsNote(ref eventProcessParams, difficulty, fret, flags);
                            });
                        }
                        else
                        {
                            processFnDict.Add(key, (ref EventProcessParams eventProcessParams) =>
                            {
                                ProcessNoteOnEventAsNote(ref eventProcessParams, difficulty, fret, defaultFlags);
                            });
                        }

                        // Double-kick
                        if (pad == MoonNote.DrumPad.Kick)
                        {
                            processFnDict.Add(key - 1, (ref EventProcessParams eventProcessParams) => {
                                ProcessNoteOnEventAsNote(ref eventProcessParams, difficulty, fret, MoonNote.Flags.InstrumentPlus);
                            });
                        }
                    }
                }
            };

            foreach (var keyVal in MidIOHelper.PAD_TO_CYMBAL_LOOKUP)
            {
                int pad = (int)keyVal.Key;
                int midiKey = keyVal.Value;

                processFnDict.Add(midiKey, (ref EventProcessParams eventProcessParams) =>
                {
                    ProcessNoteOnEventAsFlagToggle(ref eventProcessParams, MoonNote.Flags.ProDrums_Cymbal, pad);
                });
            }

            return processFnDict;
        }

        private static Dictionary<int, EventProcessFn> BuildVocalsNoteProcessDict()
        {
            var processFnDict = new Dictionary<int, EventProcessFn>()
            {
                { MidIOHelper.RANGE_SHIFT_NOTE, (ref EventProcessParams eventProcessParams) =>
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.Vocals_RangeShift)
                },
                { MidIOHelper.LYRIC_SHIFT_NOTE, (ref EventProcessParams eventProcessParams) =>
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.Vocals_LyricShift)
                },

                { MidIOHelper.LYRICS_PHRASE_1, (ref EventProcessParams eventProcessParams) => {
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.Versus_Player1);
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.Vocals_LyricPhrase);
                }},
                { MidIOHelper.LYRICS_PHRASE_2, (ref EventProcessParams eventProcessParams) => {
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.Versus_Player2);
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams, MoonPhrase.Type.Vocals_LyricPhrase);
                }},

                { MidIOHelper.PERCUSSION_NOTE, (ref EventProcessParams eventProcessParams) => {
                    foreach (var difficulty in EnumExtensions<MoonSong.Difficulty>.Values)
                    {
                        // Force percussion notes to be 0-length
                        var newParams = eventProcessParams;
                        newParams.timedEvent.endTick = newParams.timedEvent.startTick;
                        ProcessNoteOnEventAsNote(ref newParams, difficulty, 0, MoonNote.Flags.Vocals_Percussion,
                            sustainCutoff: false);
                    };
                }},
            };

            for (int i = MidIOHelper.VOCALS_RANGE_START; i <= MidIOHelper.VOCALS_RANGE_END; i++)
            {
                int rawNote = i; // Capture the note value
                processFnDict.Add(i, (ref EventProcessParams eventProcessParams) => {
                    foreach (var difficulty in EnumExtensions<MoonSong.Difficulty>.Values)
                    {
                        ProcessNoteOnEventAsNote(ref eventProcessParams, difficulty, rawNote, sustainCutoff: false);
                    };
                });
            }

            return processFnDict;
        }

        private static Dictionary<int, EventProcessFn> BuildProKeysNoteProcessDict()
        {
            var processFnDict = new Dictionary<int, EventProcessFn>()
            {
                { MidIOHelper.PRO_KEYS_SHIFT_0, (ref EventProcessParams eventProcessParams) =>
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams,
                        MoonPhrase.Type.ProKeys_RangeShift0, eventProcessParams.trackDifficulty)
                },
                { MidIOHelper.PRO_KEYS_SHIFT_1, (ref EventProcessParams eventProcessParams) =>
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams,
                        MoonPhrase.Type.ProKeys_RangeShift1, eventProcessParams.trackDifficulty)
                },
                { MidIOHelper.PRO_KEYS_SHIFT_2, (ref EventProcessParams eventProcessParams) =>
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams,
                        MoonPhrase.Type.ProKeys_RangeShift2, eventProcessParams.trackDifficulty)
                },
                { MidIOHelper.PRO_KEYS_SHIFT_3, (ref EventProcessParams eventProcessParams) =>
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams,
                        MoonPhrase.Type.ProKeys_RangeShift3, eventProcessParams.trackDifficulty)
                },
                { MidIOHelper.PRO_KEYS_SHIFT_4, (ref EventProcessParams eventProcessParams) =>
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams,
                        MoonPhrase.Type.ProKeys_RangeShift4, eventProcessParams.trackDifficulty)
                },
                { MidIOHelper.PRO_KEYS_SHIFT_5, (ref EventProcessParams eventProcessParams) =>
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams,
                        MoonPhrase.Type.ProKeys_RangeShift5, eventProcessParams.trackDifficulty)
                },

                { MidIOHelper.PRO_KEYS_GLISSANDO, (ref EventProcessParams eventProcessParams) =>
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams,
                        MoonPhrase.Type.ProKeys_Glissando, eventProcessParams.trackDifficulty)
                },
                { MidIOHelper.TRILL_LANE_NOTE, (ref EventProcessParams eventProcessParams) =>
                    ProcessNoteOnEventAsSpecialPhrase(ref eventProcessParams,
                        MoonPhrase.Type.TrillLane, eventProcessParams.trackDifficulty)
                },
            };

            for (int key = MidIOHelper.PRO_KEYS_RANGE_START; key <= MidIOHelper.PRO_KEYS_RANGE_END; key++)
            {
                int fret = key - MidIOHelper.PRO_KEYS_RANGE_START;

                processFnDict.Add(key, (ref EventProcessParams eventProcessParams) =>
                {
                    if (eventProcessParams.trackDifficulty is null)
                    {
                        YargLogger.Fail("`trackDifficulty` cannot be null when processing Pro Keys!");
                        return;
                    }

                    var diff = eventProcessParams.trackDifficulty.Value;
                    ProcessNoteOnEventAsNote(ref eventProcessParams, diff, fret);
                });
            }

            return processFnDict;
        }
    }
}
</file>

<file path="MoonscraperChartParser/IO/Midi/PhaseShiftSysEx.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System;
using System.Collections.Generic;
using System.Linq;
using Melanchall.DryWetMidi.Core;

namespace MoonscraperChartEditor.Song.IO
{
    // SysEx event format: https://dwsk.proboards.com/thread/404/song-standard-advancements
    internal class PhaseShiftSysEx : SysExEvent
    {
        public enum Type : byte
        {
            Phrase = 0x00
        }

        public enum Difficulty : byte
        {
            Easy = 0x00,
            Medium = 0x01,
            Hard = 0x02,
            Expert = 0x03,

            All = 0xFF
        }

        public enum PhraseCode : byte
        {
            Guitar_Open = 0x01,
            Guitar_Tap = 0x04,

            RealDrums_HihatOpen = 0x05,
            RealDrums_HihatPedal = 0x06,
            RealDrums_SnareRimshot = 0x07,
            RealDrums_HihatSizzle = 0x08,
            RealDrums_CymbalAndTomYellow = 0x11,
            RealDrums_CymbalAndTomBlue = 0x12,
            RealDrums_CymbalAndTomGreen = 0x13,

            ProGuitar_SlideUp = 0x02,
            ProGuitar_SlideDown = 0x03,
            ProGuitar_PalmMute = 0x09,
            ProGuitar_Vibrato = 0x0A,
            ProGuitar_Harmonic = 0x0B,
            ProGuitar_PinchHarmonic = 0x0C,
            ProGuitar_Bend = 0x0D,
            ProGuitar_Accent = 0x0E,
            ProGuitar_Pop = 0x0F,
            ProGuitar_Slap = 0x10,
        }

        public enum PhraseValue : byte
        {
            End = 0x00,
            Start = 0x01,
        }

        // Data as provided by DryWetMidi:
        // sysexData[0-2]: Header
        // sysexData[3]: Event type
        // sysexData[4]: Difficulty
        // sysexData[5]: Event code
        // sysexData[6]: Event value
        // sysexData[7]: SysEx terminator (F7)

        private const int EXPECTED_LENGTH = 8;

        private const int INDEX_TYPE = 3;
        private const int INDEX_DIFFICULTY = 4;
        private const int INDEX_CODE = 5;
        private const int INDEX_VALUE = 6;

        private static readonly Range HEADER_RANGE = ..3;
        private static readonly byte[] HEADER = { 0x50, 0x53, 0x00 }; // "PS\0"

        public static readonly Dictionary<Difficulty, MoonSong.Difficulty> SysExDiffToMsDiff = new()
        {
            { Difficulty.Easy, MoonSong.Difficulty.Easy },
            { Difficulty.Medium, MoonSong.Difficulty.Medium },
            { Difficulty.Hard, MoonSong.Difficulty.Hard },
            { Difficulty.Expert, MoonSong.Difficulty.Expert }
        };

        public static readonly Dictionary<MoonSong.Difficulty, Difficulty> MsDiffToSysExDiff =
            SysExDiffToMsDiff.ToDictionary((i) => i.Value, (i) => i.Key);

        private byte m_type;
        private byte m_difficulty;
        public byte code;
        public byte value;

        public Type type
        {
            get => (Type)m_type;
            set => m_type = (byte)value;
        }

        public Difficulty difficulty
        {
            get => (Difficulty)m_difficulty;
            set => m_difficulty = (byte)value;
        }

        public PhraseCode phraseCode
        {
            get => (PhraseCode)code;
            set => code = (byte)value;
        }

        public PhraseValue phraseValue
        {
            get => (PhraseValue)value;
            set => this.value = (byte)value;
        }

        protected PhaseShiftSysEx() : base(MidiEventType.NormalSysEx)
        { }

        protected PhaseShiftSysEx(PhaseShiftSysEx other) : this()
        {
            DeltaTime = other.DeltaTime;
            m_type = other.m_type;
            m_difficulty = other.m_difficulty;
            code = other.code;
            value = other.value;
        }

        public PhaseShiftSysEx(SysExEvent sysex) : this()
        {
            if (!TryParseInternal(sysex, this))
            {
                throw new ArgumentException("The given event data is not a Phase Shift SysEx event.", nameof(sysex));
            }
        }

        public static bool TryParse(SysExEvent sysex, out PhaseShiftSysEx psSysex)
        {
            psSysex = new PhaseShiftSysEx();
            return TryParseInternal(sysex, psSysex);
        }

        protected static bool TryParseInternal(SysExEvent sysex, PhaseShiftSysEx psSysex)
        {
            byte[] sysexData = sysex.Data;
            if (IsPhaseShiftSysex(sysexData))
            {
                psSysex.DeltaTime = sysex.DeltaTime;
                psSysex.m_type = sysexData[INDEX_TYPE];
                psSysex.m_difficulty = sysexData[INDEX_DIFFICULTY];
                psSysex.code = sysexData[INDEX_CODE];
                psSysex.value = sysexData[INDEX_VALUE];

                return true;
            }
            else
            {
                return false;
            }
        }

        public static bool IsPhaseShiftSysex(ReadOnlySpan<byte> sysexData)
        {
            if (sysexData == null)
                throw new ArgumentNullException(nameof(sysexData));

            return sysexData.Length == EXPECTED_LENGTH && sysexData[HEADER_RANGE].SequenceEqual(HEADER);
        }

        public bool MatchesWith(PhaseShiftSysEx otherEvent)
        {
            return type == otherEvent.type && difficulty == otherEvent.difficulty && code == otherEvent.code;
        }

        public override string ToString()
        {
            return $"DeltaTime: {DeltaTime}, Type: {type}, Difficulty: {difficulty}, Code: {code}, Value: {value}";
        }

        protected override MidiEvent CloneEvent()
        {
            return new PhaseShiftSysEx(this);
        }
    }
}
</file>

<file path="MoonscraperChartParser/IO/NoteFlagPriority.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace MoonscraperChartEditor.Song.IO
{
    internal class NoteFlagPriority
    {
        // Flags to skip adding if the corresponding flag is already present
        private static readonly Dictionary<MoonNote.Flags, MoonNote.Flags> NoteBlockingFlagsLookup = new()
        {
            { MoonNote.Flags.Forced, MoonNote.Flags.Tap },
            { MoonNote.Flags.ProDrums_Ghost, MoonNote.Flags.ProDrums_Accent },
        };

        // Flags to remove if the corresponding flag is being added
        private static readonly Dictionary<MoonNote.Flags, MoonNote.Flags> NoteFlagsToRemoveLookup =
            NoteBlockingFlagsLookup.ToDictionary((i) => i.Value, (i) => i.Key);

        public static readonly NoteFlagPriority Forced = new(MoonNote.Flags.Forced);
        public static readonly NoteFlagPriority Tap = new(MoonNote.Flags.Tap);
        public static readonly NoteFlagPriority InstrumentPlus = new(MoonNote.Flags.InstrumentPlus);
        public static readonly NoteFlagPriority Cymbal = new(MoonNote.Flags.ProDrums_Cymbal);
        public static readonly NoteFlagPriority Accent = new(MoonNote.Flags.ProDrums_Accent);
        public static readonly NoteFlagPriority Ghost = new(MoonNote.Flags.ProDrums_Ghost);

        private static readonly List<NoteFlagPriority> priorities = new()
        {
            Forced,
            Tap,
            InstrumentPlus,
            Cymbal,
            Accent,
            Ghost,
        };

        public MoonNote.Flags flagToAdd { get; } = MoonNote.Flags.None;
        public MoonNote.Flags blockingFlag { get; } = MoonNote.Flags.None;
        public MoonNote.Flags flagToRemove { get; } = MoonNote.Flags.None;

        public NoteFlagPriority(MoonNote.Flags flag)
        {
            flagToAdd = flag;

            if (NoteBlockingFlagsLookup.TryGetValue(flagToAdd, out var blockingFlag))
            {
                this.blockingFlag = blockingFlag;
            }

            if (NoteFlagsToRemoveLookup.TryGetValue(flagToAdd, out var flagToRemove))
            {
                this.flagToRemove = flagToRemove;
            }
        }

        public bool TryApplyToNote(MoonNote note)
        {
            // Don't add if the flag to be added is lower-priority than a conflicting, already-added flag
            if (blockingFlag != MoonNote.Flags.None && note.flags.HasFlag(blockingFlag))
            {
                return false;
            }

            // Flag can be added without issue
            note.flags |= flagToAdd;

            // Remove flags that are lower-priority than the added flag
            if (flagToRemove != MoonNote.Flags.None && note.flags.HasFlag(flagToRemove))
            {
                note.flags &= ~flagToRemove;
            }

            return true;
        }

        public bool AreFlagsValid(MoonNote.Flags flags)
        {
            if (flagToAdd == MoonNote.Flags.None)
            {
                // No flag to validate against
                return true;
            }

            if (blockingFlag != MoonNote.Flags.None)
            {
                if (flags.HasFlag(blockingFlag) && flags.HasFlag(flagToAdd))
                {
                    // Note has conflicting flags
                    return false;
                }
            }

            if (flagToRemove != MoonNote.Flags.None)
            {
                if (flags.HasFlag(flagToAdd) && flags.HasFlag(flagToRemove))
                {
                    // Note has conflicting flags
                    return false;
                }
            }

            return true;
        }

        public static bool AreFlagsValidForAll(MoonNote.Flags flags, [NotNullWhen(false)] out NoteFlagPriority? invalidPriority)
        {
            foreach (var priority in priorities)
            {
                if (!priority.AreFlagsValid(flags))
                {
                    invalidPriority = priority;
                    return false;
                }
            }

            invalidPriority = null;
            return true;
        }
    }
}
</file>

<file path="MoonscraperChartParser/LICENSE">
BSD 3-Clause License

Copyright (c) 2016-2021, Alexander Ong
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</file>

<file path="MoonscraperChartParser/Metadata.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System.Diagnostics.CodeAnalysis;

namespace MoonscraperChartEditor.Song
{
    internal class Metadata
    {
        private string m_name, m_artist, m_charter, m_genre, m_album;

        public string name
        {
            get => m_name;
            [MemberNotNull(nameof(m_name))]
            set => m_name = MakeValidMetadataString(value);
        }

        public string artist
        {
            get => m_artist;
            [MemberNotNull(nameof(m_artist))]
            set => m_artist = MakeValidMetadataString(value);
        }

        public string charter
        {
            get => m_charter;
            [MemberNotNull(nameof(m_charter))]
            set => m_charter = MakeValidMetadataString(value);
        }

        public string genre
        {
            get => m_genre;
            [MemberNotNull(nameof(m_genre))]
            set => m_genre = MakeValidMetadataString(value);
        }

        public string album
        {
            get => m_album;
            [MemberNotNull(nameof(m_album))]
            set => m_album = MakeValidMetadataString(value);
        }

        public string year;

        public int difficulty;
        public float previewStart, previewEnd;

        public Metadata()
        {
            name = artist = charter = album = year = string.Empty;
            difficulty = 0;
            previewStart = previewEnd = 0;
            genre = "rock";
        }

        public Metadata(Metadata metaData)
        {
            name = metaData.name;
            artist = metaData.artist;
            charter = metaData.charter;
            album = metaData.album;
            year = metaData.year;
            difficulty = metaData.difficulty;
            previewStart = metaData.previewStart;
            previewEnd = metaData.previewEnd;
            genre = metaData.genre;
        }

        private string MakeValidMetadataString(string v)
        {
            return v.Replace("\"", string.Empty);
        }
    }
}
</file>

<file path="MoonscraperChartParser/MoonChart.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System.Collections.Generic;

namespace MoonscraperChartEditor.Song
{
    internal class MoonChart
    {
        /// <summary>
        /// The song this chart is connected to.
        /// </summary>
        public MoonSong song { get; private set; }
        /// <summary>
        /// The game mode the chart is designed for
        /// </summary>
        public GameMode gameMode { get; private set; }

        /// <summary>
        /// Read only list of notes.
        /// </summary>
        public List<MoonNote> notes { get; private set; } = new();
        /// <summary>
        /// Read only list of special phrases.
        /// </summary>
        public List<MoonPhrase> specialPhrases { get; private set; } = new();
        /// <summary>
        /// Read only list of local events.
        /// </summary>
        public List<MoonText> events { get; private set; } = new();

        public bool IsEmpty => notes.Count == 0 && specialPhrases.Count == 0 && events.Count == 0;

        /// <summary>
        /// Creates a new chart object.
        /// </summary>
        /// <param name="_song">The song to associate this chart with.</param>
        public MoonChart(MoonSong _song, GameMode _gameMode)
        {
            song = _song;
            gameMode = _gameMode;
        }

        public MoonChart(MoonSong song, MoonSong.MoonInstrument Instrument)
            : this(song, MoonSong.InstrumentToChartGameMode(Instrument))
        {
        }

        public void Clear()
        {
            notes.Clear();
            events.Clear();
            specialPhrases.Clear();
        }

        public int Add(MoonNote note)
        {
            return MoonObjectHelper.Insert(note, notes);
        }

        public int Add(MoonPhrase phrase)
        {
            return MoonObjectHelper.Insert(phrase, specialPhrases);
        }

        public int Add(MoonText ev)
        {
            return MoonObjectHelper.Insert(ev, events);
        }

        public bool Remove(MoonNote note)
        {
            return MoonObjectHelper.Remove(note, notes);
        }

        public bool Remove(MoonPhrase phrase)
        {
            return MoonObjectHelper.Remove(phrase, specialPhrases);
        }

        public bool Remove(MoonText ev)
        {
            return MoonObjectHelper.Remove(ev, events);
        }

        public enum GameMode
        {
            Guitar,
            Drums,
            GHLGuitar,
            ProGuitar,
            ProKeys,
            Vocals,
        }
    }
}
</file>

<file path="MoonscraperChartParser/MoonSong.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System;
using System.Collections;
using System.Collections.Generic;
using YARG.Core.Chart;
using YARG.Core.Extensions;

namespace MoonscraperChartEditor.Song
{
    internal class MoonSong
    {
        public uint resolution => syncTrack.Resolution;
        public uint hopoThreshold;

        // Charts
        private readonly MoonChart[] charts;

        public IReadOnlyList<MoonChart> Charts => charts;

        /// <summary>
        /// Read only list of song events.
        /// </summary>
        public List<MoonText> events { get; private set; } = new();
        /// <summary>
        /// Read only list of song sections.
        /// </summary>
        public List<MoonText> sections { get; private set; } = new();
        /// <summary>
        /// Read only list of venue events.
        /// </summary>
        public List<MoonVenue> venue { get; private set; } = new();

        public SyncTrack syncTrack { get; private set; }

        /// <summary>
        /// Default constructor for a new chart. Initialises all lists and adds locked bpm and timesignature objects.
        /// </summary>
        public MoonSong(uint resolution)
        {
            syncTrack = new(resolution);
            syncTrack.Tempos.Add(new TempoChange(120, 0, 0));
            syncTrack.TimeSignatures.Add(new TimeSignatureChange(4, 4, 0, 0));

            // Chart initialisation
            charts = new MoonChart[EnumExtensions<MoonInstrument>.Count * EnumExtensions<Difficulty>.Count];
            for (int i = 0; i < charts.Length; ++i)
            {
                var instrument = (MoonInstrument)(i / EnumExtensions<Difficulty>.Count);
                charts[i] = new MoonChart(this, instrument);
            }
        }

        public MoonChart GetChart(MoonInstrument instrument, Difficulty difficulty)
        {
            return charts[(int)instrument * EnumExtensions<Difficulty>.Count + (int)difficulty];
        }

        public bool ChartExistsForInstrument(MoonInstrument instrument)
        {
            foreach (var difficulty in EnumExtensions<Difficulty>.Values)
            {
                var chart = GetChart(instrument, difficulty);
                if (!chart.IsEmpty)
                {
                    return true;
                }
            }

            return false;
        }

        public bool DoesChartExist(MoonInstrument instrument, Difficulty difficulty)
        {
            return !GetChart(instrument, difficulty).IsEmpty;
        }

        public double TickToTime(uint tick)
        {
            return syncTrack.TickToTime(tick);
        }

        public double TickToTime(uint tick, TempoChange tempo)
        {
            return syncTrack.TickToTime(tick, tempo);
        }

        public uint TimeToTick(double time)
        {
            return syncTrack.TimeToTick(time);
        }

        public uint TimeToTick(double time, TempoChange tempo)
        {
            return syncTrack.TimeToTick(time, tempo);
        }

        public MoonText? GetPrevSection(uint position)
        {
            return MoonObjectHelper.GetPrevious(sections, position);
        }

        private void AddSyncEvent<TEvent>(List<TEvent> events, TEvent newEvent)
            where TEvent : SyncEvent
        {
            if (events.Count < 1)
            {
                events.Add(newEvent);
                return;
            }

            uint lastTick = events[^1].Tick;
            if (newEvent.Tick == lastTick)
            {
                // Replace
                events[^1] = newEvent;
            }
            else if (newEvent.Tick < lastTick)
            {
                throw new InvalidOperationException($"Out-of-order sync track event at tick {newEvent.Tick}!");
            }
            else
            {
                events.Add(newEvent);
            }
        }

        public void Add(Beatline beat)
        {
            AddSyncEvent(syncTrack.Beatlines, beat);
        }

        public void Add(TimeSignatureChange timeSig)
        {
            AddSyncEvent(syncTrack.TimeSignatures, timeSig);
        }

        public void Add(TempoChange bpm)
        {
            AddSyncEvent(syncTrack.Tempos, bpm);
        }

        public void Add(MoonText ev)
        {
            MoonObjectHelper.Insert(ev, events);
        }

        public void AddSection(MoonText section)
        {
            MoonObjectHelper.Insert(section, sections);
        }

        public void Add(MoonVenue venueEvent)
        {
            MoonObjectHelper.Insert(venueEvent, venue);
        }

        public bool Remove(MoonText ev)
        {
            return MoonObjectHelper.Remove(ev, events);
        }

        public bool RemoveSection(MoonText section)
        {
            return MoonObjectHelper.Remove(section, sections);
        }

        public bool Remove(MoonVenue venueEvent)
        {
            return MoonObjectHelper.Remove(venueEvent, venue);
        }

        public float ResolutionScaleRatio(uint targetResoltion)
        {
            return (float)targetResoltion / resolution;
        }

        public static MoonChart.GameMode InstrumentToChartGameMode(MoonInstrument instrument)
        {
            switch (instrument)
            {
                case MoonInstrument.Guitar:
                case MoonInstrument.GuitarCoop:
                case MoonInstrument.Bass:
                case MoonInstrument.Rhythm:
                case MoonInstrument.Keys:
                    return MoonChart.GameMode.Guitar;

                case MoonInstrument.Drums:
                    return MoonChart.GameMode.Drums;

                case MoonInstrument.GHLiveGuitar:
                case MoonInstrument.GHLiveBass:
                case MoonInstrument.GHLiveRhythm:
                case MoonInstrument.GHLiveCoop:
                    return MoonChart.GameMode.GHLGuitar;

                case MoonInstrument.ProGuitar_17Fret:
                case MoonInstrument.ProGuitar_22Fret:
                case MoonInstrument.ProBass_17Fret:
                case MoonInstrument.ProBass_22Fret:
                    return MoonChart.GameMode.ProGuitar;

                case MoonInstrument.ProKeys:
                    return MoonChart.GameMode.ProKeys;

                case MoonInstrument.Vocals:
                case MoonInstrument.Harmony1:
                case MoonInstrument.Harmony2:
                case MoonInstrument.Harmony3:
                    return MoonChart.GameMode.Vocals;

                default:
                    throw new NotImplementedException($"Unhandled instrument {instrument}!");
            }
        }

        public enum Difficulty
        {
            Expert = 0,
            Hard = 1,
            Medium = 2,
            Easy = 3
        }

        public enum MoonInstrument
        {
            Guitar,
            GuitarCoop,
            Bass,
            Rhythm,
            Keys,
            Drums,
            GHLiveGuitar,
            GHLiveBass,
            GHLiveRhythm,
            GHLiveCoop,
            ProGuitar_17Fret,
            ProGuitar_22Fret,
            ProBass_17Fret,
            ProBass_22Fret,
            ProKeys,
            Vocals,
            Harmony1,
            Harmony2,
            Harmony3,
        }

        public enum AudioInstrument
        {
            // Keep these in numerical order, there are a few places we're looping over these by casting to avoid GC allocs
            Song = 0,
            Guitar = 1,
            Bass = 2,
            Rhythm = 3,
            Drum = 4,
            Drums_2 = 5,
            Drums_3 = 6,
            Drums_4 = 7,
            Vocals = 8,
            Keys = 9,
            Crowd = 10
        }
    }

    internal class ReadOnlyList<T> : IList<T>, IEnumerable<T>
    {
        private readonly List<T> _realListHandle;
        public ReadOnlyList(List<T> realListHandle)
        {
            _realListHandle = realListHandle;
        }

        public T this[int index] { get { return _realListHandle[index]; } set { _realListHandle[index] = value; } }

        public int Count
        {
            get { return _realListHandle.Count; }
        }

        public bool IsReadOnly
        {
            get { return true; }
        }

        public void Add(T item)
        {
            throw new NotSupportedException();
        }

        public void Clear()
        {
            throw new NotSupportedException();
        }

        public bool Contains(T item)
        {
            return _realListHandle.Contains(item);
        }

        public void CopyTo(T[] array, int arrayIndex)
        {

        }

        public IEnumerator<T> GetEnumerator()
        {
            return _realListHandle.GetEnumerator();
        }

        public int IndexOf(T item)
        {
            return _realListHandle.IndexOf(item);
        }

        public void Insert(int index, T item)
        {
            throw new NotSupportedException();
        }

        public bool Remove(T item)
        {
            throw new NotSupportedException();
        }

        public void RemoveAt(int index)
        {
            throw new NotSupportedException();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return _realListHandle.GetEnumerator();
        }

        public T[] ToArray()
        {
            return _realListHandle.ToArray();
        }
    }
}
</file>

<file path="MoonscraperChartParser/SongObjectHelper.cs">
// Copyright (c) 2016-2020 Alexander Ong
// See LICENSE in project root for license information.

using System.Collections.Generic;

namespace MoonscraperChartEditor.Song
{
    internal static class MoonObjectHelper
    {
        public const int NOTFOUND = -1;

        /// <summary>
        /// Searches through the array and finds the array position of item most similar to the one provided.
        /// </summary>
        /// <typeparam name="T">Only objects that extend from the SongObject class.</typeparam>
        /// <param name="searchItem">The item you want to search for.</param>
        /// <param name="objects">The items you want to search through.</param>
        /// <returns>Returns the array position of the object most similar to the search item provided in the 'objects' parameter. 
        /// Returns SongObjectHelper.NOTFOUND if there are no objects provided. </returns>
        public static int FindClosestPosition<T>(T searchItem, IList<T> objects) where T : MoonObject
        {
            int lowerBound = 0;
            int upperBound = objects.Count - 1;
            int index = NOTFOUND;

            int midPoint;

            while (lowerBound <= upperBound)
            {
                midPoint = (lowerBound + upperBound) / 2;
                index = midPoint;

                if (objects[midPoint].InsertionEquals(searchItem))
                {
                    break;
                }
                else
                {
                    if (objects[midPoint].InsertionCompareTo(searchItem) < 0)
                    {
                        // data is in upper half
                        lowerBound = midPoint + 1;
                    }
                    else
                    {
                        // data is in lower half 
                        upperBound = midPoint - 1;
                    }
                }
            }
            return index;
        }

        /// <summary>
        /// Searches through the array and finds the array position of item with the closest position to the one provided.
        /// </summary>
        /// <typeparam name="T">Only objects that extend from the SongObject class.</typeparam>
        /// <param name="searchItem">The item you want to search for.</param>
        /// <param name="objects">The items you want to search through.</param>
        /// <returns>Returns the array position of the closest object located at the specified tick position. 
        /// Returns SongObjectHelper.NOTFOUND if there are no objects provided. </returns>
        public static int FindClosestPosition<T>(uint position, IList<T> objects) where T : MoonObject
        {
            int lowerBound = 0;
            int upperBound = objects.Count - 1;
            int index = NOTFOUND;

            int midPoint;

            while (lowerBound <= upperBound)
            {
                midPoint = (lowerBound + upperBound) / 2;
                index = midPoint;

                if (objects[midPoint].tick == position)
                {
                    break;
                }
                else
                {
                    if (objects[midPoint].tick < position)
                    {
                        // data is in upper half
                        lowerBound = midPoint + 1;
                    }
                    else
                    {
                        // data is in lower half 
                        upperBound = midPoint - 1;
                    }
                }
            }

            return index;
        }

        public static int FindClosestPositionRoundedDown<T>(uint tick, IList<T> objects) where T : MoonObject
        {
            int index = FindClosestPosition(tick, objects);

            if (index > 0 && objects[index].tick > tick)
                --index;

            return index;
        }

        /// <summary>
        /// Searches through the array to collect all the items found at the specified position.
        /// </summary>
        /// <typeparam name="T">Only objects that extend from the SongObject class.</typeparam>
        /// <param name="position">The tick position of the items.</param>
        /// <param name="objects">The list you want to search through.</param>
        /// <returns>Returns an array of items located at the specified tick position. 
        /// Returns an empty array if no items are at that exact tick position. </returns>
        public static void FindObjectsAtPosition<T>(uint position, IList<T> objects, out int startIndex, out int length) where T : MoonObject
        {
            int index = FindClosestPosition(position, objects);
            startIndex = 0;
            length = 0;

            if (index != NOTFOUND && objects[index].tick == position)
            {
                int lowRange = index, highRange = index;

                while (lowRange > 0 && objects[index].tick == objects[lowRange - 1].tick)
                {
                    --lowRange;
                }

                while (highRange < objects.Count - 1 && objects[index].tick == objects[highRange + 1].tick)
                {
                    ++highRange;
                }

                length = highRange - lowRange + 1;
                startIndex = lowRange;

                //T[] objectSelection = new T[length];
                //System.Array.Copy(objects, lowRange, objectSelection, 0, length);
                //
                //return objectSelection;
            }
        }

        /// <summary>
        /// Searches through the provided array to find the item specified.  
        /// </summary>
        /// <typeparam name="T">Only objects that extend from the SongObject class.</typeparam>
        /// <param name="searchItem">The item you want to search for.</param>
        /// <param name="objects">The items you want to search through.</param>
        /// <returns>Returns the array position that the search item was found at within the objects array. 
        /// Returns SongObjectHelper.NOTFOUND if the item does not exist in the objects array. </returns>
        public static int FindObjectPosition<T>(T searchItem, IList<T> objects) where T : MoonObject
        {
            int pos = FindClosestPosition(searchItem, objects);

            if (pos != NOTFOUND && objects[pos] != searchItem)
            {
                pos = NOTFOUND;
            }

            return pos;
        }

        public static int FindObjectPosition<T>(uint position, IList<T> objects) where T : MoonObject
        {
            int pos = FindClosestPosition(position, objects);

            if (pos != NOTFOUND && objects[pos].tick != position)
            {
                pos = NOTFOUND;
            }

            return pos;
        }

        private static int FindPreviousPosition<T>(System.Type type, int startPosition, IList<T> list) where T : MoonObject
        {
            // Linear search
            if (startPosition < 0 || startPosition > list.Count - 1)
                return NOTFOUND;
            else
            {
                --startPosition;

                while (startPosition >= 0)
                {
                    if (list[startPosition].GetType() == type)
                        return startPosition;
                    --startPosition;
                }

                return NOTFOUND;
            }
        }

        private static T? FindPreviousOfType<T>(System.Type type, int startPosition, IList<T> list) where T : MoonObject
        {
            int pos = FindPreviousPosition(type, startPosition, list);

            if (pos == NOTFOUND)
                return null;
            else
                return list[pos];
        }

        private static int FindNextPosition<T>(System.Type type, int startPosition, IList<T> list) where T : MoonObject
        {
            // Linear search
            if (startPosition < 0 || startPosition > list.Count - 1)
                return NOTFOUND;
            else
            {
                ++startPosition;

                while (startPosition < list.Count)
                {
                    if (list[startPosition].GetType() == type)
                        return startPosition;
                    ++startPosition;
                }

                return NOTFOUND;
            }
        }

        private static T? FindNextOfType<T>(System.Type type, int startPosition, IList<T> list) where T : MoonObject
        {
            int pos = FindNextPosition(type, startPosition, list);
            if (pos == NOTFOUND)
                return null;
            else
                return list[pos];
        }


        /// <summary>
        /// Pushes a MoonNote to the back of a list, ensuring correct setting of `previous` & `next` variables.
        /// </summary>
        /// <param name="note">The note to be inserted, with assumed correct ordering.</param>
        /// <param name="notes">The list in which the note will be inserted.</param>
        /// <returns>Returns the list position it was inserted into,
        /// which equates to the list size before insertion.</returns>
        public static int PushNote(MoonNote note, List<MoonNote> notes)
        {
            int pos = notes.Count;
            if (pos > 0)
            {
                note.previous = notes[pos - 1];
                notes[pos - 1].next = note;
            }
            notes.Add(note);
            return pos;
        }

        /// <summary>
        /// Insert a note into the provided list linearly, with the search starting from the back of the list.
        /// Ensures correct setting of 'previous' and 'next' variables.
        /// Use for handling .mid note off events
        /// </summary>
        /// <param name="note">The note to be inserted.</param>
        /// <param name="notes">The list in which the note will be inserted.</param>
        /// <returns>Returns the list position it was inserted into.</returns>
        public static int OrderedInsertFromBack(MoonNote note, List<MoonNote> notes)
        {
            int pos = notes.Count;
            while (pos > 0 && notes[pos - 1].tick > note.tick)
                --pos;

            if (pos > 0 && notes[pos - 1].tick == note.tick)
            {
                int check = pos - 1;
                do
                {
                    if (notes[check].InsertionEquals(note))
                        return check;
                    --check;
                } while (check >= 0 && notes[check].tick == note.tick);
            }

            if (pos > 0)
            {
                note.previous = notes[pos - 1];
                notes[pos - 1].next = note;
            }

            if (pos < notes.Count)
            {
                notes[pos].previous = note;
                note.next = notes[pos];
            }
            notes.Insert(pos, note);
            return pos;
        }

        /// <summary>
        /// Insert an item into the provided list linearly, with the search starting from the back of the list.
        /// Use for handling .mid note off events
        /// </summary>
        /// <param name="item">The item to be inserted.</param>
        /// <param name="list">The list in which the item will be inserted.</param>
        /// <returns>Returns the list position it was inserted into.</returns>
        public static int OrderedInsertFromBack<T>(T item, List<T> list) where T : MoonObject
        {
            int pos = list.Count;
            while (pos > 0 && item.tick < list[pos - 1].tick)
                --pos;

            if (pos > 0 && list[pos - 1].tick == item.tick)
            {
                int check = pos - 1;
                do
                {
                    if (list[check].InsertionEquals(item))
                        return check;
                    --check;
                } while (check >= 0 && list[check].tick == item.tick);
            }

            list.Insert(pos, item);
            return pos;
        }

        /// <summary>
        /// Adds the item into a sorted position into the specified list and updates the note linked list if a note is inserted. 
        /// </summary>
        /// <typeparam name="T">Only objects that extend from the SongObject class.</typeparam>
        /// <param name="item">The item to be inserted.</param>
        /// <param name="list">The list in which the item will be inserted.</param>
        /// <returns>Returns the list position it was inserted into.</returns>
        public static int Insert<T>(T item, List<T> list) where T : MoonObject
        {
            int insertionPos = NOTFOUND;
            int count = list.Count;

            if (count > 0)
            {
                if (list[count - 1].InsertionCompareTo(item) < 0)
                {
                    insertionPos = count;
                    list.Add(item);
                }
                else if (list[count - 1].tick == item.tick && item.classID == list[count - 1].classID)
                {
                    // Linear search backwards
                    int pos = count - 1;
                    while (pos >= 0 && list[pos].InsertionCompareTo(item) >= 0)        // Find the next item less than the current one and insert into the position after that
                        --pos;

                    insertionPos = pos + 1;

                    // Account for overwrite
                    if (insertionPos < count && list[insertionPos].InsertionEquals(item))
                    {
                        list[insertionPos] = item;
                    }
                    else
                        list.Insert(insertionPos, item);
                }
                else
                {
                    insertionPos = FindClosestPosition(item, list);

                    if (insertionPos != NOTFOUND)
                    {
                        if (list[insertionPos].InsertionEquals(item) && item.classID == list[insertionPos].classID)
                        {
                            list[insertionPos] = item;
                        }
                        // Insert into sorted position
                        else
                        {
                            if (item.InsertionCompareTo(list[insertionPos]) > 0)
                            {
                                ++insertionPos;
                            }
                            list.Insert(insertionPos, item);
                        }
                    }
                }
            }

            if (insertionPos == NOTFOUND)
            {
                // Adding the first note
                list.Add(item);
                insertionPos = list.Count - 1;
            }

            if ((MoonObject.ID)item.classID == MoonObject.ID.Note && list[insertionPos] is MoonNote current)
            {
                // Update linked list
                var previous = FindPreviousOfType(typeof(MoonNote), insertionPos, list) as MoonNote;
                var next = FindNextOfType(typeof(MoonNote), insertionPos, list) as MoonNote;

                current.previous = previous;
                if (previous != null)
                    previous.next = current;

                current.next = next;
                if (next != null)
                    next.previous = current;

                // Update flags depending on open notes
                //Note.Flags flags = current.flags;
                //previous = current.previous;
                //next = current.next;
                //
                //Note openNote = null;
                ////bool openFound = false;
                //bool standardFound = false;
                //
                //// Collect all the flags
                //while (previous != null && previous.tick == current.tick)
                //{
                //    if (previous.IsOpenNote())
                //        openNote = previous;
                //    else
                //        standardFound = true;
                //
                //    flags |= previous.flags;
                //    previous = previous.previous;
                //}
                //
                //while (next != null && next.tick == current.tick)
                //{
                //    if (next.IsOpenNote())
                //        openNote = next;
                //    else
                //        standardFound = true;
                //
                //    flags |= next.flags;
                //    next = next.next;
                //}
                //
                //// Apply flags
                //if (!current.IsOpenNote() && openNote != null)
                //{
                //    //openNote.controller.Delete();
                //}
                //else if (current.IsOpenNote() && standardFound)
                //{ }
                //else
                //{
                //    current.flags = flags;
                //
                //    previous = current.previous;
                //    next = current.next;
                //    while (previous != null && previous.tick == current.tick)
                //    {
                //        previous.flags = flags;
                //        previous = previous.previous;
                //    }
                //
                //    while (next != null && next.tick == current.tick)
                //    {
                //        next.flags = flags;
                //        next = next.next;
                //    }
                //}
            }

            return insertionPos;
        }

        /// <summary>
        /// Removes the item from the specified list and updates the note linked list if a note is removed. 
        /// </summary>
        /// <typeparam name="T">Only objects that extend from the SongObject class.</typeparam>
        /// <param name="item">The item to be remove.</param>
        /// <param name="list">The list in which the item will be removed from.</param>
        /// <returns>Returns whether the item was successfully removed or not (may not be removed if the objects was not found).</returns>
        public static bool Remove(MoonNote item, IList<MoonNote> list, bool uniqueData = true)
        {
            int pos = FindObjectPosition(item, list);

            if (pos != NOTFOUND)
            {
                if (uniqueData)
                {
                    // Update linked list
                    var previous = FindPreviousOfType(item.GetType(), pos, list);
                    var next = FindNextOfType(item.GetType(), pos, list);

                    if (previous != null)
                        previous.next = next;

                    if (next != null)
                        next.previous = previous;
                }
                list.RemoveAt(pos);

                return true;
            }

            return false;
        }

        public static bool Remove<T>(T item, IList<T> list) where T : MoonObject
        {
            int pos = FindObjectPosition(item, list);
            if (pos != NOTFOUND)
            {
                list.RemoveAt(pos);
                return true;
            }
            return false;
        }


        public static T[] GetRangeCopy<T>(T[] list, uint minPos, uint maxPos) where T : MoonObject
        {
            GetRange(list, minPos, maxPos, out int index, out int length);

            var rangedList = new T[length];
            System.Array.Copy(list, index, rangedList, 0, rangedList.Length);

            return rangedList;
        }

        /// <summary>
        /// Gets a collection of items between a minimum and maximum tick position range.
        /// </summary>
        /// <typeparam name="T">Only objects that extend from the SongObject class.</typeparam>
        /// <param name="list">The list to search through.</param>
        /// <param name="minPos">The minimum range (inclusive).</param>
        /// <param name="maxPos">The maximum range (inclusive).</param>
        /// <returns>Returns all the objects found between the minimum and maximum tick positions specified.</returns>
        public static void GetRange<T>(IList<T> list, uint minPos, uint maxPos, out int index, out int length) where T : MoonObject
        {
            index = 0;
            length = 0;

            if (minPos > maxPos || list.Count < 1)
                return;

            int minArrayPos = FindClosestPosition(minPos, list);
            int maxArrayPos = FindClosestPosition(maxPos, list);

            if (minArrayPos == NOTFOUND || maxArrayPos == NOTFOUND)
                return;
            else
            {
                // Find position may return an object located at a lower position than the minimum position
                while (minArrayPos < list.Count && list[minArrayPos].tick < minPos)
                {
                    ++minArrayPos;
                }

                if (minArrayPos > list.Count - 1)
                    return;

                // Iterate to the very first object at a greater position, as there may be multiple objects located at the same position
                while (minArrayPos - 1 >= 0 && list[minArrayPos - 1].tick >= minPos)
                {
                    --minArrayPos;
                }

                // Find position may return an object locationed at a greater position than the maximum position
                while (maxArrayPos >= 0 && list[maxArrayPos].tick > maxPos)
                {
                    --maxArrayPos;
                }

                if (maxArrayPos < 0)
                    return;

                // Iterate to the very last object at a lesser position, as there may be multiple objects located at the same position
                while (maxArrayPos + 1 < list.Count && list[maxArrayPos + 1].tick <= maxPos)
                {
                    ++maxArrayPos;
                }

                if (minArrayPos > maxArrayPos)
                    return;

                index = minArrayPos;
                length = maxArrayPos - minArrayPos + 1;

                if (list[minArrayPos].tick < minPos || list[maxArrayPos].tick > maxPos)
                    length = 0;
            }
        }

        public static void sort<T>(T[] songObjects) where T : MoonObject
        {
            int j;
            T temp;
            for (int i = 1; i < songObjects.Length; i++)
            {
                temp = songObjects[i];
                j = i - 1;

                while (j >= 0 && songObjects[j].InsertionCompareTo(temp) > 0)
                {
                    songObjects[j + 1] = songObjects[j];
                    j--;
                }

                songObjects[j + 1] = temp;
            }
        }

        public static int GetIndexOfPrevious<T>(IList<T> songObjects, uint position) where T : MoonObject
        {
            int closestPos = FindClosestPosition(position, songObjects);
            if (closestPos != NOTFOUND)
            {
                // Select the smaller of the two
                if (songObjects[closestPos].tick <= position)
                    return closestPos;
                else if (closestPos > 0)
                    return closestPos - 1;
                else
                    return NOTFOUND;
            }

            return closestPos;
        }

        public static int GetIndexOfNext<T>(IList<T> songObjects, uint position) where T : MoonObject
        {
            int closestPos = FindClosestPosition(position, songObjects);
            if (closestPos != NOTFOUND)
            {
                // Select the larger of the two
                if (songObjects[closestPos].tick >= position)
                    return closestPos;
                else if (closestPos < songObjects.Count - 1)
                    return closestPos + 1;
                else
                    return NOTFOUND;
            }

            return closestPos;
        }

        public static T? GetPrevious<T>(IList<T> songObjects, uint position) where T : MoonObject
        {
            int pos = GetIndexOfPrevious(songObjects, position);
            if (pos != NOTFOUND)
                return songObjects[pos];
            else
                return null;
        }

        public static T? GetPreviousNonInclusive<T>(IList<T> songObjects, uint position) where T : MoonObject
        {
            int pos = GetIndexOfPrevious(songObjects, position);
            if (pos != NOTFOUND)
            {
                if (songObjects[pos].tick == position && pos > 0)
                    --pos;

                return songObjects[pos];
            }
            else
                return null;
        }

        public static T? GetNextNonInclusive<T>(IList<T> songObjects, uint position) where T : MoonObject
        {
            int pos = GetIndexOfNext(songObjects, position);
            if (pos != NOTFOUND)
            {
                if (songObjects[pos].tick == position && pos < songObjects.Count - 1)
                    ++pos;

                return songObjects[pos];
            }
            else
                return null;
        }
    }
}
</file>

<file path="obj/Debug/netstandard2.1/.NETStandard,Version=v2.1.AssemblyAttributes.cs">
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETStandard,Version=v2.1", FrameworkDisplayName = ".NET Standard 2.1")]
</file>

<file path="obj/Debug/netstandard2.1/YARG.Core.AssemblyInfo.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("YARG.Core")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+0a9f93505f22a7d3aaa710d6956ebda37ea8a95c")]
[assembly: System.Reflection.AssemblyProductAttribute("YARG.Core")]
[assembly: System.Reflection.AssemblyTitleAttribute("YARG.Core")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.
</file>

<file path="obj/Debug/netstandard2.1/YARG.Core.AssemblyInfoInputs.cache">
8e7146dde3a4aebb4f97278601c4b9b7d00a9a0a17b9cdcac6f6b944563624b3
</file>

<file path="obj/Debug/netstandard2.1/YARG.Core.csproj.CoreCompileInputs.cache">
c2520753c8678dc8bc11d1162c7a232616224ebed55eb77681f0d8730f5ebc26
</file>

<file path="obj/Debug/netstandard2.1/YARG.Core.csproj.FileListAbsolute.txt">
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/bin/Debug/netstandard2.1/YARG.Core.deps.json
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/bin/Debug/netstandard2.1/YARG.Core.dll
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/bin/Debug/netstandard2.1/YARG.Core.pdb
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Debug/netstandard2.1/YARG.Core.csproj.AssemblyReference.cache
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Debug/netstandard2.1/YARG.Core.GeneratedMSBuildEditorConfig.editorconfig
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Debug/netstandard2.1/YARG.Core.AssemblyInfoInputs.cache
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Debug/netstandard2.1/YARG.Core.AssemblyInfo.cs
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Debug/netstandard2.1/YARG.Core.csproj.CoreCompileInputs.cache
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Debug/netstandard2.1/YARG.Core.sourcelink.json
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Debug/netstandard2.1/YARG.Core.dll
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Debug/netstandard2.1/YARG.Core.pdb
</file>

<file path="obj/Debug/netstandard2.1/YARG.Core.GeneratedMSBuildEditorConfig.editorconfig">
is_global = true
build_property.RootNamespace = YARG.Core
build_property.ProjectDir = /Users/dionny/projects/YARG/YARG.Core/YARG.Core/
build_property.EnableComHosting = 
build_property.EnableGeneratedComInterfaceComImportInterop = 
build_property.CsWinRTUseWindowsUIXamlProjections = false
build_property.PolySharpUsePublicAccessibilityForGeneratedTypes = 
build_property.PolySharpIncludeRuntimeSupportedAttributes = 
build_property.PolySharpUseInteropServices2NamespaceForUnmanagedCallersOnlyAttribute = 
build_property.PolySharpExcludeGeneratedTypes = 
build_property.PolySharpIncludeGeneratedTypes = 
build_property.PolySharpExcludeTypeForwardedToDeclarations = 
build_property.EffectiveAnalysisLevelStyle = 
build_property.EnableCodeStyleSeverity =
</file>

<file path="obj/Debug/netstandard2.1/YARG.Core.sourcelink.json">
{"documents":{"/Users/dionny/projects/YARG/YARG.Core/*":"https://raw.githubusercontent.com/YARC-Official/YARG.Core/0a9f93505f22a7d3aaa710d6956ebda37ea8a95c/*"}}
</file>

<file path="obj/Release/netstandard2.1/.NETStandard,Version=v2.1.AssemblyAttributes.cs">
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETStandard,Version=v2.1", FrameworkDisplayName = ".NET Standard 2.1")]
</file>

<file path="obj/Release/netstandard2.1/PublishOutputs.cfbcd496df.txt">
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/bin/Release/netstandard2.1/publish/YARG.Core.dll
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/bin/Release/netstandard2.1/publish/YARG.Core.pdb
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/bin/Release/netstandard2.1/publish/Melanchall.DryWetMidi.dll
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/bin/Release/netstandard2.1/publish/Newtonsoft.Json.dll
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/bin/Release/netstandard2.1/publish/System.Runtime.CompilerServices.Unsafe.dll
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/bin/Release/netstandard2.1/publish/ZString.dll
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/bin/Release/netstandard2.1/publish/YARG.Core.deps.json
</file>

<file path="obj/Release/netstandard2.1/YARG.Core.AssemblyInfo.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("YARG.Core")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+0a9f93505f22a7d3aaa710d6956ebda37ea8a95c")]
[assembly: System.Reflection.AssemblyProductAttribute("YARG.Core")]
[assembly: System.Reflection.AssemblyTitleAttribute("YARG.Core")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.
</file>

<file path="obj/Release/netstandard2.1/YARG.Core.AssemblyInfoInputs.cache">
88267cad4bbd200004e84fec3649675f7c4940f05047415fa07a30c7eeaf62d4
</file>

<file path="obj/Release/netstandard2.1/YARG.Core.csproj.CoreCompileInputs.cache">
2fda5b4ea2409c87386ca3cd16a7bc2aed8949e530f095d6a6568a6392f13c9a
</file>

<file path="obj/Release/netstandard2.1/YARG.Core.csproj.FileListAbsolute.txt">
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/bin/Release/netstandard2.1/YARG.Core.deps.json
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/bin/Release/netstandard2.1/YARG.Core.dll
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/bin/Release/netstandard2.1/YARG.Core.pdb
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Release/netstandard2.1/YARG.Core.csproj.AssemblyReference.cache
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Release/netstandard2.1/YARG.Core.GeneratedMSBuildEditorConfig.editorconfig
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Release/netstandard2.1/YARG.Core.AssemblyInfoInputs.cache
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Release/netstandard2.1/YARG.Core.AssemblyInfo.cs
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Release/netstandard2.1/YARG.Core.csproj.CoreCompileInputs.cache
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Release/netstandard2.1/YARG.Core.sourcelink.json
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Release/netstandard2.1/YARG.Core.dll
/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/Release/netstandard2.1/YARG.Core.pdb
</file>

<file path="obj/Release/netstandard2.1/YARG.Core.deps.json">
{
  "runtimeTarget": {
    "name": ".NETStandard,Version=v2.1/",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETStandard,Version=v2.1": {},
    ".NETStandard,Version=v2.1/": {
      "YARG.Core/1.0.0": {
        "dependencies": {
          "Melanchall.DryWetMidi.Nativeless": "7.0.0",
          "Newtonsoft.Json": "13.0.3",
          "PolySharp": "1.13.2",
          "System.Runtime.CompilerServices.Unsafe": "6.0.0",
          "ZString": "2.5.1"
        },
        "runtime": {
          "YARG.Core.dll": {}
        }
      },
      "Melanchall.DryWetMidi.Nativeless/7.0.0": {
        "runtime": {
          "lib/netstandard2.0/Melanchall.DryWetMidi.dll": {
            "assemblyVersion": "7.0.0.0",
            "fileVersion": "7.0.0.0"
          }
        }
      },
      "Newtonsoft.Json/13.0.3": {
        "runtime": {
          "lib/netstandard2.0/Newtonsoft.Json.dll": {
            "assemblyVersion": "13.0.0.0",
            "fileVersion": "13.0.3.27908"
          }
        }
      },
      "PolySharp/1.13.2": {},
      "System.Runtime.CompilerServices.Unsafe/6.0.0": {
        "runtime": {
          "lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.dll": {
            "assemblyVersion": "6.0.0.0",
            "fileVersion": "6.0.21.52210"
          }
        }
      },
      "ZString/2.5.1": {
        "dependencies": {
          "System.Runtime.CompilerServices.Unsafe": "6.0.0"
        },
        "runtime": {
          "lib/netstandard2.1/ZString.dll": {
            "assemblyVersion": "2.5.1.0",
            "fileVersion": "2.5.1.0"
          }
        }
      }
    }
  },
  "libraries": {
    "YARG.Core/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Melanchall.DryWetMidi.Nativeless/7.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-85PE2K7X/4gHKfQOlAN32qNesYEoyBDSFHc+8O7s2q6fqgwSOipDveZI8D3cvtkVEKg/JfIadObEJHwTMvMuog==",
      "path": "melanchall.drywetmidi.nativeless/7.0.0",
      "hashPath": "melanchall.drywetmidi.nativeless.7.0.0.nupkg.sha512"
    },
    "Newtonsoft.Json/13.0.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-HrC5BXdl00IP9zeV+0Z848QWPAoCr9P3bDEZguI+gkLcBKAOxix/tLEAAHC+UvDNPv4a2d18lOReHMOagPa+zQ==",
      "path": "newtonsoft.json/13.0.3",
      "hashPath": "newtonsoft.json.13.0.3.nupkg.sha512"
    },
    "PolySharp/1.13.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-XwNhfkr7IeUiH8AE4pzob8YioxfL6nxgAx+fHEeWCObY/NZuBMfWLh39FznXbneKvagiqeeI7quIvZ6P1eVaEA==",
      "path": "polysharp/1.13.2",
      "hashPath": "polysharp.1.13.2.nupkg.sha512"
    },
    "System.Runtime.CompilerServices.Unsafe/6.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-/iUeP3tq1S0XdNNoMz5C9twLSrM/TH+qElHkXWaPvuNOt+99G75NrV0OS2EqHx5wMN7popYjpc8oTjC1y16DLg==",
      "path": "system.runtime.compilerservices.unsafe/6.0.0",
      "hashPath": "system.runtime.compilerservices.unsafe.6.0.0.nupkg.sha512"
    },
    "ZString/2.5.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-hHZnrIZAgda8j9n2gR4M7GbETcjr6EBo4CUnMtK8o2MgkgzARg+Y7XI142nNOpRRuup1LJb12/gd/tMhzwdw8g==",
      "path": "zstring/2.5.1",
      "hashPath": "zstring.2.5.1.nupkg.sha512"
    }
  }
}
</file>

<file path="obj/Release/netstandard2.1/YARG.Core.GeneratedMSBuildEditorConfig.editorconfig">
is_global = true
build_property.RootNamespace = YARG.Core
build_property.ProjectDir = /Users/dionny/projects/YARG/YARG.Core/YARG.Core/
build_property.EnableComHosting = 
build_property.EnableGeneratedComInterfaceComImportInterop = 
build_property.CsWinRTUseWindowsUIXamlProjections = false
build_property.PolySharpUsePublicAccessibilityForGeneratedTypes = 
build_property.PolySharpIncludeRuntimeSupportedAttributes = 
build_property.PolySharpUseInteropServices2NamespaceForUnmanagedCallersOnlyAttribute = 
build_property.PolySharpExcludeGeneratedTypes = 
build_property.PolySharpIncludeGeneratedTypes = 
build_property.PolySharpExcludeTypeForwardedToDeclarations = 
build_property.EffectiveAnalysisLevelStyle = 
build_property.EnableCodeStyleSeverity =
</file>

<file path="obj/Release/netstandard2.1/YARG.Core.genpublishdeps.cache">
1b31a5f55744f17fb987beb1825da04d606dda4c7a3164c22470b29840f81104
</file>

<file path="obj/Release/netstandard2.1/YARG.Core.sourcelink.json">
{"documents":{"/Users/dionny/projects/YARG/YARG.Core/*":"https://raw.githubusercontent.com/YARC-Official/YARG.Core/0a9f93505f22a7d3aaa710d6956ebda37ea8a95c/*"}}
</file>

<file path="obj/project.assets.json">
{
  "version": 3,
  "targets": {
    ".NETStandard,Version=v2.1": {
      "Melanchall.DryWetMidi.Nativeless/7.0.0": {
        "type": "package",
        "compile": {
          "lib/netstandard2.0/Melanchall.DryWetMidi.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/netstandard2.0/Melanchall.DryWetMidi.dll": {
            "related": ".xml"
          }
        }
      },
      "Newtonsoft.Json/13.0.3": {
        "type": "package",
        "compile": {
          "lib/netstandard2.0/Newtonsoft.Json.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/netstandard2.0/Newtonsoft.Json.dll": {
            "related": ".xml"
          }
        }
      },
      "PolySharp/1.13.2": {
        "type": "package",
        "build": {
          "buildTransitive/PolySharp.targets": {}
        }
      },
      "System.Runtime.CompilerServices.Unsafe/6.0.0": {
        "type": "package",
        "compile": {
          "lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.dll": {
            "related": ".xml"
          }
        }
      },
      "ZString/2.5.1": {
        "type": "package",
        "dependencies": {
          "System.Runtime.CompilerServices.Unsafe": "6.0.0"
        },
        "compile": {
          "lib/netstandard2.1/ZString.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/netstandard2.1/ZString.dll": {
            "related": ".xml"
          }
        }
      }
    }
  },
  "libraries": {
    "Melanchall.DryWetMidi.Nativeless/7.0.0": {
      "sha512": "85PE2K7X/4gHKfQOlAN32qNesYEoyBDSFHc+8O7s2q6fqgwSOipDveZI8D3cvtkVEKg/JfIadObEJHwTMvMuog==",
      "type": "package",
      "path": "melanchall.drywetmidi.nativeless/7.0.0",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "icon-nativeless.png",
        "lib/net45/Melanchall.DryWetMidi.dll",
        "lib/net45/Melanchall.DryWetMidi.xml",
        "lib/netstandard2.0/Melanchall.DryWetMidi.dll",
        "lib/netstandard2.0/Melanchall.DryWetMidi.xml",
        "melanchall.drywetmidi.nativeless.7.0.0.nupkg.sha512",
        "melanchall.drywetmidi.nativeless.nuspec"
      ]
    },
    "Newtonsoft.Json/13.0.3": {
      "sha512": "HrC5BXdl00IP9zeV+0Z848QWPAoCr9P3bDEZguI+gkLcBKAOxix/tLEAAHC+UvDNPv4a2d18lOReHMOagPa+zQ==",
      "type": "package",
      "path": "newtonsoft.json/13.0.3",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "LICENSE.md",
        "README.md",
        "lib/net20/Newtonsoft.Json.dll",
        "lib/net20/Newtonsoft.Json.xml",
        "lib/net35/Newtonsoft.Json.dll",
        "lib/net35/Newtonsoft.Json.xml",
        "lib/net40/Newtonsoft.Json.dll",
        "lib/net40/Newtonsoft.Json.xml",
        "lib/net45/Newtonsoft.Json.dll",
        "lib/net45/Newtonsoft.Json.xml",
        "lib/net6.0/Newtonsoft.Json.dll",
        "lib/net6.0/Newtonsoft.Json.xml",
        "lib/netstandard1.0/Newtonsoft.Json.dll",
        "lib/netstandard1.0/Newtonsoft.Json.xml",
        "lib/netstandard1.3/Newtonsoft.Json.dll",
        "lib/netstandard1.3/Newtonsoft.Json.xml",
        "lib/netstandard2.0/Newtonsoft.Json.dll",
        "lib/netstandard2.0/Newtonsoft.Json.xml",
        "newtonsoft.json.13.0.3.nupkg.sha512",
        "newtonsoft.json.nuspec",
        "packageIcon.png"
      ]
    },
    "PolySharp/1.13.2": {
      "sha512": "XwNhfkr7IeUiH8AE4pzob8YioxfL6nxgAx+fHEeWCObY/NZuBMfWLh39FznXbneKvagiqeeI7quIvZ6P1eVaEA==",
      "type": "package",
      "path": "polysharp/1.13.2",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "README.md",
        "analyzers/dotnet/cs/PolySharp.SourceGenerators.dll",
        "build/PolySharp.targets",
        "buildTransitive/PolySharp.targets",
        "icon.png",
        "polysharp.1.13.2.nupkg.sha512",
        "polysharp.nuspec"
      ]
    },
    "System.Runtime.CompilerServices.Unsafe/6.0.0": {
      "sha512": "/iUeP3tq1S0XdNNoMz5C9twLSrM/TH+qElHkXWaPvuNOt+99G75NrV0OS2EqHx5wMN7popYjpc8oTjC1y16DLg==",
      "type": "package",
      "path": "system.runtime.compilerservices.unsafe/6.0.0",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "Icon.png",
        "LICENSE.TXT",
        "THIRD-PARTY-NOTICES.TXT",
        "buildTransitive/netcoreapp2.0/System.Runtime.CompilerServices.Unsafe.targets",
        "buildTransitive/netcoreapp3.1/_._",
        "lib/net461/System.Runtime.CompilerServices.Unsafe.dll",
        "lib/net461/System.Runtime.CompilerServices.Unsafe.xml",
        "lib/net6.0/System.Runtime.CompilerServices.Unsafe.dll",
        "lib/net6.0/System.Runtime.CompilerServices.Unsafe.xml",
        "lib/netcoreapp3.1/System.Runtime.CompilerServices.Unsafe.dll",
        "lib/netcoreapp3.1/System.Runtime.CompilerServices.Unsafe.xml",
        "lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.dll",
        "lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.xml",
        "system.runtime.compilerservices.unsafe.6.0.0.nupkg.sha512",
        "system.runtime.compilerservices.unsafe.nuspec",
        "useSharedDesignerContext.txt"
      ]
    },
    "ZString/2.5.1": {
      "sha512": "hHZnrIZAgda8j9n2gR4M7GbETcjr6EBo4CUnMtK8o2MgkgzARg+Y7XI142nNOpRRuup1LJb12/gd/tMhzwdw8g==",
      "type": "package",
      "path": "zstring/2.5.1",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "Icon.png",
        "lib/net6.0/ZString.dll",
        "lib/net6.0/ZString.xml",
        "lib/net7.0/ZString.dll",
        "lib/net7.0/ZString.xml",
        "lib/netstandard2.0/ZString.dll",
        "lib/netstandard2.0/ZString.xml",
        "lib/netstandard2.1/ZString.dll",
        "lib/netstandard2.1/ZString.xml",
        "zstring.2.5.1.nupkg.sha512",
        "zstring.nuspec"
      ]
    }
  },
  "projectFileDependencyGroups": {
    ".NETStandard,Version=v2.1": [
      "Melanchall.DryWetMidi.Nativeless >= 7.0.0",
      "Newtonsoft.Json >= 13.0.3",
      "PolySharp >= 1.13.2",
      "System.Runtime.CompilerServices.Unsafe >= 6.0.0",
      "ZString >= 2.5.1"
    ]
  },
  "packageFolders": {
    "/Users/dionny/.nuget/packages/": {}
  },
  "project": {
    "version": "1.0.0",
    "restore": {
      "projectUniqueName": "/Users/dionny/projects/YARG/YARG.Core/YARG.Core/YARG.Core.csproj",
      "projectName": "YARG.Core",
      "projectPath": "/Users/dionny/projects/YARG/YARG.Core/YARG.Core/YARG.Core.csproj",
      "packagesPath": "/Users/dionny/.nuget/packages/",
      "outputPath": "/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/",
      "projectStyle": "PackageReference",
      "configFilePaths": [
        "/Users/dionny/.nuget/NuGet/NuGet.Config"
      ],
      "originalTargetFrameworks": [
        "netstandard2.1"
      ],
      "sources": {
        "https://api.nuget.org/v3/index.json": {}
      },
      "frameworks": {
        "netstandard2.1": {
          "targetAlias": "netstandard2.1",
          "projectReferences": {}
        }
      },
      "warningProperties": {
        "warnAsError": [
          "NU1605"
        ]
      },
      "restoreAuditProperties": {
        "enableAudit": "true",
        "auditLevel": "low",
        "auditMode": "direct"
      },
      "SdkAnalysisLevel": "9.0.200"
    },
    "frameworks": {
      "netstandard2.1": {
        "targetAlias": "netstandard2.1",
        "dependencies": {
          "Melanchall.DryWetMidi.Nativeless": {
            "target": "Package",
            "version": "[7.0.0, )"
          },
          "Newtonsoft.Json": {
            "target": "Package",
            "version": "[13.0.3, )"
          },
          "PolySharp": {
            "include": "Runtime, Build, Native, ContentFiles, Analyzers, BuildTransitive",
            "suppressParent": "All",
            "target": "Package",
            "version": "[1.13.2, )"
          },
          "System.Runtime.CompilerServices.Unsafe": {
            "target": "Package",
            "version": "[6.0.0, )"
          },
          "ZString": {
            "target": "Package",
            "version": "[2.5.1, )"
          }
        },
        "imports": [
          "net461",
          "net462",
          "net47",
          "net471",
          "net472",
          "net48",
          "net481"
        ],
        "assetTargetFallback": true,
        "warn": true,
        "frameworkReferences": {
          "NETStandard.Library": {
            "privateAssets": "all"
          }
        },
        "runtimeIdentifierGraphPath": "/usr/local/share/dotnet/sdk/9.0.202/RuntimeIdentifierGraph.json"
      }
    }
  }
}
</file>

<file path="obj/project.nuget.cache">
{
  "version": 2,
  "dgSpecHash": "8YhtJ1cX/Fo=",
  "success": true,
  "projectFilePath": "/Users/dionny/projects/YARG/YARG.Core/YARG.Core/YARG.Core.csproj",
  "expectedPackageFiles": [
    "/Users/dionny/.nuget/packages/melanchall.drywetmidi.nativeless/7.0.0/melanchall.drywetmidi.nativeless.7.0.0.nupkg.sha512",
    "/Users/dionny/.nuget/packages/newtonsoft.json/13.0.3/newtonsoft.json.13.0.3.nupkg.sha512",
    "/Users/dionny/.nuget/packages/polysharp/1.13.2/polysharp.1.13.2.nupkg.sha512",
    "/Users/dionny/.nuget/packages/system.runtime.compilerservices.unsafe/6.0.0/system.runtime.compilerservices.unsafe.6.0.0.nupkg.sha512",
    "/Users/dionny/.nuget/packages/zstring/2.5.1/zstring.2.5.1.nupkg.sha512"
  ],
  "logs": []
}
</file>

<file path="obj/YARG.Core.csproj.nuget.dgspec.json">
{
  "format": 1,
  "restore": {
    "/Users/dionny/projects/YARG/YARG.Core/YARG.Core/YARG.Core.csproj": {}
  },
  "projects": {
    "/Users/dionny/projects/YARG/YARG.Core/YARG.Core/YARG.Core.csproj": {
      "version": "1.0.0",
      "restore": {
        "projectUniqueName": "/Users/dionny/projects/YARG/YARG.Core/YARG.Core/YARG.Core.csproj",
        "projectName": "YARG.Core",
        "projectPath": "/Users/dionny/projects/YARG/YARG.Core/YARG.Core/YARG.Core.csproj",
        "packagesPath": "/Users/dionny/.nuget/packages/",
        "outputPath": "/Users/dionny/projects/YARG/YARG.Core/YARG.Core/obj/",
        "projectStyle": "PackageReference",
        "configFilePaths": [
          "/Users/dionny/.nuget/NuGet/NuGet.Config"
        ],
        "originalTargetFrameworks": [
          "netstandard2.1"
        ],
        "sources": {
          "https://api.nuget.org/v3/index.json": {}
        },
        "frameworks": {
          "netstandard2.1": {
            "targetAlias": "netstandard2.1",
            "projectReferences": {}
          }
        },
        "warningProperties": {
          "warnAsError": [
            "NU1605"
          ]
        },
        "restoreAuditProperties": {
          "enableAudit": "true",
          "auditLevel": "low",
          "auditMode": "direct"
        },
        "SdkAnalysisLevel": "9.0.200"
      },
      "frameworks": {
        "netstandard2.1": {
          "targetAlias": "netstandard2.1",
          "dependencies": {
            "Melanchall.DryWetMidi.Nativeless": {
              "target": "Package",
              "version": "[7.0.0, )"
            },
            "Newtonsoft.Json": {
              "target": "Package",
              "version": "[13.0.3, )"
            },
            "PolySharp": {
              "include": "Runtime, Build, Native, ContentFiles, Analyzers, BuildTransitive",
              "suppressParent": "All",
              "target": "Package",
              "version": "[1.13.2, )"
            },
            "System.Runtime.CompilerServices.Unsafe": {
              "target": "Package",
              "version": "[6.0.0, )"
            },
            "ZString": {
              "target": "Package",
              "version": "[2.5.1, )"
            }
          },
          "imports": [
            "net461",
            "net462",
            "net47",
            "net471",
            "net472",
            "net48",
            "net481"
          ],
          "assetTargetFallback": true,
          "warn": true,
          "frameworkReferences": {
            "NETStandard.Library": {
              "privateAssets": "all"
            }
          },
          "runtimeIdentifierGraphPath": "/usr/local/share/dotnet/sdk/9.0.202/RuntimeIdentifierGraph.json"
        }
      }
    }
  }
}
</file>

<file path="obj/YARG.Core.csproj.nuget.g.props">
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <RestoreSuccess Condition=" '$(RestoreSuccess)' == '' ">True</RestoreSuccess>
    <RestoreTool Condition=" '$(RestoreTool)' == '' ">NuGet</RestoreTool>
    <ProjectAssetsFile Condition=" '$(ProjectAssetsFile)' == '' ">$(MSBuildThisFileDirectory)project.assets.json</ProjectAssetsFile>
    <NuGetPackageRoot Condition=" '$(NuGetPackageRoot)' == '' ">/Users/dionny/.nuget/packages/</NuGetPackageRoot>
    <NuGetPackageFolders Condition=" '$(NuGetPackageFolders)' == '' ">/Users/dionny/.nuget/packages/</NuGetPackageFolders>
    <NuGetProjectStyle Condition=" '$(NuGetProjectStyle)' == '' ">PackageReference</NuGetProjectStyle>
    <NuGetToolVersion Condition=" '$(NuGetToolVersion)' == '' ">6.13.1</NuGetToolVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <SourceRoot Include="/Users/dionny/.nuget/packages/" />
  </ItemGroup>
</Project>
</file>

<file path="obj/YARG.Core.csproj.nuget.g.targets">
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <Import Project="$(NuGetPackageRoot)polysharp/1.13.2/buildTransitive/PolySharp.targets" Condition="Exists('$(NuGetPackageRoot)polysharp/1.13.2/buildTransitive/PolySharp.targets')" />
  </ImportGroup>
</Project>
</file>

<file path="Parsing/TextEvents.cs">
using System;
using YARG.Core.Extensions;

namespace YARG.Core.Parsing
{
    /// <summary>
    /// Available stem configurations for a drums mix event.
    /// </summary>
    public enum DrumsMixConfiguration
    {
        StereoKit = 0,
        NoStem = StereoKit,
        MonoKickSnare_StereoKit = 1,
        MonoKick_StereoSnareKit = 2,
        StereoKickSnareKit = 3,
        MonoKick_StereoKit = 4,
        StereoKickSnareTomCymbal = 5,
    }

    /// <summary>
    /// Additional settings for a drums mix event.
    /// </summary>
    public enum DrumsMixSetting
    {
        None = 0,

        /// <summary>
        /// Swap the red and yellow lanes on Pro Drums, along with their assigned stems.
        /// </summary>
        DiscoFlip = 1,

        /// <summary>
        /// Swap the stems assigned to the red/yellow lanes without swapping the notes.
        /// </summary>
        DiscoNoFlip = 2,

        /// <summary>
        /// Force-unmute the tom and cymbal stems on Easy.
        /// </summary>
        Easy = 3,

        /// <summary>
        /// Force-unmute the kick stem on Easy.
        /// </summary>
        EasyNoKick = 4,
    }

    /// <summary>
    /// Constants and utilities for handling text events.
    /// </summary>
    public static partial class TextEvents
    {
        public const string BIG_ROCK_ENDING_START = "coda";
        public const string END_MARKER = "end";

        /// <summary>
        /// Normalizes text events into a consistent format. This includes stripping any
        /// leading/trailing whitespace, and isolating any text inside square brackets.
        /// </summary>
        /// <remarks>
        /// All text events must be passed through this method before being used elsewhere.
        /// All other methods that operate on text events expect them to be normalized.
        /// </remarks>
        // Equivalent to reading the capture of this regex: \[(.*?)\]
        public static ReadOnlySpan<char> NormalizeTextEvent(ReadOnlySpan<char> text, out bool hadBrackets)
        {
            int startIndex = text.IndexOf('[');
            int endIndex = text.IndexOf(']');
            if (startIndex >= 0 && endIndex >= 0 && startIndex <= endIndex)
            {
                hadBrackets = true;
                return text[++startIndex..endIndex].TrimAscii();
            }
            else
            {
                hadBrackets = false;
                return text.TrimAscii();
            }
        }

        /// <inheritdoc cref="NormalizeTextEvent(ReadOnlySpan{char}, out bool)"/>
        public static ReadOnlySpan<char> NormalizeTextEvent(ReadOnlySpan<char> text)
            => NormalizeTextEvent(text, out _);

        // For events that have either space or underscore separators
        private static ReadOnlySpan<char> SkipSpaceOrUnderscore(this ReadOnlySpan<char> text)
        {
            return text.TrimStart('_').TrimStart();
        }

        /// <summary>
        /// Parses a section name from a text event.
        /// </summary>
        /// <returns>
        /// True if the event was parsed successfully, false otherwise.
        /// </returns>
        // Equivalent to reading the capture of this regex: (?:section|prc)[ _](.*)
        public static bool TryParseSectionEvent(ReadOnlySpan<char> text, out ReadOnlySpan<char> name)
        {
            name = ReadOnlySpan<char>.Empty;

            const string SECTION_PREFIX = "section";
            const string PRC_PREFIX = "prc";

            // Remove event prefix
            if (text.StartsWith(SECTION_PREFIX))
                text = text[SECTION_PREFIX.Length..];
            else if (text.StartsWith(PRC_PREFIX))
                text = text[PRC_PREFIX.Length..];
            else
                return false;

            // Isolate section name
            name = text.TrimStart('_').Trim();
            return !name.IsEmpty;
        }

        /// <summary>
        /// Parses mix info from a drums mix event.
        /// </summary>
        /// <returns>
        /// True if the event was parsed successfully, false otherwise.
        /// </returns>
        public static bool TryParseDrumsMixEvent(ReadOnlySpan<char> text, out Difficulty difficulty,
            out DrumsMixConfiguration config, out DrumsMixSetting setting)
        {
            difficulty = Difficulty.Expert;
            config = DrumsMixConfiguration.NoStem;
            setting = DrumsMixSetting.None;

            // Remove event prefix
            const string MIX_PREFIX = "mix";
            if (!text.StartsWith(MIX_PREFIX))
                return false;
            text = text[MIX_PREFIX.Length..].SkipSpaceOrUnderscore();
            if (text.IsEmpty)
                return false;

            // Parse difficulty number
            if (!text[0].TryAsciiToNumber(out uint diffNumber))
                return false;
            text = text[1..].SkipSpaceOrUnderscore();

            switch (diffNumber)
            {
                case 3: difficulty = Difficulty.Expert; break;
                case 2: difficulty = Difficulty.Hard; break;
                case 1: difficulty = Difficulty.Medium; break;
                case 0: difficulty = Difficulty.Easy; break;
                default: return false;
            }

            // Skip 'drums' text
            const string DRUMS_PREFIX = "drums";
            if (!text.StartsWith(DRUMS_PREFIX))
                return false;
            text = text[DRUMS_PREFIX.Length..].SkipSpaceOrUnderscore();
            if (text.IsEmpty)
                return false;

            // Parse configuration number
            if (!text[0].TryAsciiToNumber(out uint configNumber) || configNumber > 5)
                return false;
            text = text[1..].SkipSpaceOrUnderscore();

            config = (DrumsMixConfiguration) configNumber;

            // Parse settings
            var settingText = text;
            if (settingText.Equals("d", StringComparison.Ordinal))
                setting = DrumsMixSetting.DiscoFlip;
            else if (settingText.Equals("dnoflip", StringComparison.Ordinal))
                setting = DrumsMixSetting.DiscoNoFlip;
            else if (settingText.Equals("easy", StringComparison.Ordinal))
                setting = DrumsMixSetting.Easy;
            else if (settingText.Equals("easynokick", StringComparison.Ordinal))
                setting = DrumsMixSetting.EasyNoKick;
            else
                setting = DrumsMixSetting.None;

            return true;
        }
    }
}
</file>

<file path="Parsing/TextEvents.Phrases.cs">
using System.Collections.Generic;
using MoonscraperChartEditor.Song;

namespace YARG.Core.Parsing
{
    internal interface ITextPhraseConverter
    {
        string StartEvent { get; }
        string EndEvent { get; }

        void AddPhrase(uint startTick, uint endTick);
        void AddPhraseEvent(string text, uint tick);
    }

    public static partial class TextEvents
    {
        #region Global lyric events
        public const string
        LYRIC_PREFIX = "lyric",
        LYRIC_PREFIX_WITH_SPACE = LYRIC_PREFIX + " ",
        LYRIC_PHRASE_START = "phrase_start",
        LYRIC_PHRASE_END = "phrase_end";
        #endregion

        #region Solos
        public const string
        SOLO_START = "solo",
        SOLO_END = "soloend";
        #endregion

        #region Text event to phrase conversion
        private struct TextConversionState
        {
            public uint currentTick;
            public uint? startTick;
            public bool start;
            public bool end;

            // Events pending for the current tick if a start event hasn't occurred yet
            // Cleared on the next tick if no start event is on this tick
            public List<string> pendingEvents;
        }

        internal static void ConvertToPhrases(List<MoonText> events, ITextPhraseConverter converter, uint maxTick)
        {
            string startEvent = converter.StartEvent;
            string endEvent = converter.EndEvent;

            var state = new TextConversionState()
            {
                currentTick = 0,
                startTick = null,
                start = false,
                end = false,
                pendingEvents = new(),
            };

            for (int i = 0; i < events.Count; i++)
            {
                var textEv = events[i];
                uint tick = textEv.tick;
                string text = textEv.text;

                // Commit found events on start of next tick
                if (tick != state.currentTick)
                {
                    ProcessPhraseEvents(converter, ref state);
                    state.currentTick = tick;
                    state.start = state.end = false;
                    state.pendingEvents.Clear();
                }

                // Determine what events are present on the current tick
                if (text == startEvent)
                {
                    events.RemoveAt(i);
                    i--;
                    state.start = true;
                }
                else if (text == endEvent)
                {
                    events.RemoveAt(i);
                    i--;
                    state.end = true;
                }
                else
                {
                    // Store event as pending for this tick
                    state.pendingEvents.Add(text);
                }
            }

            if (state.start && !state.end)
            {
                // Unterminated start event, we place it at the end of the song
                state.end = true;
                state.currentTick = maxTick + 1;
            }

            // Handle final event state
            if (state.end)
                ProcessPhraseEvents(converter, ref state);
        }

        private static void ProcessPhraseEvents(ITextPhraseConverter converter, ref TextConversionState state)
        {
            // Phrase starts or ends on this tick
            if (state.start ^ state.end)
            {
                if (state.startTick == null)
                {
                    // Phrase starts on this tick
                    state.startTick = state.currentTick;
                }
                else
                {
                    // Phrase ends on this tick
                    converter.AddPhrase(state.startTick!.Value, state.currentTick);
                    // A new one may also start here
                    state.startTick = state.start ? state.currentTick : null;
                }
            }
            else if (state.start && state.end)
            {
                if (state.startTick == null)
                {
                    // Phrase starts and ends on this tick
                    // Process pending events first, they are part of this phrase
                    FlushPendingEvents(converter, ref state);
                    converter.AddPhrase(state.currentTick, state.currentTick);
                }
                else
                {
                    // Phrase ends on this tick and a new one starts
                    // Process phrase end first, pending events are part of the next phrase
                    converter.AddPhrase(state.startTick.Value, state.currentTick);
                    state.startTick = state.currentTick;
                }
            }

            // Only dequeue pending events if we're within a phrase
            if (state.startTick != null)
                FlushPendingEvents(converter, ref state);
        }

        private static void FlushPendingEvents(ITextPhraseConverter converter, ref TextConversionState state)
        {
            foreach (string pending in state.pendingEvents)
            {
                converter.AddPhraseEvent(pending, state.currentTick);
            }
        }
        #endregion
    }
}
</file>

<file path="Replays/Analyzer/AnalysisResult.cs">
using System.Collections.Generic;
using YARG.Core.Engine;

namespace YARG.Core.Replays.Analyzer
{
    public struct AnalysisResult
    {
        public bool Passed;

        public ReplayFrame Frame;

        public BaseStats OriginalStats;
        public BaseStats ResultStats;

        public int ScoreDifference;
    }
}
</file>

<file path="Replays/Analyzer/ReplayAnalyzer.cs">
using System;
using System.Collections.Generic;
using System.Text;
using YARG.Core.Chart;
using YARG.Core.Engine;
using YARG.Core.Engine.Drums;
using YARG.Core.Engine.Drums.Engines;
using YARG.Core.Engine.Guitar;
using YARG.Core.Engine.Guitar.Engines;
using YARG.Core.Engine.ProKeys.Engines;
using YARG.Core.Engine.ProKeys;
using YARG.Core.Engine.Vocals;
using YARG.Core.Engine.Vocals.Engines;
using YARG.Core.Game;
using YARG.Core.Logging;

namespace YARG.Core.Replays.Analyzer
{
    public class ReplayAnalyzer
    {
        private readonly SongChart  _chart;
        private readonly ReplayData _replay;

        private readonly double _fps;
        private readonly bool   _doFrameUpdates;

        private readonly Random _random = new();

        public ReplayAnalyzer(SongChart chart, ReplayData replay, double fps)
        {
            _chart = chart;
            _replay = replay;

            _fps = fps;
            _doFrameUpdates = _fps > 0;
        }

        public static AnalysisResult[] AnalyzeReplay(SongChart chart, ReplayData replay, double fps = 0)
        {
            var analyzer = new ReplayAnalyzer(chart, replay, fps);
            return analyzer.Analyze();
        }

        public static string PrintStatDifferences(BaseStats originalStats, BaseStats resultStats)
        {
            var sb = new StringBuilder();

            void AppendStatDifference<T>(string name, T frameStat, T resultStat)
                where T : IEquatable<T>
            {
                if (frameStat.Equals(resultStat))
                    sb.AppendLine($"- {name + ":",-31} {frameStat,-12} (identical)");
                else
                    sb.AppendLine($"- {name + ":",-31} {frameStat,-10} -> {resultStat}");
            }

            sb.AppendLine("Base stats:");
            AppendStatDifference("CommittedScore", originalStats.CommittedScore, resultStats.CommittedScore);
            AppendStatDifference("PendingScore", originalStats.PendingScore, resultStats.PendingScore);
            AppendStatDifference("TotalScore", originalStats.TotalScore, resultStats.TotalScore);
            AppendStatDifference("StarScore", originalStats.StarScore, resultStats.StarScore);
            AppendStatDifference("Combo", originalStats.Combo, resultStats.Combo);
            AppendStatDifference("MaxCombo", originalStats.MaxCombo, resultStats.MaxCombo);
            AppendStatDifference("ScoreMultiplier", originalStats.ScoreMultiplier, resultStats.ScoreMultiplier);
            AppendStatDifference("NotesHit", originalStats.NotesHit, resultStats.NotesHit);
            AppendStatDifference("TotalNotes", originalStats.TotalNotes, resultStats.TotalNotes);
            AppendStatDifference("NotesMissed", originalStats.NotesMissed, resultStats.NotesMissed);
            AppendStatDifference("Percent", originalStats.Percent, resultStats.Percent);
            AppendStatDifference("StarPowerTickAmount", originalStats.StarPowerTickAmount,
                resultStats.StarPowerTickAmount);
            AppendStatDifference("TotalStarPowerTicks", originalStats.TotalStarPowerTicks,
                resultStats.TotalStarPowerTicks);
            AppendStatDifference("TimeInStarPower", originalStats.TimeInStarPower, resultStats.TimeInStarPower);
            AppendStatDifference("IsStarPowerActive", originalStats.IsStarPowerActive, resultStats.IsStarPowerActive);
            AppendStatDifference("StarPowerPhrasesHit", originalStats.StarPowerPhrasesHit,
                resultStats.StarPowerPhrasesHit);
            AppendStatDifference("TotalStarPowerPhrases", originalStats.TotalStarPowerPhrases,
                resultStats.TotalStarPowerPhrases);
            AppendStatDifference("StarPowerPhrasesMissed", originalStats.StarPowerPhrasesMissed,
                resultStats.StarPowerPhrasesMissed);
            AppendStatDifference("SoloBonuses", originalStats.SoloBonuses, resultStats.SoloBonuses);
            AppendStatDifference("StarPowerScore", originalStats.StarPowerScore, resultStats.StarPowerScore);
            // PrintStatDifference("Stars",                  originalStats.Stars,                  resultStats.Stars);

            sb.AppendLine();
            switch (originalStats, resultStats)
            {
                case (GuitarStats originalGuitar, GuitarStats resultGuitar):
                {
                    sb.AppendLine("Guitar stats:");
                    AppendStatDifference("Overstrums", originalGuitar.Overstrums, resultGuitar.Overstrums);
                    AppendStatDifference("HoposStrummed", originalGuitar.HoposStrummed, resultGuitar.HoposStrummed);
                    AppendStatDifference("GhostInputs", originalGuitar.GhostInputs, resultGuitar.GhostInputs);
                    AppendStatDifference("StarPowerWhammyTicks", originalGuitar.StarPowerWhammyTicks,
                        resultGuitar.StarPowerWhammyTicks);
                    AppendStatDifference("SustainScore", originalGuitar.SustainScore, resultGuitar.SustainScore);
                    break;
                }
                case (DrumsStats originalDrums, DrumsStats resultDrums):
                {
                    sb.AppendLine("Drums stats:");
                    AppendStatDifference("Overhits", originalDrums.Overhits, resultDrums.Overhits);
                    break;
                }
                case (VocalsStats originalVocals, VocalsStats resultVocals):
                {
                    sb.AppendLine("Vocals stats:");
                    AppendStatDifference("TicksHit", originalVocals.TicksHit, resultVocals.TicksHit);
                    AppendStatDifference("TicksMissed", originalVocals.TicksMissed, resultVocals.TicksMissed);
                    AppendStatDifference("TotalTicks", originalVocals.TotalTicks, resultVocals.TotalTicks);
                    break;
                }
                case (ProKeysStats originalKeys, ProKeysStats resultKeys):
                {
                    sb.AppendLine("Pro Keys stats:");
                    AppendStatDifference("Overhits", originalKeys.Overhits, resultKeys.Overhits);
                    break;
                }
                default:
                {
                    if (originalStats.GetType() != resultStats.GetType())
                        sb.AppendLine(
                            $"Stats types do not match! Original: {originalStats.GetType()}, result: {resultStats.GetType()}");
                    else
                        sb.AppendLine($"Unhandled stats type {originalStats.GetType()}!");
                    break;
                }
            }
            return sb.ToString();
        }

        private AnalysisResult[] Analyze()
        {
            var results = new AnalysisResult[_replay.Frames.Length];

            for (int i = 0; i < results.Length; i++)
            {
                var frame = _replay.Frames[i];
                var result = RunFrame(frame);

                results[i] = result;
            }

            return results;
        }

        private AnalysisResult RunFrame(ReplayFrame frame)
        {
            var engine = CreateEngine(frame.Profile, frame.EngineParameters);
            engine.SetSpeed(frame.EngineParameters.SongSpeed);
            engine.Reset();

            double maxTime = _chart.GetEndTime();
            if (frame.Inputs.Length > 0)
            {
                double last = frame.Inputs[^1].Time;
                if (last > maxTime)
                {
                    maxTime = last;
                }
            }
            maxTime += 2;

            if (!_doFrameUpdates)
            {
                // If we're not doing frame updates, just queue all of the inputs at once
                foreach (var input in frame.Inputs)
                {
                    var inp = input;
                    engine.QueueInput(ref inp);
                }

                // Run the engine updates
                engine.Update(maxTime);
            }
            else
            {
                // If we're doing frame updates, the inputs and frame times must be
                // "interweaved" so nothing gets queued in the future
                int currentInput = 0;
                foreach (var time in GenerateFrameTimes(-2, maxTime))
                {
                    for (; currentInput < frame.Inputs.Length; currentInput++)
                    {
                        var input = frame.Inputs[currentInput];
                        if (input.Time > time)
                        {
                            break;
                        }

                        engine.QueueInput(ref input);
                    }

                    engine.Update(time);
                }
            }

            bool passed = IsPassResult(frame.Stats, engine.BaseStats);

            return new AnalysisResult
            {
                Passed = passed,
                Frame = frame,
                OriginalStats = frame.Stats,
                ResultStats = engine.BaseStats,
            };
        }

        private BaseEngine CreateEngine(YargProfile profile, BaseEngineParameters parameters)
        {
            switch (profile.GameMode)
            {
                case GameMode.FiveFretGuitar:
                {
                    // Reset the notes
                    var notes = _chart.GetFiveFretTrack(profile.CurrentInstrument)
                        .GetDifficulty(profile.CurrentDifficulty).Clone();
                    profile.ApplyModifiers(notes);
                    foreach (var note in notes.Notes)
                    {
                        foreach (var subNote in note.AllNotes)
                        {
                            subNote.ResetNoteState();
                        }
                    }

                    // Create engine
                    return new YargFiveFretEngine(
                        notes,
                        _chart.SyncTrack,
                        (GuitarEngineParameters) parameters,
                        profile.IsBot);
                }
                case GameMode.FourLaneDrums:
                case GameMode.FiveLaneDrums:
                {
                    // Reset the notes
                    var notes = _chart.GetDrumsTrack(profile.CurrentInstrument)
                        .GetDifficulty(profile.CurrentDifficulty).Clone();
                    profile.ApplyModifiers(notes);
                    foreach (var note in notes.Notes)
                    {
                        foreach (var subNote in note.AllNotes)
                        {
                            subNote.ResetNoteState();
                        }
                    }

                    // Create engine
                    return new YargDrumsEngine(
                        notes,
                        _chart.SyncTrack,
                        (DrumsEngineParameters) parameters,
                        profile.IsBot);
                }
                case GameMode.ProKeys:
                {
                    // Reset the notes
                    var notes = _chart.ProKeys.GetDifficulty(profile.CurrentDifficulty).Clone();
                    profile.ApplyModifiers(notes);
                    foreach (var note in notes.Notes)
                    {
                        foreach (var subNote in note.AllNotes)
                        {
                            subNote.ResetNoteState();
                        }
                    }

                    // Create engine
                    return new YargProKeysEngine(
                        notes,
                        _chart.SyncTrack,
                        (ProKeysEngineParameters) parameters,
                        profile.IsBot);
                }
                case GameMode.Vocals:
                {
                    // Get the notes
                    var notes = _chart.GetVocalsTrack(profile.CurrentInstrument)
                        .Parts[profile.HarmonyIndex].Clone();
                    profile.ApplyVocalModifiers(notes);

                    // Create engine
                    return new YargVocalsEngine(
                        // hate the double-clone lol but for now it'll be fine
                        notes.CloneAsInstrumentDifficulty(),
                        _chart.SyncTrack,
                        (VocalsEngineParameters) parameters,
                        profile.IsBot);
                }
                default:
                    throw new InvalidOperationException("Game mode not configured!");
            }
        }

        private List<double> GenerateFrameTimes(double from, double to)
        {
            YargLogger.Assert(to > from, "Invalid time range");

            double frameTime = 1.0 / _fps;

            var times = new List<double>();
            for (double time = from; time < to; time += frameTime)
            {
                // Add up to 45% random adjustment to the frame time
                var randomAdjustment = _random.NextDouble() * 0.5;

                // Randomly make the adjustment negative
                if (_random.Next(2) == 0 && time > from)
                {
                    randomAdjustment = -randomAdjustment;
                }

                double adjustedTime = time + frameTime * randomAdjustment;

                if (adjustedTime > to)
                {
                    adjustedTime = to;
                }

                times.Add(adjustedTime);
            }

            // Add the end time just in case
            times.Add(to);

            return times;
        }

        private static bool IsPassResult(BaseStats original, BaseStats result)
        {
            YargLogger.LogFormatDebug("Score: {0} == {1}\nHit: {2} == {3}\nMissed: {4} == {5}\nCombo: {6} == {7}\nMaxCombo: {8} == {9}\n",
                original.CommittedScore, result.CommittedScore,
                original.NotesHit, result.NotesHit,
                original.NotesMissed, result.NotesMissed,
                original.Combo, result.Combo,
                original.MaxCombo, result.MaxCombo);

            YargLogger.LogFormatDebug("Solo: {0} == {1}\nSP Bonus: {2} == {3}\nSP Phrases: {4} == {5}\n" +
                "Time In SP: {6} == {7}\nSP Ticks: {8} == {9}",
                original.SoloBonuses, result.SoloBonuses,
                original.StarPowerScore, result.StarPowerScore,
                original.StarPowerPhrasesHit, result.StarPowerPhrasesHit,
                original.TimeInStarPower, result.TimeInStarPower,
                original.TotalStarPowerTicks, result.TotalStarPowerTicks);

            bool instrumentPass = true;

            if(original is GuitarStats originalGuitar && result is GuitarStats resultGuitar)
            {
                instrumentPass = originalGuitar.Overstrums == resultGuitar.Overstrums &&
                    originalGuitar.GhostInputs == resultGuitar.GhostInputs &&
                    originalGuitar.HoposStrummed == resultGuitar.HoposStrummed &&
                    originalGuitar.StarPowerWhammyTicks == resultGuitar.StarPowerWhammyTicks &&
                    originalGuitar.SustainScore == resultGuitar.SustainScore;

                YargLogger.LogFormatDebug("Guitar:\nOverstrums: {0} == {1}\nGhost Inputs: {2} == {3}\nHOPOs Strummed: {4} == {5}\n" +
                    "Whammy Ticks: {6} == {7}\nSustain Points: {8} == {9}",
                    originalGuitar.Overstrums, resultGuitar.Overstrums,
                    originalGuitar.GhostInputs, resultGuitar.GhostInputs,
                    originalGuitar.HoposStrummed, resultGuitar.HoposStrummed,
                    originalGuitar.StarPowerWhammyTicks, resultGuitar.StarPowerWhammyTicks,
                    originalGuitar.SustainScore, resultGuitar.SustainScore);
            }

            bool generalPass = original.CommittedScore == result.CommittedScore &&
                original.NotesHit == result.NotesHit &&
                original.NotesMissed == result.NotesMissed &&
                original.Combo == result.Combo &&
                original.MaxCombo == result.MaxCombo &&
                original.SoloBonuses == result.SoloBonuses &&
                original.StarPowerScore == result.StarPowerScore &&
                original.StarPowerPhrasesHit == result.StarPowerPhrasesHit &&
                // ReSharper disable once CompareOfFloatsByEqualityOperator
                original.TimeInStarPower == result.TimeInStarPower &&
                original.TotalStarPowerTicks == result.TotalStarPowerTicks;

            return generalPass && instrumentPass;
        }
    }
}
</file>

<file path="Replays/ReplayStats/DrumsReplayStats.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using YARG.Core.Engine.Drums;
using YARG.Core.Extensions;
using YARG.Core.IO;

namespace YARG.Core.Replays
{
    public sealed class DrumsReplayStats : ReplayStats
    {
        public readonly int TotalNotes;
        public readonly int NumNotesHit;
        public readonly float PercentageHit;
        public readonly int Overhits;
        public readonly int SoloBonuses;

        public DrumsReplayStats(string name, DrumsStats stats)
            : base(name, stats)
        {
            TotalNotes = stats.TotalNotes;
            NumNotesHit = stats.NotesHit;
            Overhits = stats.Overhits;
            SoloBonuses = stats.SoloBonuses;

            PercentageHit = 100.0f * NumNotesHit / TotalNotes;
        }

        public DrumsReplayStats(ref FixedArrayStream stream, int version)
            : base(ref stream, version)
        {
            TotalNotes = stream.Read<int>(Endianness.Little);
            NumNotesHit = stream.Read<int>(Endianness.Little);
            Overhits = stream.Read<int>(Endianness.Little);
            SoloBonuses = stream.Read<int>(Endianness.Little);

            PercentageHit = 100.0f * NumNotesHit / TotalNotes;
        }


        public override void Serialize(BinaryWriter writer)
        {
            // Five lane & Four lane are interchangeable here
            writer.Write((byte)GameMode.FourLaneDrums);
            base.Serialize(writer);
            writer.Write(TotalNotes);
            writer.Write(NumNotesHit);
            writer.Write(Overhits);
            writer.Write(SoloBonuses);
        }
    }
}
</file>

<file path="Replays/ReplayStats/GuitarReplayStats.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using YARG.Core.Engine.Guitar;
using YARG.Core.Extensions;
using YARG.Core.IO;

namespace YARG.Core.Replays
{
    public sealed class GuitarReplayStats : ReplayStats
    {
        public readonly int TotalNotes;
        public readonly int NumNotesHit;
        public readonly float PercentageHit;
        public readonly int Overstrums;
        public readonly int GhostInputs;
        public readonly int SoloBonuses;

        public GuitarReplayStats(string name, GuitarStats stats)
            : base(name, stats)
        {
            TotalNotes = stats.TotalNotes;
            NumNotesHit = stats.NotesHit;
            Overstrums = stats.Overstrums;
            GhostInputs = stats.GhostInputs;
            SoloBonuses = stats.SoloBonuses;

            PercentageHit = 100.0f * NumNotesHit / TotalNotes;
        }

        public GuitarReplayStats(ref FixedArrayStream stream, int version)
            : base(ref stream, version)
        {
            TotalNotes = stream.Read<int>(Endianness.Little);
            NumNotesHit = stream.Read<int>(Endianness.Little);
            Overstrums = stream.Read<int>(Endianness.Little);
            GhostInputs = stream.Read<int>(Endianness.Little);
            SoloBonuses = stream.Read<int>(Endianness.Little);

            PercentageHit = 100.0f * NumNotesHit / TotalNotes;
        }

        public override void Serialize(BinaryWriter writer)
        {
            // Five fret & six fret are interchangeable here
            writer.Write((byte) GameMode.FiveFretGuitar);
            base.Serialize(writer);
            writer.Write(TotalNotes);
            writer.Write(NumNotesHit);
            writer.Write(Overstrums);
            writer.Write(GhostInputs);
            writer.Write(SoloBonuses);
        }
    }
}
</file>

<file path="Replays/ReplayStats/ProKeysReplayStats.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using YARG.Core.Engine.ProKeys;
using YARG.Core.Extensions;
using YARG.Core.IO;

namespace YARG.Core.Replays
{
    public sealed class ProKeysReplayStats : ReplayStats
    {
        public readonly int TotalNotes;
        public readonly int NumNotesHit;
        public readonly float PercentageHit;
        public readonly int Overhits;
        public readonly int SoloBonuses;

        public ProKeysReplayStats(string name, ProKeysStats stats)
            : base(name, stats)
        {
            TotalNotes = stats.TotalNotes;
            NumNotesHit = stats.NotesHit;
            Overhits = stats.Overhits;
            SoloBonuses = stats.SoloBonuses;

            PercentageHit = 100.0f * NumNotesHit / TotalNotes;
        }

        public ProKeysReplayStats(ref FixedArrayStream stream, int version)
            : base(ref stream, version)
        {
            TotalNotes = stream.Read<int>(Endianness.Little);
            NumNotesHit = stream.Read<int>(Endianness.Little);
            Overhits = stream.Read<int>(Endianness.Little);
            SoloBonuses = stream.Read<int>(Endianness.Little);

            PercentageHit = 100.0f * NumNotesHit / TotalNotes;
        }


        public override void Serialize(BinaryWriter writer)
        {
            writer.Write((byte) GameMode.ProKeys);
            base.Serialize(writer);
            writer.Write(TotalNotes);
            writer.Write(NumNotesHit);
            writer.Write(Overhits);
            writer.Write(SoloBonuses);
        }
    }
}
</file>

<file path="Replays/ReplayStats/ReplayStats.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using YARG.Core.Engine;
using YARG.Core.Extensions;
using YARG.Core.Game;
using YARG.Core.IO;

namespace YARG.Core.Replays
{
    public abstract class ReplayStats
    {
        public readonly string PlayerName;
        public readonly int Score;
        public readonly float Stars;
        public readonly int TotalOverdrivePhrases;
        public readonly int NumOverdrivePhrasesHit;
        public readonly int NumOverdriveActivations;
        public readonly float AverageMultiplier;
        public readonly int NumPauses;

        protected ReplayStats(string name, BaseStats stats)
        {
            PlayerName = name;
            Score = stats.TotalScore;
            Stars = stats.Stars;
            TotalOverdrivePhrases = stats.TotalStarPowerPhrases;
            NumOverdrivePhrasesHit = TotalOverdrivePhrases - stats.StarPowerPhrasesMissed;
            NumOverdriveActivations = stats.StarPowerActivationCount;
            AverageMultiplier = 0;
            NumPauses = 0;
        }

        protected ReplayStats(ref FixedArrayStream stream, int version)
        {
            PlayerName = stream.ReadString();
            Score = stream.Read<int>(Endianness.Little);
            Stars = stream.Read<float>(Endianness.Little);
            TotalOverdrivePhrases = stream.Read<int>(Endianness.Little);
            NumOverdrivePhrasesHit = stream.Read<int>(Endianness.Little);
            NumOverdriveActivations = stream.Read<int>(Endianness.Little);
            AverageMultiplier = stream.Read<float>(Endianness.Little);
            NumPauses = stream.Read<int>(Endianness.Little);
        }

        public virtual void Serialize(BinaryWriter writer)
        {
            writer.Write(PlayerName);
            writer.Write(Score);
            writer.Write(Stars);
            writer.Write(TotalOverdrivePhrases);
            writer.Write(NumOverdrivePhrasesHit);
            writer.Write(NumOverdriveActivations);
            writer.Write(AverageMultiplier);
            writer.Write(NumPauses);
        }
    }
}
</file>

<file path="Replays/ReplayStats/VocalReplayStats.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using YARG.Core.Engine.Vocals;
using YARG.Core.Extensions;
using YARG.Core.IO;

namespace YARG.Core.Replays
{
    public sealed class VocalsReplayStats : ReplayStats
    {
        public readonly int NumPhrases;
        public readonly int NumPerfectPhrases;

        public VocalsReplayStats(string name, VocalsStats stats)
            : base(name, stats)
        {
            NumPhrases = 0;
            NumPerfectPhrases = 0;
        }

        public VocalsReplayStats(ref FixedArrayStream stream, int version)
            : base(ref stream, version)
        {
            NumPhrases = stream.Read<int>(Endianness.Little);
            NumPerfectPhrases = stream.Read<int>(Endianness.Little);
        }

        public override void Serialize(BinaryWriter writer)
        {
            writer.Write((byte) GameMode.Vocals);
            base.Serialize(writer);
            writer.Write(NumPhrases);
            writer.Write(NumPerfectPhrases);
        }
    }
}
</file>

<file path="Replays/ReplayData.cs">
using System.Collections.Generic;
using System;
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.Game;
using Newtonsoft.Json;
using YARG.Core.Utility;
using YARG.Core.IO;

namespace YARG.Core.Replays
{
    public class ReplayData
    {
        private const int PRESETS_VERSION = 0;
        private readonly Dictionary<Guid, ColorProfile> _colorProfiles;
        private readonly Dictionary<Guid, CameraPreset> _cameraPresets;
        public readonly ReplayFrame[] Frames;

        public int PlayerCount => Frames.Length;

        public ReplayData(Dictionary<Guid, ColorProfile> colors, Dictionary<Guid, CameraPreset> cameras, ReplayFrame[] frames)
        {
            _colorProfiles = colors;
            _cameraPresets = cameras;
            Frames = frames;
        }

        public ReplayData(FixedArrayStream stream, int version)
        {
            int _ = stream.Read<int>(Endianness.Little);
            _colorProfiles = DeserializeDict<ColorProfile>(ref stream);
            _cameraPresets = DeserializeDict<CameraPreset>(ref stream);

            int count = stream.Read<int>(Endianness.Little);
            Frames = new ReplayFrame[count];
            for (int i = 0; i != count; i++)
            {
                Frames[i] = new ReplayFrame(ref stream, version);
            }
        }

        public ReadOnlySpan<byte> Serialize()
        {
            // Write all the data for the replay hash
            using var stream = new MemoryStream();
            using var writer = new BinaryWriter(stream);

            writer.Write(PRESETS_VERSION);
            SerializeDict(writer, _colorProfiles);
            SerializeDict(writer, _cameraPresets);

            writer.Write(Frames.Length);
            foreach (var frame in Frames)
            {
                frame.Serialize(writer);
            }
            return new ReadOnlySpan<byte>(stream.GetBuffer(), 0, (int) stream.Length);
        }

        /// <returns>
        /// The color profile if it's in this container, otherwise, <c>null</c>.
        /// </returns>
        public ColorProfile? GetColorProfile(Guid guid)
        {
            _colorProfiles.TryGetValue(guid, out var color);
            return color;
        }

        /// <returns>
        /// The camera preset if it's in this container, otherwise, <c>null</c>.
        /// </returns>
        public CameraPreset? GetCameraPreset(Guid guid)
        {
            _cameraPresets.TryGetValue(guid, out var preset);
            return preset;
        }

        private static readonly JsonSerializerSettings _jsonSettings = new()
        {
            Converters =
            {
                new JsonColorConverter()
            }
        };

        private static void SerializeDict<T>(BinaryWriter writer, Dictionary<Guid, T> dict)
        {
            writer.Write(dict.Count);
            foreach (var (key, value) in dict)
            {
                // Write key
                writer.Write(key);

                // Write preset
                var json = JsonConvert.SerializeObject(value, _jsonSettings);
                writer.Write(json);
            }
        }

        private static Dictionary<Guid, T> DeserializeDict<T>(ref FixedArrayStream stream)
        {
            var dict = new Dictionary<Guid, T>();
            int len = stream.Read<int>(Endianness.Little);
            for (int i = 0; i < len; i++)
            {
                // Read key
                var guid = stream.ReadGuid();

                // Read preset
                var json = stream.ReadString();
                var preset = JsonConvert.DeserializeObject<T>(json, _jsonSettings)!;

                dict.Add(guid, preset);
            }
            return dict;
        }
    }
}
</file>

<file path="Replays/ReplayFrame.cs">
using System;
using System.IO;
using YARG.Core.Engine;
using YARG.Core.Engine.Drums;
using YARG.Core.Engine.Guitar;
using YARG.Core.Engine.ProKeys;
using YARG.Core.Engine.Vocals;
using YARG.Core.Extensions;
using YARG.Core.Game;
using YARG.Core.Input;
using YARG.Core.IO;

namespace YARG.Core.Replays
{
    public class ReplayFrame
    {
        private static readonly FourCC FRAME_TAG = new('R', 'P', 'F', 'M');

        public readonly YargProfile          Profile;
        public readonly BaseEngineParameters EngineParameters;
        public readonly BaseStats            Stats;
        public readonly GameInput[]          Inputs;

        public int InputCount => Inputs.Length;

        public ReplayFrame(YargProfile profile, BaseEngineParameters param, BaseStats stats, GameInput[] inputs)
        {
            Profile = profile;
            Stats = stats;
            EngineParameters = param;
            Inputs = inputs;
        }

        public ReplayFrame(ref FixedArrayStream stream, int version)
        {
            if (!FRAME_TAG.Matches(ref stream))
            {
                throw new Exception("RPFM tag not found");
            }

            Profile = new YargProfile(ref stream);
            switch (Profile.CurrentInstrument.ToGameMode())
            {
                case GameMode.FiveFretGuitar:
                case GameMode.SixFretGuitar:
                    EngineParameters = new GuitarEngineParameters(ref stream, version);
                    Stats = new GuitarStats(ref stream, version);
                    break;
                case GameMode.FourLaneDrums:
                case GameMode.FiveLaneDrums:
                    EngineParameters = new DrumsEngineParameters(ref stream, version);
                    Stats = new DrumsStats(ref stream, version);
                    break;
                case GameMode.Vocals:
                    EngineParameters = new VocalsEngineParameters(ref stream, version);
                    Stats = new VocalsStats(ref stream, version);
                    break;
                case GameMode.ProKeys:
                    EngineParameters = new ProKeysEngineParameters(ref stream, version);
                    Stats = new ProKeysStats(ref stream, version);
                    break;
                default:
                    throw new InvalidOperationException("Stat creation not implemented.");
            }

            int count = stream.Read<int>(Endianness.Little);
            Inputs = new GameInput[count];
            for (int i = 0; i < count; i++)
            {
                double time = stream.Read<double>(Endianness.Little);
                int action = stream.Read<int>(Endianness.Little);
                int value = stream.Read<int>(Endianness.Little);

                Inputs[i] = new GameInput(time, action, value);
            }
        }

        public void Serialize(BinaryWriter writer)
        {
            FRAME_TAG.Serialize(writer);
            Profile.Serialize(writer);
            EngineParameters.Serialize(writer);
            Stats.Serialize(writer);

            writer.Write(InputCount);
            for (int i = 0; i < InputCount; i++)
            {
                writer.Write(Inputs[i].Time);
                writer.Write(Inputs[i].Action);
                writer.Write(Inputs[i].Integer);
            }
        }
    }
}
</file>

<file path="Replays/ReplayInfo.cs">
using System;
using System.IO;
using System.Text.RegularExpressions;
using YARG.Core.Extensions;
using YARG.Core.Game;
using YARG.Core.IO;
using YARG.Core.Song;
using YARG.Core.Utility;

namespace YARG.Core.Replays
{
    public class ReplayInfo
    {
        public readonly string FilePath;
        public readonly string ReplayName;

        public readonly int ReplayVersion;
        public readonly int EngineVersion;
        public readonly HashWrapper ReplayChecksum;

        public readonly string SongName;
        public readonly string ArtistName;
        public readonly string CharterName;
        public readonly float SongSpeed;
        public readonly int BandScore;
        public readonly StarAmount BandStars;
        public readonly double ReplayLength;
        public readonly DateTime Date;
        public readonly HashWrapper SongChecksum;

        public readonly ReplayStats[] Stats;

        public ReplayInfo(string path, string replayName, int replayVersion, int engineVerion, in HashWrapper replayChecksum, string song, string artist, string charter, in HashWrapper songChecksum, in DateTime date, float speed, double length, int score, StarAmount stars, ReplayStats[] stats)
        {
            FilePath = path;
            ReplayName = replayName;

            ReplayVersion = replayVersion;
            EngineVersion = engineVerion;
            ReplayChecksum = replayChecksum;

            SongName = song;
            ArtistName = artist;
            CharterName = charter;
            SongChecksum = songChecksum;
            Date = date;
            SongSpeed = speed;
            ReplayLength = length;
            BandScore = score;
            BandStars = stars;
            Stats = stats;
        }

        public ReplayInfo(string path, FixedArrayStream stream)
            : this(path, ref stream) {}

        public ReplayInfo(string path, ref FixedArrayStream stream)
        {
            FilePath = path;

            ReplayVersion = stream.Read<int>(Endianness.Little);
            EngineVersion = stream.Read<int>(Endianness.Little);
            ReplayChecksum = HashWrapper.Deserialize(ref stream);

            SongName = stream.ReadString();
            ArtistName = stream.ReadString();
            CharterName = stream.ReadString();
            SongChecksum = HashWrapper.Deserialize(ref stream);
            Date = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
            SongSpeed = stream.Read<float>(Endianness.Little);
            ReplayLength = stream.Read<double>(Endianness.Little);
            BandScore = stream.Read<int>(Endianness.Little);
            BandStars = (StarAmount) stream.ReadByte();

            ReplayName = ConstructReplayName(SongName, ArtistName, CharterName, in Date);

            int statCount = stream.Read<int>(Endianness.Little);
            Stats = new ReplayStats[statCount];
            for (int i = 0; i < statCount; i++)
            {
                var mode = (GameMode) stream.ReadByte();
                Stats[i] = mode switch
                {
                    GameMode.FiveFretGuitar or
                    GameMode.SixFretGuitar => new GuitarReplayStats(ref stream, ReplayVersion),
                    GameMode.FourLaneDrums or
                    GameMode.FiveLaneDrums => new DrumsReplayStats(ref stream, ReplayVersion),
                    GameMode.ProKeys => new ProKeysReplayStats(ref stream, ReplayVersion),
                    GameMode.Vocals => new VocalsReplayStats(ref stream, ReplayVersion),
                    _ => throw new Exception($"Stats for {mode} not supported"),
                };
            }
        }

        public void Serialize(BinaryWriter writer)
        {
            writer.Write(ReplayVersion);
            writer.Write(EngineVersion);
            ReplayChecksum.Serialize(writer);

            writer.Write(SongName);
            writer.Write(ArtistName);
            writer.Write(CharterName);
            SongChecksum.Serialize(writer);
            writer.Write(Date.ToBinary());
            writer.Write(SongSpeed);
            writer.Write(ReplayLength);
            writer.Write(BandScore);
            writer.Write((byte) BandStars);

            writer.Write(Stats.Length);
            foreach (var stat in Stats)
            {
                stat.Serialize(writer);
            }
        }

        // Remove invalid characters from the replay name
        private static readonly Regex ReplayNameRegex = new("[<>:\"/\\|?*]", RegexOptions.Compiled);
        public static string ConstructReplayName(string song, string artist, string charter, in DateTime date)
        {
            var strippedSong = ReplayNameRegex.Replace(RichTextUtils.StripRichTextTags(song), "");
            var strippedArtist = ReplayNameRegex.Replace(RichTextUtils.StripRichTextTags(artist), "");
            var strippedCharter = ReplayNameRegex.Replace(RichTextUtils.StripRichTextTags(charter), "");

            return $"{strippedArtist}-{strippedSong}-{strippedCharter}-{date:yy-MM-dd-HH-mm-ss}";
        }
    }
}
</file>

<file path="Replays/ReplayIO.cs">
using System;
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.Game;
using YARG.Core.IO;
using YARG.Core.Logging;
using YARG.Core.Song;

namespace YARG.Core.Replays
{
    public enum ReplayReadResult
    {
        Valid,
        MetadataOnly,
        InvalidVersion,
        DataMismatch,
        NotAReplay,
        Corrupted,
        FileNotFound,
    }

    public static class ReplayIO
    {
        private static readonly EightCC REPLAY_MAGIC_HEADER_OLD = new('Y', 'A', 'R', 'G', 'P', 'L', 'A', 'Y');
        private static readonly EightCC REPLAY_MAGIC_HEADER = new('Y', 'A', 'R', 'E', 'P', 'L', 'A', 'Y');

        private static readonly (int OLD_MIN, int METADATA_MIN, int DATA_MIN, int CURRENT) REPLAY_VERSIONS = (4, 6, 7, 7);
        private const int ENGINE_VERSION = 2;

        public static (ReplayReadResult Result, ReplayInfo Info, ReplayData Data) TryDeserialize(string path)
        {
            try
            {
                using var fstream = File.OpenRead(path);
                if (!REPLAY_MAGIC_HEADER.Matches(fstream))
                {
                    fstream.Position = 0;
                    // Old replays don't have their actual data deserialized
                    if (REPLAY_MAGIC_HEADER_OLD.Matches(fstream))
                    {
                        var (result, info_old) = ReadInfo_Old(path, fstream);
                        return (result, info_old, null!);
                    }
                    else
                    {
                        return (ReplayReadResult.NotAReplay, null!, null!);
                    }
                }

                var headerHash = HashWrapper.Deserialize(fstream);
                int headerLength = fstream.Read<int>(Endianness.Little);
                using var headerArray = FixedArray.Read(fstream, headerLength);
                if (!headerHash.Equals(HashWrapper.Hash(headerArray.ReadOnlySpan)))
                {
                    return (ReplayReadResult.Corrupted, null!, null!);
                }

                var info = new ReplayInfo(path, headerArray.ToValueStream());
                if (info.ReplayVersion < REPLAY_VERSIONS.METADATA_MIN || info.ReplayVersion > REPLAY_VERSIONS.CURRENT)
                {
                    return (ReplayReadResult.InvalidVersion, null!, null!);
                }

                // Ensures a cutoff for only legible data
                if (info.ReplayVersion < REPLAY_VERSIONS.DATA_MIN)
                {
                    return (ReplayReadResult.MetadataOnly, info, null!);
                }

                using var data = FixedArray.ReadRemainder(fstream);
                if (!info.ReplayChecksum.Equals(HashWrapper.Hash(data.ReadOnlySpan)))
                {
                    return (ReplayReadResult.Corrupted, null!, null!);
                }

                var replayData = new ReplayData(data.ToValueStream(), info.ReplayVersion);
                return (ReplayReadResult.Valid, info, replayData);
            }
            catch (Exception ex)
            {
                YargLogger.LogException(ex, "Failed to read replay file");
                return (ReplayReadResult.Corrupted, null!, null!);
            }
        }

        public static (ReplayReadResult Result, ReplayInfo Info) TryReadMetadata(string path)
        {
            try
            {
                using var fstream = File.OpenRead(path);
                if (!REPLAY_MAGIC_HEADER.Matches(fstream))
                {
                    fstream.Position = 0;
                    // Old replays use a different read pattern with fewer checks
                    if (REPLAY_MAGIC_HEADER_OLD.Matches(fstream))
                    {
                        return ReadInfo_Old(path, fstream);
                    }
                    else
                    {
                        return (ReplayReadResult.NotAReplay, null!);
                    }
                }

                var headerHash = HashWrapper.Deserialize(fstream);
                int headerLength = fstream.Read<int>(Endianness.Little);
                using var headerArray = FixedArray.Read(fstream, headerLength);
                if (!headerHash.Equals(HashWrapper.Hash(headerArray.ReadOnlySpan)))
                {
                    return (ReplayReadResult.Corrupted, null!);
                }

                var info = new ReplayInfo(path, headerArray.ToValueStream());
                if (info.ReplayVersion < REPLAY_VERSIONS.METADATA_MIN || info.ReplayVersion > REPLAY_VERSIONS.CURRENT)
                {
                    return (ReplayReadResult.InvalidVersion, null!);
                }

                if (info.ReplayVersion < REPLAY_VERSIONS.DATA_MIN)
                {
                    return (ReplayReadResult.MetadataOnly, info);
                }

                // The stream-based hashing function provides better efficiency in this instance
                // as we don't read the entire file.
                //
                // We still want to check the integrity here so that it doesn't error out when attempting to load
                // the file in its entirety later.
                using var algo = HashWrapper.Algorithm;
                var hash = algo.ComputeHash(fstream);
                if (!info.ReplayChecksum.Equals(HashWrapper.Create(hash)))
                {
                    return (ReplayReadResult.Corrupted, null!);
                }
                return (ReplayReadResult.Valid, info);
            }
            catch (Exception ex)
            {
                YargLogger.LogException(ex, "Failed to read replay file");
                return (ReplayReadResult.Corrupted, null!);
            }
        }

        public static (ReplayReadResult Result, ReplayData Data) TryLoadData(ReplayInfo info)
        {
            try
            {
                using var fstream = File.OpenRead(info.FilePath);
                if (!REPLAY_MAGIC_HEADER.Matches(fstream))
                {
                    fstream.Position = 0;
                    // Old replays don't have their actual data deserialized
                    if (REPLAY_MAGIC_HEADER_OLD.Matches(fstream))
                    {
                        // If true, someone did a no-no and swapped the file
                        if (info.ReplayVersion >= REPLAY_VERSIONS.METADATA_MIN)
                        {
                            return (ReplayReadResult.DataMismatch, null!);
                        }

                        int replayVersion_old = fstream.Read<int>(Endianness.Little);
                        int engineVersion_old = fstream.Read<int>(Endianness.Little);
                        var replayChecksum_old = HashWrapper.Deserialize(fstream);
                        // If true, someone did a no-no and swapped the file
                        if (replayVersion_old != info.ReplayVersion || info.EngineVersion != engineVersion_old || !info.ReplayChecksum.Equals(replayChecksum_old))
                        {
                            return (ReplayReadResult.DataMismatch, null!);
                        }
                    }
                    return (ReplayReadResult.InvalidVersion, null!);
                }

                // If true, someone did a no-no and swapped the file
                if (info.ReplayVersion < REPLAY_VERSIONS.METADATA_MIN)
                {
                    return (ReplayReadResult.DataMismatch, null!);
                }

                var headerHash = HashWrapper.Deserialize(fstream);
                int headerLength = fstream.Read<int>(Endianness.Little);
                using var headerArray = FixedArray.Read(fstream, headerLength);
                if (!headerHash.Equals(HashWrapper.Hash(headerArray.ReadOnlySpan)))
                {
                    return (ReplayReadResult.Corrupted, null!);
                }

                var headerStream = headerArray.ToValueStream();
                int replayVersion = headerStream.Read<int>(Endianness.Little);
                int engineVersion = headerStream.Read<int>(Endianness.Little);
                var replayChecksum = HashWrapper.Deserialize(ref headerStream);
                // If true, someone did a no-no and swapped the file
                if (replayVersion != info.ReplayVersion || info.EngineVersion != engineVersion || !info.ReplayChecksum.Equals(replayChecksum))
                {
                    return (ReplayReadResult.DataMismatch, null!);
                }

                using var data = FixedArray.ReadRemainder(fstream);
                if (!info.ReplayChecksum.Equals(HashWrapper.Hash(data.ReadOnlySpan)))
                {
                    return (ReplayReadResult.Corrupted, null!);
                }

                var replayData = new ReplayData(data.ToValueStream(), info.ReplayVersion);
                return (ReplayReadResult.Valid, replayData);
            }
            catch (Exception ex)
            {
                YargLogger.LogException(ex, "Failed to read replay file");
                return (ReplayReadResult.Corrupted, null!);
            }
        }

        public static (bool Success, ReplayInfo Info) TrySerialize(string directory, SongEntry song, float speed, double length, int score, StarAmount stars, ReplayStats[] stats, ReplayData data)
        {
            try
            {
                // Write all the data for the replay hash
                var replayData = data.Serialize();
                var replayChecksum = HashWrapper.Hash(replayData);

                var date = DateTime.Now;
                var replayName = ReplayInfo.ConstructReplayName(song.Name, song.Artist, song.Charter, in date);

                var path = Path.Combine(directory, replayName + ".replay");
                var info = new ReplayInfo(path, replayName, REPLAY_VERSIONS.CURRENT, ENGINE_VERSION, in replayChecksum, song.Name, song.Artist, song.Charter, song.Hash, in date, speed, length, score, stars, stats);

                // Write all the data for the header hash
                using var headerStream = new MemoryStream();
                using var headerWriter = new BinaryWriter(headerStream);
                info.Serialize(headerWriter);

                var headerData = new ReadOnlySpan<byte>(headerStream.GetBuffer(), 0, (int) headerStream.Length);
                var headerChecksum = HashWrapper.Hash(headerData);

                // Write all processed data to the file
                using var fstream = File.OpenWrite(path);
                using var fileWriter = new BinaryWriter(fstream);
                REPLAY_MAGIC_HEADER.Serialize(fileWriter);
                headerChecksum.Serialize(fileWriter);
                fileWriter.Write(headerData.Length);
                fileWriter.Write(headerData);
                fileWriter.Write(replayData);
                return (true, info);
            }
            catch (Exception e)
            {
                YargLogger.LogException(e, "Failed to save replay to file");
                return (false, null!);
            }
        }

        private static (ReplayReadResult, ReplayInfo) ReadInfo_Old(string path, FileStream fstream)
        {
            // This value can't be correctly parsed from old data due to version inconsistencies
            // + It originally only came from EngineParameters
            const float DEFAULT_SPEED = 1.0f;
            int replayVersion = fstream.Read<int>(Endianness.Little);
            if (replayVersion < REPLAY_VERSIONS.OLD_MIN || replayVersion >= REPLAY_VERSIONS.METADATA_MIN)
            {
                return (ReplayReadResult.InvalidVersion, null!);
            }

            int engineVersion = fstream.Read<int>(Endianness.Little);
            var replayChecksum = HashWrapper.Deserialize(fstream);

            using var data = FixedArray.ReadRemainder(fstream);
            if (!replayChecksum.Equals(HashWrapper.Hash(data.ReadOnlySpan)))
            {
                return (ReplayReadResult.Corrupted, null!);
            }

            var memStream = data.ToValueStream();
            var song = memStream.ReadString();
            var artist = memStream.ReadString();
            var charter = memStream.ReadString();
            var score = memStream.Read<int>(Endianness.Little);
            var stars = (StarAmount) memStream.ReadByte();
            var length = memStream.Read<double>(Endianness.Little);
            var date = DateTime.FromBinary(memStream.Read<long>(Endianness.Little));
            var songChecksum = HashWrapper.Deserialize(ref memStream);

            var replayName = ReplayInfo.ConstructReplayName(song, artist, charter, in date);
            var info = new ReplayInfo(path, replayName, replayVersion, engineVersion, in replayChecksum, song, artist, charter, in songChecksum, in date, DEFAULT_SPEED, length, score, stars, Array.Empty<ReplayStats>());
            return (ReplayReadResult.MetadataOnly, info);
        }
    }
}
</file>

<file path="Song/Cache/CacheGroups/CONEntryGroup.cs">
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.IO;

namespace YARG.Core.Song.Cache
{
    internal abstract class CONEntryGroup : IEntryGroup, IDisposable, IEnumerable<KeyValuePair<string, List<YARGTextContainer<byte>>>>
    {
        public const string SONGS_DTA = "songs.dta";

        private readonly Dictionary<string, List<(int Index, RBCONEntry Entry)>> _entries;
        private readonly string _defaultPlaylist;
        protected readonly AbridgedFileInfo _root;
        protected readonly Dictionary<string, List<YARGTextContainer<byte>>> _nodes;
        protected FixedArray<byte> _data;

        protected abstract bool Tag { get; }

        public AbridgedFileInfo Root => _root;
        public string DefaultPlaylist => _defaultPlaylist;

        public abstract void DeserializeEntry(ref FixedArrayStream stream, string name, int index, CacheReadStrings strings);

        public virtual CONEntryGroup InitScan() { return this; }

        public abstract ScanExpected<RBCONEntry> CreateEntry(in RBScanParameters paramaters);

        public void AddEntry(string name, int index, RBCONEntry entry)
        {
            lock (_entries)
            {
                if (!_entries.TryGetValue(name, out var list))
                {
                    _entries.Add(name, list = new List<(int Index, RBCONEntry Entry)>(1));
                }

                int position = 0;
                while (position < list.Count && list[position].Index < index)
                {
                    ++position;
                }
                list.Insert(position, (index, entry));
            }
        }

        public void RemoveEntries(string name)
        {
            lock ( _entries)
            {
                _entries.Remove(name);
            }
        }

        public bool TryGetEntry(string name, int index, out RBCONEntry entry)
        {
            lock (_entries)
            {
                if (_entries.TryGetValue(name, out var list))
                {
                    for (int i = 0; i < list.Count; ++i)
                    {
                        if (list[i].Index == index)
                        {
                            entry = list[i].Entry;
                            return true;
                        }
                    }
                }
            }
            entry = null!;
            return false;
        }

        public void Serialize(MemoryStream groupStream, Dictionary<SongEntry, CacheWriteIndices> indices)
        {
            _root.Serialize(groupStream);
            groupStream.Write(Tag);

            int count = 0;
            foreach (var list in _entries)
            {
                count += list.Value.Count;
            }
            groupStream.Write(count, Endianness.Little);

            using var entryStream = new MemoryStream();
            foreach (var list in _entries)
            {
                foreach (var node in list.Value)
                {
                    entryStream.SetLength(0);

                    entryStream.Write(list.Key);
                    entryStream.WriteByte((byte)node.Index);
                    node.Entry.Serialize(entryStream, indices[node.Entry]);

                    groupStream.Write((int)entryStream.Length, Endianness.Little);
                    groupStream.Write(entryStream.GetBuffer(), 0, (int)entryStream.Length);
                }
            }
        }

        public virtual void Dispose()
        {
            _data.Dispose();
        }

        public Dictionary<string, List<YARGTextContainer<byte>>>.Enumerator GetEnumerator()
        {
            return _nodes.GetEnumerator();
        }

        IEnumerator<KeyValuePair<string, List<YARGTextContainer<byte>>>> IEnumerable<KeyValuePair<string, List<YARGTextContainer<byte>>>>.GetEnumerator()
        {
            return _nodes.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return _nodes.GetEnumerator();
        }

        protected CONEntryGroup(in AbridgedFileInfo root, string defaultPlaylist)
        {
            _root = root;
            _nodes = new Dictionary<string, List<YARGTextContainer<byte>>>();
            _entries = new Dictionary<string, List<(int Index, RBCONEntry Entry)>>();
            _defaultPlaylist = defaultPlaylist;
        }
    }
}
</file>

<file path="Song/Cache/CacheGroups/CONModificationGroup.cs">
using System.Collections.Generic;
using YARG.Core.IO;

namespace YARG.Core.Song.Cache
{
    internal class CONModifcationGroup<TValue>
    {
        public readonly AbridgedFileInfo Root;
        public readonly Dictionary<string, TValue> Values;
        public FixedArray<byte> Data;

        public CONModifcationGroup(in AbridgedFileInfo root)
        {
            Root = root;
            Values = new Dictionary<string, TValue>();
            Data = FixedArray<byte>.Null;
        }
    }
}
</file>

<file path="Song/Cache/CacheGroups/CONUpdateGroup.cs">
using System;
using System.Collections.Generic;
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.IO;
using YARG.Core.Logging;

namespace YARG.Core.Song.Cache
{
    internal class CONUpdateGroup : IDisposable
    {
        private readonly Dictionary<string, (List<YARGTextContainer<byte>> Containers, DateTime? Update)> _updates = new();
        private AbridgedFileInfo _root;
        private FixedArray<byte> _data;
       
        public AbridgedFileInfo Root => _root;
        public Dictionary<string, (List<YARGTextContainer<byte>> Containers, DateTime? Update)> Updates => _updates;

        public void Dispose()
        {
            _data.Dispose();
        }

        private CONUpdateGroup() { }

        public static bool Create(string directory, FileInfo dtaInfo, out CONUpdateGroup group)
        {
            group = new CONUpdateGroup()
            {
                _root = new AbridgedFileInfo(directory, AbridgedFileInfo.NormalizedLastWrite(dtaInfo)),
            };

            try
            {
                using var data = FixedArray.LoadFile(dtaInfo.FullName);
                var container = YARGDTAReader.Create(in data);
                while (YARGDTAReader.StartNode(ref container))
                {
                    string name = YARGDTAReader.GetNameOfNode(ref container, true);
                    if (!group._updates.TryGetValue(name, out var node))
                    {
                        DateTime? lastWriteTime = null;
                        var info = new FileInfo(Path.Combine(group._root.FullName, name, name + "_update.mid"));
                        if (info.Exists)
                        {
                            lastWriteTime = AbridgedFileInfo.NormalizedLastWrite(info);
                        }
                        group._updates.Add(name, node = (new List<YARGTextContainer<byte>>(), lastWriteTime));
                    }
                    node.Containers.Add(container);
                    YARGDTAReader.EndNode(ref container);
                }
                group._data = data.TransferOwnership();
                return true;
            }
            catch (Exception e)
            {
                YargLogger.LogException(e);
                group = null!;
                return false;
            }
        }

        public static void SerializeGroups(FileStream fileStream, List<CONUpdateGroup> groups)
        {
            using var groupStream = new MemoryStream();
            fileStream.Write(groups.Count, Endianness.Little);
            for (int i = 0; i < groups.Count; i++)
            {
                groupStream.SetLength(0);
                groups[i]._root.Serialize(groupStream);
                groupStream.Write(groups[i]._updates.Count, Endianness.Little);
                foreach (var node in groups[i]._updates)
                {
                    groupStream.Write(node.Key);
                    groupStream.Write(node.Value.Update.HasValue);
                    if (node.Value.Update.HasValue)
                    {
                        groupStream.Write(node.Value.Update.Value.ToBinary(), Endianness.Little);
                    }
                }
                fileStream.Write((int) groupStream.Length, Endianness.Little);
                fileStream.Write(groupStream.GetBuffer(), 0, (int) groupStream.Length);
            }
        }
    }
}
</file>

<file path="Song/Cache/CacheGroups/CONUpgradeGroup.cs">
using System;
using System.Collections.Generic;
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.IO;
using YARG.Core.Logging;

namespace YARG.Core.Song.Cache
{
    internal class PackedCONUpgradeGroup
    {
        private readonly Dictionary<string, (YARGTextContainer<byte> Container, PackedRBProUpgrade Upgrade)> _upgrades = new();
        private AbridgedFileInfo _root;
        private FixedArray<byte> _data;

        public AbridgedFileInfo Root => _root;
        public Dictionary<string, (YARGTextContainer<byte> Container, PackedRBProUpgrade Upgrade)> Upgrades => _upgrades;

        public void Dispose()
        {
            _data.Dispose();
        }

        private PackedCONUpgradeGroup() { }

        public static bool Create(Stream stream, List<CONFileListing> listings, in AbridgedFileInfo root, out PackedCONUpgradeGroup group)
        {
            const string UPGRADES_PATH = PackedRBProUpgrade.UPGRADES_DIRECTORY + RBProUpgrade.UPGRADES_DTA;
            group = null!;
            if (listings.FindListing(UPGRADES_PATH, out var listing))
            {
                group = new PackedCONUpgradeGroup()
                {
                    _root = root,
                };

                using var data = CONFileStream.LoadFile(stream, listing);
                var container = YARGDTAReader.Create(in data);
                while (YARGDTAReader.StartNode(ref container))
                {
                    string name = YARGDTAReader.GetNameOfNode(ref container, true);
                    if (listings.FindListing(PackedRBProUpgrade.UPGRADES_DIRECTORY + name + RBProUpgrade.UPGRADES_MIDI_EXT, out listing))
                    {
                        group._upgrades[name] = (container, new PackedRBProUpgrade(listing, root));
                    }
                    YARGDTAReader.EndNode(ref container);
                }
                group._data = data.TransferOwnership();
            }
            return group != null;
        }

        public static void SerializeGroups(FileStream fileStream, List<PackedCONUpgradeGroup> groups)
        {
            using var groupStream = new MemoryStream();
            fileStream.Write(groups.Count, Endianness.Little);
            for (int i = 0; i < groups.Count; i++)
            {
                groupStream.SetLength(0);
                groups[i]._root.Serialize(groupStream);
                groupStream.Write(groups[i]._upgrades.Count, Endianness.Little);
                foreach (var node in groups[i]._upgrades)
                {
                    groupStream.Write(node.Key);
                }
                fileStream.Write((int) groupStream.Length, Endianness.Little);
                fileStream.Write(groupStream.GetBuffer(), 0, (int) groupStream.Length);
            }
        }
    }

    internal class UnpackedCONUpgradeGroup
    {
        private readonly Dictionary<string, (YARGTextContainer<byte> Container, UnpackedRBProUpgrade Upgrade)> _upgrades = new();
        private AbridgedFileInfo _root;
        private FixedArray<byte> _data;

        public AbridgedFileInfo Root => _root;
        public Dictionary<string, (YARGTextContainer<byte> Container, UnpackedRBProUpgrade Upgrade)> Upgrades => _upgrades;

        public void Dispose()
        {
            _data.Dispose();
        }

        private UnpackedCONUpgradeGroup() { }

        public static bool Create(in FileCollection collection, FileInfo dtaInfo, out UnpackedCONUpgradeGroup group)
        {
            group = new UnpackedCONUpgradeGroup()
            {
                _root = new AbridgedFileInfo(collection.Directory, AbridgedFileInfo.NormalizedLastWrite(dtaInfo))
            };

            try
            {
                using var data = FixedArray.LoadFile(dtaInfo.FullName);
                var container = YARGDTAReader.Create(in data);
                while (YARGDTAReader.StartNode(ref container))
                {
                    string name = YARGDTAReader.GetNameOfNode(ref container, true);
                    if (collection.FindFile(name.ToLower() + RBProUpgrade.UPGRADES_MIDI_EXT, out var info))
                    {
                        group._upgrades[name] = (container, new UnpackedRBProUpgrade(name, info.LastWriteTime, group._root));
                    }
                    YARGDTAReader.EndNode(ref container);
                }
                group._data = data.TransferOwnership();
                return true;
            }
            catch (Exception e)
            {
                YargLogger.LogException(e);
                group = null!;
                return false;
            }
        }

        public static void SerializeGroups(FileStream fileStream, List<UnpackedCONUpgradeGroup> groups)
        {
            using var groupStream = new MemoryStream();
            fileStream.Write(groups.Count, Endianness.Little);
            for (int i = 0; i < groups.Count; i++)
            {
                groupStream.SetLength(0);
                groups[i]._root.Serialize(groupStream);
                groupStream.Write(groups[i]._upgrades.Count, Endianness.Little);
                foreach (var node in groups[i]._upgrades)
                {
                    groupStream.Write(node.Key);
                    groupStream.Write(node.Value.Upgrade.LastWriteTime.ToBinary(), Endianness.Little);
                }
                fileStream.Write((int) groupStream.Length, Endianness.Little);
                fileStream.Write(groupStream.GetBuffer(), 0, (int) groupStream.Length);
            }
        }
    }
}
</file>

<file path="Song/Cache/CacheGroups/EntryGroup.cs">
using System.Collections.Generic;
using System.IO;
using YARG.Core.Extensions;

namespace YARG.Core.Song.Cache
{
    internal interface IEntryGroup
    {
        public void Serialize(MemoryStream groupStream, Dictionary<SongEntry, CacheWriteIndices> indices);

        public static void SerializeGroups<TGroup>(FileStream fileStream, List<TGroup> groups, Dictionary<SongEntry, CacheWriteIndices> nodes)
            where TGroup : IEntryGroup
        {
            using var groupStream = new MemoryStream();
            fileStream.Write(groups.Count, Endianness.Little);
            for (int i = 0; i < groups.Count; i++)
            {
                groupStream.SetLength(0);
                groups[i].Serialize(groupStream, nodes);
                fileStream.Write((int) groupStream.Length, Endianness.Little);
                fileStream.Write(groupStream.GetBuffer(), 0, (int) groupStream.Length);
            }
        }
    }
}
</file>

<file path="Song/Cache/CacheGroups/IniEntryGroup.cs">
using System.Collections.Generic;
using System.IO;
using YARG.Core.Extensions;

namespace YARG.Core.Song.Cache
{
    internal sealed class IniEntryGroup : IEntryGroup
    {
        private readonly string _directory;
        private readonly List<UnpackedIniEntry> _unpacked = new();
        private readonly List<SngEntry> _packed = new();

        public string Directory => _directory;

        public IniEntryGroup(string directory)
        {
            _directory = directory;
        }

        public void AddEntry(UnpackedIniEntry entry)
        {
            lock (_unpacked)
            {
                _unpacked.Add(entry);
            }
        }

        public void AddEntry(SngEntry entry)
        {
            lock (_packed)
            {
                _packed.Add(entry);
            }
        }

        public void Serialize(MemoryStream groupStream, Dictionary<SongEntry, CacheWriteIndices> nodes)
        {
            groupStream.Write(_directory);
            using MemoryStream entryStream = new();
            SerializeList(entryStream, _unpacked, groupStream, nodes);
            SerializeList(entryStream, _packed, groupStream, nodes);
        }

        private void SerializeList<TEntry>(MemoryStream entryStream, List<TEntry> entries, MemoryStream groupStream, Dictionary<SongEntry, CacheWriteIndices> nodes)
            where TEntry : IniSubEntry
        {
            groupStream.Write(entries.Count, Endianness.Little);
            foreach (var entry in entries)
            {
                entryStream.SetLength(0);

                // Validation block
                string relativePath = Path.GetRelativePath(_directory, entry.ActualLocation);
                if (relativePath == ".")
                {
                    relativePath = string.Empty;
                }
                entryStream.Write(relativePath);

                entry.Serialize(entryStream, nodes[entry]);

                groupStream.Write((int) entryStream.Length, Endianness.Little);
                groupStream.Write(entryStream.GetBuffer(), 0, (int) entryStream.Length);
            }
        }
    }
}
</file>

<file path="Song/Cache/CacheGroups/PackedCONEntryGroup.cs">
using Microsoft.Win32.SafeHandles;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.MemoryMappedFiles;
using System.Text;
using YARG.Core.IO;
using YARG.Core.Logging;

namespace YARG.Core.Song.Cache
{
    internal class PackedCONEntryGroup : CONEntryGroup
    {
        private readonly List<CONFileListing> _listings;
        private FileStream _stream = null!;

        protected override bool Tag => true;

        private PackedCONEntryGroup(List<CONFileListing> listings, in AbridgedFileInfo root, string defaultPlaylist)
            : base(root, defaultPlaylist)
        {
            _listings = listings;
        }

        public override CONEntryGroup InitScan()
        {
            _stream = new FileStream(_root.FullName, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
            return this;
        }

        public override ScanExpected<RBCONEntry> CreateEntry(in RBScanParameters paramaters)
        {
            return PackedRBCONEntry.Create(in paramaters, _listings, _stream);
        }

        public override void Dispose()
        {
            _stream.Dispose();
            base.Dispose();
        }

        public override void DeserializeEntry(ref FixedArrayStream stream, string name, int index, CacheReadStrings strings)
        {
            var entry = PackedRBCONEntry.TryDeserialize(_listings, in _root, name, ref stream, strings);
            if (entry != null)
            {
                AddEntry(name, index, entry);
            }
        }

        public static bool Create(Stream stream, List<CONFileListing> listings, in AbridgedFileInfo root, string defaultPlaylist, out PackedCONEntryGroup group)
        {
            const string SONGS_PATH = "songs/songs.dta";
            group = null!;
            if (listings.FindListing(SONGS_PATH, out var listing))
            {
                group = new PackedCONEntryGroup(listings, in root, defaultPlaylist);
                using var data = CONFileStream.LoadFile(stream, listing);
                var container = YARGDTAReader.Create(in data);
                while (YARGDTAReader.StartNode(ref container))
                {
                    string name = YARGDTAReader.GetNameOfNode(ref container, true);
                    if (!group._nodes.TryGetValue(name, out var list))
                    {
                        // Most dtas abide by the `unique name` rule, so we only really need the space for one
                        //.... "MOST"
                        group._nodes.Add(name, list = new List<YARGTextContainer<byte>>(1));
                    }
                    list.Add(container);
                    YARGDTAReader.EndNode(ref container);
                }
                group._data = data.TransferOwnership();
            }
            return group != null;
        }
    }
}
</file>

<file path="Song/Cache/CacheGroups/UnpackedCONEntryGroup.cs">
using System;
using System.Collections.Generic;
using System.IO;
using YARG.Core.IO;
using YARG.Core.Logging;

namespace YARG.Core.Song.Cache
{
    internal class UnpackedCONEntryGroup : CONEntryGroup
    {
        protected override bool Tag => false;
        private UnpackedCONEntryGroup(in AbridgedFileInfo root, string defaultPlaylist)
            : base(root, defaultPlaylist) { }

        public override ScanExpected<RBCONEntry> CreateEntry(in RBScanParameters paramaters)
        {
            return UnpackedRBCONEntry.Create(in paramaters);
        }

        public override void DeserializeEntry(ref FixedArrayStream stream, string name, int index, CacheReadStrings strings)
        {
            var entry = UnpackedRBCONEntry.TryDeserialize(in _root, name, ref stream, strings);
            if (entry != null)
            {
                AddEntry(name, index, entry);
            }
        }

        public static bool Create(string directory, FileInfo dtaInfo, string defaultPlaylist, out UnpackedCONEntryGroup group)
        {
            var dtaLastWrite = AbridgedFileInfo.NormalizedLastWrite(dtaInfo);
            var root = new AbridgedFileInfo(directory, dtaLastWrite);
            group = new UnpackedCONEntryGroup(in root, defaultPlaylist);
            try
            {
                using var data = FixedArray.LoadFile(dtaInfo.FullName);
                var container = YARGDTAReader.Create(in data);
                while (YARGDTAReader.StartNode(ref container))
                {
                    string name = YARGDTAReader.GetNameOfNode(ref container, true);
                    if (!group._nodes.TryGetValue(name, out var list))
                    {
                        // Most dtas abide by the `unique name` rule, so we only really need the space for one
                        //.... "MOST"
                        group._nodes.Add(name, list = new List<YARGTextContainer<byte>>(1));
                    }
                    list.Add(container);
                    YARGDTAReader.EndNode(ref container);
                }
                group._data = data.TransferOwnership();
                return true;
            }
            catch (Exception e)
            {
                YargLogger.LogException(e);
                group = null!;
                return false;
            }
        }
    }
}
</file>

<file path="Song/Cache/CacheHandler.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using YARG.Core.Audio;
using YARG.Core.Extensions;
using YARG.Core.IO;
using YARG.Core.Logging;

namespace YARG.Core.Song.Cache
{
    public enum ScanStage
    {
        LoadingCache,
        LoadingSongs,
        Sorting,
        WritingCache,
        WritingBadSongs
    }

    public struct ScanProgressTracker
    {
        public ScanStage Stage;
        public int Count;
        public int NumScannedDirectories;
        public int BadSongCount;
    }

    public class CacheHandler : IDisposable
    {
        /// <summary>
        /// The date revision of the cache format, relative to UTC.
        /// Format is YY_MM_DD_RR: Y = year, M = month, D = day, R = revision (reset across dates, only increment
        /// if multiple cache version changes happen in a single day).
        /// </summary>
        private const int CACHE_VERSION = 25_03_14_01;

        public static ScanProgressTracker Progress => _progress;
        private static ScanProgressTracker _progress;

        public static SongCache RunScan(bool tryQuickScan, string cacheLocation, string badSongsLocation, bool fullDirectoryPlaylists, List<string> baseDirectories)
        {
            using var handler = new CacheHandler(baseDirectories);

            // Some ini entry items won't come with the song length defined in the .ini file.
            // In those instances, we'll need to attempt to load the audio files that accompany the chart
            // to evaluate the length directly.
            // This toggle simply keeps those generated mixers from spamming the logs on creation.
            GlobalAudioHandler.LogMixerStatus = false;
            try
            {
                // Quick scans only fail if they parse zero entries (which could be the result of a few things)
                if (!tryQuickScan || !QuickScan(handler, cacheLocation, fullDirectoryPlaylists))
                {
                    // If a quick scan failed, there's no point to re-reading it in the full scan
                    FullScan(handler, !tryQuickScan, cacheLocation, badSongsLocation, fullDirectoryPlaylists);
                }
            }
            catch (Exception ex)
            {
                YargLogger.LogException(ex, "Unknown error while running song scan!");
            }
            GlobalAudioHandler.LogMixerStatus = true;
            return handler.cache;
        }

        /// <summary>
        /// Reads the entries from a cache file - performing very few validation checks on the entries contained within
        /// for the sole purpose of speeding through to gameplay.
        /// </summary>
        /// <param name="handler">A parallel or sequential handler</param>
        /// <param name="cacheLocation">File path of the cache</param>
        /// <returns>Whether the scan sucessfully parsed entries</returns>
        private static bool QuickScan(CacheHandler handler, string cacheLocation, bool fullDirectoryPlaylists)
        {
            try
            {
                using var cacheFile = LoadCacheToMemory(cacheLocation, fullDirectoryPlaylists);
                if (cacheFile.IsAllocated)
                {
                    _progress.Stage = ScanStage.LoadingCache;
                    YargLogger.LogDebug("Quick Read start");
                    handler.Deserialize_Quick(in cacheFile);
                }
            }
            catch (Exception ex)
            {
                YargLogger.LogException(ex, "Error occurred during quick cache file read!");
            }

            if (handler.cache.Entries.Count == 0)
            {
                return false;
            }

            _progress.Stage = ScanStage.Sorting;
            SongEntrySorting.SortEntries(handler.cache);
            YargLogger.LogFormatDebug("Total Entries: {0}", _progress.Count);
            return true;
        }

        /// <summary>
        /// Runs a full scan process for a user's library.
        /// Firstly, it attempts to read entries from a cache file - performing all validation checks necessary
        /// to ensure that the player can immediately play whatever comes off the cache.
        /// Secondly, we traverse the user's filesystem starting from their provided base directory nodes for any entries
        /// that were not found from the cache or required re-evaluating.
        /// Finally, we write the results of the scan back to a cache file and, if necessary, a badsongs.txt file containing the failures.
        /// </summary>
        /// <param name="handler">A parallel or sequential handler</param>
        /// <param name="loadCache">A flag communicating whether to perform the cache read (false only from failed quick scans)</param>
        /// <param name="cacheLocation">File path of the cache</param>
        /// <param name="badSongsLocation">File path of the badsongs.txt</param>
        private static void FullScan(CacheHandler handler, bool loadCache, string cacheLocation, string badSongsLocation, bool fullDirectoryPlaylists)
        {
            if (loadCache)
            {
                try
                {
                    using var cacheFile = LoadCacheToMemory(cacheLocation, fullDirectoryPlaylists);
                    if (cacheFile.IsAllocated)
                    {
                        _progress.Stage = ScanStage.LoadingCache;
                        YargLogger.LogDebug("Full Read start");
                        handler.Deserialize(in cacheFile, fullDirectoryPlaylists);
                    }
                }
                catch (Exception ex)
                {
                    YargLogger.LogException(ex, "Error occurred during full cache file read!");
                }
            }

            _progress.Stage = ScanStage.LoadingSongs;
            handler.FindNewEntries(fullDirectoryPlaylists);
            // CON, Upgrade, and Update groups hold onto the DTA data in memory.
            // Once all entries are processed, they are no longer useful to us, so we dispose of them here.
            handler.Dispose();

            _progress.Stage = ScanStage.Sorting;
            SongEntrySorting.SortEntries(handler.cache);
            YargLogger.LogFormatDebug("Total Entries: {0}", _progress.Count);

            try
            {
                _progress.Stage = ScanStage.WritingCache;
                handler.Serialize(cacheLocation, fullDirectoryPlaylists);
            }
            catch (Exception ex)
            {
                YargLogger.LogException(ex, "Error when writing song cache!");
            }

            try
            {
                if (handler.badSongs.Count > 0)
                {
                    _progress.Stage = ScanStage.WritingBadSongs;
                    handler.WriteBadSongs(badSongsLocation);
                }
                else
                {
                    File.Delete(badSongsLocation);
                }
            }
            catch (Exception ex)
            {
                YargLogger.LogException(ex, "Error when writing bad songs file!");
            }
        }

        #region Data

        private readonly SongCache cache = new();

        private readonly List<IniEntryGroup> iniGroups;
        private readonly List<CONEntryGroup> conEntryGroups = new();
        private readonly List<CONUpdateGroup> updateGroups = new();
        private readonly List<PackedCONUpgradeGroup> packedUpgradeGroups = new();
        private readonly List<UnpackedCONUpgradeGroup> unpackedUpgradeGroups = new();

        private readonly Dictionary<string, CONModification> conModifications = new();

        private readonly HashSet<string> preScannedPaths = new();
        private readonly SortedDictionary<string, ScanResult> badSongs = new();
        #endregion

        #region Common

        private CacheHandler(List<string> baseDirectories)
        {
            _progress = default;

            iniGroups = new(baseDirectories.Count);
            foreach (string dir in baseDirectories)
            {
                if (!string.IsNullOrEmpty(dir) && !iniGroups.Exists(group => { return group.Directory == dir; }))
                {
                    iniGroups.Add(new IniEntryGroup(dir));
                }
            }
        }

        /// <summary>
        /// Removes all the entries present in all packed and unpacked con groups that have a matching DTA node name
        /// </summary>
        private void RemoveCONEntries<T>(Dictionary<string, T> modifications)
        {
            lock (conEntryGroups)
            {
                foreach (var mod in modifications)
                {
                    for (int i = 0; i < conEntryGroups.Count; i++)
                    {
                        conEntryGroups[i].RemoveEntries(mod.Key);
                    }
                }
            }
        }

        /// <summary>
        /// Grabs or constructs a node containing all the updates or upgrades that can applied to any DTA entries
        /// that have a name matching the one provided.
        /// </summary>
        /// <param name="name">The name of the DTA node for the entry</param>
        /// <returns>The node with the update and upgrade information</returns>
        private CONModification GetCONMod(string name)
        {
            CONModification mods;
            lock (conModifications)
            {
                if (!conModifications.TryGetValue(name, out mods))
                {
                    conModifications.Add(name, mods = new CONModification());
                }
            }

            lock (mods)
            {
                if (!mods.Processed)
                {
                    foreach (var group in updateGroups)
                    {
                        if (!group.Updates.TryGetValue(name, out var node))
                        {
                            continue;
                        }

                        if (mods.UpdateDirectoryAndDtaLastWrite.HasValue &&
                            group.Root.LastWriteTime <= mods.UpdateDirectoryAndDtaLastWrite.Value.LastWriteTime)
                        {
                            continue;
                        }

                        mods.UpdateDirectoryAndDtaLastWrite = group.Root;
                        mods.UpdateDTA = DTAEntry.Empty;
                        for (int i = 0; i < node.Containers.Count; ++i)
                        {
                            mods.UpdateDTA.LoadData(name, node.Containers[i]);
                        }

                        mods.UpdateMidiLastWrite = node.Update;
                        if (!mods.UpdateMidiLastWrite.HasValue && mods.UpdateDTA.DiscUpdate)
                        {
                            YargLogger.LogFormatWarning("Update midi expected in directory {0}", Path.Combine(group.Root.FullName, name));
                        }
                    }

                    foreach (var group in packedUpgradeGroups)
                    {
                        if (!group.Upgrades.TryGetValue(name, out var node))
                        {
                            continue;
                        }

                        if (mods.Upgrade != null && node.Upgrade.LastWriteTime <= mods.Upgrade.LastWriteTime)
                        {
                            continue;
                        }

                        mods.Upgrade = node.Upgrade;
                        mods.UpgradeDTA = DTAEntry.Create(name, node.Container);
                    }

                    foreach (var group in unpackedUpgradeGroups)
                    {
                        if (!group.Upgrades.TryGetValue(name, out var node))
                        {
                            continue;
                        }

                        if (mods.Upgrade != null && node.Upgrade.LastWriteTime <= mods.Upgrade.LastWriteTime)
                        {
                            continue;
                        }

                        mods.Upgrade = node.Upgrade;
                        mods.UpgradeDTA = DTAEntry.Create(name, node.Container);
                    }
                    mods.Processed = true;
                }
            }
            return mods;
        }

        /// <summary>
        /// Performs the traversal of the filesystem in search of new entries to add to a user's library
        /// </summary>
        private void FindNewEntries(bool fullDirectoryPlaylists)
        {
            var tracker = new PlaylistTracker(fullDirectoryPlaylists, null);
            Parallel.ForEach(iniGroups, group =>
            {
                var dirInfo = new DirectoryInfo(group.Directory);
                ScanDirectory(dirInfo, group, tracker);
            });

            Parallel.ForEach(conEntryGroups, group =>
            {
                group.InitScan();
                Parallel.ForEach(group, node =>
                {
                    var mods = GetCONMod(node.Key);
                    if (mods.UpdateDirectoryAndDtaLastWrite != null)
                    {
                        string moggPath = Path.Combine(mods.UpdateDirectoryAndDtaLastWrite.Value.FullName, node.Key, node.Key + ".mogg");
                        if (File.Exists(moggPath))
                        {
                            try
                            {
                                using var stream = new FileStream(moggPath, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
                                if (stream.Read<int>(Endianness.Little) != RBCONEntry.UNENCRYPTED_MOGG)
                                {
                                    AddToBadSongs(group.Root.FullName + " - " + node.Key, ScanResult.MoggError_Update);
                                    return;
                                }
                            }
                            catch (Exception e)
                            {
                                YargLogger.LogException(e);
                                AddToBadSongs(group.Root.FullName + " - " + node.Key, ScanResult.MoggError_Update);
                                return;
                            }
                        }
                    }

                    var parameters = new RBScanParameters()
                    {
                        UpdateDta = mods.UpdateDTA,
                        UpgradeDta = mods.UpgradeDTA,
                        Root = group.Root,
                        NodeName = node.Key,
                        UpdateDirectory = mods.UpdateDirectoryAndDtaLastWrite,
                        UpdateMidi = mods.UpdateMidiLastWrite,
                        Upgrade = mods.Upgrade,
                        DefaultPlaylist = group.DefaultPlaylist,
                    };

                    for (int i = 0; i < node.Value.Count; i++)
                    {
                        if (!group.TryGetEntry(node.Key, i, out var entry))
                        {
                            try
                            {
                                parameters.BaseDta = DTAEntry.Create(node.Key, node.Value[i]);
                                var result = group.CreateEntry(in parameters);
                                if (!result)
                                {
                                    AddToBadSongs(group.Root.FullName + " - " + node.Key, result.Error);
                                    continue;
                                }
                                group.AddEntry(node.Key, i, result.Value);
                                AddEntry(result.Value);
                            }
                            catch (Exception e)
                            {
                                YargLogger.LogException(e);
                            }
                        }
                        else
                        {
                            entry.UpdateInfo(in parameters.UpdateDirectory, in parameters.UpdateMidi, parameters.Upgrade);
                            AddEntry(entry);
                        }
                    }
                });
                group.Dispose();
            });
        }

        /// <summary>
        /// Attempts to mark a directory as "processed"
        /// </summary>
        /// <param name="directory">The directory to mark</param>
        /// <returns><see langword="true"/> if the directory was not previously marked</returns>
        private bool FindOrMarkDirectory(string directory)
        {
            lock (preScannedPaths)
            {
                if (!preScannedPaths.Add(directory))
                {
                    return false;
                }
                _progress.NumScannedDirectories++;
            }
            return true;
        }

        /// <summary>
        /// Attempts to mark a file as "processed"
        /// </summary>
        /// <param name="file">The file to mark</param>
        /// <returns><see langword="true"/> if the file was not previously marked</returns>
        private bool FindOrMarkFile(string file)
        {
            lock (preScannedPaths)
            {
                return preScannedPaths.Add(file);
            }
        }

        /// <summary>
        /// Adds an instance of a bad song
        /// </summary>
        /// <param name="filePath">The file that produced the error</param>
        /// <param name="err">The error produced</param>
        private void AddToBadSongs(string filePath, ScanResult err)
        {
            lock (badSongs)
            {
                badSongs.Add(filePath, err);
                _progress.BadSongCount++;
            }
        }

        /// <summary>
        /// Attempts to add a new entry to current list. If duplicates are allowed, this will always return true.
        /// If they are disallowed, then this will only succeed if the entry is not a duplicate or if it
        /// takes precedence over the entry currently in its place (based on a variety of factors)
        /// </summary>
        /// <param name="entry">The entry to add</param>
        /// <returns>Whether the song was accepted into the list</returns>
        private void AddEntry(SongEntry entry)
        {
            static bool ShouldReplaceFront(SongEntry replacment, SongEntry entryToReplace)
            {
                if (replacment.SubType != entryToReplace.SubType)
                {
                    return replacment.SubType > entryToReplace.SubType;
                }
                return SongEntrySorting.CompareMetadata(replacment, entryToReplace);
            }

            List<SongEntry> list;
            lock (cache.Entries)
            {
                if (!cache.Entries.TryGetValue(entry.Hash, out list))
                {
                    // Most entries will accompany unique hashes, so we can usually safely reserve just a single slot
                    cache.Entries.Add(entry.Hash, list = new List<SongEntry>(1));
                }
            }

            lock (list)
            {
                int index = 0;
                if (list.Count > 0)
                {
                    if (!ShouldReplaceFront(entry, list[0]))
                    {
                        entry.MarkAsDuplicate();
                        index = list.Count;
                    }
                    else
                    {
                        list[0].MarkAsDuplicate();
                    }
                }
                list.Insert(index, entry);
            }
            Interlocked.Increment(ref _progress.Count);
        }

        /// <summary>
        /// Disposes all DTA FixedArray data present in upgrade and update nodes.
        /// The songDTA arrays will already have been disposed of before reaching this point.
        /// </summary>
        public void Dispose()
        {
            foreach (var group in updateGroups)
            {
                group.Dispose();
            }

            foreach (var group in unpackedUpgradeGroups)
            {
                group.Dispose();
            }

            foreach (var group in packedUpgradeGroups)
            {
                group.Dispose();
            }
        }

        /// <summary>
        /// Writes all bad song instances to a badsongs.txt file for the user
        /// </summary>
        /// <param name="badSongsLocation">The path for the file</param>
        private void WriteBadSongs(string badSongsLocation)
        {
            using var stream = new FileStream(badSongsLocation, FileMode.Create, FileAccess.Write);
            using var writer = new StreamWriter(stream);

            writer.WriteLine($"Total Errors: {badSongs.Count}");
            writer.WriteLine();

            foreach (var error in badSongs)
            {
                writer.WriteLine(error.Key);
                switch (error.Value)
                {
                    case ScanResult.DirectoryError:
                        writer.WriteLine("Error accessing directory contents");
                        break;
                    case ScanResult.DuplicateFilesFound:
                        writer.WriteLine("Multiple sub files or directories that share the same name found in this location.");
                        writer.WriteLine("You must rename or remove all duplicates before they will be processed.");
                        break;
                    case ScanResult.IniEntryCorruption:
                        writer.WriteLine("Corruption of either the ini file or chart/mid file");
                        break;
                    case ScanResult.NoAudio:
                        writer.WriteLine("No audio accompanying the chart file");
                        break;
                    case ScanResult.NoName:
                        writer.WriteLine("Name metadata not provided");
                        break;
                    case ScanResult.NoNotes:
                        writer.WriteLine("No notes found");
                        break;
                    case ScanResult.DTAError:
                        writer.WriteLine("Error occured while parsing DTA file node");
                        break;
                    case ScanResult.MoggError:
                        writer.WriteLine("Required mogg audio file not present or used invalid encryption");
                        break;
                    case ScanResult.UnsupportedEncryption:
                        writer.WriteLine("Mogg file uses unsupported encryption");
                        break;
                    case ScanResult.MissingCONMidi:
                        writer.WriteLine("Midi file queried for found missing");
                        break;
                    case ScanResult.PossibleCorruption:
                        writer.WriteLine("Possible corruption of a queried midi file");
                        break;
                    case ScanResult.FailedSngLoad:
                        writer.WriteLine("File structure invalid or corrupted");
                        break;
                    case ScanResult.PathTooLong:
                        writer.WriteLine("Path too long for the Windows Filesystem (path limitation can be changed in registry settings if you so wish)");
                        break;
                    case ScanResult.MultipleMidiTrackNames:
                        writer.WriteLine("At least one track fails midi spec for containing multiple unique track names (thus making it ambiguous)");
                        break;
                    case ScanResult.MultipleMidiTrackNames_Update:
                        writer.WriteLine("At least one track fails midi spec for containing multiple unique track names (thus making it ambiguous) - Thrown by a midi update");
                        break;
                    case ScanResult.MultipleMidiTrackNames_Upgrade:
                        writer.WriteLine("At least one track fails midi spec for containing multiple unique track names (thus making it ambiguous) - Thrown by a pro guitar upgrade");
                        break;
                    case ScanResult.LooseChart_Warning:
                        writer.WriteLine("Loose chart files halted all traversal into the subdirectories at this location.");
                        writer.WriteLine("To fix, if desired, place the loose chart files in a separate dedicated folder.");
                        break;
                    case ScanResult.InvalidResolution:
                        writer.WriteLine("This chart uses an invalid resolution (or possibly contains it in an improper format, if .chart)");
                        break;
                    case ScanResult.InvalidResolution_Update:
                        writer.WriteLine("The midi chart update file applicable with this chart has an invalid resolution of zero");
                        break;
                    case ScanResult.InvalidResolution_Upgrade:
                        writer.WriteLine("The midi pro guitar upgrade file applicable with this chart has an invalid resolution of zero");
                        break;
                }
                writer.WriteLine();
            }
        }
        #endregion

        #region Scanning

        private readonly struct PlaylistTracker
        {
            private readonly bool _fullDirectoryFlag;
            // We use `null` as the default state to grant two levels of subdirectories before
            // supplying directories as the actual playlist (null -> empty -> directory)
            private readonly string? _playlist;

            public string Playlist => !string.IsNullOrEmpty(_playlist) ? _playlist : "Unknown Playlist";

            public PlaylistTracker(bool fullDirectoryFlag, string? playlist)
            {
                _fullDirectoryFlag = fullDirectoryFlag;
                _playlist = playlist;
            }

            public PlaylistTracker Append(string directory)
            {
                string playlist = string.Empty;
                if (_playlist != null)
                {
                    playlist = _fullDirectoryFlag ? Path.Combine(_playlist, directory) : directory;
                }
                return new PlaylistTracker(_fullDirectoryFlag, playlist);
            }
        }

        /// <summary>
        /// Checks for the presence of files pertaining to an unpacked ini entry or whether the directory
        /// is to be used for CON updates, upgrades, or extracted CON song entries.
        /// If none of those, this will further traverse through any of the subdirectories present in this directory
        /// and process all the subfiles for potential CONs or SNGs.
        /// </summary>
        /// <param name="directory">The directory instance to load and scan through</param>
        /// <param name="group">The group aligning to one of the base directories provided by the user</param>
        /// <param name="tracker">A tracker used to apply provide entries with default playlists</param>
        private void ScanDirectory(DirectoryInfo directory, IniEntryGroup group, PlaylistTracker tracker)
        {
            try
            {
                if (!FindOrMarkDirectory(directory.FullName))
                {
                    return;
                }

                switch (directory.Name)
                {
                    case "songs_updates":
                    {
                        var dta = new FileInfo(Path.Combine(directory.FullName, RBCONEntry.SONGUPDATES_DTA));
                        if (dta.Exists && CONUpdateGroup.Create(directory.FullName, dta, out var updateGroup))
                        {
                            lock (updateGroups)
                            {
                                updateGroups.Add(updateGroup);
                            }
                            // Ensures any con entries pulled from cache are removed for re-evaluation
                            RemoveCONEntries(updateGroup!.Updates);
                        }
                        return;
                    }
                    // A missing dta file means that we will treat the folder like any other subdirectory.
                    // It's likely that directories of this name do not denote CON entires, so that's necessary.
                    case "songs":
                    {
                        var dta = new FileInfo(Path.Combine(directory.FullName, CONEntryGroup.SONGS_DTA));
                        if (dta.Exists)
                        {
                            if (UnpackedCONEntryGroup.Create(directory.FullName, dta, tracker.Playlist, out var entryGroup))
                            {
                                lock (conEntryGroups)
                                {
                                    conEntryGroups.Add(entryGroup);
                                }
                            }
                            else
                            {
                                AddToBadSongs(directory.FullName, ScanResult.DirectoryError);
                            }
                            return;
                        }
                        break;
                    }
                }

                if (!collectionCache.TryGetValue(directory.FullName, out var collection))
                {
                    collection = new FileCollection(directory);
                }

                // Only possible on UNIX-based systems where file names are case-sensitive
                if (collection.ContainedDupes)
                {
                    AddToBadSongs(collection.Directory, ScanResult.DuplicateFilesFound);
                }

                if (directory.Name == "songs_upgrades")
                {
                    if (collection.FindFile(RBProUpgrade.UPGRADES_DTA, out var dta)
                    && UnpackedCONUpgradeGroup.Create(collection, dta, out var upgradeGroup))
                    {
                        lock (unpackedUpgradeGroups)
                        {
                            unpackedUpgradeGroups.Add(upgradeGroup);
                        }
                        // Ensures any con entries pulled from cache are removed for re-evaluation
                        RemoveCONEntries(upgradeGroup!.Upgrades);
                    }
                }
                // If we discover any combo of valid unpacked ini entry files in this directory,
                // we will traverse none of the subdirectories present in this scope
                else if (ScanIniEntry(in collection, group, tracker.Playlist))
                {
                    // However, the presence of subdirectories could mean that the user didn't properly
                    // organize their collection. So as a service, we warn them in the badsongs.txt.
                    if (collection.ContainsDirectory())
                    {
                        AddToBadSongs(directory.FullName, ScanResult.LooseChart_Warning);
                    }
                }
                else
                {
                    var nextTracker = tracker.Append(directory.Name);
                    Parallel.ForEach(collection, entry =>
                    {
                        switch (entry.Value)
                        {
                            case DirectoryInfo directory:
                                ScanDirectory(directory, group, nextTracker);
                                break;
                            case FileInfo file:
                                ScanFile(file, group, nextTracker);
                                break;
                        }
                    });
                }
            }
            catch (PathTooLongException)
            {
                YargLogger.LogFormatError("Path {0} is too long for the file system!", directory.FullName);
                AddToBadSongs(directory.FullName, ScanResult.PathTooLong);
            }
            catch (Exception e)
            {
                YargLogger.LogException(e, $"Error while scanning directory {directory.FullName}!");
            }
        }

        /// <summary>
        /// Attempts to process the provided file as either a CON or SNG
        /// </summary>
        /// <param name="info">The info for provided file</param>
        /// <param name="group">The group aligning to one of the base directories provided by the user</param>
        /// <param name="tracker">A tracker used to apply provide entries with default playlists</param>
        private void ScanFile(FileInfo info, IniEntryGroup group, in PlaylistTracker tracker)
        {
            string filename = info.FullName;
            try
            {
                // Ensures only fully downloaded unmarked files are processed
                if (FindOrMarkFile(filename))
                {
                    string ext = info.Extension;
                    if (ext == ".sng" || ext == ".yargsong")
                    {
                        using var sngFile = SngFile.TryLoadFromFile(info.FullName, true);
                        if (sngFile.IsLoaded)
                        {
                            ScanSngFile(in sngFile, info, group, tracker.Playlist);
                        }
                        else
                        {
                            AddToBadSongs(info.FullName, ScanResult.PossibleCorruption);
                        }
                    }
                    else
                    {
                        var result = CreateCONGroup(info, tracker.Playlist);
                        if (result.Upgrades != null)
                        {
                            // Ensures any con entries pulled from cache are removed for re-evaluation
                            RemoveCONEntries(result.Upgrades.Upgrades);
                        }
                    }
                }
            }
            catch (PathTooLongException)
            {
                YargLogger.LogFormatError("Path {0} is too long for the file system!", filename);
                AddToBadSongs(filename, ScanResult.PathTooLong);
            }
            catch (Exception e)
            {
                YargLogger.LogException(e, $"Error while scanning file {filename}!");
            }
        }

        /// <summary>
        /// Searches for a ".ini" and any .mid or .chart file to possibly extract as a song entry.
        /// If found, even if we can't extract an entry from them, we should perform no further directory traversal.
        /// </summary>
        /// <param name="collection">The collection containing the subfiles to search from</param>
        /// <param name="group">The group aligning to one of the base directories provided by the user</param>
        /// <param name="defaultPlaylist">The default directory-based playlist to use for any successful entry</param>
        /// <returns>Whether files pertaining to an unpacked ini entry were discovered</returns>
        private bool ScanIniEntry(in FileCollection collection, IniEntryGroup group, string defaultPlaylist)
        {
            int i = collection.FindFile("song.ini", out var ini) ? 0 : 2;
            while (i < 3)
            {
                if (!collection.FindFile(IniSubEntry.CHART_FILE_TYPES[i].Filename, out var chart))
                {
                    ++i;
                    continue;
                }

                // Can't play a song without any audio can you?
                //
                // Note though that this is purely a pre-add check.
                // We will not invalidate an entry from cache if the user removes the audio after the fact.
                if (!collection.ContainsAudio())
                {
                    AddToBadSongs(chart.FullName, ScanResult.NoAudio);
                    break;
                }

                try
                {
                    var entry = UnpackedIniEntry.ProcessNewEntry(collection.Directory, chart, IniSubEntry.CHART_FILE_TYPES[i].Format, ini, defaultPlaylist);
                    if (entry)
                    {
                        AddEntry(entry.Value);
                        group.AddEntry(entry.Value);
                    }
                    else
                    {
                        AddToBadSongs(chart.FullName, entry.Error);
                    }
                }
                catch (PathTooLongException)
                {
                    YargLogger.LogFormatError("Path {0} is too long for the file system!", chart);
                    AddToBadSongs(chart.FullName, ScanResult.PathTooLong);
                }
                catch (Exception e)
                {
                    YargLogger.LogException(e, $"Error while scanning chart file {chart}!");
                    AddToBadSongs(collection.Directory, ScanResult.IniEntryCorruption);
                }
                return true;
            }
            return false;
        }

        /// <summary>
        /// Searches for any .mid or .chart file to possibly extract as a song entry.
        /// </summary>
        /// <param name="sngFile">The sngfile to search through</param>
        /// <param name="group">The group aligning to one of the base directories provided by the user</param>
        /// <param name="defaultPlaylist">The default directory-based playlist to use for any successful entry</param>
        private void ScanSngFile(in SngFile sngFile, FileInfo info, IniEntryGroup group, string defaultPlaylist)
        {
            int i = !sngFile.Modifiers.IsEmpty() ? 0 : 2;
            while (i < 3)
            {
                if (!sngFile.TryGetListing(IniSubEntry.CHART_FILE_TYPES[i].Filename, out var chart))
                {
                    ++i;
                    continue;
                }

                if (!sngFile.ContainsAudio())
                {
                    AddToBadSongs(info.FullName, ScanResult.NoAudio);
                    break;
                }

                try
                {
                    var entry = SngEntry.ProcessNewEntry(in sngFile, in chart, info, IniSubEntry.CHART_FILE_TYPES[i].Format, defaultPlaylist);
                    if (entry.HasValue)
                    {
                        AddEntry(entry.Value);
                        group.AddEntry(entry.Value);
                    }
                    else
                    {
                        AddToBadSongs(info.FullName, entry.Error);
                    }
                }
                catch (Exception e)
                {
                    YargLogger.LogException(e, $"Error while scanning chart file {chart} within {info.FullName}!");
                    AddToBadSongs(info.FullName, ScanResult.IniEntryCorruption);
                }
                break;
            }
        }
        #endregion

        #region Serialization

        public const int SIZEOF_DATETIME = 8;
        private HashSet<string> invalidSongsInCache = new();
        private Dictionary<string, FileCollection> collectionCache = new();
        private Dictionary<string, QuickCONMods> cacheCONModifications = new();
        private Dictionary<string, List<CONFileListing>?> cacheCONListings = new();

        /// <summary>
        /// The sum of all "count" variables in a file
        /// 4 - (version number(4 bytes))
        /// 1 - (FullDirectoryPlaylist flag(1 byte))
        /// 64 - (section size(4 bytes) + zero string count(4 bytes)) * # categories(8)
        /// 24 - (# groups(4 bytes) * # group types(6))
        ///
        /// </summary>
        private const int MIN_CACHEFILESIZE = 93;

        /// <summary>
        /// Attempts to laod the cache file's data into a FixedArray. This will fail if an error is thrown,
        /// the cache is outdated, or if the the "full playlist" toggle mismatches.
        /// </summary>
        /// <param name="cacheLocation">File location for the cache</param>
        /// <param name="fullDirectoryPlaylists">Toggle for the display style of directory-based playlists</param>
        /// <returns>A FixedArray instance pointing to a buffer of the cache file's data, or <see cref="FixedArray&lt;&rt;"/>.Null if invalid</returns>
        private static FixedArray<byte> LoadCacheToMemory(string cacheLocation, bool fullDirectoryPlaylists)
        {
            FileInfo info = new(cacheLocation);
            if (!info.Exists || info.Length < MIN_CACHEFILESIZE)
            {
                YargLogger.LogDebug("Cache invalid or not found");
                return FixedArray<byte>.Null;
            }

            using var stream = new FileStream(cacheLocation, FileMode.Open, FileAccess.Read);
            if (stream.Read<int>(Endianness.Little) != CACHE_VERSION)
            {
                YargLogger.LogDebug($"Cache outdated");
                return FixedArray<byte>.Null;
            }

            if (stream.ReadBoolean() != fullDirectoryPlaylists)
            {
                YargLogger.LogDebug($"FullDirectoryFlag flipped");
                return FixedArray<byte>.Null;
            }
            return FixedArray.ReadRemainder(stream);
        }

        /// <summary>
        /// Serializes the cache to a file, duhhhhhhh
        /// </summary>
        /// <param name="cacheLocation">Location to save to</param>
        private void Serialize(string cacheLocation, bool fullDirectoryPlaylists)
        {
            using var filestream = new FileStream(cacheLocation, FileMode.Create, FileAccess.Write);

            filestream.Write(CACHE_VERSION, Endianness.Little);
            filestream.Write(fullDirectoryPlaylists);

            Dictionary<SongEntry, CacheWriteIndices> nodes = new();
            SongEntrySorting.WriteCategoriesToCache(filestream, cache, nodes);
            CONUpdateGroup.SerializeGroups(filestream, updateGroups);
            UnpackedCONUpgradeGroup.SerializeGroups(filestream, unpackedUpgradeGroups);
            PackedCONUpgradeGroup.SerializeGroups(filestream, packedUpgradeGroups);
            IEntryGroup.SerializeGroups(filestream, iniGroups, nodes);
            IEntryGroup.SerializeGroups(filestream, conEntryGroups, nodes);
        }

        /// <summary>
        /// Deserializes a cache file into the separate song entries with all validation checks
        /// </summary>
        /// <param name="stream">The stream containging the cache file data</param>
        private unsafe void Deserialize(in FixedArray<byte> data, bool fullDirectoryPlaylists)
        {
            var stream = data.ToValueStream();
            var strings = new CacheReadStrings(&stream);
            Parallel.ForEach(new CacheLoopable(&stream), node =>
            {
                ReadUpdateDirectory(node.Slice);
            });

            Parallel.ForEach(new CacheLoopable(&stream), node =>
            {
                ReadUpgradeDirectory(node.Slice);
            });

            Parallel.ForEach(new CacheLoopable(&stream), node =>
            {
                ReadUpgradeCON(node.Slice, fullDirectoryPlaylists);
            });

            Parallel.ForEach(new CacheLoopable(&stream), node =>
            {
                ReadIniDirectory(node.Slice, strings);
            });

            Parallel.ForEach(new CacheLoopable(&stream), node =>
            {
                ReadCONGroup(node.Slice, strings, fullDirectoryPlaylists);
            });
        }

        /// <summary>
        /// Deserializes a cache file into the separate song entries with minimal validations
        /// </summary>
        /// <param name="stream">The stream containging the cache file data</param>
        private unsafe void Deserialize_Quick(in FixedArray<byte> data)
        {
            var stream = data.ToValueStream();
            var strings = new CacheReadStrings(&stream);
            Parallel.ForEach(new CacheLoopable(&stream), node =>
            {
                QuickReadUpdateDirectory(node.Slice);
            });

            Parallel.ForEach(new CacheLoopable(&stream), node =>
            {
                QuickReadUpgradeDirectory(node.Slice);
            });

            Parallel.ForEach(new CacheLoopable(&stream), node =>
            {
                QuickReadUpgradeCON(node.Slice);
            });

            Parallel.ForEach(new CacheLoopable(&stream), node =>
            {
                QuickReadIniDirectory(node.Slice, strings);
            });

            Parallel.ForEach(new CacheLoopable(&stream), node =>
            {
                QuickReadCONGroup(node.Slice, strings);
            });
        }

        /// <summary>
        /// Reads a section of the cache containing a list of updates to apply from a specific directory,
        /// performing validations on each update node. If an update node from the cache is invalidated, it will mark
        /// any RBCON entry nodes that share its DTA name as invalid, forcing re-evaluation.
        /// </summary>
        /// <param name="stream">The stream containing the list of updates</param>
        private void ReadUpdateDirectory(FixedArrayStream stream)
        {
            string directory = stream.ReadString();
            var dtaLastWrite = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
            int count = stream.Read<int>(Endianness.Little);

            // Functions as a "check base directory" call
            if (!GetBaseIniGroup(directory, out var _))
            {
                goto Invalidate;
            }

            var dtaInfo = new FileInfo(Path.Combine(directory, RBCONEntry.SONGUPDATES_DTA));
            if (!dtaInfo.Exists)
            {
                goto Invalidate;
            }

            FindOrMarkDirectory(directory);

            // Will add the update group to the shared list on success
            if (CONUpdateGroup.Create(directory, dtaInfo, out var group) && group.Root.LastWriteTime == dtaLastWrite)
            {
                lock (updateGroups)
                {
                    updateGroups.Add(group);
                }
                // We need to compare what we have on the filesystem against what's written one by one
                var songsToInvalidate = new Dictionary<string, DateTime?>();
                songsToInvalidate.EnsureCapacity(group.Updates.Count);
                foreach (var update in group.Updates)
                {
                    songsToInvalidate.Add(update.Key, update.Value.Update);
                }

                for (int i = 0; i < count; i++)
                {
                    string name = stream.ReadString();
                    DateTime? lastWrite = null;
                    if (stream.ReadBoolean())
                    {
                        lastWrite = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
                    }

                    if (songsToInvalidate.TryGetValue(name, out var currLastWrite))
                    {
                        if (lastWrite.HasValue == currLastWrite.HasValue)
                        {
                            if (!lastWrite.HasValue || lastWrite.Value == currLastWrite!.Value)
                            {
                                songsToInvalidate.Remove(name);
                            }
                        }
                    }
                    else
                    {
                        AddInvalidSong(name);
                    }
                }

                // Anything left in the dictionary may require invalidation of cached entries
                foreach (var leftover in songsToInvalidate)
                {
                    AddInvalidSong(leftover.Key);
                }
                return;
            }

        Invalidate:
            for (int i = 0; i < count; i++)
            {
                AddInvalidSong(stream.ReadString());
                if (stream.ReadBoolean())
                {
                    stream.Position += SIZEOF_DATETIME;
                }
            }
        }

        /// <summary>
        /// Loads all the upgrade nodes present in the cache from an "upgrades folder" section
        /// </summary>
        /// <param name="stream">Stream containing the data for a folder's upgrade nodes</param>
        private void QuickReadUpdateDirectory(FixedArrayStream stream)
        {
            var root = new AbridgedFileInfo(ref stream);
            int count = stream.Read<int>(Endianness.Little);
            for (int i = 0; i < count; i++)
            {
                string name = stream.ReadString();
                DateTime? midiLastWrite = default;
                if (stream.ReadBoolean())
                {
                    midiLastWrite = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
                }

                var mods = GetQuickCONMods(name);
                lock (mods)
                {
                    if (!mods.UpdateDirectoryAndDtaLastWrite.HasValue || mods.UpdateDirectoryAndDtaLastWrite.Value.LastWriteTime < root.LastWriteTime)
                    {
                        mods.UpdateDirectoryAndDtaLastWrite = root;
                        mods.UpdateMidi = midiLastWrite;
                    }
                }
            }
        }

        /// <summary>
        /// Reads a section of the cache containing a list of upgrades to apply from a specific directory,
        /// performing validations on each upgrade node. If an upgrade node from the cache is invalidated, it will mark
        /// any RBCON entry nodes that share its DTA name as invalid, forcing re-evaluation.
        /// </summary>
        /// <param name="stream">The stream containing the list of upgrades</param>
        private void ReadUpgradeDirectory(FixedArrayStream stream)
        {
            string directory = stream.ReadString();
            var dtaLastWritten = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
            int count = stream.Read<int>(Endianness.Little);

            // Functions as a "check base directory" call
            if (!GetBaseIniGroup(directory, out var _))
            {
                goto Invalidate;
            }

            var dirInfo = new DirectoryInfo(directory);
            if (!dirInfo.Exists)
            {
                goto Invalidate;
            }

            var collection = new FileCollection(dirInfo);
            if (!collection.FindFile(RBProUpgrade.UPGRADES_DTA, out var dta))
            {
                // We don't *mark* the directory to allow the "New Entries" process
                // to access this collection
                lock (collectionCache)
                {
                    collectionCache.Add(directory, collection);
                }
                goto Invalidate;
            }

            FindOrMarkDirectory(directory);

            if (UnpackedCONUpgradeGroup.Create(in collection, dta, out var group))
            {
                lock (unpackedUpgradeGroups)
                {
                    unpackedUpgradeGroups.Add(group);
                }

                if (dta.LastWriteTime == dtaLastWritten)
                {
                    var songsToInvalidate = new Dictionary<string, DateTime>();
                    songsToInvalidate.EnsureCapacity(group.Upgrades.Count);
                    foreach (var node in group.Upgrades)
                    {
                        songsToInvalidate.Add(node.Key, node.Value.Upgrade.LastWriteTime);
                    }

                    for (int i = 0; i < count; i++)
                    {
                        string name = stream.ReadString();
                        if (songsToInvalidate.TryGetValue(name, out var upgradeLastWrite))
                        {
                            var midiLastWrite = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
                            if (upgradeLastWrite == midiLastWrite)
                            {
                                songsToInvalidate.Remove(name);
                            }
                        }
                        else
                        {
                            AddInvalidSong(name);
                            stream.Position += SIZEOF_DATETIME;
                        }
                    }

                    // Anything left in the dictionary may require invalidation of cached entries
                    foreach (var leftover in songsToInvalidate)
                    {
                        AddInvalidSong(leftover.Key);
                    }
                    return;
                }
            }

        Invalidate:
            for (int i = 0; i < count; i++)
            {
                AddInvalidSong(stream.ReadString());
                stream.Position += SIZEOF_DATETIME;
            }
        }

        /// <summary>
        /// Loads all the upgrade nodes present in the cache from an "upgrades folder" section
        /// </summary>
        /// <param name="stream">Stream containing the data for a folder's upgrade nodes</param>
        private void QuickReadUpgradeDirectory(FixedArrayStream stream)
        {
            var root = new AbridgedFileInfo(ref stream);
            int count = stream.Read<int>(Endianness.Little);
            for (int i = 0; i < count; i++)
            {
                string name = stream.ReadString();
                var midiLastWrite = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
                var mods = GetQuickCONMods(name);
                lock (mods)
                {
                    if (mods.Upgrade == null || mods.Upgrade.LastWriteTime < midiLastWrite)
                    {
                        mods.Upgrade = new UnpackedRBProUpgrade(name, midiLastWrite, in root);
                    }
                }
            }
        }

        /// <summary>
        /// Reads a section of the cache containing a list of upgrades to apply from a packed CON file,
        /// performing validations on each upgrade node. If an upgrade node from the cache is invalidated, it will mark
        /// any RBCON entry nodes that share its DTA name as invalid, forcing re-evaluation.
        /// </summary>
        /// <param name="stream">The stream containing the list of upgrades</param>
        private void ReadUpgradeCON(FixedArrayStream stream, bool fullDirectoryPlaylists)
        {
            string filename = stream.ReadString();
            var conLastWrite = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
            int count = stream.Read<int>(Endianness.Little);

            if (!GetBaseIniGroup(filename, out var baseGroup))
            {
                goto Invalidate;
            }

            var info = new FileInfo(filename);
            if (!info.Exists)
            {
                goto Invalidate;
            }

            FindOrMarkFile(filename);

            string defaultPlaylist = ConstructPlaylist(filename, baseGroup.Directory, fullDirectoryPlaylists);
            var result = CreateCONGroup(info, defaultPlaylist);
            if (result.Upgrades != null && result.Upgrades.Root.LastWriteTime == conLastWrite)
            {
                var songsToInvalidate = new HashSet<string>();
                songsToInvalidate.EnsureCapacity(result.Upgrades.Upgrades.Count);
                foreach (var node in result.Upgrades.Upgrades)
                {
                    songsToInvalidate.Add(node.Key);
                }

                for (int i = 0; i < count; i++)
                {
                    string name = stream.ReadString();
                    if (!songsToInvalidate.Remove(name))
                    {
                        AddInvalidSong(name);
                    }
                }

                // Anything left in the dictionary may require invalidation of cached entries
                foreach (var leftover in songsToInvalidate)
                {
                    AddInvalidSong(leftover);
                }
                return;
            }

        Invalidate:
            for (int i = 0; i < count; i++)
            {
                AddInvalidSong(stream.ReadString());
            }
        }

        /// <summary>
        /// Loads all the upgrade nodes present in the cache from an "upgrade CON" section.
        /// </summary>
        /// <param name="stream">Stream containing the data for a CON's upgrade nodes</param>
        private void QuickReadUpgradeCON(FixedArrayStream stream)
        {
            var root = new AbridgedFileInfo(ref stream);
            var listings = GetCacheCONListings(root.FullName);
            int count = stream.Read<int>(Endianness.Little);
            for (int i = 0; i < count; i++)
            {
                string name = stream.ReadString();
                CONFileListing? listing = null;
                listings?.FindListing(PackedRBProUpgrade.UPGRADES_DIRECTORY + name + RBProUpgrade.UPGRADES_MIDI_EXT, out listing);
                var mods = GetQuickCONMods(name);
                lock (mods)
                {
                    if (mods.Upgrade == null || mods.Upgrade.LastWriteTime < root.LastWriteTime)
                    {
                        mods.Upgrade = new PackedRBProUpgrade(listing, in root);
                    }
                }
            }
        }

        private void ReadIniDirectory(FixedArrayStream stream, CacheReadStrings strings)
        {
            string directory = stream.ReadString();
            if (!GetBaseIniGroup(directory, out var baseGroup))
            {
                return;
            }

            unsafe
            {
                Parallel.ForEach(new CacheLoopable(&stream), node =>
                {
                    var entry = UnpackedIniEntry.TryDeserialize(directory, ref node.Slice, strings);
                    if (entry != null)
                    {
                        FindOrMarkDirectory(entry.ActualLocation);
                        AddEntry(entry);
                        baseGroup.AddEntry(entry);
                    }
                });

                Parallel.ForEach(new CacheLoopable(&stream), node =>
                {
                    var entry = SngEntry.TryDeserialize(directory, ref node.Slice, strings);
                    if (entry != null)
                    {
                        FindOrMarkFile(entry.ActualLocation);
                        AddEntry(entry);
                        baseGroup.AddEntry(entry);
                    }
                });
            }
        }

        private void QuickReadIniDirectory(FixedArrayStream stream, CacheReadStrings strings)
        {
            string directory = stream.ReadString();
            unsafe
            {
                Parallel.ForEach(new CacheLoopable(&stream), node => AddEntry(UnpackedIniEntry.ForceDeserialize(directory, ref node.Slice, strings)));
                Parallel.ForEach(new CacheLoopable(&stream), node => AddEntry(SngEntry.ForceDeserialize(directory, ref node.Slice, strings)));
            }
        }

        private void ReadCONGroup(FixedArrayStream stream, CacheReadStrings strings, bool fullDirectoryPlaylists)
        {
            string location = stream.ReadString();
            if (!GetBaseIniGroup(location, out var baseGroup))
            {
                return;
            }

            var lastWriteTime = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
            string defaultPlaylist = ConstructPlaylist(location, baseGroup.Directory, fullDirectoryPlaylists);

            CONEntryGroup? group = null;
            if (stream.ReadBoolean())
            {
                lock (conEntryGroups)
                {
                    group = conEntryGroups.Find(node => node.Root.FullName == location);
                }

                if (group == null)
                {
                    var info = new FileInfo(location);
                    if (info.Exists)
                    {
                        FindOrMarkFile(location);
                        group = CreateCONGroup(info, defaultPlaylist).Entries;
                    }
                }
            }
            else
            {
                var dtaInfo = new FileInfo(Path.Combine(location, CONEntryGroup.SONGS_DTA));
                if (dtaInfo.Exists)
                {
                    FindOrMarkDirectory(location);
                    if (UnpackedCONEntryGroup.Create(location, dtaInfo, defaultPlaylist, out var unpacked))
                    {
                        lock (conEntryGroups)
                        {
                            conEntryGroups.Add(unpacked);
                        }
                        group = unpacked;
                    }
                }
            }

            if (group == null || group.Root.LastWriteTime != lastWriteTime)
            {
                return;
            }

            unsafe
            {
                Parallel.ForEach(new CacheLoopable(&stream), node =>
                {
                    try
                    {
                        string name = node.Slice.ReadString();
                        if (invalidSongsInCache.Contains(name))
                        {
                            return;
                        }

                        int index = node.Slice.ReadByte();
                        group.DeserializeEntry(ref node.Slice, name, index, strings);
                    }
                    catch (Exception e)
                    {
                        YargLogger.LogException(e);
                    }
                });
            }
        }

        private void QuickReadCONGroup(FixedArrayStream stream, CacheReadStrings strings)
        {
            var root = new AbridgedFileInfo(ref stream);
            List<CONFileListing>? listings = null;
            bool packed = stream.ReadBoolean();
            if (packed)
            {
                listings = GetCacheCONListings(root.FullName);
            }

            unsafe
            {
                Parallel.ForEach(new CacheLoopable(&stream), node =>
                {
                    string name = node.Slice.ReadString();
                    int index = node.Slice.ReadByte();
                    RBCONEntry entry = packed
                            ? PackedRBCONEntry.ForceDeserialize(listings, in root, name, ref node.Slice, strings)
                            : UnpackedRBCONEntry.ForceDeserialize(in root, name, ref node.Slice, strings);

                    if (cacheCONModifications.TryGetValue(name, out var mods))
                    {
                        entry.UpdateInfo(mods.UpdateDirectoryAndDtaLastWrite, mods.UpdateMidi, mods.Upgrade);
                    }
                    AddEntry(entry);
                });
            }
        }

        /// <summary>
        /// Grabs the iniGroup that parents the provided path, if one exists
        /// </summary>
        /// <param name="path">The absolute file path</param>
        /// <returns>The applicable group if found; <see langword="null"/> otherwise</returns>
        private bool GetBaseIniGroup(string path, out IniEntryGroup baseGroup)
        {
            foreach (var group in iniGroups)
            {
                if (path.StartsWith(group.Directory) &&
                    // Ensures directories with similar names (previously separate bases)
                    // that are consolidated in-game to a single base directory
                    // don't have conflicting "relative path" issues
                    (path.Length == group.Directory.Length || path[group.Directory.Length] == Path.DirectorySeparatorChar))
                {
                    baseGroup = group;
                    return true;
                }
            }
            baseGroup = null!;
            return false;
        }

        private QuickCONMods GetQuickCONMods(string name)
        {
            QuickCONMods mods;
            lock (cacheCONModifications)
            {
                if (!cacheCONModifications.TryGetValue(name, out mods))
                {
                    cacheCONModifications.Add(name, mods = new QuickCONMods());
                }
            }
            return mods;
        }

        /// <summary>
        /// Marks a CON song with the DTA name as invalid for addition from the cache
        /// </summary>
        /// <param name="name">The DTA name to mark</param>
        private void AddInvalidSong(string name)
        {
            lock (invalidSongsInCache)
            {
                invalidSongsInCache.Add(name);
            }
        }

        private List<CONFileListing>? GetCacheCONListings(string filename)
        {
            List<CONFileListing>? listings = null;
            lock (cacheCONListings)
            {
                if (!cacheCONListings.TryGetValue(filename, out listings))
                {
                    if (File.Exists(filename))
                    {
                        using var filestream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
                        listings = CONFile.TryParseListings(filename, filestream);
                    }
                    cacheCONListings.Add(filename, listings);
                }
            }
            return listings;
        }

        private struct PackedGroupResult
        {
            public PackedCONEntryGroup? Entries;
            public PackedCONUpgradeGroup? Upgrades;
        }

        /// <summary>
        /// Attempts to create a PackedCONGroup with the provided fileinfo.
        /// </summary>
        /// <param name="info">The file info for the possible CONFile</param>
        /// <param name="defaultPlaylist">The playlist to use for any entries generated from the CON (if it is one)</param>
        /// <returns>A PackedCONGroup instance on success; <see langword="null"/> otherwise</returns>
        private PackedGroupResult CreateCONGroup(FileInfo info, string defaultPlaylist)
        {
            var result = default(PackedGroupResult);
            try
            {
                using var stream = new FileStream(info.FullName, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
                var listings = CONFile.TryParseListings(info.FullName, stream);
                if (listings != null)
                {
                    var abridged = new AbridgedFileInfo(info);
                    try
                    {
                        if (PackedCONEntryGroup.Create(stream, listings, in abridged, defaultPlaylist, out result.Entries))
                        {
                            lock (conEntryGroups)
                            {
                                conEntryGroups.Add(result.Entries!);
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        YargLogger.LogException(e, $"Error while loading {info.FullName} - for song entries");
                    }

                    try
                    {
                        if (PackedCONUpgradeGroup.Create(stream, listings, in abridged, out result.Upgrades))
                        {
                            lock (packedUpgradeGroups)
                            {
                                packedUpgradeGroups.Add(result.Upgrades!);
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        YargLogger.LogException(e, $"Error while loading {info.FullName} - for song upgrades");
                    }
                }
            }
            catch (Exception ex)
            {
                YargLogger.LogException(ex, $"Error while loading {info.FullName}");
            }
            return result;
        }

        /// <summary>
        /// Constructs a directory-based playlist based on the provided file name
        /// </summary>
        /// <param name="filename">The path for the current file</param>
        /// <param name="baseDirectory">One of the base directories provided by the user</param>
        /// <returns>The default playlist to potentially use</returns>
        private string ConstructPlaylist(string filename, string baseDirectory, bool fullDirectoryPlaylists)
        {
            string directory = Path.GetDirectoryName(filename);
            if (directory.Length == baseDirectory.Length)
            {
                return "Unknown Playlist";
            }

            if (!fullDirectoryPlaylists)
            {
                return Path.GetFileName(directory);
            }
            return directory[(baseDirectory.Length + 1)..];
        }
        #endregion
    }

    internal static class AudioFinder
    {
        public static bool ContainsAudio(this SngFile sngFile)
        {
            foreach (var file in sngFile.Listings)
            {
                if (IniAudio.IsAudioFile(file.Key))
                {
                    return true;
                }
            }
            return false;
        }
    }
}
</file>

<file path="Song/Cache/CacheLoopable.cs">
using System;
using System.Collections;
using System.Collections.Generic;
using YARG.Core.Extensions;
using YARG.Core.IO;

namespace YARG.Core.Song
{
    internal unsafe struct CacheLoopable : IEnumerable<(FixedArrayStream Slice, int Index)>
    {
        public FixedArrayStream* Stream;
        public int Count;

        public CacheLoopable(FixedArrayStream* stream)
        {
            Stream = stream;
            Count = stream->Read<int>(Endianness.Little);
        }

        public readonly Enumerator GetEnumerator()
        {
            return new Enumerator(Stream, Count);
        }

        readonly IEnumerator<(FixedArrayStream Slice, int Index)> IEnumerable<(FixedArrayStream Slice, int Index)>.GetEnumerator()
        {
            return new Enumerator(Stream, Count);
        }

        readonly IEnumerator IEnumerable.GetEnumerator()
        {
            return new Enumerator(Stream, Count);
        }

        public struct Enumerator : IEnumerator<(FixedArrayStream Slice, int Index)>
        {
            private readonly FixedArrayStream* _stream;
            private readonly int _count;
            private (FixedArrayStream Slice, int Index) _current;

            public Enumerator(FixedArrayStream* stream, int count)
            {
                _stream = stream;
                _count = count;
                _current = (default(FixedArrayStream), -1);
            }

            public readonly (FixedArrayStream Slice, int Index) Current => _current;

            readonly object IEnumerator.Current => _current;

            public readonly void Dispose()
            {
            }

            public bool MoveNext()
            {
                if (++_current.Index == _count)
                {
                    return false;
                }

                int length = _stream->Read<int>(Endianness.Little);
                _current.Slice = _stream->Slice(length);
                return true;
            }

            public void Reset()
            {
                throw new NotImplementedException();
            }
        }
    }
}
</file>

<file path="Song/Cache/CacheNodes.cs">
using System.Threading.Tasks;
using YARG.Core.Extensions;
using YARG.Core.IO;

namespace YARG.Core.Song
{
    internal sealed class CacheWriteIndices
    {
        public int Title;
        public int Artist;
        public int Album;
        public int Genre;
        public int Year;
        public int Charter;
        public int Playlist;
        public int Source;
    }

    internal class CacheReadStrings
    {
        public const int NUM_CATEGORIES = 8;

        private string[][] _categories = new string[NUM_CATEGORIES][];

        public string[] Titles    => _categories[0];
        public string[] Artists   => _categories[1];
        public string[] Albums    => _categories[2];
        public string[] Genres    => _categories[3];
        public string[] Years     => _categories[4];
        public string[] Charters  => _categories[5];
        public string[] Playlists => _categories[6];
        public string[] Sources   => _categories[7];

        public unsafe CacheReadStrings(FixedArrayStream* stream)
        {
            Parallel.ForEach(new CacheLoopable() { Stream = stream, Count = NUM_CATEGORIES },
                node =>
            {
                int count = node.Slice.Read<int>(Endianness.Little);
                var strings = _categories[node.Index] = new string[count];
                for (int i = 0; i < count; ++i)
                {
                    strings[i] = node.Slice.ReadString();
                }
            });
        }
    }
}
</file>

<file path="Song/Cache/CONModification.cs">
using System;
using YARG.Core.IO;

namespace YARG.Core.Song
{
    internal class CONModification
    {
        public bool Processed = false;
        public DTAEntry UpdateDTA = DTAEntry.Empty;
        public DTAEntry UpgradeDTA = DTAEntry.Empty;
        public AbridgedFileInfo? UpdateDirectoryAndDtaLastWrite;
        public DateTime? UpdateMidiLastWrite;
        public RBProUpgrade? Upgrade;
    }

    internal class QuickCONMods
    {
        public AbridgedFileInfo? UpdateDirectoryAndDtaLastWrite;
        public DateTime? UpdateMidi;
        public RBProUpgrade? Upgrade;
    }
}
</file>

<file path="Song/Cache/FileCollection.cs">
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;

namespace YARG.Core.Song.Cache
{
    internal readonly struct FileCollection : IEnumerable<KeyValuePair<string, FileSystemInfo>>
    {
        private readonly Dictionary<string, FileSystemInfo> _entries;
        public readonly string Directory;
        public readonly bool ContainedDupes;

        // Attribute maps to Remote Storage files (ex. oneDrive) that are not locally present
        private const FileAttributes RECALL_ON_DATA_ACCESS = (FileAttributes) 0x00400000;
        private static readonly EnumerationOptions OPTIONS = new()
        {
            MatchType = MatchType.Win32,
            AttributesToSkip = RECALL_ON_DATA_ACCESS,
            IgnoreInaccessible = false,
        };

        public FileCollection(DirectoryInfo directory)
        {
            Directory = directory.FullName;
            _entries = new Dictionary<string, FileSystemInfo>(StringComparer.Ordinal);
            var dupes = new HashSet<string>();

            foreach (var entry in directory.EnumerateFileSystemInfos("*", OPTIONS))
            {
                string name = entry.Name.ToLowerInvariant();
                if (!_entries.TryAdd(name, entry))
                {
                    dupes.Add(name);
                }
            }

            // Removes any sort of ambiguity from duplicates
            ContainedDupes = dupes.Count > 0;
            foreach (var dupe in dupes)
            {
                _entries.Remove(dupe);
            }
        }

        public bool FindFile(string name, out FileInfo file)
        {
            file = null!;
            if (_entries.TryGetValue(name, out var entry))
            {
                file = (entry as FileInfo)!;
            }
            return file != null!;
        }

        public bool FindDirectory(string name, out DirectoryInfo directory)
        {
            directory = null!;
            if (_entries.TryGetValue(name, out var entry))
            {
                directory = (entry as DirectoryInfo)!;
            }
            return directory != null!;
        }

        public bool ContainsDirectory()
        {
            foreach (var entry in _entries)
            {
                if (entry.Value.Attributes == FileAttributes.Directory)
                {
                    return true;
                }
            }
            return false;
        }

        public bool ContainsAudio()
        {
            foreach (var entry in _entries)
            {
                if (IniAudio.IsAudioFile(entry.Key))
                {
                    return true;
                }
            }
            return false;
        }

        public Dictionary<string, FileSystemInfo>.Enumerator GetEnumerator()
        {
            return _entries.GetEnumerator();
        }

        IEnumerator<KeyValuePair<string, FileSystemInfo>> IEnumerable<KeyValuePair<string, FileSystemInfo>>.GetEnumerator()
        {
            return _entries.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return _entries.GetEnumerator();
        }
    }
}
</file>

<file path="Song/Cache/SongCache.cs">
using System;
using System.Collections.Generic;

namespace YARG.Core.Song
{
    [Serializable]
    public sealed class SongCache
    {
        private readonly struct DateFlippedComparer : IComparer<DateTime>
        {
            public static readonly DateFlippedComparer Instance = default;
            public int Compare(DateTime x, DateTime y)
            {
                return y.CompareTo(x);
            }
        }

        [NonSerialized]
        public readonly Dictionary<HashWrapper, List<SongEntry>> Entries = new();

        public readonly SortedDictionary<string,     List<SongEntry>> Titles       = new();
        public readonly SortedDictionary<string,     List<SongEntry>> Years        = new();
        public readonly SortedDictionary<SortString, List<SongEntry>> Artists      = new();
        public readonly SortedDictionary<SortString, List<SongEntry>> Albums       = new();
        public readonly SortedDictionary<SortString, List<SongEntry>> Genres       = new();
        public readonly SortedDictionary<SortString, List<SongEntry>> Charters     = new();
        public readonly SortedDictionary<SortString, List<SongEntry>> Playlists    = new();
        public readonly SortedDictionary<SortString, List<SongEntry>> Sources      = new();

        [NonSerialized]
        public readonly SortedDictionary<string,     List<SongEntry>> SongLengths  = new();
        [NonSerialized]
        public readonly SortedDictionary<DateTime,   List<SongEntry>> DatesAdded   = new(DateFlippedComparer.Instance);
        [NonSerialized]
        public readonly SortedDictionary<SortString, SortedDictionary<SortString, List<SongEntry>>> ArtistAlbums = new();

        [NonSerialized]
        public readonly SortedDictionary<Instrument, SortedDictionary<int, List<SongEntry>>> Instruments = new();
    }
}
</file>

<file path="Song/Entries/AvailableParts/AvailableParts.cs">
using System;

namespace YARG.Core.Song
{
    [Serializable]
    public struct AvailableParts
    {
        public static readonly AvailableParts Default = new()
        {
            BandDifficulty = PartValues.Default,
            FiveFretGuitar = PartValues.Default,
            FiveFretBass = PartValues.Default,
            FiveFretRhythm = PartValues.Default,
            FiveFretCoopGuitar = PartValues.Default,
            Keys = PartValues.Default,

            SixFretGuitar = PartValues.Default,
            SixFretBass = PartValues.Default,
            SixFretRhythm = PartValues.Default,
            SixFretCoopGuitar = PartValues.Default,

            FourLaneDrums = PartValues.Default,
            ProDrums = PartValues.Default,
            FiveLaneDrums = PartValues.Default,

            EliteDrums = PartValues.Default,

            ProGuitar_17Fret = PartValues.Default,
            ProGuitar_22Fret = PartValues.Default,
            ProBass_17Fret = PartValues.Default,
            ProBass_22Fret = PartValues.Default,

            ProKeys = PartValues.Default,

            // DJ = PartValues.Default,

            LeadVocals = PartValues.Default,
            HarmonyVocals = PartValues.Default,
        };

        public PartValues BandDifficulty;

        public PartValues FiveFretGuitar;
        public PartValues FiveFretBass;
        public PartValues FiveFretRhythm;
        public PartValues FiveFretCoopGuitar;
        public PartValues Keys;

        public PartValues SixFretGuitar;
        public PartValues SixFretBass;
        public PartValues SixFretRhythm;
        public PartValues SixFretCoopGuitar;

        public PartValues FourLaneDrums;
        public PartValues ProDrums;
        public PartValues FiveLaneDrums;

        public PartValues EliteDrums;

        public PartValues ProGuitar_17Fret;
        public PartValues ProGuitar_22Fret;
        public PartValues ProBass_17Fret;
        public PartValues ProBass_22Fret;

        public PartValues ProKeys;

        public PartValues LeadVocals;
        public PartValues HarmonyVocals;
    }
}
</file>

<file path="Song/Entries/AvailableParts/PartValues.cs">
using System;
using System.Runtime.InteropServices;

namespace YARG.Core.Song
{
    [Serializable]
    [StructLayout(LayoutKind.Explicit)]
    public struct PartValues
    {
        public static readonly PartValues Default = new()
        {
            SubTracks = 0,
            Difficulties = DifficultyMask.None,
            Intensity = -1
        };

        [FieldOffset(0)] public byte SubTracks;
        [FieldOffset(0)] public DifficultyMask Difficulties;

        [FieldOffset(1)] public sbyte Intensity;

        public readonly bool this[int subTrack]
        {
            get
            {
                const int BITS_IN_BYTE = 8;
                if (subTrack >= BITS_IN_BYTE)
                {
                    throw new IndexOutOfRangeException("Subtrack out of range");
                }
                return ((1 << subTrack) & SubTracks) > 0;
            }
        }

        public readonly bool this[Difficulty difficulty]
        {
            get
            {
                if (difficulty < Difficulty.Beginner || difficulty > Difficulty.ExpertPlus)
                {
                    throw new Exception("Difficulty out of range");
                }
                return ((1 << (int)difficulty) & SubTracks) > 0;
            }
        }

        public void ActivateSubtrack(int subTrack)
        {
            SubTracks |= (byte) (1 << subTrack);
        }

        public void ActivateDifficulty(Difficulty difficulty)
        {
            Difficulties |= (DifficultyMask) (1 << (int)difficulty);
        }

        public readonly bool IsActive() { return SubTracks > 0; }
    }
}
</file>

<file path="Song/Entries/Ini/SongEntry.IniBase.cs">
using MoonscraperChartEditor.Song.IO;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using YARG.Core.Chart;
using YARG.Core.Extensions;
using YARG.Core.IO;
using YARG.Core.IO.Ini;
using YARG.Core.Song.Cache;

namespace YARG.Core.Song
{
    public static class IniAudio
    {
        public static readonly string[] SupportedStems = { "song", "guitar", "bass", "rhythm", "keys", "vocals", "vocals_1", "vocals_2", "drums", "drums_1", "drums_2", "drums_3", "drums_4", "crowd", };
        public static readonly string[] SupportedFormats = { ".opus", ".ogg", ".mp3", ".wav", ".aiff", };
        private static readonly HashSet<string> SupportedAudioFiles = new();

        static IniAudio()
        {
            foreach (string stem in SupportedStems)
                foreach (string format in SupportedFormats)
                    SupportedAudioFiles.Add(stem + format);
        }

        public static bool IsAudioFile(string file)
        {
            return SupportedAudioFiles.Contains(file);
        }
    }

    internal abstract class IniSubEntry : SongEntry
    {
        public static readonly (string Filename, ChartFormat Format)[] CHART_FILE_TYPES =
        {
            ("notes.mid"  , ChartFormat.Mid),
            ("notes.midi" , ChartFormat.Midi),
            ("notes.chart", ChartFormat.Chart),
        };

        protected static readonly string[] ALBUMART_FILES;
        protected static readonly string[] PREVIEW_FILES;

        static IniSubEntry()
        {
            ALBUMART_FILES = new string[IMAGE_EXTENSIONS.Length];
            for (int i = 0; i < ALBUMART_FILES.Length; i++)
            {
                ALBUMART_FILES[i] = "album" + IMAGE_EXTENSIONS[i];
            }

            PREVIEW_FILES = new string[IniAudio.SupportedFormats.Length];
            for (int i = 0; i < PREVIEW_FILES.Length; i++)
            {
                PREVIEW_FILES[i] = "preview" + IniAudio.SupportedFormats[i];
            }
        }

        protected readonly string _location;
        protected readonly DateTime _chartLastWrite;
        protected readonly ChartFormat _chartFormat;
        protected string _background = string.Empty;
        protected string _video = string.Empty;
        protected string _cover = string.Empty;

        public override string SortBasedLocation => _location;
        public override string ActualLocation => _location;
        public override DateTime GetLastWriteTime() { return _chartLastWrite; }

        protected abstract FixedArray<byte> GetChartData(string filename);

        internal override void Serialize(MemoryStream stream, CacheWriteIndices indices)
        {
            base.Serialize(stream, indices);
            stream.Write(_background);
            stream.Write(_video);
            stream.Write(_cover);
        }

        public override SongChart? LoadChart()
        {
            using var data = GetChartData(CHART_FILE_TYPES[(int) _chartFormat].Filename);
            if (!data.IsAllocated)
            {
                return null;
            }

            var parseSettings = new ParseSettings()
            {
                HopoThreshold = _settings.HopoThreshold,
                SustainCutoffThreshold = _settings.SustainCutoffThreshold,
                StarPowerNote = _settings.OverdiveMidiNote,
                DrumsType = ParseDrumsType(in _parts),
                ChordHopoCancellation = _chartFormat != ChartFormat.Chart
            };

            using var stream = data.ToReferenceStream();
            if (_chartFormat == ChartFormat.Mid || _chartFormat == ChartFormat.Midi)
            {
                return SongChart.FromMidi(in parseSettings, MidFileLoader.LoadMidiFile(stream));
            }

            using var reader = new StreamReader(stream);
            return SongChart.FromDotChart(in parseSettings, reader.ReadToEnd());
        }

        public override FixedArray<byte> LoadMiloData()
        {
            return FixedArray<byte>.Null;
        }

        protected new void Deserialize(ref FixedArrayStream stream, CacheReadStrings strings)
        {
            base.Deserialize(ref stream, strings);
            _background = stream.ReadString();
            _video = stream.ReadString();
            _cover = stream.ReadString();
            (_parsedYear, _yearAsNumber) = ParseYear(_metadata.Year);
        }

        protected IniSubEntry(string location, in DateTime chartLastWrite, ChartFormat chartFormat)
        {
            _location = location;
            _chartLastWrite = chartLastWrite;
            _chartFormat = chartFormat;
        }

        protected internal static ScanResult ScanChart(IniSubEntry entry, in FixedArray<byte> file, IniModifierCollection modifiers)
        {
            var drums_type = DrumsType.Any;
            if (modifiers.Extract("five_lane_drums", out bool fiveLaneDrums))
            {
                drums_type = fiveLaneDrums ? DrumsType.FiveLane : DrumsType.FourOrPro;
            }

            ScanExpected<long> resolution;
            if (entry._chartFormat == ChartFormat.Chart)
            {
                if (YARGTextReader.TryUTF8(file, out var byteContainer))
                {
                    resolution = ParseDotChart(ref byteContainer, modifiers, ref entry._parts, ref drums_type);
                }
                else
                {
                    using var chars = YARGTextReader.TryUTF16Cast(in file);
                    if (chars.IsAllocated)
                    {
                        var charContainer = YARGTextReader.CreateUTF16Container(in chars);
                        resolution = ParseDotChart(ref charContainer, modifiers, ref entry._parts, ref drums_type);
                    }
                    else
                    {
                        using var ints = YARGTextReader.CastUTF32(in file);
                        var intContainer = YARGTextReader.CreateUTF32Container(in ints);
                        resolution = ParseDotChart(ref intContainer, modifiers, ref entry._parts, ref drums_type);
                    }
                }
            }
            else // if (chartType == ChartType.Mid || chartType == ChartType.Midi) // Uncomment for any future file type
            {
                resolution = ParseDotMidi(in file, modifiers, ref entry._parts, ref drums_type);
            }

            if (!resolution)
            {
                return resolution.Error;
            }

            FinalizeDrums(ref entry._parts, drums_type);
            if (!IsValid(in entry._parts))
            {
                return ScanResult.NoNotes;
            }

            if (!modifiers.Contains("name"))
            {
                return ScanResult.NoName;
            }

            SongMetadata.FillFromIni(ref entry._metadata, modifiers);
            SetIntensities(modifiers, ref entry._parts);

            (entry._parsedYear, entry._yearAsNumber) = ParseYear(entry._metadata.Year);
            entry._hash = HashWrapper.Hash(file.ReadOnlySpan);
            entry.SetSortStrings();

            if (!modifiers.Extract("hopo_frequency", out entry._settings.HopoThreshold) || entry._settings.HopoThreshold <= 0)
            {
                if (modifiers.Extract("eighthnote_hopo", out bool eighthNoteHopo))
                {
                    entry._settings.HopoThreshold = resolution.Value / (eighthNoteHopo ? 2 : 3);
                }
                else if (modifiers.Extract("hopofreq", out int hopoFreq))
                {
                    long denominator = hopoFreq switch
                    {
                        0 => 24,
                        1 => 16,
                        2 => 12,
                        3 => 8,
                        4 => 6,
                        5 => 4,
                        _ => throw new NotImplementedException($"Unhandled hopofreq value {hopoFreq}!")
                    };
                    entry._settings.HopoThreshold = 4 * resolution.Value / denominator;
                }
                else
                {
                    entry._settings.HopoThreshold = resolution.Value / 3;
                }

                if (entry._chartFormat == ChartFormat.Chart)
                {
                    // With a 192 resolution, .chart has a HOPO threshold of 65 ticks, not 64,
                    // so we need to scale this factor to different resolutions (480 res = 162.5 threshold).
                    // Why?... idk, but I hate it.
                    const float DEFAULT_RESOLUTION = 192;
                    entry._settings.HopoThreshold += (long) (resolution.Value / DEFAULT_RESOLUTION);
                }
            }

            // .chart defaults to no sustain cutoff whatsoever if the ini does not define the value.
            // Since a failed `Extract` sets the value to zero, we need no additional work unless it's .mid
            if (!modifiers.Extract("sustain_cutoff_threshold", out entry._settings.SustainCutoffThreshold) && entry._chartFormat != ChartFormat.Chart)
            {
                entry._settings.SustainCutoffThreshold = resolution.Value / 3;
            }

            if (entry._chartFormat == ChartFormat.Mid || entry._chartFormat == ChartFormat.Midi)
            {
                if (!modifiers.Extract("multiplier_note", out entry._settings.OverdiveMidiNote) || entry._settings.OverdiveMidiNote != 103)
                {
                    entry._settings.OverdiveMidiNote = 116;
                }
            }

            if (modifiers.Extract("background", out string background))
            {
                entry._background = background;
            }

            if (modifiers.Extract("video", out string video))
            {
                entry._video = video;
            }

            if (modifiers.Extract("cover", out string cover))
            {
                entry._cover = cover;
            }

            if (entry._metadata.SongLength <= 0)
            {
                using var mixer = entry.LoadAudio(0, 0);
                if (mixer != null)
                {
                    entry._metadata.SongLength = (long) (mixer.Length * SongMetadata.MILLISECOND_FACTOR);
                }
            }
            return ScanResult.Success;
        }

        protected static bool TryGetRandomBackgroundImage<TValue>(Dictionary<string, TValue> dict, out TValue? value)
        {
            // Choose a valid image background present in the folder at random
            List<TValue>? images = null;
            foreach (var format in IMAGE_EXTENSIONS)
            {
                if (dict.TryGetValue("bg" + format, out var image))
                {
                    images ??= new List<TValue>();
                    images.Add(image);
                }
            }

            foreach (var (shortname, image) in dict)
            {
                if (!shortname.StartsWith("background"))
                {
                    continue;
                }

                foreach (var format in IMAGE_EXTENSIONS)
                {
                    if (shortname.EndsWith(format))
                    {
                        images ??= new List<TValue>();
                        images.Add(image);
                        break;
                    }
                }
            }

            if (images == null)
            {
                value = default!;
                return false;
            }
            value = images[BACKROUND_RNG.Next(images.Count)];
            return true;
        }

        protected static DrumsType ParseDrumsType(in AvailableParts parts)
        {
            if (parts.FourLaneDrums.IsActive())
            {
                return DrumsType.FourLane;
            }
            if (parts.FiveLaneDrums.IsActive())
            {
                return DrumsType.FiveLane;
            }
            return DrumsType.Unknown;
        }

        private static ScanExpected<long> ParseDotChart<TChar>(ref YARGTextContainer<TChar> container, IniModifierCollection modifiers, ref AvailableParts parts, ref DrumsType drumsType)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            if (drumsType != DrumsType.FiveLane && modifiers.Extract("pro_drums", out bool proDrums))
            {
                // We don't want to just immediately set the value to one of the other
                // on the chance that we still need to test for FiveLane.
                // We just know what the .ini explicitly tells us it *isn't*
                if (proDrums)
                {
                    drumsType -= DrumsType.FourLane;
                }
                else
                {
                    drumsType -= DrumsType.ProDrums;
                }
            }

            long resolution = 192;
            if (YARGChartFileReader.ValidateTrack(ref container, YARGChartFileReader.HEADERTRACK))
            {
                var chartMods = YARGChartFileReader.ExtractModifiers(ref container);
                if (chartMods.Extract("Resolution", out long res))
                {
                    resolution = res;
                    if (resolution < 1)
                    {
                        return new ScanUnexpected(ScanResult.InvalidResolution);
                    }
                }
                modifiers.Union(chartMods);
            }

            while (YARGChartFileReader.IsStartOfTrack(in container))
            {
                if (!TraverseChartTrack(ref container, ref parts, ref drumsType))
                {
                    YARGChartFileReader.SkipToNextTrack(ref container);
                }
            }
            return resolution;
        }

        private static ScanExpected<long> ParseDotMidi(in FixedArray<byte> file, IniModifierCollection modifiers, ref AvailableParts parts, ref DrumsType drumsType)
        {
            if (drumsType != DrumsType.FiveLane)
            {
                // We don't want to just immediately set the value to one of the other
                // on the chance that we still need to test for FiveLane.
                // We just know what the .ini explicitly tells us it *isn't*.
                //
                // That being said, .chart differs in that FourLane is the default state.
                // .mid's default is ProDrums, which is why we account for when the .ini does
                // not contain the flag.
                if (!modifiers.Extract("pro_drums", out bool proDrums) || proDrums)
                {
                    drumsType -= DrumsType.FourLane;
                }
                else
                {
                    drumsType -= DrumsType.ProDrums;
                }
            }
            return ParseMidi(in file, ref parts, ref drumsType);
        }

        /// <returns>Whether the track was fully traversed</returns>
        private static unsafe bool TraverseChartTrack<TChar>(ref YARGTextContainer<TChar> container, ref AvailableParts parts, ref DrumsType drumsType)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            if (!YARGChartFileReader.ValidateInstrument(ref container, out var instrument, out var difficulty))
            {
                return false;
            }

            return instrument switch
            {
                Instrument.FiveFretGuitar     => ScanFiveFret(ref parts.FiveFretGuitar,               ref container, difficulty),
                Instrument.FiveFretBass       => ScanFiveFret(ref parts.FiveFretBass,                 ref container, difficulty),
                Instrument.FiveFretRhythm     => ScanFiveFret(ref parts.FiveFretRhythm,               ref container, difficulty),
                Instrument.FiveFretCoopGuitar => ScanFiveFret(ref parts.FiveFretCoopGuitar,           ref container, difficulty),
                Instrument.Keys               => ScanFiveFret(ref parts.Keys,                         ref container, difficulty),
                Instrument.SixFretGuitar      => ScanSixFret (ref parts.SixFretGuitar,                ref container, difficulty),
                Instrument.SixFretBass        => ScanSixFret (ref parts.SixFretBass,                  ref container, difficulty),
                Instrument.SixFretRhythm      => ScanSixFret (ref parts.SixFretRhythm,                ref container, difficulty),
                Instrument.SixFretCoopGuitar  => ScanSixFret (ref parts.SixFretCoopGuitar,            ref container, difficulty),
                Instrument.FourLaneDrums      => ScanDrums   (ref parts.FourLaneDrums, ref drumsType, ref container, difficulty),
                _ => false,
            };
        }

        private const int GUITAR_FIVEFRET_MAX = 5;
        private const int OPEN_NOTE = 7;
        private static bool ScanFiveFret<TChar>(ref PartValues part, ref YARGTextContainer<TChar> container, Difficulty difficulty)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            if (part[difficulty])
            {
                return false;
            }

            var ev = default(DotChartEvent);
            while (YARGChartFileReader.TryParseEvent(ref container, ref ev))
            {
                if (ev.Type == ChartEventType.Note)
                {
                    uint lane = YARGChartFileReader.ExtractWithWhitespace<TChar, uint>(ref container);
                    ulong _ = YARGChartFileReader.Extract<TChar, ulong>(ref container);
                    if (lane < GUITAR_FIVEFRET_MAX || lane == OPEN_NOTE)
                    {
                        part.ActivateDifficulty(difficulty);
                        return false;
                    }
                }
            }
            return true;
        }

        private static bool ScanSixFret<TChar>(ref PartValues part, ref YARGTextContainer<TChar> container, Difficulty difficulty)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            const int SIX_FRET_BLACK1 = 8;
            if (part[difficulty])
            {
                return false;
            }

            var ev = default(DotChartEvent);
            while (YARGChartFileReader.TryParseEvent(ref container, ref ev))
            {
                if (ev.Type == ChartEventType.Note)
                {
                    uint lane = YARGChartFileReader.ExtractWithWhitespace<TChar, uint>(ref container);
                    ulong _ = YARGChartFileReader.Extract<TChar, ulong>(ref container);
                    if (lane < GUITAR_FIVEFRET_MAX || lane == SIX_FRET_BLACK1 || lane == OPEN_NOTE)
                    {
                        part.ActivateDifficulty(difficulty);
                        return false;
                    }
                }
            }
            return true;
        }

        private static bool ScanDrums<TChar>(ref PartValues part, ref DrumsType drumsType, ref YARGTextContainer<TChar> container, Difficulty difficulty)
            where TChar : unmanaged, IEquatable<TChar>, IConvertible
        {
            const int YELLOW_CYMBAL = 66;
            const int GREEN_CYMBAL = 68;
            const int DOUBLE_BASS_MODIFIER = 32;

            var diff_mask = (DifficultyMask)(1 << (int)difficulty);
            // No point in scan a difficulty that already exists
            if ((part.Difficulties & diff_mask) > DifficultyMask.None)
            {
                return false;
            }

            var requiredMask = diff_mask;
            if (difficulty == Difficulty.Expert)
            {
                requiredMask |= DifficultyMask.ExpertPlus;
            }

            var ev = default(DotChartEvent);
            while (YARGChartFileReader.TryParseEvent(ref container, ref ev))
            {
                if (ev.Type == ChartEventType.Note)
                {
                    uint lane = YARGChartFileReader.ExtractWithWhitespace<TChar, uint>(ref container);
                    ulong _ = YARGChartFileReader.Extract<TChar, ulong>(ref container);
                    if (0 <= lane && lane <= 4)
                    {
                        part.Difficulties |= diff_mask;
                    }
                    else if (lane == 5)
                    {
                        // In other words, the DrumsType.FiveLane bit is active
                        if (drumsType >= DrumsType.FiveLane)
                        {
                            drumsType = DrumsType.FiveLane;
                            part.Difficulties |= diff_mask;
                        }
                    }
                    else if (YELLOW_CYMBAL <= lane && lane <= GREEN_CYMBAL)
                    {
                        if ((drumsType & DrumsType.ProDrums) == DrumsType.ProDrums)
                        {
                            drumsType = DrumsType.ProDrums;
                        }
                    }
                    else if (lane == DOUBLE_BASS_MODIFIER)
                    {
                        if (difficulty == Difficulty.Expert)
                        {
                            part.Difficulties |= DifficultyMask.ExpertPlus;
                        }
                    }

                    //  Testing against zero would not work in expert
                    if ((part.Difficulties & requiredMask) == requiredMask && (drumsType == DrumsType.FourLane || drumsType == DrumsType.ProDrums || drumsType == DrumsType.FiveLane))
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        private static void SetIntensities(IniModifierCollection modifiers, ref AvailableParts parts)
        {
            if (modifiers.Extract("diff_band", out int intensity))
            {
                parts.BandDifficulty.Intensity = (sbyte) intensity;
                if (intensity != -1)
                {
                    parts.BandDifficulty.SubTracks = 1;
                }
            }

            if (modifiers.Extract("diff_guitar", out intensity))
            {
                parts.ProGuitar_22Fret.Intensity = parts.ProGuitar_17Fret.Intensity = parts.FiveFretGuitar.Intensity = (sbyte) intensity;
            }

            if (modifiers.Extract("diff_bass", out intensity))
            {
                parts.ProBass_22Fret.Intensity = parts.ProBass_17Fret.Intensity = parts.FiveFretBass.Intensity = (sbyte) intensity;
            }

            if (modifiers.Extract("diff_rhythm", out intensity))
            {
                parts.FiveFretRhythm.Intensity = (sbyte) intensity;
            }

            if (modifiers.Extract("diff_guitar_coop", out intensity))
            {
                parts.FiveFretCoopGuitar.Intensity = (sbyte) intensity;
            }

            if (modifiers.Extract("diff_guitarghl", out intensity))
            {
                parts.SixFretGuitar.Intensity = (sbyte) intensity;
            }

            if (modifiers.Extract("diff_bassghl", out intensity))
            {
                parts.SixFretBass.Intensity = (sbyte) intensity;
            }

            if (modifiers.Extract("diff_rhythm_ghl", out intensity))
            {
                parts.SixFretRhythm.Intensity = (sbyte) intensity;
            }

            if (modifiers.Extract("diff_guitar_coop_ghl", out intensity))
            {
                parts.SixFretCoopGuitar.Intensity = (sbyte) intensity;
            }

            if (modifiers.Extract("diff_keys", out intensity))
            {
                parts.ProKeys.Intensity = parts.Keys.Intensity = (sbyte) intensity;
            }

            if (modifiers.Extract("diff_drums", out intensity))
            {
                parts.FourLaneDrums.Intensity = (sbyte) intensity;
                parts.ProDrums.Intensity = (sbyte) intensity;
                parts.FiveLaneDrums.Intensity = (sbyte) intensity;
                parts.EliteDrums.Intensity = (sbyte) intensity;
            }

            if (modifiers.Extract("diff_drums_real", out intensity) && intensity != -1)
            {
                parts.ProDrums.Intensity = (sbyte) intensity;
                parts.EliteDrums.Intensity = (sbyte) intensity;
                if (parts.FourLaneDrums.Intensity == -1)
                {
                    parts.FourLaneDrums.Intensity = parts.ProDrums.Intensity;
                }
            }

            if (modifiers.Extract("diff_guitar_real", out intensity) && intensity != -1)
            {
                parts.ProGuitar_22Fret.Intensity = parts.ProGuitar_17Fret.Intensity = (sbyte) intensity;
                if (parts.FiveFretGuitar.Intensity == -1)
                {
                    parts.FiveFretGuitar.Intensity = parts.ProGuitar_17Fret.Intensity;
                }
            }

            if (modifiers.Extract("diff_bass_real", out intensity) && intensity != -1)
            {
                parts.ProBass_22Fret.Intensity = parts.ProBass_17Fret.Intensity = (sbyte) intensity;
                if (parts.FiveFretBass.Intensity == -1)
                {
                    parts.FiveFretBass.Intensity = parts.ProBass_17Fret.Intensity;
                }
            }

            if (modifiers.Extract("diff_guitar_real_22", out intensity) && intensity != -1)
            {
                parts.ProGuitar_22Fret.Intensity = (sbyte) intensity;
                if (parts.ProGuitar_17Fret.Intensity == -1)
                {
                    parts.ProGuitar_17Fret.Intensity = parts.ProGuitar_22Fret.Intensity;
                }

                if (parts.FiveFretGuitar.Intensity == -1)
                {
                    parts.FiveFretGuitar.Intensity = parts.ProGuitar_22Fret.Intensity;
                }
            }

            if (modifiers.Extract("diff_bass_real_22", out intensity) && intensity != -1)
            {
                parts.ProBass_22Fret.Intensity = (sbyte) intensity;
                if (parts.ProBass_17Fret.Intensity == -1)
                {
                    parts.ProBass_17Fret.Intensity = parts.ProBass_22Fret.Intensity;
                }

                if (parts.FiveFretBass.Intensity == -1)
                {
                    parts.FiveFretBass.Intensity = parts.ProBass_22Fret.Intensity;
                }
            }

            if (modifiers.Extract("diff_keys_real", out intensity) && intensity != -1)
            {
                parts.ProKeys.Intensity = (sbyte) intensity;
                if (parts.Keys.Intensity == -1)
                {
                    parts.Keys.Intensity = parts.ProKeys.Intensity;
                }
            }

            if (modifiers.Extract("diff_vocals", out intensity))
            {
                parts.HarmonyVocals.Intensity = parts.LeadVocals.Intensity = (sbyte) intensity;
            }

            if (modifiers.Extract("diff_vocals_harm", out intensity) && intensity != -1)
            {
                parts.HarmonyVocals.Intensity = (sbyte) intensity;
                if (parts.LeadVocals.Intensity == -1)
                {
                    parts.LeadVocals.Intensity = parts.HarmonyVocals.Intensity;
                }
            }
        }

        private static (string Parsed, int AsNumber) ParseYear(string str)
        {
            const int MINIMUM_YEAR_DIGITS = 4;
            for (int start = 0; start <= str.Length - MINIMUM_YEAR_DIGITS; ++start)
            {
                int curr = start;
                int number = 0;
                while (curr < str.Length && char.IsDigit(str[curr]))
                {
                    unchecked
                    {
                        number = 10 * number + str[curr] - '0';
                    }
                    ++curr;
                }

                if (curr >= start + MINIMUM_YEAR_DIGITS)
                {
                    return (str[start..curr], number);
                }
            }
            return (str, int.MaxValue);
        }
    }
}
</file>

<file path="Song/Entries/Ini/SongEntry.Sng.cs">
using System;
using System.IO;
using System.Linq;
using YARG.Core.Audio;
using YARG.Core.Extensions;
using YARG.Core.IO;
using YARG.Core.Logging;
using YARG.Core.Song.Cache;
using YARG.Core.Venue;

namespace YARG.Core.Song
{
    internal sealed class SngEntry : IniSubEntry
    {
        private readonly uint _version;

        public override EntryType SubType => EntryType.Sng;

        internal override void Serialize(MemoryStream stream, CacheWriteIndices indices)
        {
            // Validation block
            stream.Write(_chartLastWrite.ToBinary(), Endianness.Little);
            stream.Write(_version, Endianness.Little);
            stream.WriteByte((byte) _chartFormat);

            // Metadata block
            base.Serialize(stream, indices);
        }

        public override StemMixer? LoadAudio(float speed, double volume, params SongStem[] ignoreStems)
        {
            using var sngFile = SngFile.TryLoadFromFile(_location, false);
            if (!sngFile.IsLoaded)
            {
                YargLogger.LogFormatError("Failed to load sng file {0}", _location);
                return null;
            }

            return CreateAudioMixer(speed, volume, sngFile, ignoreStems);
        }

        public override StemMixer? LoadPreviewAudio(float speed)
        {
            using var sngFile = SngFile.TryLoadFromFile(_location, false);
            if (!sngFile.IsLoaded)
            {
                YargLogger.LogFormatError("Failed to load sng file {0}", _location);
                return null;
            }

            foreach (var filename in PREVIEW_FILES)
            {
                if (sngFile.TryGetListing(filename, out var listing))
                {
                    var stream = sngFile.CreateStream(filename, in listing);
                    string fakename = Path.Combine(_location, filename);
                    var mixer = GlobalAudioHandler.LoadCustomFile(fakename, stream, speed, 0, SongStem.Preview);
                    if (mixer == null)
                    {
                        stream.Dispose();
                        YargLogger.LogFormatError("Failed to load preview file {0}!", fakename);
                        return null;
                    }
                    return mixer;
                }
            }

            return CreateAudioMixer(speed, 0, sngFile, SongStem.Crowd);
        }

        public override YARGImage LoadAlbumData()
        {
            using var sngFile = SngFile.TryLoadFromFile(_location, false);
            if (sngFile.IsLoaded)
            {
                if (!sngFile.TryGetListing(_cover, out var listing))
                {
                    foreach (string albumFile in ALBUMART_FILES)
                    {
                        if (sngFile.TryGetListing(albumFile, out listing))
                        {
                            break;
                        }
                    }
                }

                if (listing.Length > 0)
                {
                    using var file = sngFile.LoadAllBytes(in listing);
                    var image = YARGImage.Load(in file);
                    if (image.IsAllocated)
                    {
                        return image;
                    }
                    YargLogger.LogError("Failed to load SNG album art");
                }
            }
            return YARGImage.Null;
        }

        public override BackgroundResult? LoadBackground()
        {
            using var sngFile = SngFile.TryLoadFromFile(_location, false);
            if (!sngFile.IsLoaded)
            {
                return null;
            }

            if (sngFile.TryGetListing(YARGROUND_FULLNAME, out var listing))
            {
                return new BackgroundResult(BackgroundType.Yarground, sngFile.CreateStream(YARGROUND_FULLNAME, in listing));
            }

            string file = Path.ChangeExtension(_location, YARGROUND_EXTENSION);
            if (File.Exists(file))
            {
                return new BackgroundResult(BackgroundType.Yarground, File.OpenRead(file));
            }

            if (sngFile.TryGetListing(_video, out listing))
            {
                return new BackgroundResult(BackgroundType.Video, sngFile.CreateStream(_video, in listing));
            }

            foreach (var stem in BACKGROUND_FILENAMES)
            {
                foreach (var format in VIDEO_EXTENSIONS)
                {
                    string name = stem + format;
                    if (sngFile.TryGetListing(name, out listing))
                    {
                        return new BackgroundResult(BackgroundType.Video, sngFile.CreateStream(name, in listing));
                    }
                }
            }

            foreach (var format in VIDEO_EXTENSIONS)
            {
                string path = Path.ChangeExtension(_location, format);
                if (File.Exists(path))
                {
                    return new BackgroundResult(BackgroundType.Video, File.OpenRead(path));
                }
            }

            if (sngFile.TryGetListing(_background, out listing) || TryGetRandomBackgroundImage(sngFile.Listings, out listing))
            {
                using var data = sngFile.LoadAllBytes(in listing);
                var image = YARGImage.Load(in data);
                if (image.IsAllocated)
                {
                    return new BackgroundResult(image);
                }
                YargLogger.LogError("Failed to load SNG background image");
            }

            // Fallback to a potential external image mapped specifically to the sng
            foreach (var format in IMAGE_EXTENSIONS)
            {
                string path = Path.ChangeExtension(_location, format);
                if (File.Exists(path))
                {
                    using var data = FixedArray.LoadFile(path);
                    var image = YARGImage.Load(in data);
                    if (image.IsAllocated)
                    {
                        return new BackgroundResult(image);
                    }
                    YargLogger.LogFormatError("Failed to load background image {0}", path);
                }
            }
            return null;
        }

        public override FixedArray<byte> LoadMiloData()
        {
            return FixedArray<byte>.Null;
        }

        protected override FixedArray<byte> GetChartData(string filename)
        {
            var data = FixedArray<byte>.Null;
            if (AbridgedFileInfo.Validate(_location, _chartLastWrite))
            {
                using var sng = SngFile.TryLoadFromFile(_location, false);
                if (sng.IsLoaded && sng.TryGetListing(filename, out var listing))
                {
                    data = sng.LoadAllBytes(in listing);
                }
            }
            return data;
        }

        private StemMixer? CreateAudioMixer(float speed, double volume, in SngFile sngFile, params SongStem[] ignoreStems)
        {
            bool clampStemVolume = _metadata.Source.ToLowerInvariant() == "yarg";
            var mixer = GlobalAudioHandler.CreateMixer(ToString(), speed, volume, clampStemVolume);
            if (mixer == null)
            {
                YargLogger.LogError("Failed to create mixer");
                return null;
            }

            foreach (var stem in IniAudio.SupportedStems)
            {
                var stemEnum = AudioHelpers.SupportedStems[stem];
                if (ignoreStems.Contains(stemEnum))
                {
                    continue;
                }

                foreach (var format in IniAudio.SupportedFormats)
                {
                    var file = stem + format;
                    if (sngFile.TryGetListing(file, out var listing))
                    {
                        var stream = sngFile.CreateStream(file, in listing);
                        if (mixer.AddChannel(stemEnum, stream))
                        {
                            // No duplicates
                            break;
                        }
                        stream.Dispose();
                        YargLogger.LogFormatError("Failed to load stem file {0}", file);
                    }
                }
            }

            if (mixer.Channels.Count == 0)
            {
                YargLogger.LogError("Failed to add any stems!");
                mixer.Dispose();
                return null;
            }

            if (GlobalAudioHandler.LogMixerStatus)
            {
                YargLogger.LogFormatInfo("Loaded {0} stems", mixer.Channels.Count);
            }
            return mixer;
        }

        private SngEntry(uint version, string location, in DateTime lastWrite, ChartFormat format)
            : base(location, in lastWrite, format)
        {
            _version = version;
        }

        public static unsafe ScanExpected<SngEntry> ProcessNewEntry(in SngFile sng, in SngFileListing listing, FileInfo info, ChartFormat format, string defaultPlaylist)
        {
            var entry = new SngEntry(sng.Version, info.FullName, AbridgedFileInfo.NormalizedLastWrite(info), format);
            entry._metadata.Playlist = defaultPlaylist;

            using var file = sng.LoadAllBytes(in listing);
            var result = ScanChart(entry, file, sng.Modifiers);
            return result == ScanResult.Success ? entry : new ScanUnexpected(result);
        }

        public static SngEntry? TryDeserialize(string baseDirectory, ref FixedArrayStream stream, CacheReadStrings strings)
        {
            string relative = stream.ReadString();
            string location = Path.Combine(baseDirectory, relative);
            var lastWrite = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
            if (!AbridgedFileInfo.Validate(location, lastWrite))
            {
                return null;
            }

            uint version = stream.Read<uint>(Endianness.Little);
            if (!SngFile.ValidateMatch(location, version))
            {
                return null;
            }

            var format = CHART_FILE_TYPES[stream.ReadByte()].Format;
            var entry = new SngEntry(version, location, in lastWrite, format);
            entry.Deserialize(ref stream, strings);
            return entry;
        }

        public static SngEntry ForceDeserialize(string baseDirectory, ref FixedArrayStream stream, CacheReadStrings strings)
        {
            string relative = stream.ReadString();
            string location = Path.Combine(baseDirectory, relative);
            var lastWrite = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
            uint version = stream.Read<uint>(Endianness.Little);
            var format = CHART_FILE_TYPES[stream.ReadByte()].Format;
            var entry = new SngEntry(version, location, in lastWrite, format);
            entry.Deserialize(ref stream, strings);
            return entry;
        }
    }
}
</file>

<file path="Song/Entries/Ini/SongEntry.UnpackedIni.cs">
using System;
using System.Collections.Generic;
using System.IO;
using YARG.Core.Song.Cache;
using YARG.Core.IO;
using YARG.Core.IO.Ini;
using YARG.Core.Audio;
using YARG.Core.Venue;
using System.Linq;
using YARG.Core.Logging;
using YARG.Core.Extensions;

namespace YARG.Core.Song
{
    internal sealed class UnpackedIniEntry : IniSubEntry
    {
        private readonly DateTime? _iniLastWrite;

        public override EntryType SubType => EntryType.Ini;

        internal override void Serialize(MemoryStream stream, CacheWriteIndices node)
        {
            stream.WriteByte((byte) _chartFormat);
            stream.Write(_chartLastWrite.ToBinary(), Endianness.Little);
            stream.Write(_iniLastWrite.HasValue);
            if (_iniLastWrite.HasValue)
            {
                stream.Write(_iniLastWrite.Value.ToBinary(), Endianness.Little);
            }
            base.Serialize(stream, node);
        }

        public override StemMixer? LoadAudio(float speed, double volume, params SongStem[] ignoreStems)
        {
            bool clampStemVolume = _metadata.Source.ToLowerInvariant() == "yarg";
            var mixer = GlobalAudioHandler.CreateMixer(ToString(), speed, volume, clampStemVolume);
            if (mixer == null)
            {
                YargLogger.LogError("Failed to create mixer!");
                return null;
            }

            var subFiles = GetSubFiles();
            foreach (var stem in IniAudio.SupportedStems)
            {
                var stemEnum = AudioHelpers.SupportedStems[stem];
                if (ignoreStems.Contains(stemEnum))
                    continue;

                foreach (var format in IniAudio.SupportedFormats)
                {
                    var stemName = stem + format;
                    if (subFiles.TryGetValue(stemName, out var file))
                    {
                        var stream = new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
                        if (mixer.AddChannel(stemEnum, stream))
                        {
                            // No duplicates
                            break;
                        }
                        stream.Dispose();
                        YargLogger.LogFormatError("Failed to load stem file {0}", file);
                    }
                }
            }

            if (mixer.Channels.Count == 0)
            {
                YargLogger.LogError("Failed to add any stems!");
                mixer.Dispose();
                return null;
            }

            if (GlobalAudioHandler.LogMixerStatus)
            {
                YargLogger.LogFormatInfo("Loaded {0} stems", mixer.Channels.Count);
            }
            return mixer;
        }

        public override StemMixer? LoadPreviewAudio(float speed)
        {
            foreach (var filename in PREVIEW_FILES)
            {
                var audioFile = Path.Combine(_location, filename);
                if (File.Exists(audioFile))
                {
                    return GlobalAudioHandler.LoadCustomFile(audioFile, speed, 0, SongStem.Preview);
                }
            }
            return LoadAudio(speed, 0, SongStem.Crowd);
        }

        public override YARGImage LoadAlbumData()
        {
            var subFiles = GetSubFiles();
            if (!string.IsNullOrEmpty(_cover) && subFiles.TryGetValue(_cover, out var cover))
            {
                var image = YARGImage.Load(cover);
                if (image.IsAllocated)
                {
                    return image;
                }
                YargLogger.LogFormatError("Image at {0} failed to load", cover);
            }

            foreach (string albumName in ALBUMART_FILES)
            {
                if (subFiles.TryGetValue(albumName, out var file))
                {
                    var image = YARGImage.Load(file);
                    if (image.IsAllocated)
                    {
                        return image;
                    }
                    YargLogger.LogFormatError("Image at {0} failed to load", file);
                }
            }
            return YARGImage.Null;
        }

        public override BackgroundResult? LoadBackground()
        {
            var subFiles = GetSubFiles();
            if (subFiles.TryGetValue("bg.yarground", out var file))
            {
                var stream = File.OpenRead(file);
                return new BackgroundResult(BackgroundType.Yarground, stream);
            }

            if (subFiles.TryGetValue(_video, out var video))
            {
                var stream = File.OpenRead(video);
                return new BackgroundResult(BackgroundType.Video, stream);
            }

            foreach (var stem in BACKGROUND_FILENAMES)
            {
                foreach (var format in VIDEO_EXTENSIONS)
                {
                    if (subFiles.TryGetValue(stem + format, out file))
                    {
                        var stream = File.OpenRead(file);
                        return new BackgroundResult(BackgroundType.Video, stream);
                    }
                }
            }

            if (subFiles.TryGetValue(_background, out file) || TryGetRandomBackgroundImage(subFiles, out file))
            {
                var image = YARGImage.Load(file!);
                if (image.IsAllocated)
                {
                    return new BackgroundResult(image);
                }
            }
            return null;
        }

        public override FixedArray<byte> LoadMiloData()
        {
            return FixedArray<byte>.Null;
        }

        protected override FixedArray<byte> GetChartData(string filename)
        {
            var data = FixedArray<byte>.Null;
            string chartPath = Path.Combine(_location, filename);
            if (AbridgedFileInfo.Validate(chartPath, in _chartLastWrite))
            {
                string iniPath = Path.Combine(_location, "song.ini");
                if (_iniLastWrite.HasValue
                    ? AbridgedFileInfo.Validate(iniPath, _iniLastWrite.Value)
                    : !File.Exists(iniPath))
                {
                    data = FixedArray.LoadFile(chartPath);
                }
            }
            return data;
        }

        private Dictionary<string, string> GetSubFiles()
        {
            Dictionary<string, string> files = new();
            if (Directory.Exists(_location))
            {
                foreach (var file in Directory.EnumerateFiles(_location))
                {
                    files.Add(file[(_location.Length + 1)..].ToLower(), file);
                }
            }
            return files;
        }

        private UnpackedIniEntry(string directory, in DateTime chartLastWrite, in DateTime? iniLastWrite, in ChartFormat format)
            : base(directory, in chartLastWrite, format)
        {
            _iniLastWrite = iniLastWrite;
        }

        public static ScanExpected<UnpackedIniEntry> ProcessNewEntry(string directory, FileInfo chartInfo, ChartFormat format, FileInfo? iniFile, string defaultPlaylist)
        {
            IniModifierCollection iniModifiers;
            DateTime? iniLastWrite = default;
            if (iniFile != null)
            {
                iniModifiers = SongIniHandler.ReadSongIniFile(iniFile.FullName);
                iniLastWrite = AbridgedFileInfo.NormalizedLastWrite(iniFile);
            }
            else
            {
                iniModifiers = new();
            }

            var entry = new UnpackedIniEntry(directory, AbridgedFileInfo.NormalizedLastWrite(chartInfo), in iniLastWrite, format);
            entry._metadata.Playlist = defaultPlaylist;

            using var file = FixedArray.LoadFile(chartInfo.FullName);
            var result = ScanChart(entry, in file, iniModifiers);
            return result == ScanResult.Success ? entry : new ScanUnexpected(result);
        }

        public static UnpackedIniEntry? TryDeserialize(string baseDirectory, ref FixedArrayStream stream, CacheReadStrings strings)
        {
            string directory = Path.Combine(baseDirectory, stream.ReadString());
            ref readonly var chart = ref CHART_FILE_TYPES[stream.ReadByte()];
            var chartLastWrite = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
            if (!AbridgedFileInfo.Validate(Path.Combine(directory, chart.Filename), chartLastWrite))
            {
                return null;
            }

            string iniFile = Path.Combine(directory, "song.ini");
            DateTime? iniLastWrite = default;
            if (stream.ReadBoolean())
            {
                iniLastWrite = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
                if (!AbridgedFileInfo.Validate(iniFile, iniLastWrite.Value))
                {
                    return null;
                }
            }
            else if (File.Exists(iniFile))
            {
                return null;
            }

            var entry = new UnpackedIniEntry(directory, in chartLastWrite, in iniLastWrite, chart.Format);
            entry.Deserialize(ref stream, strings);
            return entry;
        }

        public static UnpackedIniEntry ForceDeserialize(string baseDirectory, ref FixedArrayStream stream, CacheReadStrings strings)
        {
            string directory = Path.Combine(baseDirectory, stream.ReadString());
            ref readonly var chart = ref CHART_FILE_TYPES[stream.ReadByte()];
            var chartLastWrite = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
            DateTime? iniLastWrite = stream.ReadBoolean() ? DateTime.FromBinary(stream.Read<long>(Endianness.Little)) : default;
            var entry = new UnpackedIniEntry(directory, in chartLastWrite, in iniLastWrite, chart.Format);
            entry.Deserialize(ref stream, strings);
            return entry;
        }
    }
}
</file>

<file path="Song/Entries/RBCON/RBAudio.cs">
using System;

namespace YARG.Core.Song
{
    public struct RBAudio<TType>
        where TType : unmanaged
    {
        public static readonly RBAudio<TType> Empty = new()
        {
            Track = Array.Empty<TType>(),
            Drums = Array.Empty<TType>(),
            Bass = Array.Empty<TType>(),
            Guitar = Array.Empty<TType>(),
            Keys = Array.Empty<TType>(),
            Vocals = Array.Empty<TType>(),
            Crowd = Array.Empty<TType>(),
        };

        public TType[] Track;
        public TType[] Drums;
        public TType[] Bass;
        public TType[] Guitar;
        public TType[] Keys;
        public TType[] Vocals;
        public TType[] Crowd;
    }
}
</file>

<file path="Song/Entries/RBCON/RBIntensities.cs">
using System;

namespace YARG.Core.Song
{
    [Serializable]
    public struct RBIntensities
    {
        public static readonly RBIntensities Default = new()
        {
            Band = -1,
            FiveFretGuitar = -1,
            FiveFretBass = -1,
            FiveFretRhythm = -1,
            FiveFretCoop = -1,
            Keys = -1,
            FourLaneDrums = -1,
            ProDrums = -1,
            ProGuitar = -1,
            ProBass = -1,
            ProKeys = -1,
            LeadVocals = -1,
            HarmonyVocals = -1,
        };

        public short Band;
        public short FiveFretGuitar;
        public short FiveFretBass;
        public short FiveFretRhythm;
        public short FiveFretCoop;
        public short Keys;
        public short FourLaneDrums;
        public short ProDrums;
        public short ProGuitar;
        public short ProBass;
        public short ProKeys;
        public short LeadVocals;
        public short HarmonyVocals;
    }
}
</file>

<file path="Song/Entries/RBCON/RBMetadata.cs">
using System;

namespace YARG.Core.Song
{
    public enum VocalGender : byte
    {
        Female,
        Male,
        Unspecified,
    };

    public enum SongTonality : byte
    {
        Major,
        Minor,
        Unspecified,
    };

    public enum EncodingType : byte
    {
        ASCII,
        Latin1,
        UTF8,
        UTF16,
        UTF32
    };

    public struct RBMetadata
    {
        public static readonly RBMetadata Default = new()
        {
            SongID = string.Empty,
            DrumBank = string.Empty,
            VocalPercussionBank = string.Empty,
            AnimTempo = 0,
            VocalSongScrollSpeed = 0,
            VocalTonicNote = 0,
            VenueVersion = 0,
            TuningOffsetCents = 0,
            VocalGender = VocalGender.Unspecified,
            SongTonality = SongTonality.Unspecified,
            Soloes = Array.Empty<string>(),
            VideoVenues = Array.Empty<string>(),
            RealGuitarTuning = Array.Empty<int>(),
            RealBassTuning = Array.Empty<int>(),
            MidiEncoding = EncodingType.Latin1
        };

        public string SongID;
        public string DrumBank;
        public string VocalPercussionBank;

        public uint AnimTempo;
        public uint VocalSongScrollSpeed;
        public uint VocalTonicNote;
        public uint VenueVersion;
        public int  TuningOffsetCents;

        public VocalGender VocalGender;
        public SongTonality SongTonality;
        
        public string[] Soloes;
        public string[] VideoVenues;

        public int[] RealGuitarTuning;
        public int[] RealBassTuning;

        public EncodingType MidiEncoding;
    }
}
</file>

<file path="Song/Entries/RBCON/RBProUpgrade.cs">
using System;
using System.IO;
using YARG.Core.IO;

namespace YARG.Core.Song
{
    internal abstract class RBProUpgrade
    {
        public const string UPGRADES_DTA = "upgrades.dta";
        public const string UPGRADES_MIDI_EXT = "_plus.mid";

        public abstract DateTime LastWriteTime { get; }
        public abstract FixedArray<byte> LoadUpgradeMidi();

        protected readonly AbridgedFileInfo _root;
        protected RBProUpgrade(in AbridgedFileInfo root)
        {
            _root = root;
        }
    }

    [Serializable]
    internal sealed class PackedRBProUpgrade : RBProUpgrade
    {
        public const string UPGRADES_DIRECTORY = "songs_upgrades/";

        private readonly CONFileListing? _listing;

        public override DateTime LastWriteTime => _root.LastWriteTime;

        public PackedRBProUpgrade(CONFileListing? listing, in AbridgedFileInfo root)
            : base(in root)
        {
            _listing = listing;
        }

        public override FixedArray<byte> LoadUpgradeMidi()
        {
            return _listing != null && _root.IsStillValid()
                ? CONFileStream.LoadFile(_root.FullName, _listing)
                : FixedArray<byte>.Null;
        }
    }

    [Serializable]
    internal sealed class UnpackedRBProUpgrade : RBProUpgrade
    {
        private readonly string _name;
        private readonly DateTime _lastWritetime;

        public override DateTime LastWriteTime => _lastWritetime;

        public UnpackedRBProUpgrade(string name, in DateTime lastWriteTime, in AbridgedFileInfo root)
            : base(root)
        {
            _name = name;
            _lastWritetime = lastWriteTime;
        }

        public override FixedArray<byte> LoadUpgradeMidi()
        {
            var data = FixedArray<byte>.Null;
            if (AbridgedFileInfo.Validate(Path.Combine(_root.FullName, UPGRADES_DTA), in _root.LastWriteTime))
            {
                string file = Path.Combine(_root.FullName, _name + UPGRADES_MIDI_EXT);
                if (AbridgedFileInfo.Validate(file, in _lastWritetime))
                {
                    data = FixedArray.LoadFile(file);
                }
            }
            return data;
        }
    }
}
</file>

<file path="Song/Entries/RBCON/SongEntry.PackedRBCON.cs">
using System;
using System.Collections.Generic;
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.Song.Cache;
using YARG.Core.IO;
using YARG.Core.Venue;
using YARG.Core.Logging;

namespace YARG.Core.Song
{
    internal sealed class PackedRBCONEntry : RBCONEntry
    {
        private CONFileListing? _midiListing;
        private CONFileListing? _moggListing;
        private CONFileListing? _miloListing;
        private CONFileListing? _imgListing;
        private string          _psuedoDirectory;

        public override EntryType SubType => EntryType.CON;
        public override string SortBasedLocation => _psuedoDirectory;
        public override string ActualLocation => _root.FullName;
        protected override DateTime MidiLastWriteTime => _root.LastWriteTime;

        internal override void Serialize(MemoryStream stream, CacheWriteIndices node)
        {
            stream.Write(_subName);
            base.Serialize(stream, node);
        }

        public override YARGImage LoadAlbumData()
        {
            var image = LoadUpdateAlbumData();
            if (!image.IsAllocated && _imgListing != null)
            {
                var bytes = CONFileStream.LoadFile(_root.FullName, _imgListing);
                image = YARGImage.TransferDXT(ref bytes);
            }
            return image;
        }

        public override BackgroundResult? LoadBackground()
        {
            if (_midiListing == null)
            {
                return null;
            }

            string actualDirectory = Path.GetDirectoryName(_root.FullName)!;
            string conName = Path.GetFileNameWithoutExtension(_root.FullName);
            string specifcVenue = Path.Combine(actualDirectory, _subName + YARGROUND_EXTENSION);
            if (File.Exists(specifcVenue))
            {
                var stream = File.OpenRead(specifcVenue);
                return new BackgroundResult(BackgroundType.Yarground, stream);
            }

            specifcVenue = Path.Combine(actualDirectory, conName + YARGROUND_EXTENSION);
            if (File.Exists(specifcVenue))
            {
                var stream = File.OpenRead(specifcVenue);
                return new BackgroundResult(BackgroundType.Yarground, stream);
            }

            var venues = Directory.GetFiles(actualDirectory, YARGROUND_EXTENSION);
            if (venues.Length > 0)
            {
                var stream = File.OpenRead(venues[BACKROUND_RNG.Next(venues.Length)]);
                return new BackgroundResult(BackgroundType.Yarground, stream);
            }

            foreach (var name in new[]{ _subName, conName, "bg", "background", "video" })
            {
                string fileBase = Path.Combine(actualDirectory, name);
                foreach (var ext in VIDEO_EXTENSIONS)
                {
                    string backgroundPath = fileBase + ext;
                    if (File.Exists(backgroundPath))
                    {
                        var stream = File.OpenRead(backgroundPath);
                        return new BackgroundResult(BackgroundType.Video, stream);
                    }
                }
            }

            foreach (var name in new[]{ _subName, conName, "bg", "background" })
            {
                var fileBase = Path.Combine(actualDirectory, name);
                foreach (var ext in IMAGE_EXTENSIONS)
                {
                    string backgroundPath = fileBase + ext;
                    if (File.Exists(backgroundPath))
                    {
                        var image = YARGImage.Load(backgroundPath);
                        if (image.IsAllocated)
                        {
                            return new BackgroundResult(image);
                        }
                    }
                }
            }
            return null;
        }

        public override FixedArray<byte> LoadMiloData()
        {
            var data = LoadUpdateMiloData();
            if (!data.IsAllocated && _miloListing != null)
            {
                data = CONFileStream.LoadFile(_root.FullName, _miloListing);
            }
            return data;
        }

        protected override FixedArray<byte> GetMainMidiData()
        {
            return _midiListing != null
                ? CONFileStream.LoadFile(_root.FullName, _midiListing)
                : FixedArray<byte>.Null;
        }

        protected override Stream? GetMoggStream()
        {
            var stream = LoadUpdateMoggStream();
            if (stream == null && _moggListing != null)
            {
                stream = CONFileStream.CreateStream(_root.FullName, _moggListing);
            }
            return stream;
        }

        private PackedRBCONEntry(in AbridgedFileInfo root, string nodeName)
            : base(in root, nodeName)
        {
            _midiListing = null!;
            _psuedoDirectory = string.Empty;
        }

        public static ScanExpected<RBCONEntry> Create(in RBScanParameters parameters, List<CONFileListing> listings, Stream stream)
        {
            try
            {
                var entry = new PackedRBCONEntry(in parameters.Root, parameters.NodeName)
                {
                    _updateDirectoryAndDtaLastWrite = parameters.UpdateDirectory,
                    _updateMidiLastWrite = parameters.UpdateMidi,
                    _upgrade = parameters.Upgrade
                };
                entry._metadata.Playlist = parameters.DefaultPlaylist;

                var location = ProcessDTAs(entry, parameters.BaseDta, parameters.UpdateDta, parameters.UpgradeDta);
                if (!location)
                {
                    return new ScanUnexpected(location.Error);
                }

                if (!listings.FindListing(location.Value + ".mid", out entry._midiListing))
                {
                    return new ScanUnexpected(ScanResult.MissingCONMidi);
                }

                if (!listings.FindListing(location.Value + ".mogg", out entry._moggListing))
                {
                    return new ScanUnexpected(ScanResult.MoggError);
                }

                var mainMidi = FixedArray<byte>.Null;
                long moggLocation = CONFileStream.CalculateBlockLocation(entry._moggListing.BlockOffset, entry._moggListing.Shift);
                lock (stream)
                {
                    if (stream.Seek(moggLocation, SeekOrigin.Begin) != moggLocation || stream.Read<int>(Endianness.Little) != UNENCRYPTED_MOGG)
                    {
                        return new ScanUnexpected(ScanResult.MoggError);
                    }
                    mainMidi = CONFileStream.LoadFile(stream, entry._midiListing);
                }

                var result = ScanMidis(entry, in mainMidi);
                mainMidi.Dispose();
                if (result != ScanResult.Success)
                {
                    return new ScanUnexpected(result);
                }
                entry._psuedoDirectory = Path.Combine(parameters.Root.FullName, listings[entry._midiListing.PathIndex].Name);
                entry._subName = location.Value[6..location.Value.IndexOf('/', 6)];

                string genPath = $"songs/{entry._subName}/gen/{entry._subName}";
                listings.FindListing(genPath + ".milo_xbox", out entry._miloListing);
                listings.FindListing(genPath + "_keep.png_xbox", out entry._imgListing);
                entry.SetSortStrings();
                return entry;
            }
            catch (Exception e)
            {
                YargLogger.LogException(e);
                return new ScanUnexpected(ScanResult.DTAError);
            }
        }

        public static PackedRBCONEntry? TryDeserialize(List<CONFileListing> listings, in AbridgedFileInfo conInfo, string nodeName, ref FixedArrayStream stream, CacheReadStrings strings)
        {
            string subname = stream.ReadString();
            string location = $"songs/{subname}/{subname}";
            if (!listings.FindListing(location + ".mid", out var midiListing))
            {
                return null;
            }

            if (!listings.FindListing(location + ".mogg", out var moggListing))
            {
                return null;
            }

            var entry = new PackedRBCONEntry(conInfo, nodeName)
            {
                _subName = subname,
                _midiListing = midiListing,
                _moggListing = moggListing,
                _psuedoDirectory = Path.Combine(conInfo.FullName, listings[midiListing.PathIndex].Name)
            };
            entry.Deserialize(ref stream, strings);

            string genPath = $"songs/{entry._subName}/gen/{entry._subName}";
            listings.FindListing(genPath + ".milo_xbox", out entry._miloListing);
            listings.FindListing(genPath + "_keep.png_xbox", out entry._imgListing);
            return entry;
        }

        public static PackedRBCONEntry ForceDeserialize(List<CONFileListing>? listings, in AbridgedFileInfo conInfo, string nodeName, ref FixedArrayStream stream, CacheReadStrings strings)
        {
            var entry = new PackedRBCONEntry(conInfo, nodeName)
            {
                _subName = stream.ReadString(),
            };
            entry.Deserialize(ref stream, strings);

            entry._psuedoDirectory = Path.Combine(conInfo.FullName, $"songs/{entry._subName}");
            if (listings != null)
            {
                string location = $"songs/{entry._subName}/{entry._subName}";
                listings.FindListing(location + ".mid", out entry._midiListing);
                listings.FindListing(location + ".mogg", out entry._moggListing);


                string genPath = $"songs/{entry._subName}/gen/{entry._subName}";
                listings.FindListing(genPath + ".milo_xbox", out entry._miloListing);
                listings.FindListing(genPath + "_keep.png_xbox", out entry._imgListing);
            }
            return entry;
        }
    }
}
</file>

<file path="Song/Entries/RBCON/SongEntry.RBCON.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using YARG.Core.Chart;
using YARG.Core.Song.Cache;
using YARG.Core.IO;
using Melanchall.DryWetMidi.Core;
using YARG.Core.Extensions;
using YARG.Core.Audio;
using YARG.Core.Logging;

namespace YARG.Core.Song
{
    internal struct RBScanParameters
    {
        public DTAEntry UpdateDta;
        public DTAEntry UpgradeDta;
        public AbridgedFileInfo Root;
        public string NodeName;
        public AbridgedFileInfo? UpdateDirectory;
        public DateTime? UpdateMidi;
        public RBProUpgrade? Upgrade;
        public string DefaultPlaylist;
        public DTAEntry BaseDta;
    }

    public abstract class RBCONEntry : SongEntry
    {
        private const long NOTE_SNAP_THRESHOLD = 10;
        public const int UNENCRYPTED_MOGG = 0xA;
        public const string SONGUPDATES_DTA = "songs_updates.dta";

        protected readonly AbridgedFileInfo _root;
        protected readonly string _nodeName;
        protected string _subName = string.Empty;
        protected AbridgedFileInfo? _updateDirectoryAndDtaLastWrite;
        protected DateTime? _updateMidiLastWrite;
        private protected RBProUpgrade? _upgrade;

        protected RBMetadata _rbMetadata = RBMetadata.Default;
        protected RBIntensities _rbIntensities = RBIntensities.Default;
        protected RBAudio<int> _indices = RBAudio<int>.Empty;
        protected RBAudio<float> _panning = RBAudio<float>.Empty;

        public string RBSongId => _rbMetadata.SongID;
        public int RBBandDiff => _rbIntensities.Band;

        protected abstract DateTime MidiLastWriteTime { get; }

        protected abstract FixedArray<byte> GetMainMidiData();
        protected abstract Stream? GetMoggStream();

        public override DateTime GetLastWriteTime()
        {
            var last_write = MidiLastWriteTime;
            if (_updateMidiLastWrite.HasValue && _updateMidiLastWrite > last_write)
            {
                last_write = _updateMidiLastWrite.Value;
            }

            if (_upgrade != null && _upgrade.LastWriteTime > last_write)
            {
                last_write = _upgrade.LastWriteTime;
            }
            return last_write;
        }

        internal override void Serialize(MemoryStream stream, CacheWriteIndices indices)
        {
            base.Serialize(stream, indices);
            stream.Write(_yearAsNumber, Endianness.Little);

            unsafe
            {
                var intensities = _rbIntensities;
                stream.Write(new ReadOnlySpan<byte>(&intensities, sizeof(RBIntensities)));
            }

            stream.WriteByte((byte)_rbMetadata.VocalGender);
            stream.WriteByte((byte)_rbMetadata.SongTonality);
            stream.WriteByte((byte)_rbMetadata.MidiEncoding);

            stream.Write(_rbMetadata.AnimTempo,            Endianness.Little);
            stream.Write(_rbMetadata.VocalSongScrollSpeed, Endianness.Little);
            stream.Write(_rbMetadata.VocalTonicNote,       Endianness.Little);
            stream.Write(_rbMetadata.TuningOffsetCents,    Endianness.Little);
            stream.Write(_rbMetadata.VenueVersion,         Endianness.Little);

            stream.Write(_rbMetadata.SongID);
            stream.Write(_rbMetadata.VocalPercussionBank);
            stream.Write(_rbMetadata.DrumBank);

            WriteArray(in _rbMetadata.RealGuitarTuning, stream);
            WriteArray(in _rbMetadata.RealBassTuning,   stream);

            WriteArray(in _rbMetadata.Soloes,      stream);
            WriteArray(in _rbMetadata.VideoVenues, stream);

            WriteAudio(in _indices, stream);
            WriteAudio(in _panning, stream);
        }

        public override SongChart? LoadChart()
        {
            MidiFile midi;
            var readingSettings = MidiSettingsLatin1.Instance; // RBCONs are always Latin-1
            // Read base MIDI
            using (var mainMidi = GetMainMidiData())
            {
                if (!mainMidi.IsAllocated)
                {
                    return null;
                }
                midi = MidiFile.Read(mainMidi.ToReferenceStream(), readingSettings);
            }

            // Merge update MIDI
            if (_updateMidiLastWrite.HasValue)
            {
                if (!AbridgedFileInfo.Validate(Path.Combine(_updateDirectoryAndDtaLastWrite!.Value.FullName, SONGUPDATES_DTA), _updateDirectoryAndDtaLastWrite.Value.LastWriteTime))
                {
                    return null;
                }

                string updateFilename = Path.Combine(_updateDirectoryAndDtaLastWrite!.Value.FullName, _nodeName, _nodeName + "_update.mid");
                if (!AbridgedFileInfo.Validate(updateFilename, _updateMidiLastWrite.Value))
                {
                    return null;
                }

                using var updateMidi = FixedArray.LoadFile(updateFilename);
                var update = MidiFile.Read(updateMidi.ToReferenceStream(), readingSettings);
                midi.Merge(update);
            }

            // Merge upgrade MIDI
            if (_upgrade != null)
            {
                using var upgradeMidi = _upgrade.LoadUpgradeMidi();
                if (!upgradeMidi.IsAllocated)
                {
                    return null;
                }

                var upgrade = MidiFile.Read(upgradeMidi.ToReferenceStream(), readingSettings);
                midi.Merge(upgrade);
            }

            var parseSettings = new ParseSettings()
            {
                HopoThreshold = _settings.HopoThreshold,
                SustainCutoffThreshold = _settings.SustainCutoffThreshold,
                StarPowerNote = _settings.OverdiveMidiNote,
                DrumsType = DrumsType.FourLane,
                ChordHopoCancellation = true
            };
            return SongChart.FromMidi(in parseSettings, midi);
        }

        public override StemMixer? LoadAudio(float speed, double volume, params SongStem[] ignoreStems)
        {
            var stream = GetMoggStream();
            if (stream == null)
            {
                return null;
            }

            int version = stream.Read<int>(Endianness.Little);
            if (version is not 0x0A and not 0xF0)
            {
                YargLogger.LogError("Original unencrypted mogg replaced by an encrypted mogg!");
                stream.Dispose();
                return null;
            }

            int start = stream.Read<int>(Endianness.Little);
            stream.Seek(start, SeekOrigin.Begin);

            bool clampStemVolume = _metadata.Source.ToLowerInvariant() == "yarg";
            var mixer = GlobalAudioHandler.CreateMixer(ToString(), stream, speed, volume, clampStemVolume);
            if (mixer == null)
            {
                YargLogger.LogError("Mogg failed to load!");
                stream.Dispose();
                return null;
            }


            if (_indices.Drums.Length > 0 && !ignoreStems.Contains(SongStem.Drums))
            {
                switch (_indices.Drums.Length)
                {
                    //drum (0 1): stereo kit --> (0 1)
                    case 1:
                    case 2:
                        mixer.AddChannel(SongStem.Drums, _indices.Drums, _panning.Drums!);
                        break;
                    //drum (0 1 2): mono kick, stereo snare/kit --> (0) (1 2)
                    case 3:
                        mixer.AddChannel(SongStem.Drums1, _indices.Drums[0..1], _panning.Drums![0..2]);
                        mixer.AddChannel(SongStem.Drums2, _indices.Drums[1..3], _panning.Drums[2..6]);
                        break;
                    //drum (0 1 2 3): mono kick, mono snare, stereo kit --> (0) (1) (2 3)
                    case 4:
                        mixer.AddChannel(SongStem.Drums1, _indices.Drums[0..1], _panning.Drums![0..2]);
                        mixer.AddChannel(SongStem.Drums2, _indices.Drums[1..2], _panning.Drums[2..4]);
                        mixer.AddChannel(SongStem.Drums3, _indices.Drums[2..4], _panning.Drums[4..8]);
                        break;
                    //drum (0 1 2 3 4): mono kick, stereo snare, stereo kit --> (0) (1 2) (3 4)
                    case 5:
                        mixer.AddChannel(SongStem.Drums1, _indices.Drums[0..1], _panning.Drums![0..2]);
                        mixer.AddChannel(SongStem.Drums2, _indices.Drums[1..3], _panning.Drums[2..6]);
                        mixer.AddChannel(SongStem.Drums3, _indices.Drums[3..5], _panning.Drums[6..10]);
                        break;
                    //drum (0 1 2 3 4 5): stereo kick, stereo snare, stereo kit --> (0 1) (2 3) (4 5)
                    case 6:
                        mixer.AddChannel(SongStem.Drums1, _indices.Drums[0..2], _panning.Drums![0..4]);
                        mixer.AddChannel(SongStem.Drums2, _indices.Drums[2..4], _panning.Drums[4..8]);
                        mixer.AddChannel(SongStem.Drums3, _indices.Drums[4..6], _panning.Drums[8..12]);
                        break;
                }
            }

            if (_indices.Bass.Length > 0 && !ignoreStems.Contains(SongStem.Bass))
                mixer.AddChannel(SongStem.Bass, _indices.Bass, _panning.Bass!);

            if (_indices.Guitar.Length > 0 && !ignoreStems.Contains(SongStem.Guitar))
                mixer.AddChannel(SongStem.Guitar, _indices.Guitar, _panning.Guitar!);

            if (_indices.Keys.Length > 0 && !ignoreStems.Contains(SongStem.Keys))
                mixer.AddChannel(SongStem.Keys, _indices.Keys, _panning.Keys!);

            if (_indices.Vocals.Length > 0 && !ignoreStems.Contains(SongStem.Vocals))
                mixer.AddChannel(SongStem.Vocals, _indices.Vocals, _panning.Vocals!);

            if (_indices.Track.Length > 0 && !ignoreStems.Contains(SongStem.Song))
                mixer.AddChannel(SongStem.Song, _indices.Track, _panning.Track!);

            if (_indices.Crowd.Length > 0 && !ignoreStems.Contains(SongStem.Crowd))
                mixer.AddChannel(SongStem.Crowd, _indices.Crowd, _panning.Crowd!);

            if (mixer.Channels.Count == 0)
            {
                YargLogger.LogError("Failed to add any stems!");
                stream.Dispose();
                mixer.Dispose();
                return null;
            }
            YargLogger.LogFormatInfo("Loaded {0} stems", mixer.Channels.Count);
            return mixer;
        }

        public override StemMixer? LoadPreviewAudio(float speed)
        {
            return LoadAudio(speed, 0, SongStem.Crowd);
        }

        internal void UpdateInfo(in AbridgedFileInfo? updateDirectory, in DateTime? updateMidi, RBProUpgrade? upgrade)
        {
            _updateDirectoryAndDtaLastWrite = updateDirectory;
            _updateMidiLastWrite = updateMidi;
            _upgrade = upgrade;
        }

        private protected new void Deserialize(ref FixedArrayStream stream, CacheReadStrings strings)
        {
            base.Deserialize(ref stream, strings);
            _yearAsNumber = stream.Read<int>(Endianness.Little);
            _parsedYear = _metadata.Year;

            unsafe
            {
                RBIntensities intensities;
                stream.Read(&intensities, sizeof(RBIntensities));
                _rbIntensities = intensities;
            }

            _rbMetadata.VocalGender  = (VocalGender) stream.ReadByte();
            _rbMetadata.SongTonality = (SongTonality)stream.ReadByte();
            _rbMetadata.MidiEncoding = (EncodingType)stream.ReadByte();

            _rbMetadata.AnimTempo            = stream.Read<uint>(Endianness.Little);
            _rbMetadata.VocalSongScrollSpeed = stream.Read<uint>(Endianness.Little);
            _rbMetadata.VocalTonicNote       = stream.Read<uint>(Endianness.Little);
            _rbMetadata.TuningOffsetCents    = stream.Read<int> (Endianness.Little);
            _rbMetadata.VenueVersion         = stream.Read<uint>(Endianness.Little);

            _rbMetadata.SongID              = stream.ReadString();
            _rbMetadata.VocalPercussionBank = stream.ReadString();
            _rbMetadata.DrumBank            = stream.ReadString();

            _rbMetadata.RealGuitarTuning = ReadArray<int>(ref stream);
            _rbMetadata.RealBassTuning   = ReadArray<int>(ref stream);

            _rbMetadata.Soloes      = ReadStringArray(ref stream);
            _rbMetadata.VideoVenues = ReadStringArray(ref stream);

            ReadAudio(ref _indices, ref stream);
            ReadAudio(ref _panning, ref stream);
        }

        protected RBCONEntry(in AbridgedFileInfo root, string nodeName)
        {
            _root = root;
            _nodeName = nodeName;
        }


        private static readonly int[] BandDiffMap = { 163, 215, 243, 267, 292, 345 };
        private static readonly int[] GuitarDiffMap = { 139, 176, 221, 267, 333, 409 };
        private static readonly int[] BassDiffMap = { 135, 181, 228, 293, 364, 436 };
        private static readonly int[] DrumDiffMap = { 124, 151, 178, 242, 345, 448 };
        private static readonly int[] KeysDiffMap = { 153, 211, 269, 327, 385, 443 };
        private static readonly int[] VocalsDiffMap = { 132, 175, 218, 279, 353, 427 };
        private static readonly int[] RealGuitarDiffMap = { 150, 205, 264, 323, 382, 442 };
        private static readonly int[] RealBassDiffMap = { 150, 208, 267, 325, 384, 442 };
        private static readonly int[] RealDrumsDiffMap = { 124, 151, 178, 242, 345, 448 };
        private static readonly int[] RealKeysDiffMap = { 153, 211, 269, 327, 385, 443 };
        private static readonly int[] HarmonyDiffMap = { 132, 175, 218, 279, 353, 427 };
        private protected static ScanExpected<string> ProcessDTAs(RBCONEntry entry, in DTAEntry baseDTA, in DTAEntry updateDTA, in DTAEntry upgradeDTA)
        {
            string? location = null;
            float[]? volumes = null;
            float[]? pans = null;
            float[]? cores = null;

            ParseDTA(entry, in baseDTA, ref location, ref volumes, ref pans, ref cores);
            ParseDTA(entry, in upgradeDTA, ref location, ref volumes, ref pans, ref cores);
            ParseDTA(entry, in updateDTA, ref location, ref volumes, ref pans, ref cores);

            if (entry._metadata.Name.Length == 0)
            {
                return new ScanUnexpected(ScanResult.NoName);
            }

            if (location == null || pans == null || volumes == null || cores == null)
            {
                return new ScanUnexpected(ScanResult.DTAError);
            }

            entry._parsedYear = entry._metadata.Year;

            unsafe
            {
                var usedIndices = stackalloc bool[pans.Length];
                float[] CalculateStemValues(int[] indices)
                {
                    float[] values = new float[2 * indices.Length];
                    for (int i = 0; i < indices.Length; i++)
                    {
                        float theta = (pans[indices[i]] + 1) * ((float) Math.PI / 4);
                        float volRatio = (float) Math.Pow(10, volumes[indices[i]] / 20);
                        values[2 * i] = volRatio * (float) Math.Cos(theta);
                        values[2 * i + 1] = volRatio * (float) Math.Sin(theta);
                        usedIndices[indices[i]] = true;
                    }
                    return values;
                }

                if (entry._indices.Drums.Length > 0)
                {
                    entry._panning.Drums = CalculateStemValues(entry._indices.Drums);
                }

                if (entry._indices.Bass.Length > 0)
                {
                    entry._panning.Bass = CalculateStemValues(entry._indices.Bass);
                }

                if (entry._indices.Guitar.Length > 0)
                {
                    entry._panning.Guitar = CalculateStemValues(entry._indices.Guitar);
                }

                if (entry._indices.Keys.Length > 0)
                {
                    entry._panning.Keys = CalculateStemValues(entry._indices.Keys);
                }

                if (entry._indices.Vocals.Length > 0)
                {
                    entry._panning.Vocals = CalculateStemValues(entry._indices.Vocals);
                }

                if (entry._indices.Crowd.Length > 0)
                {
                    entry._panning.Crowd = CalculateStemValues(entry._indices.Crowd);
                }

                var leftover = new List<int>(pans.Length);
                for (int i = 0; i < pans.Length; i++)
                {
                    if (!usedIndices[i])
                    {
                        leftover.Add(i);
                    }
                }

                if (leftover.Count > 0)
                {
                    entry._indices.Track = leftover.ToArray();
                    entry._panning.Track = CalculateStemValues(entry._indices.Track);
                }
            }

            if (entry._rbIntensities.FourLaneDrums > -1)
            {
                entry._parts.FourLaneDrums.Intensity = (sbyte)GetIntensity(entry._rbIntensities.FourLaneDrums, DrumDiffMap);
                if (entry._parts.ProDrums.Intensity == -1)
                {
                    entry._parts.ProDrums.Intensity = entry._parts.FourLaneDrums.Intensity;
                }
            }
            if (entry._rbIntensities.FiveFretGuitar > -1)
            {
                entry._parts.FiveFretGuitar.Intensity = (sbyte)GetIntensity(entry._rbIntensities.FiveFretGuitar, GuitarDiffMap);
                if (entry._parts.ProGuitar_17Fret.Intensity == -1)
                {
                    entry._parts.ProGuitar_22Fret.Intensity = entry._parts.ProGuitar_17Fret.Intensity = entry._parts.FiveFretGuitar.Intensity;
                }
            }
            if (entry._rbIntensities.FiveFretBass > -1)
            {
                entry._parts.FiveFretBass.Intensity = (sbyte)GetIntensity(entry._rbIntensities.FiveFretBass, GuitarDiffMap);
                if (entry._parts.ProBass_17Fret.Intensity == -1)
                {
                    entry._parts.ProBass_22Fret.Intensity = entry._parts.ProBass_17Fret.Intensity = entry._parts.FiveFretGuitar.Intensity;
                }
            }
            if (entry._rbIntensities.LeadVocals > -1)
            {
                entry._parts.LeadVocals.Intensity = (sbyte)GetIntensity(entry._rbIntensities.LeadVocals, GuitarDiffMap);
                if (entry._parts.HarmonyVocals.Intensity == -1)
                {
                    entry._parts.HarmonyVocals.Intensity = entry._parts.LeadVocals.Intensity;
                }
            }
            if (entry._rbIntensities.Keys > -1)
            {
                entry._parts.Keys.Intensity = (sbyte)GetIntensity(entry._rbIntensities.Keys, GuitarDiffMap);
                if (entry._parts.ProKeys.Intensity == -1)
                {
                    entry._parts.ProKeys.Intensity = entry._parts.Keys.Intensity;
                }
            }
            if (entry._rbIntensities.ProGuitar > -1)
            {
                entry._parts.ProGuitar_17Fret.Intensity = (sbyte)GetIntensity(entry._rbIntensities.ProGuitar, RealGuitarDiffMap);
                entry._parts.ProGuitar_22Fret.Intensity = entry._parts.ProGuitar_17Fret.Intensity;
                if (entry._parts.FiveFretGuitar.Intensity == -1)
                {
                    entry._parts.FiveFretGuitar.Intensity = entry._parts.ProGuitar_17Fret.Intensity;
                }
            }
            if (entry._rbIntensities.ProBass > -1)
            {
                entry._parts.ProBass_17Fret.Intensity = (sbyte)GetIntensity(entry._rbIntensities.ProBass, RealGuitarDiffMap);
                entry._parts.ProBass_22Fret.Intensity = entry._parts.ProBass_17Fret.Intensity;
                if (entry._parts.FiveFretBass.Intensity == -1)
                {
                    entry._parts.FiveFretBass.Intensity = entry._parts.ProBass_17Fret.Intensity;
                }
            }
            if (entry._rbIntensities.ProKeys > -1)
            {
                entry._parts.ProKeys.Intensity = (sbyte)GetIntensity(entry._rbIntensities.ProKeys, RealKeysDiffMap);
                if (entry._parts.Keys.Intensity == -1)
                {
                    entry._parts.Keys.Intensity = entry._parts.ProKeys.Intensity;
                }
            }
            if (entry._rbIntensities.ProDrums > -1)
            {
                entry._parts.ProDrums.Intensity = (sbyte)GetIntensity(entry._rbIntensities.ProDrums, DrumDiffMap);
                if (entry._parts.FourLaneDrums.Intensity == -1)
                {
                    entry._parts.FourLaneDrums.Intensity = entry._parts.ProDrums.Intensity;
                }
            }
            if (entry._rbIntensities.HarmonyVocals > -1)
            {
                entry._parts.HarmonyVocals.Intensity = (sbyte)GetIntensity(entry._rbIntensities.HarmonyVocals, DrumDiffMap);
                if (entry._parts.LeadVocals.Intensity == -1)
                {
                    entry._parts.LeadVocals.Intensity = entry._parts.HarmonyVocals.Intensity;
                }
            }
            if (entry._rbIntensities.Band > -1)
            {
                entry._parts.BandDifficulty.Intensity = (sbyte)GetIntensity(entry._rbIntensities.Band, BandDiffMap);
                entry._parts.BandDifficulty.SubTracks = 1;
            }
            return location;
        }

        private protected static ScanResult ScanMidis(RBCONEntry entry, in FixedArray<byte> mainMidi)
        {
            var updateMidi = FixedArray<byte>.Null;
            var upgradeMidi = FixedArray<byte>.Null;
            try
            {
                if (entry._upgrade != null)
                {
                    upgradeMidi = entry._upgrade.LoadUpgradeMidi();
                    if (!upgradeMidi.IsAllocated)
                    {
                        throw new FileNotFoundException("Upgrade midi not located");
                    }
                }

                if (entry._updateMidiLastWrite.HasValue)
                {
                    string updateFile = Path.Combine(entry._updateDirectoryAndDtaLastWrite!.Value.FullName, entry._nodeName, entry._nodeName + "_update.mid");
                    updateMidi = FixedArray.LoadFile(updateFile);
                }

                var drumsType = DrumsType.ProDrums;

                long bufLength = mainMidi.Length;
                if (updateMidi.IsAllocated)
                {
                    var updateResult = ParseMidi(in updateMidi, ref entry._parts, ref drumsType);
                    switch (updateResult.Error)
                    {
                        case ScanResult.InvalidResolution:      return ScanResult.InvalidResolution_Update;
                        case ScanResult.MultipleMidiTrackNames: return ScanResult.MultipleMidiTrackNames_Update;
                    }
                    bufLength += updateMidi.Length;
                }

                if (upgradeMidi.IsAllocated)
                {
                    var upgradeResult = ParseMidi(in upgradeMidi, ref entry._parts, ref drumsType);
                    switch (upgradeResult.Error)
                    {
                        case ScanResult.InvalidResolution:      return ScanResult.InvalidResolution_Upgrade;
                        case ScanResult.MultipleMidiTrackNames: return ScanResult.MultipleMidiTrackNames_Upgrade;
                    }
                    bufLength += upgradeMidi.Length;
                }

                var resolution = ParseMidi(in mainMidi, ref entry._parts, ref drumsType);
                if (!resolution)
                {
                    return resolution.Error;
                }

                if (!IsValid(in entry._parts))
                {
                    return ScanResult.NoNotes;
                }

                entry._parts.ProDrums.Difficulties = entry._parts.FourLaneDrums.Difficulties;
                entry._settings.SustainCutoffThreshold = resolution.Value / 3;
                if (entry._settings.HopoThreshold == -1)
                {
                    entry._settings.HopoThreshold = entry._settings.SustainCutoffThreshold;
                }

                using var buffer = FixedArray<byte>.Alloc(bufLength);
                unsafe
                {
                    System.Runtime.CompilerServices.Unsafe.CopyBlock(buffer.Ptr, mainMidi.Ptr, (uint) mainMidi.Length);

                    long offset = mainMidi.Length;
                    if (updateMidi.IsAllocated)
                    {
                        System.Runtime.CompilerServices.Unsafe.CopyBlock(buffer.Ptr + offset, updateMidi.Ptr, (uint) updateMidi.Length);
                        offset += updateMidi.Length;
                        updateMidi.Dispose();
                    }

                    if (upgradeMidi.IsAllocated)
                    {
                        System.Runtime.CompilerServices.Unsafe.CopyBlock(buffer.Ptr + offset, upgradeMidi.Ptr, (uint) upgradeMidi.Length);
                        upgradeMidi.Dispose();
                    }
                }
                entry._hash = HashWrapper.Hash(buffer.ReadOnlySpan);
                return ScanResult.Success;
            }
            catch (Exception ex)
            {
                if (updateMidi.IsAllocated)
                {
                    updateMidi.Dispose();
                }

                if (upgradeMidi.IsAllocated)
                {
                    upgradeMidi.Dispose();
                }
                YargLogger.LogException(ex);
                return ScanResult.PossibleCorruption;
            }
        }

        protected Stream? LoadUpdateMoggStream()
        {
            Stream? stream = null;
            if (_updateDirectoryAndDtaLastWrite.HasValue)
            {
                string updateMoggPath = Path.Combine(_updateDirectoryAndDtaLastWrite.Value.FullName, _subName, _subName + "_update.mogg");
                if (File.Exists(updateMoggPath))
                {
                    stream = File.OpenRead(updateMoggPath);
                }
            }
            return stream;
        }

        protected YARGImage LoadUpdateAlbumData()
        {
            var image = YARGImage.Null;
            if (_updateDirectoryAndDtaLastWrite.HasValue)
            {
                string updateImgPath = Path.Combine(_updateDirectoryAndDtaLastWrite.Value.FullName, _subName, "gen", _subName + "_keep.png_xbox");
                if (File.Exists(updateImgPath))
                {
                    image = YARGImage.LoadDXT(updateImgPath);
                }
            }
            return image;
        }

        protected FixedArray<byte> LoadUpdateMiloData()
        {
            var data = FixedArray<byte>.Null;
            if (_updateDirectoryAndDtaLastWrite.HasValue)
            {
                string updateMiloPath = Path.Combine(_updateDirectoryAndDtaLastWrite.Value.FullName, _subName, "gen", _subName + ".milo_xbox");
                if (File.Exists(updateMiloPath))
                {
                    data = FixedArray.LoadFile(updateMiloPath);
                }
            }
            return data;
        }

        private static void WriteUpdateInfo(in AbridgedFileInfo? info, MemoryStream stream)
        {
            stream.Write(info != null);
            if (info != null)
            {
                stream.Write(info.Value.FullName);
            }
        }

        private static void WriteArray<TType>(in TType[] values, MemoryStream stream)
            where TType : unmanaged
        {
            stream.Write(values.Length, Endianness.Little);
            unsafe
            {
                fixed (TType* ptr = values)
                {
                    var span = new ReadOnlySpan<byte>(ptr, values.Length * sizeof(TType));
                    stream.Write(span);
                }
            }
        }

        private static void WriteArray(in string[] strings, MemoryStream stream)
        {
            stream.Write(strings.Length, Endianness.Little);
            for (int i = 0; i < strings.Length; ++i)
            {
                stream.Write(strings[i]);
            }
        }

        private static TType[] ReadArray<TType>(ref FixedArrayStream stream)
            where TType : unmanaged
        {
            int length = stream.Read<int>(Endianness.Little);
            if (length == 0)
            {
                return Array.Empty<TType>();
            }

            var values = new TType[length];
            unsafe
            {
                fixed (TType* ptr = values)
                {
                    stream.Read(ptr, values.Length * sizeof(TType));
                }
            }
            return values;
        }

        private static string[] ReadStringArray(ref FixedArrayStream stream)
        {
            int length = stream.Read<int>(Endianness.Little);
            if (length == 0)
            {
                return Array.Empty<string>();
            }

            var strings = new string[length];
            for (int i = 0; i < strings.Length; ++i)
            {
                strings[i] = stream.ReadString();
            }
            return strings;
        }

        private static void ReadAudio<TType>(ref RBAudio<TType> audio, ref FixedArrayStream stream)
            where TType : unmanaged
        {
            audio.Track  = ReadArray<TType>(ref stream);
            audio.Drums  = ReadArray<TType>(ref stream);
            audio.Bass   = ReadArray<TType>(ref stream);
            audio.Guitar = ReadArray<TType>(ref stream);
            audio.Keys   = ReadArray<TType>(ref stream);
            audio.Vocals = ReadArray<TType>(ref stream);
            audio.Crowd  = ReadArray<TType>(ref stream);
        }

        private static void WriteAudio<TType>(in RBAudio<TType> audio, MemoryStream stream)
            where TType : unmanaged
        {
            WriteArray(in audio.Track, stream);
            WriteArray(in audio.Drums, stream);
            WriteArray(in audio.Bass, stream);
            WriteArray(in audio.Guitar, stream);
            WriteArray(in audio.Keys, stream);
            WriteArray(in audio.Vocals, stream);
            WriteArray(in audio.Crowd, stream);
        }

        private static void ParseDTA(RBCONEntry entry, in DTAEntry dta, ref string? location, ref float[]? volumes, ref float[]? pans, ref float[]? cores)
        {
            if (dta.Name != null)    { entry._metadata.Name    = YARGDTAReader.DecodeString(dta.Name.Value, dta.MetadataEncoding); }
            if (dta.Artist != null)  { entry._metadata.Artist  = YARGDTAReader.DecodeString(dta.Artist.Value, dta.MetadataEncoding); }
            if (dta.Album != null)   { entry._metadata.Album   = YARGDTAReader.DecodeString(dta.Album.Value, dta.MetadataEncoding); }
            if (dta.Charter != null) { entry._metadata.Charter = dta.Charter; }
            if (dta.Genre != null)   { entry._metadata.Genre   = dta.Genre; }
            if (dta.YearAsNumber != null)
            {
                entry._yearAsNumber = dta.YearAsNumber.Value;
                entry._metadata.Year = entry._yearAsNumber.ToString("D4");
            }
            if (dta.Source != null)
            {
                if (!entry._nodeName.StartsWith("UGC_", StringComparison.OrdinalIgnoreCase) && (dta.Source == "ugc" || dta.Source == "ugc_plus" || (dta.Source == "rb2" && dta.UGC.HasValue && dta.UGC.Value)))
                {
                    entry._metadata.Source = "customs";
                }
                else
                {
                    entry._metadata.Source = dta.Source;
                }
            }
            if (dta.Playlist != null)             { entry._metadata.Playlist      = dta.Playlist; }
            if (dta.SongLength != null)           { entry._metadata.SongLength    = dta.SongLength.Value; }
            if (dta.IsMaster != null)             { entry._metadata.IsMaster      = dta.IsMaster.Value; }
            if (dta.AlbumTrack != null)           { entry._metadata.AlbumTrack    = dta.AlbumTrack.Value; }
            if (dta.Preview != null)              { entry._metadata.Preview       = dta.Preview.Value; }
            if (dta.HopoThreshold != null)        { entry._settings.HopoThreshold = dta.HopoThreshold.Value; }
            if (dta.SongRating != null)           { entry._metadata.SongRating    = dta.SongRating.Value; }

            if (dta.VocalPercussionBank != null)  { entry._rbMetadata.VocalPercussionBank  = dta.VocalPercussionBank; }
            if (dta.VocalGender != null)          { entry._rbMetadata.VocalGender          = dta.VocalGender.Value; }
            if (dta.VocalSongScrollSpeed != null) { entry._rbMetadata.VocalSongScrollSpeed = dta.VocalSongScrollSpeed.Value; }
            if (dta.VocalTonicNote != null)       { entry._rbMetadata.VocalTonicNote       = dta.VocalTonicNote.Value; }
            if (dta.VideoVenues != null)          { entry._rbMetadata.VideoVenues          = dta.VideoVenues; }
            if (dta.DrumBank != null)             { entry._rbMetadata.DrumBank             = dta.DrumBank; }
            if (dta.SongID != null)               { entry._rbMetadata.SongID               = dta.SongID; }
            if (dta.SongTonality != null)         { entry._rbMetadata.SongTonality         = dta.SongTonality.Value; }
            if (dta.Soloes != null)               { entry._rbMetadata.Soloes               = dta.Soloes; }
            if (dta.AnimTempo != null)            { entry._rbMetadata.AnimTempo            = dta.AnimTempo.Value; }
            if (dta.TuningOffsetCents != null)    { entry._rbMetadata.TuningOffsetCents    = dta.TuningOffsetCents.Value; }
            if (dta.RealGuitarTuning != null)     { entry._rbMetadata.RealGuitarTuning     = dta.RealGuitarTuning; }
            if (dta.RealBassTuning != null)       { entry._rbMetadata.RealBassTuning       = dta.RealBassTuning; }

            if (dta.Cores != null)   { cores = dta.Cores; }
            if (dta.Volumes != null) { volumes = dta.Volumes; }
            if (dta.Pans != null)    { pans = dta.Pans; }

            if (dta.Location != null) { location = dta.Location; }

            if (dta.Indices != null)  { entry._indices = dta.Indices.Value; }

            if (dta.CrowdChannels != null) { entry._indices.Crowd = dta.CrowdChannels; }

            if (dta.Intensities.Band >= 0)           { entry._rbIntensities.Band           = dta.Intensities.Band; }
            if (dta.Intensities.FiveFretGuitar >= 0) { entry._rbIntensities.FiveFretGuitar = dta.Intensities.FiveFretGuitar; }
            if (dta.Intensities.FiveFretBass >= 0)   { entry._rbIntensities.FiveFretBass   = dta.Intensities.FiveFretBass; }
            if (dta.Intensities.FiveFretRhythm >= 0) { entry._rbIntensities.FiveFretRhythm = dta.Intensities.FiveFretRhythm; }
            if (dta.Intensities.FiveFretCoop >= 0)   { entry._rbIntensities.FiveFretCoop   = dta.Intensities.FiveFretCoop; }
            if (dta.Intensities.Keys >= 0)           { entry._rbIntensities.Keys           = dta.Intensities.Keys; }
            if (dta.Intensities.FourLaneDrums >= 0)  { entry._rbIntensities.FourLaneDrums  = dta.Intensities.FourLaneDrums; }
            if (dta.Intensities.ProDrums >= 0)       { entry._rbIntensities.ProDrums       = dta.Intensities.ProDrums; }
            if (dta.Intensities.ProGuitar >= 0)      { entry._rbIntensities.ProGuitar      = dta.Intensities.ProGuitar; }
            if (dta.Intensities.ProBass >= 0)        { entry._rbIntensities.ProBass        = dta.Intensities.ProBass; }
            if (dta.Intensities.ProKeys >= 0)        { entry._rbIntensities.ProKeys        = dta.Intensities.ProKeys; }
            if (dta.Intensities.LeadVocals >= 0)     { entry._rbIntensities.LeadVocals     = dta.Intensities.LeadVocals; }
            if (dta.Intensities.HarmonyVocals >= 0)  { entry._rbIntensities.HarmonyVocals  = dta.Intensities.HarmonyVocals; }
        }

        private static int GetIntensity(int rank, int[] values)
        {
            int intensity = 0;
            while (intensity < 6 && values[intensity] <= rank)
            {
                ++intensity;
            }
            return intensity;
        }
    }
}
</file>

<file path="Song/Entries/RBCON/SongEntry.UnpackedRBCON.cs">
using System;
using System.IO;
using YARG.Core.Extensions;
using YARG.Core.Song.Cache;
using YARG.Core.IO;
using YARG.Core.Venue;
using YARG.Core.Logging;

namespace YARG.Core.Song
{
    internal sealed class UnpackedRBCONEntry : RBCONEntry
    {
        private DateTime _midiLastWrite;

        public override EntryType SubType => EntryType.ExCON;
        public override string SortBasedLocation => Path.Combine(_root.FullName, _subName);
        public override string ActualLocation => Path.Combine(_root.FullName, _subName);
        protected override DateTime MidiLastWriteTime => _midiLastWrite;

        internal override void Serialize(MemoryStream stream, CacheWriteIndices node)
        {
            stream.Write(_subName);
            stream.Write(_midiLastWrite.ToBinary(), Endianness.Little);
            base.Serialize(stream, node);
        }

        public override YARGImage LoadAlbumData()
        {
            var image = LoadUpdateAlbumData();
            if (!image.IsAllocated)
            {
                string path = Path.Combine(_root.FullName, _subName, "gen", _subName + "_keep.png_xbox");
                if (File.Exists(path))
                {
                    image = YARGImage.LoadDXT(path);
                }
            }
            return image;
        }

        public override BackgroundResult? LoadBackground()
        {
            string yarground = Path.Combine(_root.FullName, _subName, YARGROUND_FULLNAME);
            if (File.Exists(yarground))
            {
                var stream = File.OpenRead(yarground);
                return new BackgroundResult(BackgroundType.Yarground, stream);
            }

            foreach (var name in BACKGROUND_FILENAMES)
            {
                var fileBase = Path.Combine(_root.FullName, _subName, name);
                foreach (var ext in VIDEO_EXTENSIONS)
                {
                    string videoFile = fileBase + ext;
                    if (File.Exists(videoFile))
                    {
                        var stream = File.OpenRead(videoFile);
                        return new BackgroundResult(BackgroundType.Video, stream);
                    }
                }
            }

            //                                     No "video"
            foreach (var name in BACKGROUND_FILENAMES[..2])
            {
                var fileBase = Path.Combine(_root.FullName, _subName, name);
                foreach (var ext in IMAGE_EXTENSIONS)
                {
                    string imageFile = fileBase + ext;
                    if (File.Exists(imageFile))
                    {
                        var image = YARGImage.Load(imageFile);
                        if (image.IsAllocated)
                        {
                            return new BackgroundResult(image);
                        }
                    }
                }
            }
            return null;
        }

        public override FixedArray<byte> LoadMiloData()
        {
            var data = LoadUpdateMiloData();
            if (!data.IsAllocated)
            {
                string path = Path.Combine(_root.FullName, _subName, "gen", _subName + ".mogg");
                if (File.Exists(path))
                {
                    data = FixedArray.LoadFile(path);
                }
            }
            return data;
        }

        protected override FixedArray<byte> GetMainMidiData()
        {
            string path = Path.Combine(_root.FullName, _subName, _subName + ".mid");
            return File.Exists(path) ? FixedArray.LoadFile(path) : FixedArray<byte>.Null;
        }

        protected override Stream? GetMoggStream()
        {
            var stream = LoadUpdateMoggStream();
            if (stream == null)
            {
                string path = Path.Combine(_root.FullName, _subName, _subName + ".mogg");
                if (File.Exists(path))
                {
                    stream = File.OpenRead(path);
                }
            }
            return stream;
        }

        private UnpackedRBCONEntry(in AbridgedFileInfo root, string nodeName)
            : base(in root, nodeName) {}

        public static ScanExpected<RBCONEntry> Create(in RBScanParameters parameters)
        {
            try
            {
                var entry = new UnpackedRBCONEntry(in parameters.Root, parameters.NodeName)
                {
                    _updateDirectoryAndDtaLastWrite = parameters.UpdateDirectory,
                    _updateMidiLastWrite = parameters.UpdateMidi,
                    _upgrade = parameters.Upgrade
                };
                entry._metadata.Playlist = parameters.DefaultPlaylist;

                var location = ProcessDTAs(entry, parameters.BaseDta, parameters.UpdateDta, parameters.UpgradeDta);
                if (!location)
                {
                    return new ScanUnexpected(location.Error);
                }

                entry._subName = location.Value[6..location.Value.IndexOf('/', 6)];

                string songDirectory = Path.Combine(parameters.Root.FullName, entry._subName);
                var midiInfo = new FileInfo(Path.Combine(songDirectory, entry._subName + ".mid"));
                if (!midiInfo.Exists)
                {
                    return new ScanUnexpected(ScanResult.MissingCONMidi);
                }

                string moggPath = Path.Combine(songDirectory, entry._subName + ".mogg");
                if (File.Exists(moggPath))
                {
                    using var moggStream = new FileStream(moggPath, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
                    if (moggStream.Read<int>(Endianness.Little) != UNENCRYPTED_MOGG)
                    {
                        return new ScanUnexpected(ScanResult.MoggError);
                    }
                }
                else
                {
                    return new ScanUnexpected(ScanResult.MoggError);
                }

                using var mainMidi = FixedArray.LoadFile(midiInfo.FullName);
                var result = ScanMidis(entry, in mainMidi);
                if (result != ScanResult.Success)
                {
                    return new ScanUnexpected(result);
                }
                entry._midiLastWrite = AbridgedFileInfo.NormalizedLastWrite(midiInfo);
                entry.SetSortStrings();
                return entry;
            }
            catch (Exception e)
            {
                YargLogger.LogException(e);
                return new ScanUnexpected(ScanResult.DTAError);
            }
        }

        public static UnpackedRBCONEntry? TryDeserialize(in AbridgedFileInfo root, string nodeName, ref FixedArrayStream stream, CacheReadStrings strings)
        {
            string subname = stream.ReadString();
            string midiPath = Path.Combine(root.FullName, subname, subname + ".mid");
            var midiInfo = new FileInfo(midiPath);
            if (!midiInfo.Exists)
            {
                return null;
            }

            var midiLastWrite = DateTime.FromBinary(stream.Read<long>(Endianness.Little));
            if (midiLastWrite != midiInfo.LastWriteTime)
            {
                return null;
            }

            var entry = new UnpackedRBCONEntry(in root, nodeName)
            {
                _subName = subname,
                _midiLastWrite = midiLastWrite,
            };
            entry.Deserialize(ref stream, strings);
            return entry;
        }

        public static UnpackedRBCONEntry ForceDeserialize(in AbridgedFileInfo root, string nodeName, ref FixedArrayStream stream, CacheReadStrings strings)
        {
            var entry = new UnpackedRBCONEntry(in root, nodeName)
            {
                _subName = stream.ReadString(),
                _midiLastWrite = DateTime.FromBinary(stream.Read<long>(Endianness.Little)),
            };
            entry.Deserialize(ref stream, strings);
            return entry;
        }
    }
}
</file>

<file path="Song/Entries/Types/HashWrapper.cs">
using System;
using System.Globalization;
using System.IO;
using System.Security.Cryptography;
using YARG.Core.IO;
using YARG.Core.Logging;

namespace YARG.Core.Song
{
    [Serializable]
    public unsafe struct HashWrapper : IComparable<HashWrapper>, IEquatable<HashWrapper>
    {
        public static HashAlgorithm Algorithm => SHA1.Create();

        public const int HASH_SIZE_IN_BYTES = 20;
        public const int HASH_SIZE_IN_INTS = HASH_SIZE_IN_BYTES / sizeof(int);

        private fixed int _hash[HASH_SIZE_IN_INTS];

        public readonly byte[] HashBytes
        {
            get
            {
                var bytes = new byte[HASH_SIZE_IN_BYTES];
                fixed (byte* ptr = bytes)
                {
                    int* integers = (int*)ptr;
                    for (var i = 0; i < HASH_SIZE_IN_INTS; i++)
                    {
                        integers[i] = _hash[i];
                    }
                }
                return bytes;
            }
        }

        public static HashWrapper Deserialize(Stream stream)
        {
            var wrapper = new HashWrapper();
            var span = new Span<byte>(wrapper._hash, HASH_SIZE_IN_BYTES);
            if (stream.Read(span) != HASH_SIZE_IN_BYTES)
            {
                throw new EndOfStreamException();
            }
            return wrapper;
        }

        public static HashWrapper Deserialize(ref FixedArrayStream stream)
        {
            var wrapper = new HashWrapper();
            stream.Read(wrapper._hash, HASH_SIZE_IN_BYTES);
            return wrapper;
        }

        public static HashWrapper Hash(ReadOnlySpan<byte> span)
        {
            var wrapper = new HashWrapper();
            var hashSpan = new Span<byte>(wrapper._hash, HASH_SIZE_IN_BYTES);

            using var algo = Algorithm;
            if (!algo.TryComputeHash(span, hashSpan, out int written))
            {
                throw new Exception("fucking how??? Hash generation error");
            }
            return wrapper;
        }

        public static HashWrapper Create(ReadOnlySpan<byte> hash)
        {
            var wrapper = new HashWrapper();
            var span = new Span<byte>(wrapper._hash, HASH_SIZE_IN_BYTES);
            hash.CopyTo(span);
            return wrapper;
        }

        public static HashWrapper FromString(ReadOnlySpan<char> str)
        {
            var wrapper = new HashWrapper();
            try
            {
                var bytes = new Span<byte>(wrapper._hash, HASH_SIZE_IN_BYTES);
                for (int i = 0; i < HASH_SIZE_IN_BYTES; i++)
                {
                    // Each set of 2 characters represents 1 byte
                    var slice = str.Slice(i *  2, 2);
                    bytes[i]= byte.Parse(slice, NumberStyles.AllowHexSpecifier);
                }
            }
            catch (Exception e)
            {
                YargLogger.LogException(e, "Failed to read hash");
            }
            return wrapper;
        }

        public readonly void Serialize(BinaryWriter writer)
        {
            fixed (int* values = _hash)
            {
                var bytes = new Span<byte>(values, HASH_SIZE_IN_BYTES);
                writer.Write(bytes);
            }
        }

        public readonly void Serialize(Stream stream)
        {
            fixed (int* values = _hash)
            {
                var bytes = new Span<byte>(values, HASH_SIZE_IN_BYTES);
                stream.Write(bytes);
            }
        }

        public readonly int CompareTo(HashWrapper other)
        {
            for (int i = 0; i < HASH_SIZE_IN_INTS; ++i)
            {
                if (_hash[i] != other._hash[i])
                {
                    return _hash[i] - other._hash[i];
                }
            }
            return 0;
        }

        public readonly bool Equals(HashWrapper other)
        {
            for (int i = 0; i < HASH_SIZE_IN_INTS; ++i)
            {
                if (_hash[i] != other._hash[i])
                {
                    return false;
                }
            }
            return true;
        }

        public readonly override int GetHashCode()
        {
            int hashcode = 0;
            for (int i = 0; i < HASH_SIZE_IN_INTS; ++i)
            {
                hashcode ^= _hash[i];
            }
            return hashcode;
        }

        public readonly override string ToString()
        {
            string str = string.Empty;
            fixed (int* values = _hash)
            {
                var bytes = new Span<byte>(values, HASH_SIZE_IN_BYTES);
                for (int i = 0; i < HASH_SIZE_IN_BYTES; i++)
                {
                    str += bytes[i].ToString("X2");
                }
            }
            return str;
        }
    }
}
</file>

<file path="Song/Entries/Types/ScanExpected.cs">
using System;

namespace YARG.Core.Song
{
    internal enum ScanResult
    {
        Success,
        DirectoryError,
        DuplicateFilesFound,
        IniEntryCorruption,
        NoName,
        NoNotes,
        DTAError,
        MoggError,
        MoggError_Update,
        UnsupportedEncryption,
        MissingCONMidi,
        PossibleCorruption,
        FailedSngLoad,

        InvalidResolution,
        InvalidResolution_Update,
        InvalidResolution_Upgrade,

        NoAudio,
        PathTooLong,
        MultipleMidiTrackNames,
        MultipleMidiTrackNames_Update,
        MultipleMidiTrackNames_Upgrade,

        LooseChart_Warning,
    }

    internal struct ScanUnexpected
    {
        private ScanResult _error;
        public readonly ScanResult Error => _error;

        public ScanUnexpected(ScanResult error)
        {
            _error = error;
        }
    }

    internal struct ScanExpected<T>
    {
        private ScanResult _result;
        private T _value;

        public readonly bool HasValue => _result == ScanResult.Success;

        public readonly T Value
        {
            get
            {
                if (_result == ScanResult.Success)
                {
                    return _value;
                }
                throw new InvalidOperationException();
            }
        }

        public readonly ScanResult Error => _result;

        public ScanExpected(in T value)
        {
            _value = value;
            _result = ScanResult.Success;
        }

        public ScanExpected(in ScanUnexpected unexpected)
        {
            _result = unexpected.Error;
            _value = default!;
        }

        public static implicit operator bool(in ScanExpected<T> expected) => expected.HasValue;
        public static implicit operator ScanExpected<T>(in T value) => new(in value);
        public static implicit operator ScanExpected<T>(in ScanUnexpected unexpected) => new(in unexpected);
    }
}
</file>

<file path="Song/Entries/Types/SongMetadata.cs">
using YARG.Core.IO.Ini;

namespace YARG.Core.Song
{
    public enum SongRating : uint
    {
        Unspecified,
        Family_Friendly,
        Supervision_Recommended,
        Mature,
        No_Rating
    };

    public struct SongMetadata
    {
        public const double MILLISECOND_FACTOR = 1000.0;
        public const string DEFAULT_NAME = "Unknown Name";
        public const string DEFAULT_ARTIST = "Unknown Artist";
        public const string DEFAULT_ALBUM = "Unknown Album";
        public const string DEFAULT_GENRE = "Unknown Genre";
        public const string DEFAULT_CHARTER = "Unknown Charter";
        public const string DEFAULT_SOURCE = "Unknown Source";
        public const string DEFAULT_YEAR = "####";

        public static readonly SongMetadata Default = new()
        {
            Name = DEFAULT_NAME,
            Artist = DEFAULT_ARTIST,
            Album = DEFAULT_ALBUM,
            Genre = DEFAULT_GENRE,
            Charter = DEFAULT_CHARTER,
            Source = DEFAULT_SOURCE,
            Year = DEFAULT_YEAR,
            Playlist = string.Empty,
            IsMaster = true,
            VideoLoop = false,
            AlbumTrack = int.MaxValue,
            PlaylistTrack = int.MaxValue,
            LoadingPhrase = string.Empty,
            LinkBandcamp = string.Empty,
            LinkBluesky = string.Empty,
            LinkFacebook = string.Empty,
            LinkInstagram = string.Empty,
            LinkSpotify = string.Empty,
            LinkTwitter = string.Empty,
            LinkOther = string.Empty,
            LinkYoutube = string.Empty,
            Location = string.Empty,
            CreditAlbumArtDesignedBy = string.Empty,
            CreditArrangedBy = string.Empty,
            CreditComposedBy = string.Empty,
            CreditCourtesyOf = string.Empty,
            CreditEngineeredBy = string.Empty,
            CreditLicense = string.Empty,
            CreditMasteredBy = string.Empty,
            CreditMixedBy = string.Empty,
            CreditOther = string.Empty,
            CreditPerformedBy = string.Empty,
            CreditProducedBy = string.Empty,
            CreditPublishedBy = string.Empty,
            CreditWrittenBy = string.Empty,
            CharterBass = string.Empty,
            CharterDrums = string.Empty,
            CharterEliteDrums = string.Empty,
            CharterGuitar = string.Empty,
            CharterKeys = string.Empty,
            CharterLowerDiff = string.Empty,
            CharterProBass = string.Empty,
            CharterProKeys = string.Empty,
            CharterProGuitar = string.Empty,
            CharterVocals = string.Empty,
            SongLength = 0,
            SongOffset = 0,
            Preview = (-1, -1),
            Video = (0, -1),
        };

        public string Name;
        public string Artist;
        public string Album;
        public string Genre;
        public string Charter;
        public string Source;
        public string Playlist;
        public string Year;

        public long SongLength;
        public long SongOffset;
        public SongRating SongRating;

        public (long Start, long End) Preview;
        public (long Start, long End) Video;

        public bool IsMaster;
        public bool VideoLoop;

        public int AlbumTrack;
        public int PlaylistTrack;

        public string LoadingPhrase;

        public string LinkBandcamp;
        public string LinkBluesky;
        public string LinkFacebook;
        public string LinkInstagram;
        public string LinkSpotify;
        public string LinkTwitter;
        public string LinkOther;
        public string LinkYoutube;

        public string Location;

        public string CreditAlbumArtDesignedBy;
        public string CreditArrangedBy;
        public string CreditComposedBy;
        public string CreditCourtesyOf;
        public string CreditEngineeredBy;
        public string CreditLicense;
        public string CreditMasteredBy;
        public string CreditMixedBy;
        public string CreditOther;
        public string CreditPerformedBy;
        public string CreditProducedBy;
        public string CreditPublishedBy;
        public string CreditWrittenBy;

        public string CharterBass;
        public string CharterDrums;
        public string CharterEliteDrums;
        public string CharterGuitar;
        public string CharterKeys;
        public string CharterLowerDiff;
        public string CharterProBass;
        public string CharterProKeys;
        public string CharterProGuitar;
        public string CharterVocals;

        public static SongMetadata CreateFromIni(IniModifierCollection modifiers)
        {
            var metadata = Default;
            FillFromIni(ref metadata, modifiers);
            return metadata;
        }

        public static void FillFromIni(ref SongMetadata metadata, IniModifierCollection modifiers)
        {
            if (modifiers.Extract("name", out string name) && name.Length > 0)
            {
                metadata.Name = name;
            }

            if (modifiers.Extract("artist", out string artist) && artist.Length > 0)
            {
                metadata.Artist = artist;
            }

            if (modifiers.Extract("album", out string album) && album.Length > 0)
            {
                metadata.Album = album;
            }

            if (modifiers.Extract("genre", out string genre) && genre.Length > 0)
            {
                metadata.Genre = genre;
            }

            if (modifiers.Extract("year", out string year) && year.Length > 0)
            {
                metadata.Year = year;
            }
            else if (modifiers.Extract("year_chart", out year) && year.Length > 0)
            {
                if (year.StartsWith(", "))
                {
                    metadata.Year = year[2..];
                }
                else if (year.StartsWith(','))
                {
                    metadata.Year = year[1..];
                }
                else
                {
                    metadata.Year = year;
                }
            }

            if (modifiers.Extract("charter", out string charter) || modifiers.Extract("frets", out charter))
            {
                if (charter.Length > 0)
                {
                    metadata.Charter = charter;
                }
            }

            if (modifiers.Extract("icon", out string source) && source.Length > 0)
            {
                metadata.Source = source;
            }

            if (modifiers.Extract("playlist", out string playlist) && playlist.Length > 0)
            {
                metadata.Playlist = playlist;
            }

            if (modifiers.Extract("loading_phrase", out string loadingPhrase))
            {
                metadata.LoadingPhrase = loadingPhrase;
            }

            if (modifiers.Extract("link_bluesky", out string linkBluesky))
            {
                metadata.LinkBluesky = linkBluesky;
            }

            if (modifiers.Extract("link_facebook", out string linkFacebook))
            {
                metadata.LinkFacebook = linkFacebook;
            }

            if (modifiers.Extract("link_instagram", out string linkInstagram))
            {
                metadata.LinkInstagram = linkInstagram;
            }

            if (modifiers.Extract("link_spotify", out string linkSpotify))
            {
                metadata.LinkSpotify = linkSpotify;
            }

            if (modifiers.Extract("link_twitter", out string linkTwitter))
            {
                metadata.LinkTwitter = linkTwitter;
            }

            if (modifiers.Extract("link_other", out string linkOther))
            {
                metadata.LinkOther = linkOther;
            }

            if (modifiers.Extract("link_youtube", out string linkYoutube))
            {
                metadata.LinkYoutube = linkYoutube;
            }

            if (modifiers.Extract("location", out string location))
            {
                metadata.Location = location;
            }

            if (modifiers.Extract("credit_album_art_designed_by", out string creditAlbumArt))
            {
                metadata.CreditAlbumArtDesignedBy = creditAlbumArt;
            }

            if (modifiers.Extract("credit_arranged_by", out string creditArrangedBy))
            {
                metadata.CreditArrangedBy = creditArrangedBy;
            }

            if (modifiers.Extract("credit_composed_by", out string creditComposedBy))
            {
                metadata.CreditComposedBy = creditComposedBy;
            }

            if (modifiers.Extract("credit_courtesy_of", out string creditCourtesyOf))
            {
                metadata.CreditCourtesyOf = creditCourtesyOf;
            }

            if (modifiers.Extract("credit_engineered_by", out string creditEngineeredBy))
            {
                metadata.CreditEngineeredBy = creditEngineeredBy;
            }

            if (modifiers.Extract("credit_license", out string creditLicense))
            {
                metadata.CreditLicense = creditLicense;
            }

            if (modifiers.Extract("credit_mastered_by", out string creditMasteredBy))
            {
                metadata.CreditMasteredBy = creditMasteredBy;
            }

            if (modifiers.Extract("credit_mixed_by", out string creditMixedBy))
            {
                metadata.CreditMixedBy = creditMixedBy;
            }

            if (modifiers.Extract("credit_other", out string creditOther))
            {
                metadata.CreditOther = creditOther;
            }

            if (modifiers.Extract("credit_performed_by", out string creditPerformedBy))
            {
                metadata.CreditPerformedBy = creditPerformedBy;
            }

            if (modifiers.Extract("credit_produced_by", out string creditProducedBy))
            {
                metadata.CreditProducedBy = creditProducedBy;
            }

            if (modifiers.Extract("credit_published_by", out string creditPublishedBy))
            {
                metadata.CreditPublishedBy = creditPublishedBy;
            }

            if (modifiers.Extract("credit_written_by", out string creditWrittenBy))
            {
                metadata.CreditWrittenBy = creditWrittenBy;
            }

            if (modifiers.Extract("charter_bass", out string charterBass))
            {
                metadata.CharterBass = charterBass;
            }

            if (modifiers.Extract("charter_drums", out string charterDrums))
            {
                metadata.CharterDrums = charterDrums;
            }

            if (modifiers.Extract("charter_elite_drums", out string charterEliteDrums))
            {
                metadata.CharterEliteDrums = charterEliteDrums;
            }

            if (modifiers.Extract("charter_guitar", out string charterGuitar))
            {
                metadata.CharterGuitar = charterGuitar;
            }

            if (modifiers.Extract("charter_keys", out string charterKeys))
            {
                metadata.CharterKeys = charterKeys;
            }

            if (modifiers.Extract("charter_lower_diff", out string charterLowerDiff))
            {
                metadata.CharterLowerDiff = charterLowerDiff;
            }

            if (modifiers.Extract("charter_pro_bass", out string charterProBass))
            {
                metadata.CharterProBass = charterProBass;
            }

            if (modifiers.Extract("charter_pro_keys", out string charterProKeys))
            {
                metadata.CharterProKeys = charterProKeys;
            }

            if (modifiers.Extract("charter_pro_guitar", out string charterProGuitar))
            {
                metadata.CharterProGuitar = charterProGuitar;
            }

            if (modifiers.Extract("charter_vocals", out string charterVocals))
            {
                metadata.CharterVocals = charterVocals;
            }

            if (modifiers.Extract("playlist_track", out int playlistTrack))
            {
                metadata.PlaylistTrack = playlistTrack;
            }
            else
            {
                metadata.PlaylistTrack = int.MaxValue;
            }

            if (modifiers.Extract("album_track", out int albumTrack))
            {
                metadata.AlbumTrack = albumTrack;
            }
            else
            {
                metadata.AlbumTrack = int.MaxValue;
            }

            if (modifiers.Extract("rating", out uint songRating))
            {
                metadata.SongRating = (SongRating)songRating;
            }

            if (modifiers.Extract("song_length", out long songLength))
            {
                metadata.SongLength = songLength;
            }

            if (modifiers.Extract("video_start_time", out long videoStartTime))
            {
                metadata.Video.Start = videoStartTime;
            }

            if (modifiers.Extract("video_end_time", out long videoEndTime))
            {
                metadata.Video.End = videoEndTime;
            }

            if (modifiers.Extract("preview", out (long Start, long End) preview))
            {
                metadata.Preview = preview;
            }
            else
            {
                if (modifiers.Extract("preview_start_time", out preview.Start))
                {
                    metadata.Preview.Start = preview.Start;
                }
                else if (modifiers.Extract("preview_start_seconds", out double previewStartSeconds))
                {
                    metadata.Preview.Start = (long)((previewStartSeconds) * MILLISECOND_FACTOR);
                }

                if (modifiers.Extract("preview_end_time", out preview.End))
                {
                    metadata.Preview.End = preview.Item2;
                }
                else if (modifiers.Extract("preview_end_seconds", out double previewEndSeconds))
                {
                    metadata.Preview.End = (long) ((previewEndSeconds) * MILLISECOND_FACTOR);
                }
            }

            if (modifiers.Extract("delay", out long songOffset) && songOffset != 0)
            {
                metadata.SongOffset = songOffset;
            }
            else if (modifiers.Extract("delay_seconds", out double songOffsetSeconds))
            {
                metadata.SongOffset = (long)((songOffsetSeconds) * MILLISECOND_FACTOR);
            }

            if (modifiers.Extract("tags", out string tags))
            {
                metadata.IsMaster = tags.ToLower() != "cover";
            }

            if (modifiers.Extract("video_loop", out bool videoLoop))
            {
                metadata.VideoLoop = videoLoop;
            }

            if (modifiers.Extract("link_bandcamp", out string linkBandcamp))
            {
                metadata.LinkBandcamp = linkBandcamp;
            }
        }
    }
}
</file>

<file path="Song/Entries/Types/SortString.cs">
using System;
using YARG.Core.Utility;

namespace YARG.Core.Song
{
    public readonly struct SortString : IComparable<SortString>
    {
        public static readonly SortString Empty = new(string.Empty);

        private readonly string _original;
        private readonly string _searchStr;
        private readonly string _sortStr;
        private readonly CharacterGroup _group;
        private readonly int _hashcode;

        public string Original => _original;
        public string SearchStr => _searchStr;
        public string SortStr => _sortStr;
        public CharacterGroup Group => _group;
        public int Length => Original.Length;
        public char this[int index] => Original[index];

        public SortString(string str)
        {
            _original = str;
            _searchStr = StringTransformations.RemoveUnwantedWhitespace(StringTransformations.RemoveDiacritics(RichTextUtils.StripRichTextTags(str)));
            _sortStr = StringTransformations.RemoveArticle(_searchStr);
            _group = StringTransformations.GetCharacterGrouping(_sortStr);
            _hashcode = _sortStr.GetHashCode();
        }

        public override int GetHashCode()
        {
            return _hashcode;
        }

        public override string ToString()
        {
            return _original;
        }

        public int CompareTo(SortString other)
        {
            if (_group != other._group)
            {
                return _group - other._group;
            }
            return string.CompareOrdinal(_sortStr, other._sortStr);
        }

        public static implicit operator string(in SortString str) => str.Original;
    }
}
</file>

<file path="Song/Entries/SongEntry.cs">
using System;
using System.IO;
using YARG.Core.Chart;
using YARG.Core.Extensions;
using YARG.Core.IO;
using YARG.Core.Song.Cache;
using YARG.Core.Utility;

namespace YARG.Core.Song
{
    /// <summary>
    /// The type of chart file to read.
    /// </summary>
    public enum ChartFormat
    {
        Mid,
        Midi,
        Chart,
    };

    public enum EntryType
    {
        Ini,
        Sng,
        ExCON,
        CON,
    }

    public struct LoaderSettings
    {
        public static readonly LoaderSettings Default = new()
        {
            HopoThreshold = -1,
            SustainCutoffThreshold = -1,
            OverdiveMidiNote = 116
        };

        public long HopoThreshold;
        public long SustainCutoffThreshold;
        public int OverdiveMidiNote;
    }

    /// <summary>
    /// The metadata for a song.
    /// </summary>
    /// <remarks>
    /// This class is intended to hold all metadata for all songs, whether it be displayed in the song list or used for
    /// parsing/loading of the song.
    /// <br/>
    /// Display/common metadata should be added directly to this class. Metadata only used in a specific file type
    /// should not be handled through inheritance, make a separate class for that data instead and add it as a field to
    /// this one.
    /// <br/>
    /// Instances of this class should not be created directly (except for things like a chart editor), instead they
    /// should be created through static methods which parse in a metadata file of a specific type and return an
    /// instance.
    /// </remarks>
    [Serializable]
    public abstract partial class SongEntry
    {
        protected static readonly string[] BACKGROUND_FILENAMES =
        {
            "bg", "background", "video"
        };

        protected static readonly string[] VIDEO_EXTENSIONS =
        {
            ".mp4", ".mov", ".webm",
        };

        protected static readonly string[] IMAGE_EXTENSIONS =
        {
            ".png", ".jpg", ".jpeg", ".tga", ".bmp", ".psd", ".gif", ".pic"
        };

        protected const string YARGROUND_EXTENSION = ".yarground";
        protected const string YARGROUND_FULLNAME = "bg.yarground";
        protected static readonly Random BACKROUND_RNG = new();

        private SortString _name = SortString.Empty;
        private SortString _artist = SortString.Empty;
        private SortString _album = SortString.Empty;
        private SortString _genre = SortString.Empty;
        private SortString _charter = SortString.Empty;
        private SortString _source = SortString.Empty;
        private SortString _playlist = SortString.Empty;
        private bool _isDuplicate = false;

        protected SongMetadata _metadata = SongMetadata.Default;
        protected AvailableParts _parts = AvailableParts.Default;
        protected HashWrapper _hash = default;
        protected LoaderSettings _settings = LoaderSettings.Default;
        protected string _parsedYear = string.Empty;
        protected int _yearAsNumber = int.MaxValue;

        public abstract EntryType SubType { get; }
        public abstract string SortBasedLocation { get; }
        public abstract string ActualLocation { get; }

        public HashWrapper Hash => _hash;
        public SortString Name => _name;
        public SortString Artist => _artist;
        public SortString Album => _album;
        public SortString Genre => _genre;
        public SortString Charter => _charter;
        public SortString Source => _source;
        public SortString Playlist => _playlist;

        public string UnmodifiedYear => _metadata.Year;
        public string ParsedYear => _parsedYear;
        public int YearAsNumber => _yearAsNumber;

        public bool IsMaster => _metadata.IsMaster;
        public bool VideoLoop => _metadata.VideoLoop;

        public int AlbumTrack => _metadata.AlbumTrack;

        public int PlaylistTrack => _metadata.PlaylistTrack;

        public SongRating SongRating => _metadata.SongRating;

        public string LoadingPhrase => _metadata.LoadingPhrase;

        public string LinkBandcamp  => _metadata.LinkBandcamp;
        public string LinkBluesky   => _metadata.LinkBluesky;
        public string LinkFacebook  => _metadata.LinkFacebook;
        public string LinkInstagram => _metadata.LinkInstagram;
        public string LinkSpotify   => _metadata.LinkSpotify;
        public string LinkTwitter   => _metadata.LinkTwitter;
        public string LinkOther     => _metadata.LinkOther;
        public string LinkYoutube   => _metadata.LinkYoutube;

        public string Location      => _metadata.Location;

        public string CreditAlbumArtDesignedBy   => _metadata.CreditAlbumArtDesignedBy;
        public string CreditArrangedBy           => _metadata.CreditArrangedBy;
        public string CreditComposedBy           => _metadata.CreditComposedBy;
        public string CreditCourtesyOf           => _metadata.CreditCourtesyOf;
        public string CreditEngineeredBy         => _metadata.CreditEngineeredBy;
        public string CreditLicense              => _metadata.CreditLicense;
        public string CreditMasteredBy           => _metadata.CreditMasteredBy;
        public string CreditMixedBy              => _metadata.CreditMixedBy;
        public string CreditOther                => _metadata.CreditOther;
        public string CreditPerformedBy          => _metadata.CreditPerformedBy;
        public string CreditProducedBy           => _metadata.CreditProducedBy;
        public string CreditPublishedBy          => _metadata.CreditPublishedBy;
        public string CreditWrittenBy            => _metadata.CreditWrittenBy;

        public string CharterBass       => _metadata.CharterBass;
        public string CharterDrums      => _metadata.CharterDrums;
        public string CharterEliteDrums => _metadata.CharterEliteDrums;
        public string CharterGuitar     => _metadata.CharterGuitar;
        public string CharterKeys       => _metadata.CharterKeys;
        public string CharterLowerDiff  => _metadata.CharterLowerDiff;
        public string CharterProBass    => _metadata.CharterProBass;
        public string CharterProKeys    => _metadata.CharterProKeys;
        public string CharterProGuitar  => _metadata.CharterProGuitar;
        public string CharterVocals     => _metadata.CharterVocals;

        public long SongLengthMilliseconds => _metadata.SongLength;

        public long SongOffsetMilliseconds => _metadata.SongOffset;

        public long PreviewStartMilliseconds => _metadata.Preview.Start;

        public long PreviewEndMilliseconds => _metadata.Preview.End;

        public long VideoStartTimeMilliseconds => _metadata.Video.Start;

        public long VideoEndTimeMilliseconds => _metadata.Video.End;

        public double SongLengthSeconds => SongLengthMilliseconds / SongMetadata.MILLISECOND_FACTOR;

        public double SongOffsetSeconds => SongOffsetMilliseconds / SongMetadata.MILLISECOND_FACTOR;

        public double PreviewStartSeconds => PreviewStartMilliseconds / SongMetadata.MILLISECOND_FACTOR;

        public double PreviewEndSeconds => PreviewEndMilliseconds / SongMetadata.MILLISECOND_FACTOR;

        public double VideoStartTimeSeconds => VideoStartTimeMilliseconds / SongMetadata.MILLISECOND_FACTOR;

        public double VideoEndTimeSeconds => VideoEndTimeMilliseconds >= 0 ? VideoEndTimeMilliseconds / SongMetadata.MILLISECOND_FACTOR : -1;

        public int VocalsCount
        {
            get
            {
                if (_parts.HarmonyVocals[2])
                {
                    return 3;
                }

                if (_parts.HarmonyVocals[1])
                {
                    return 2;
                }
                return _parts.HarmonyVocals[0] || _parts.LeadVocals[0] ? 1 : 0;
            }
        }

        public sbyte BandDifficulty => _parts.BandDifficulty.Intensity;

        public bool IsDuplicate => _isDuplicate;

        public abstract DateTime GetLastWriteTime();

        public override string ToString() { return Artist + " | " + Name; }

        public PartValues this[Instrument instrument]
        {
            get
            {
                return instrument switch
                {
                    Instrument.FiveFretGuitar => _parts.FiveFretGuitar,
                    Instrument.FiveFretBass => _parts.FiveFretBass,
                    Instrument.FiveFretRhythm => _parts.FiveFretRhythm,
                    Instrument.FiveFretCoopGuitar => _parts.FiveFretCoopGuitar,
                    Instrument.Keys => _parts.Keys,

                    Instrument.SixFretGuitar => _parts.SixFretGuitar,
                    Instrument.SixFretBass => _parts.SixFretBass,
                    Instrument.SixFretRhythm => _parts.SixFretRhythm,
                    Instrument.SixFretCoopGuitar => _parts.SixFretCoopGuitar,

                    Instrument.FourLaneDrums => _parts.FourLaneDrums,
                    Instrument.FiveLaneDrums => _parts.FiveLaneDrums,
                    Instrument.ProDrums => _parts.ProDrums,

                    Instrument.EliteDrums => _parts.EliteDrums,

                    Instrument.ProGuitar_17Fret => _parts.ProGuitar_17Fret,
                    Instrument.ProGuitar_22Fret => _parts.ProGuitar_22Fret,
                    Instrument.ProBass_17Fret => _parts.ProBass_17Fret,
                    Instrument.ProBass_22Fret => _parts.ProBass_22Fret,

                    Instrument.ProKeys => _parts.ProKeys,

                    // Instrument.Dj => DJ,

                    Instrument.Vocals => _parts.LeadVocals,
                    Instrument.Harmony => _parts.HarmonyVocals,
                    Instrument.Band => _parts.BandDifficulty,

                    _ => throw new NotImplementedException($"Unhandled instrument {instrument}!")
                };
            }
        }

        public bool HasInstrument(Instrument instrument)
        {
            return instrument switch
            {
                Instrument.FiveFretGuitar => _parts.FiveFretGuitar.IsActive(),
                Instrument.FiveFretBass => _parts.FiveFretBass.IsActive(),
                Instrument.FiveFretRhythm => _parts.FiveFretRhythm.IsActive(),
                Instrument.FiveFretCoopGuitar => _parts.FiveFretCoopGuitar.IsActive(),
                Instrument.Keys => _parts.Keys.IsActive(),

                Instrument.SixFretGuitar => _parts.SixFretGuitar.IsActive(),
                Instrument.SixFretBass => _parts.SixFretBass.IsActive(),
                Instrument.SixFretRhythm => _parts.SixFretRhythm.IsActive(),
                Instrument.SixFretCoopGuitar => _parts.SixFretCoopGuitar.IsActive(),

                Instrument.FourLaneDrums => _parts.FourLaneDrums.IsActive(),
                Instrument.FiveLaneDrums => _parts.FiveLaneDrums.IsActive(),
                Instrument.ProDrums => _parts.ProDrums.IsActive(),

                Instrument.EliteDrums => _parts.EliteDrums.IsActive(),

                Instrument.ProGuitar_17Fret => _parts.ProGuitar_17Fret.IsActive(),
                Instrument.ProGuitar_22Fret => _parts.ProGuitar_22Fret.IsActive(),
                Instrument.ProBass_17Fret => _parts.ProBass_17Fret.IsActive(),
                Instrument.ProBass_22Fret => _parts.ProBass_22Fret.IsActive(),

                Instrument.ProKeys => _parts.ProKeys.IsActive(),

                Instrument.Vocals => _parts.LeadVocals.IsActive(),
                Instrument.Harmony => _parts.HarmonyVocals.IsActive(),
                Instrument.Band => _parts.BandDifficulty.IsActive(),

                _ => false
            };
        }

        internal void MarkAsDuplicate() { _isDuplicate = true; }

        internal virtual void Serialize(MemoryStream stream, CacheWriteIndices node)
        {
            _hash.Serialize(stream);
            unsafe
            {
                var parts = _parts;
                stream.Write(new Span<byte>(&parts, sizeof(AvailableParts)));
            }

            stream.Write(node.Title, Endianness.Little);
            stream.Write(node.Artist, Endianness.Little);
            stream.Write(node.Album, Endianness.Little);
            stream.Write(node.Genre, Endianness.Little);
            stream.Write(node.Year, Endianness.Little);
            stream.Write(node.Charter, Endianness.Little);
            stream.Write(node.Playlist, Endianness.Little);
            stream.Write(node.Source, Endianness.Little);

            stream.Write(_metadata.IsMaster);
            stream.Write(_metadata.VideoLoop);

            stream.Write(_metadata.AlbumTrack, Endianness.Little);
            stream.Write(_metadata.PlaylistTrack, Endianness.Little);

            stream.Write(_metadata.SongLength, Endianness.Little);
            stream.Write(_metadata.SongOffset, Endianness.Little);
            stream.Write((int)_metadata.SongRating, Endianness.Little);

            stream.Write(_metadata.Preview.Start, Endianness.Little);
            stream.Write(_metadata.Preview.End, Endianness.Little);

            stream.Write(_metadata.Video.Start, Endianness.Little);
            stream.Write(_metadata.Video.End, Endianness.Little);

            stream.Write(_metadata.LoadingPhrase);

            stream.Write(_metadata.LinkBandcamp);
            stream.Write(_metadata.LinkBluesky);
            stream.Write(_metadata.LinkFacebook);
            stream.Write(_metadata.LinkInstagram);
            stream.Write(_metadata.LinkSpotify);
            stream.Write(_metadata.LinkTwitter);
            stream.Write(_metadata.LinkOther);
            stream.Write(_metadata.LinkYoutube);

            stream.Write(_metadata.Location);

            stream.Write(_metadata.CreditAlbumArtDesignedBy);
            stream.Write(_metadata.CreditArrangedBy);
            stream.Write(_metadata.CreditComposedBy);
            stream.Write(_metadata.CreditCourtesyOf);
            stream.Write(_metadata.CreditEngineeredBy);
            stream.Write(_metadata.CreditLicense);
            stream.Write(_metadata.CreditMasteredBy);
            stream.Write(_metadata.CreditMixedBy);
            stream.Write(_metadata.CreditOther);
            stream.Write(_metadata.CreditPerformedBy);
            stream.Write(_metadata.CreditProducedBy);
            stream.Write(_metadata.CreditPublishedBy);
            stream.Write(_metadata.CreditWrittenBy);

            stream.Write(_metadata.CharterBass);
            stream.Write(_metadata.CharterDrums);
            stream.Write(_metadata.CharterEliteDrums);
            stream.Write(_metadata.CharterGuitar);
            stream.Write(_metadata.CharterKeys);
            stream.Write(_metadata.CharterLowerDiff);
            stream.Write(_metadata.CharterProBass);
            stream.Write(_metadata.CharterProKeys);
            stream.Write(_metadata.CharterProGuitar);
            stream.Write(_metadata.CharterVocals);

            stream.Write(_settings.HopoThreshold, Endianness.Little);
            stream.Write(_settings.SustainCutoffThreshold, Endianness.Little);
            stream.Write(_settings.OverdiveMidiNote, Endianness.Little);
        }

        protected SongEntry() { }

        private protected void Deserialize(ref FixedArrayStream stream, CacheReadStrings strings)
        {
            _hash = HashWrapper.Deserialize(ref stream);
            unsafe
            {
                AvailableParts parts;
                stream.Read(&parts, sizeof(AvailableParts));
                _parts = parts;
            }

            _metadata.Name =     strings.Titles   [stream.Read<int>(Endianness.Little)];
            _metadata.Artist =   strings.Artists  [stream.Read<int>(Endianness.Little)];
            _metadata.Album =    strings.Albums   [stream.Read<int>(Endianness.Little)];
            _metadata.Genre =    strings.Genres   [stream.Read<int>(Endianness.Little)];
            _metadata.Year =     strings.Years    [stream.Read<int>(Endianness.Little)];
            _metadata.Charter =  strings.Charters [stream.Read<int>(Endianness.Little)];
            _metadata.Playlist = strings.Playlists[stream.Read<int>(Endianness.Little)];
            _metadata.Source =   strings.Sources  [stream.Read<int>(Endianness.Little)];

            _metadata.IsMaster =  stream.ReadBoolean();
            _metadata.VideoLoop = stream.ReadBoolean();

            _metadata.AlbumTrack =    stream.Read<int>(Endianness.Little);
            _metadata.PlaylistTrack = stream.Read<int>(Endianness.Little);

            _metadata.SongLength = stream.Read<long>(Endianness.Little);
            _metadata.SongOffset = stream.Read<long>(Endianness.Little);
            _metadata.SongRating = (SongRating)stream.Read<uint>(Endianness.Little);

            _metadata.Preview.Start = stream.Read<long>(Endianness.Little);
            _metadata.Preview.End   = stream.Read<long>(Endianness.Little);

            _metadata.Video.Start = stream.Read<long>(Endianness.Little);
            _metadata.Video.End = stream.Read<long>(Endianness.Little);

            _metadata.LoadingPhrase = stream.ReadString();

            _metadata.LinkBandcamp = stream.ReadString();
            _metadata.LinkBluesky = stream.ReadString();
            _metadata.LinkFacebook = stream.ReadString();
            _metadata.LinkInstagram = stream.ReadString();
            _metadata.LinkSpotify = stream.ReadString();
            _metadata.LinkTwitter = stream.ReadString();
            _metadata.LinkOther = stream.ReadString();
            _metadata.LinkYoutube = stream.ReadString();

            _metadata.Location = stream.ReadString();

            _metadata.CreditAlbumArtDesignedBy = stream.ReadString();
            _metadata.CreditArrangedBy = stream.ReadString();
            _metadata.CreditComposedBy = stream.ReadString();
            _metadata.CreditCourtesyOf = stream.ReadString();
            _metadata.CreditEngineeredBy = stream.ReadString();
            _metadata.CreditLicense = stream.ReadString();
            _metadata.CreditMasteredBy = stream.ReadString();
            _metadata.CreditMixedBy = stream.ReadString();
            _metadata.CreditOther = stream.ReadString();
            _metadata.CreditPerformedBy = stream.ReadString();
            _metadata.CreditProducedBy = stream.ReadString();
            _metadata.CreditPublishedBy = stream.ReadString();
            _metadata.CreditWrittenBy = stream.ReadString();

            _metadata.CharterBass = stream.ReadString();
            _metadata.CharterDrums = stream.ReadString();
            _metadata.CharterEliteDrums = stream.ReadString();
            _metadata.CharterGuitar = stream.ReadString();
            _metadata.CharterKeys = stream.ReadString();
            _metadata.CharterLowerDiff = stream.ReadString();
            _metadata.CharterProBass = stream.ReadString();
            _metadata.CharterProKeys = stream.ReadString();
            _metadata.CharterProGuitar = stream.ReadString();
            _metadata.CharterVocals = stream.ReadString();

            _settings.HopoThreshold = stream.Read<long>(Endianness.Little);
            _settings.SustainCutoffThreshold = stream.Read<long>(Endianness.Little);
            _settings.OverdiveMidiNote = stream.Read<int>(Endianness.Little);

            SetSortStrings();
        }

        protected void SetSortStrings()
        {
            _name = new SortString(_metadata.Name);
            _artist = new SortString(_metadata.Artist);
            _album = new SortString(_metadata.Album);
            _genre = new SortString(_metadata.Genre);
            _charter = new SortString(_metadata.Charter);
            _source = new SortString(_metadata.Source);
            _playlist = new SortString(_metadata.Playlist);
        }
    }
}
</file>

<file path="Song/Entries/SongEntry.Loading.cs">
using System;
using System.IO;
using YARG.Core.Audio;
using YARG.Core.Chart;
using YARG.Core.IO;
using YARG.Core.Venue;

namespace YARG.Core.Song
{
    public class BackgroundResult : IDisposable
    {
        private YARGImage      _image;
        public  BackgroundType Type   { get; }
        public  Stream?        Stream { get; }

        public YARGImage Image => _image;

        public BackgroundResult(BackgroundType type, Stream stream)
        {
            _image = YARGImage.Null;
            Type = type;
            Stream = stream;
        }

        public BackgroundResult(YARGImage image)
        {
            _image = image;
            Type = BackgroundType.Image;
            Stream = null;
        }

        public void Dispose()
        {
            _image.Dispose();
            Stream?.Dispose();
        }
    }

    public abstract partial class SongEntry
    {
        public abstract SongChart? LoadChart();
        public abstract StemMixer? LoadAudio(float speed, double volume, params SongStem[] ignoreStems);
        public abstract StemMixer? LoadPreviewAudio(float speed);
        public abstract YARGImage LoadAlbumData();
        public abstract BackgroundResult? LoadBackground();
        public abstract FixedArray<byte> LoadMiloData();
    }
}
</file>

<file path="Song/Entries/SongEntry.Scanning.cs">
using System.Text;
using YARG.Core.Chart;
using YARG.Core.IO;

namespace YARG.Core.Song
{
    public abstract partial class SongEntry
    {
        private protected static ScanExpected<long> ParseMidi(in FixedArray<byte> file, ref AvailableParts parts, ref DrumsType drumsType)
        {
            var midiFile = YARGMidiFile.Load(in file);
            if (midiFile.Resolution == 0)
            {
                return new ScanUnexpected(ScanResult.InvalidResolution);
            }

            bool harm2 = false;
            bool harm3 = false;
            while (midiFile.GetNextTrack(out var _, out var track))
            {
                if (!track.FindTrackName(out var trackname))
                {
                    return new ScanUnexpected(ScanResult.MultipleMidiTrackNames);
                }

                if (!YARGMidiTrack.TRACKNAMES.TryGetValue(trackname.GetString(Encoding.ASCII), out var type))
                {
                    continue;
                }

                switch (type)
                {
                    case MidiTrackType.Guitar_5: if (!parts.FiveFretGuitar.IsActive())     parts.FiveFretGuitar.Difficulties     = Midi_FiveFret_Preparser.Parse(track); break;
                    case MidiTrackType.Bass_5:   if (!parts.FiveFretBass.IsActive())       parts.FiveFretBass.Difficulties       = Midi_FiveFret_Preparser.Parse(track); break;
                    case MidiTrackType.Rhythm_5: if (!parts.FiveFretRhythm.IsActive())     parts.FiveFretRhythm.Difficulties     = Midi_FiveFret_Preparser.Parse(track); break;
                    case MidiTrackType.Coop_5:   if (!parts.FiveFretCoopGuitar.IsActive()) parts.FiveFretCoopGuitar.Difficulties = Midi_FiveFret_Preparser.Parse(track); break;
                    case MidiTrackType.Keys:     if (!parts.Keys.IsActive())               parts.Keys.Difficulties               = Midi_FiveFret_Preparser.Parse(track); break;

                    case MidiTrackType.Guitar_6: if (!parts.SixFretGuitar.IsActive())      parts.SixFretGuitar.Difficulties      = Midi_SixFret_Preparser.Parse(track); break;
                    case MidiTrackType.Bass_6:   if (!parts.SixFretBass.IsActive())        parts.SixFretBass.Difficulties        = Midi_SixFret_Preparser.Parse(track); break;
                    case MidiTrackType.Rhythm_6: if (!parts.SixFretRhythm.IsActive())      parts.SixFretRhythm.Difficulties      = Midi_SixFret_Preparser.Parse(track); break;
                    case MidiTrackType.Coop_6:   if (!parts.SixFretCoopGuitar.IsActive())  parts.SixFretCoopGuitar.Difficulties  = Midi_SixFret_Preparser.Parse(track); break;

                    case MidiTrackType.Drums:      if (!parts.FourLaneDrums.IsActive()) parts.FourLaneDrums.Difficulties = Midi_Drums_Preparser.Parse(track, ref drumsType); break;
                    case MidiTrackType.EliteDrums: if (!parts.EliteDrums.IsActive())    parts.EliteDrums.Difficulties    = Midi_EliteDrums_Preparser.Parse(track); break;

                    case MidiTrackType.Pro_Guitar_17: if (!parts.ProGuitar_17Fret.IsActive()) parts.ProGuitar_17Fret.Difficulties = Midi_ProGuitar_Preparser.Parse_17Fret(track); break;
                    case MidiTrackType.Pro_Guitar_22: if (!parts.ProGuitar_22Fret.IsActive()) parts.ProGuitar_22Fret.Difficulties = Midi_ProGuitar_Preparser.Parse_22Fret(track); break;
                    case MidiTrackType.Pro_Bass_17:   if (!parts.ProBass_17Fret.IsActive())   parts.ProBass_17Fret.Difficulties   = Midi_ProGuitar_Preparser.Parse_17Fret(track); break;
                    case MidiTrackType.Pro_Bass_22:   if (!parts.ProBass_22Fret.IsActive())   parts.ProBass_22Fret.Difficulties   = Midi_ProGuitar_Preparser.Parse_22Fret(track); break;

                    case MidiTrackType.Pro_Keys_E: if (!parts.ProKeys[Difficulty.Easy]   && Midi_ProKeys_Preparser.Parse(track)) parts.ProKeys.ActivateDifficulty(Difficulty.Easy); break;
                    case MidiTrackType.Pro_Keys_M: if (!parts.ProKeys[Difficulty.Medium] && Midi_ProKeys_Preparser.Parse(track)) parts.ProKeys.ActivateDifficulty(Difficulty.Medium); break;
                    case MidiTrackType.Pro_Keys_H: if (!parts.ProKeys[Difficulty.Hard]   && Midi_ProKeys_Preparser.Parse(track)) parts.ProKeys.ActivateDifficulty(Difficulty.Hard); break;
                    case MidiTrackType.Pro_Keys_X: if (!parts.ProKeys[Difficulty.Expert] && Midi_ProKeys_Preparser.Parse(track)) parts.ProKeys.ActivateDifficulty(Difficulty.Expert); break;

                    case MidiTrackType.Vocals: if (!parts.LeadVocals[0]    && Midi_Vocal_Preparser.Parse(track, true))  parts.LeadVocals.ActivateSubtrack(0); break;
                    case MidiTrackType.Harm1:  if (!parts.HarmonyVocals[0] && Midi_Vocal_Preparser.Parse(track, true))  parts.HarmonyVocals.ActivateSubtrack(0); break;
                    case MidiTrackType.Harm2:  if (!harm2) harm2 = Midi_Vocal_Preparser.Parse(track, false); break;
                    case MidiTrackType.Harm3:  if (!harm3) harm3 = Midi_Vocal_Preparser.Parse(track, false); break;
                }
            }

            // HARM 2/3 are not playable without HARM1 phrases
            if (parts.HarmonyVocals[0])
            {
                if (harm2)
                {
                    parts.HarmonyVocals.ActivateSubtrack(1);
                }
                if (harm3)
                {
                    parts.HarmonyVocals.ActivateSubtrack(2);
                }
            }
            return midiFile.Resolution;
        }

        protected static void FinalizeDrums(ref AvailableParts parts, DrumsType drumsType)
        {
            if ((drumsType & DrumsType.FourLane) != DrumsType.FourLane)
            {
                if ((drumsType & DrumsType.ProDrums) == DrumsType.ProDrums)
                {
                    parts.ProDrums.Difficulties = parts.FourLaneDrums.Difficulties;
                }
                else
                {
                    parts.FiveLaneDrums.Difficulties = parts.FourLaneDrums.Difficulties;
                    parts.FourLaneDrums.Difficulties = DifficultyMask.None;
                }
            }
        }

        protected static bool IsValid(in AvailableParts parts)
        {
            return parts.FiveFretGuitar.IsActive()
                || parts.FiveFretBass.IsActive()
                || parts.FiveFretRhythm.IsActive()
                || parts.FiveFretCoopGuitar.IsActive()
                || parts.Keys.IsActive()
                || parts.SixFretGuitar.IsActive()
                || parts.SixFretBass.IsActive()
                || parts.SixFretRhythm.IsActive()
                || parts.SixFretCoopGuitar.IsActive()
                || parts.FourLaneDrums.IsActive()
                || parts.ProDrums.IsActive()
                || parts.FiveLaneDrums.IsActive()
                || parts.EliteDrums.IsActive()
                || parts.ProGuitar_17Fret.IsActive()
                || parts.ProGuitar_22Fret.IsActive()
                || parts.ProBass_17Fret.IsActive()
                || parts.ProBass_22Fret.IsActive()
                || parts.ProKeys.IsActive()
                || parts.LeadVocals.IsActive()
                || parts.HarmonyVocals.IsActive();
        }
    }
}
</file>

<file path="Song/Entries/SongEntry.Sorting.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using YARG.Core.Extensions;
using YARG.Core.IO;
using YARG.Core.Song.Cache;
using YARG.Core.Utility;

namespace YARG.Core.Song
{
    public enum SongAttribute
    {
        Name,
        Artist,
        Album,
        Artist_Album,
        Genre,
        Year,
        Charter,
        Playlist,
        Source,
        SongLength,
        DateAdded,
    };

    public static class SongEntrySorting
    {
        public static bool CompareMetadata(SongEntry lhs, SongEntry rhs)
        {
            return MetadataComparer.Instance.Compare(lhs, rhs) < 0;
        }

        public readonly struct MetadataComparer : IComparer<SongEntry>
        {
            public static readonly MetadataComparer Instance = default;
            public readonly int Compare(SongEntry lhs, SongEntry rhs)
            {
                int strCmp;
                if ((strCmp = lhs.Name   .CompareTo(rhs.Name))    == 0 &&
                    (strCmp = lhs.Artist .CompareTo(rhs.Artist))  == 0 &&
                    (strCmp = lhs.Album  .CompareTo(rhs.Album))   == 0 &&
                    (strCmp = lhs.Charter.CompareTo(rhs.Charter)) == 0)
                {
                    strCmp = lhs.SortBasedLocation.CompareTo(rhs.SortBasedLocation);
                }
                return strCmp;
            }
        }

        private readonly struct ArtistComparer : IComparer<SongEntry>
        {
            public static readonly ArtistComparer Instance = default;
            public readonly int Compare(SongEntry lhs, SongEntry rhs)
            {
                int strCmp;
                if ((strCmp = lhs.Name.CompareTo(rhs.Name)) == 0 &&
                    (strCmp = lhs.Album.CompareTo(rhs.Album)) == 0 &&
                    (strCmp = lhs.Charter.CompareTo(rhs.Charter)) == 0)
                {
                    strCmp = lhs.SortBasedLocation.CompareTo(rhs.SortBasedLocation);
                }
                return strCmp;
            }
        }

        private readonly struct AlbumComparer : IComparer<SongEntry>
        {
            public static readonly AlbumComparer Instance = default;
            public readonly int Compare(SongEntry lhs, SongEntry rhs)
            {
                int strCmp;
                if ((strCmp = lhs.AlbumTrack.CompareTo(rhs.AlbumTrack)) == 0 &&
                    (strCmp = lhs.Name.CompareTo(rhs.Name)) == 0 &&
                    (strCmp = lhs.Album.CompareTo(rhs.Album)) == 0 &&
                    (strCmp = lhs.Charter.CompareTo(rhs.Charter)) == 0)
                {
                    strCmp = lhs.SortBasedLocation.CompareTo(rhs.SortBasedLocation);
                }
                return strCmp;
            }
        }

        private readonly struct PlaylistComparer : IComparer<SongEntry>
        {
            public static readonly PlaylistComparer Instance = default;
            public readonly int Compare(SongEntry lhs, SongEntry rhs)
            {
                if (lhs.PlaylistTrack != rhs.PlaylistTrack)
                {
                    return lhs.PlaylistTrack.CompareTo(rhs.PlaylistTrack);
                }

                if (lhs is RBCONEntry rblhs && rhs is RBCONEntry rbrhs)
                {
                    int lhsBand = rblhs.RBBandDiff;
                    int rhsBand = rbrhs.RBBandDiff;
                    if (lhsBand != rhsBand)
                    {
                        if (lhsBand == -1)
                        {
                            return 1;
                        }
                        if (rhsBand == -1)
                        {
                            return -1;
                        }
                        return lhsBand.CompareTo(rhsBand);
                    }
                }
                return MetadataComparer.Instance.Compare(lhs, rhs);
            }
        }

        private readonly struct YearComparer : IComparer<SongEntry>
        {
            public static readonly YearComparer Instance = default;
            public readonly int Compare(SongEntry lhs, SongEntry rhs)
            {
                if (lhs.YearAsNumber != rhs.YearAsNumber)
                {
                    if (lhs.YearAsNumber == int.MaxValue)
                    {
                        return 1;
                    }
                    if (rhs.YearAsNumber == int.MaxValue)
                    {
                        return -1;
                    }
                    return lhs.YearAsNumber.CompareTo(rhs.YearAsNumber);
                }
                return MetadataComparer.Instance.Compare(lhs, rhs);
            }
        }

        private readonly struct CharterComparer : IComparer<SongEntry>
        {
            public static readonly CharterComparer Instance = default;
            public readonly int Compare(SongEntry lhs, SongEntry rhs)
            {
                int strCmp;
                if ((strCmp = lhs.AlbumTrack.CompareTo(rhs.AlbumTrack)) == 0 &&
                    (strCmp = lhs.Name.CompareTo(rhs.Name)) == 0 &&
                    (strCmp = lhs.Album.CompareTo(rhs.Album)) == 0)
                {
                    strCmp = lhs.SortBasedLocation.CompareTo(rhs.SortBasedLocation);
                }
                return strCmp;
            }
        }

        private readonly struct LengthComparer : IComparer<SongEntry>
        {
            public static readonly LengthComparer Instance = default;
            public readonly int Compare(SongEntry lhs, SongEntry rhs)
            {
                if (lhs.SongLengthMilliseconds != rhs.SongLengthMilliseconds)
                {
                    return lhs.SongLengthMilliseconds.CompareTo(rhs.SongLengthMilliseconds);
                }
                return MetadataComparer.Instance.Compare(lhs, rhs);
            }
        }

        private readonly struct InstrumentComparer : IComparer<SongEntry>
        {
            private readonly Instrument _instrument;
            private readonly int _intensity;

            public InstrumentComparer(Instrument instrument, int intensity)
            {
                _instrument = instrument;
                _intensity = intensity;
            }

            public readonly int Compare(SongEntry lhs, SongEntry rhs)
            {
                var otherIntensity = rhs[_instrument].Intensity;
                if (_intensity == otherIntensity)
                {
                    return MetadataComparer.Instance.Compare(lhs, rhs);
                }
                return _intensity != -1 && (otherIntensity == -1 || _intensity < otherIntensity)
                    ? -1 : 1;
            }
        }

        private static readonly unsafe delegate*<SongCache, void>[] SORTERS =
        {
            &SortByTitle,    &SortByArtist, &SortByAlbum,       &SortByGenre,  &SortByYear,      &SortByCharter,
            &SortByPlaylist, &SortBySource, &SortByArtistAlbum, &SortByLength, &SortByDateAdded, &SortByInstruments
        };

        internal static unsafe void SortEntries(SongCache cache)
        {
            Parallel.For(0, SORTERS.Length, i => SORTERS[i](cache));
        }

        private static void SortByTitle(SongCache cache)
        {
            foreach (var list in cache.Entries)
            {
                foreach (var entry in list.Value)
                {
                    string name = entry.Name.Group switch
                    {
                        CharacterGroup.Empty or
                        CharacterGroup.AsciiSymbol => "*",
                        CharacterGroup.AsciiNumber => "0-9",
                        _ => char.ToUpper(entry.Name.SortStr[0]).ToString(),
                    };

                    if (!cache.Titles.TryGetValue(name, out var category))
                    {
                        cache.Titles.Add(name, category = new List<SongEntry>());
                    }

                    int index = category.BinarySearch(entry, MetadataComparer.Instance);
                    category.Insert(~index, entry);
                }
            }
        }

        private static void SortByArtist(SongCache cache)
        {
            foreach (var list in cache.Entries)
            {
                foreach (var entry in list.Value)
                {
                    var artist = entry.Artist;
                    if (!cache.Artists.TryGetValue(artist, out var category))
                    {
                        cache.Artists.Add(artist, category = new List<SongEntry>());
                    }

                    int index = category.BinarySearch(entry, MetadataComparer.Instance);
                    category.Insert(~index, entry);
                }
            }
        }

        private static void SortByAlbum(SongCache cache)
        {
            foreach (var list in cache.Entries)
            {
                foreach (var entry in list.Value)
                {
                    var album = entry.Album;
                    if (!cache.Albums.TryGetValue(album, out var category))
                    {
                        cache.Albums.Add(album, category = new List<SongEntry>());
                    }

                    int index = category.BinarySearch(entry, AlbumComparer.Instance);
                    category.Insert(~index, entry);
                }
            }
        }

        private static void SortByGenre(SongCache cache)
        {
            foreach (var list in cache.Entries)
            {
                foreach (var entry in list.Value)
                {
                    var genre = entry.Genre;
                    if (!cache.Genres.TryGetValue(genre, out var category))
                    {
                        cache.Genres.Add(genre, category = new List<SongEntry>());
                    }

                    int index = category.BinarySearch(entry, MetadataComparer.Instance);
                    category.Insert(~index, entry);
                }
            }
        }

        private static void SortByYear(SongCache cache)
        {
            foreach (var list in cache.Entries)
            {
                foreach (var entry in list.Value)
                {
                    string year = entry.YearAsNumber != int.MaxValue ? entry.ParsedYear[..^1] + "0s" : entry.ParsedYear;
                    if (!cache.Years.TryGetValue(year, out var category))
                    {
                        cache.Years.Add(year, category = new List<SongEntry>());
                    }

                    int index = category.BinarySearch(entry, YearComparer.Instance);
                    category.Insert(~index, entry);
                }
            }
        }

        private static void SortByCharter(SongCache cache)
        {
            foreach (var list in cache.Entries)
            {
                foreach (var entry in list.Value)
                {
                    var charter = entry.Charter;
                    if (!cache.Charters.TryGetValue(charter, out var category))
                    {
                        cache.Charters.Add(charter, category = new List<SongEntry>());
                    }

                    int index = category.BinarySearch(entry, MetadataComparer.Instance);
                    category.Insert(~index, entry);
                }
            }
        }

        private static void SortByPlaylist(SongCache cache)
        {
            foreach (var list in cache.Entries)
            {
                foreach (var entry in list.Value)
                {
                    var playlist = entry.Playlist;
                    if (!cache.Playlists.TryGetValue(playlist, out var category))
                    {
                        cache.Playlists.Add(playlist, category = new List<SongEntry>());
                    }

                    int index = category.BinarySearch(entry, PlaylistComparer.Instance);
                    category.Insert(~index, entry);
                }
            }
        }

        private static void SortBySource(SongCache cache)
        {
            foreach (var list in cache.Entries)
            {
                foreach (var entry in list.Value)
                {
                    var source = entry.Source;
                    if (!cache.Sources.TryGetValue(source, out var category))
                    {
                        cache.Sources.Add(source, category = new List<SongEntry>());
                    }

                    int index = category.BinarySearch(entry, MetadataComparer.Instance);
                    category.Insert(~index, entry);
                }
            }
        }

        private static void SortByLength(SongCache cache)
        {
            foreach (var list in cache.Entries)
            {
                foreach (var entry in list.Value)
                {
                    // constants represents upper milliseconds limit of each range
                    string range = entry.SongLengthMilliseconds switch
                    {
                        < 120000 => "00:00 - 02:00",
                        < 300000 => "02:00 - 05:00",
                        < 600000 => "05:00 - 10:00",
                        < 900000 => "10:00 - 15:00",
                        < 1200000 => "15:00 - 20:00",
                        _ => "20:00+",
                    };

                    if (!cache.SongLengths.TryGetValue(range, out var category))
                    {
                        cache.SongLengths.Add(range, category = new List<SongEntry>());
                    }

                    int index = category.BinarySearch(entry, LengthComparer.Instance);
                    category.Insert(~index, entry);
                }
            }
        }

        private static void SortByDateAdded(SongCache cache)
        {
            foreach (var list in cache.Entries)
            {
                foreach (var entry in list.Value)
                {
                    var dateAdded = entry.GetLastWriteTime().Date;
                    if (!cache.DatesAdded.TryGetValue(dateAdded, out var category))
                    {
                        cache.DatesAdded.Add(dateAdded, category = new List<SongEntry>());
                    }

                    int index = category.BinarySearch(entry, MetadataComparer.Instance);
                    category.Insert(~index, entry);
                }
            }
        }

        private static void SortByArtistAlbum(SongCache cache)
        {
            foreach (var list in cache.Entries)
            {
                foreach (var entry in list.Value)
                {
                    var artist = entry.Artist;
                    if (!cache.ArtistAlbums.TryGetValue(artist, out var albums))
                    {
                        cache.ArtistAlbums.Add(artist, albums = new SortedDictionary<SortString, List<SongEntry>>());
                    }

                    var album = entry.Album;
                    if (!albums.TryGetValue(album, out var category))
                    {
                        albums.Add(album, category = new List<SongEntry>());
                    }

                    int index = category.BinarySearch(entry, AlbumComparer.Instance);
                    category.Insert(~index, entry);
                }
            }
        }

        private static void SortByInstruments(SongCache cache)
        {
            Parallel.ForEach(EnumExtensions<Instrument>.Values, instrument =>
            {
                SortedDictionary<int, List<SongEntry>>? intensities = null;
                foreach (var list in cache.Entries)
                {
                    foreach (var entry in list.Value)
                    {
                        var part = entry[instrument];
                        if (part.IsActive())
                        {
                            if (intensities == null)
                            {
                                lock (cache.Instruments)
                                {
                                    cache.Instruments.Add(instrument, intensities = new SortedDictionary<int, List<SongEntry>>());
                                }
                            }

                            if (!intensities.TryGetValue(part.Intensity, out var category))
                            {
                                intensities.Add(part.Intensity, category = new List<SongEntry>());
                            }

                            int index = category.BinarySearch(entry, new InstrumentComparer(instrument, part.Intensity));
                            category.Insert(~index, entry);
                        }
                    }
                }
            });
        }

        private static readonly unsafe delegate*<SongCache, Dictionary<SongEntry, CacheWriteIndices>, List<string>>[] COLLECTORS =
        {
            &CollectCacheTitles, &CollectCacheArtists,  &CollectCacheAlbums,    &CollectCacheGenres,
            &CollectCacheYears,  &CollectCacheCharters, &CollectCachePlaylists, &CollectCacheSources,
        };

        internal static void WriteCategoriesToCache(FileStream filestream, SongCache cache, Dictionary<SongEntry, CacheWriteIndices> nodes)
        {
            foreach (var list in cache.Entries)
            {
                foreach (var entry in list.Value)
                {
                    nodes.Add(entry, new CacheWriteIndices());
                }
            }

            var categories = new List<string>[CacheReadStrings.NUM_CATEGORIES];
            Parallel.For(0, CacheReadStrings.NUM_CATEGORIES, i =>
            {
                unsafe
                {
                    categories[i] = COLLECTORS[i](cache, nodes);
                }
            });

            using MemoryStream ms = new();
            for (int i = 0; i < categories.Length; ++i)
            {
                var strings = categories[i];
                ms.SetLength(0);
                ms.Write(strings.Count, Endianness.Little);
                foreach (string str in strings)
                {
                    ms.Write(str);
                }

                filestream.Write((int) ms.Length, Endianness.Little);
                filestream.Write(ms.GetBuffer(), 0, (int) ms.Length);
            }
        }

        private static List<string> CollectCacheTitles(SongCache cache, Dictionary<SongEntry, CacheWriteIndices> nodes)
        {
            var strings = new List<string>();
            foreach (var element in cache.Titles)
            {
                foreach (var entry in element.Value)
                {
                    var indices = nodes[entry];
                    if (strings.Count == 0 || strings[^1] != entry.Name)
                    {
                        indices.Title = strings.Count;
                        strings.Add(entry.Name);
                    }
                    else
                    {
                        indices.Title = strings.Count - 1;
                    }
                }
            }
            return strings;
        }

        private static List<string> CollectCacheArtists(SongCache cache, Dictionary<SongEntry, CacheWriteIndices> nodes)
        {
            using var placements = FixedArray<int>.Alloc(64);

            var strings = new List<string>();
            foreach (var element in cache.Artists)
            {
                if (element.Value.Count > placements.Length)
                {
                    placements.Resize(element.Value.Count);
                }

                for (int i = 0; i < element.Value.Count; i++)
                {
                    var entry = element.Value[i];
                    var indices = nodes[entry];

                    int query = 0;
                    while (query < i && element.Value[query].Artist != entry.Artist)
                    {
                        query++;
                    }

                    if (query == i)
                    {
                        placements[i] = strings.Count;
                        strings.Add(entry.Artist);
                    }
                    else
                    {
                        placements[i] = placements[query];
                    }
                    indices.Artist = placements[i];
                }
            }
            return strings;
        }

        private static List<string> CollectCacheAlbums(SongCache cache, Dictionary<SongEntry, CacheWriteIndices> nodes)
        {
            using var placements = FixedArray<int>.Alloc(64);

            var strings = new List<string>();
            foreach (var element in cache.Albums)
            {
                if (element.Value.Count > placements.Length)
                {
                    placements.Resize(element.Value.Count);
                }

                for (int i = 0; i < element.Value.Count; i++)
                {
                    var entry = element.Value[i];
                    var indices = nodes[entry];

                    int query = 0;
                    while (query < i && element.Value[query].Album != entry.Album)
                    {
                        query++;
                    }

                    if (query == i)
                    {
                        placements[i] = strings.Count;
                        strings.Add(entry.Album);
                    }
                    else
                    {
                        placements[i] = placements[query];
                    }
                    indices.Album = placements[i];
                }
            }
            return strings;
        }

        private static List<string> CollectCacheGenres(SongCache cache, Dictionary<SongEntry, CacheWriteIndices> nodes)
        {
            using var placements = FixedArray<int>.Alloc(64);

            var strings = new List<string>();
            foreach (var element in cache.Genres)
            {
                if (element.Value.Count > placements.Length)
                {
                    placements.Resize(element.Value.Count);
                }

                for (int i = 0; i < element.Value.Count; i++)
                {
                    var entry = element.Value[i];
                    var indices = nodes[entry];

                    int query = 0;
                    while (query < i && element.Value[query].Genre != entry.Genre)
                    {
                        query++;
                    }

                    if (query == i)
                    {
                        placements[i] = strings.Count;
                        strings.Add(entry.Genre);
                    }
                    else
                    {
                        placements[i] = placements[query];
                    }
                    indices.Genre = placements[i];
                }
            }
            return strings;
        }

        private static List<string> CollectCacheYears(SongCache cache, Dictionary<SongEntry, CacheWriteIndices> nodes)
        {
            using var placements = FixedArray<int>.Alloc(64);

            var strings = new List<string>();
            foreach (var element in cache.Years)
            {
                if (element.Value.Count > placements.Length)
                {
                    placements.Resize(element.Value.Count);
                }

                for (int i = 0; i < element.Value.Count; i++)
                {
                    var entry = element.Value[i];
                    var indices = nodes[entry];

                    int query = 0;
                    while (query < i && element.Value[query].UnmodifiedYear != entry.UnmodifiedYear)
                    {
                        query++;
                    }

                    if (query == i)
                    {
                        placements[i] = strings.Count;
                        strings.Add(entry.UnmodifiedYear);
                    }
                    else
                    {
                        placements[i] = placements[query];
                    }
                    indices.Year = placements[i];
                }
            }
            return strings;
        }

        private static List<string> CollectCacheCharters(SongCache cache, Dictionary<SongEntry, CacheWriteIndices> nodes)
        {
            using var placements = FixedArray<int>.Alloc(64);

            var strings = new List<string>();
            foreach (var element in cache.Charters)
            {
                if (element.Value.Count > placements.Length)
                {
                    placements.Resize(element.Value.Count);
                }

                for (int i = 0; i < element.Value.Count; i++)
                {
                    var entry = element.Value[i];
                    var indices = nodes[entry];

                    int query = 0;
                    while (query < i && element.Value[query].Charter != entry.Charter)
                    {
                        query++;
                    }

                    if (query == i)
                    {
                        placements[i] = strings.Count;
                        strings.Add(entry.Charter);
                    }
                    else
                    {
                        placements[i] = placements[query];
                    }
                    indices.Charter = placements[i];
                }
            }
            return strings;
        }

        private static List<string> CollectCachePlaylists(SongCache cache, Dictionary<SongEntry, CacheWriteIndices> nodes)
        {
            using var placements = FixedArray<int>.Alloc(64);

            var strings = new List<string>();
            foreach (var element in cache.Playlists)
            {
                if (element.Value.Count > placements.Length)
                {
                    placements.Resize(element.Value.Count);
                }

                for (int i = 0; i < element.Value.Count; i++)
                {
                    var entry = element.Value[i];
                    var indices = nodes[entry];

                    int query = 0;
                    while (query < i && element.Value[query].Playlist != entry.Playlist)
                    {
                        query++;
                    }

                    if (query == i)
                    {
                        placements[i] = strings.Count;
                        strings.Add(entry.Playlist);
                    }
                    else
                    {
                        placements[i] = placements[query];
                    }
                    indices.Playlist = placements[i];
                }
            }
            return strings;
        }

        private static List<string> CollectCacheSources(SongCache cache, Dictionary<SongEntry, CacheWriteIndices> nodes)
        {
            using var placements = FixedArray<int>.Alloc(64);

            var strings = new List<string>();
            foreach (var element in cache.Sources)
            {
                if (element.Value.Count > placements.Length)
                {
                    placements.Resize(element.Value.Count);
                }

                for (int i = 0; i < element.Value.Count; i++)
                {
                    var entry = element.Value[i];
                    var indices = nodes[entry];

                    int query = 0;
                    while (query < i && element.Value[query].Source != entry.Source)
                    {
                        query++;
                    }

                    if (query == i)
                    {
                        placements[i] = strings.Count;
                        strings.Add(entry.Source);
                    }
                    else
                    {
                        placements[i] = placements[query];
                    }
                    indices.Source = placements[i];
                }
            }
            return strings;
        }
    }
}
</file>

<file path="Song/MidiPreparsers/MidiDrumsPreparser.cs">
using System;
using YARG.Core.Chart;
using YARG.Core.IO;

namespace YARG.Core.Song
{
    internal static class Midi_Drums_Preparser
    {
        private static readonly int[] INDICES = new int[MidiPreparser_Constants.NUM_DIFFICULTIES * MidiPreparser_Constants.NOTES_PER_DIFFICULTY]
        {
            0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
            0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
            0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
            0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
        };

        public static unsafe DifficultyMask Parse(YARGMidiTrack track, ref DrumsType drumsType)
        {
            const int MAX_NUMPADS = 7;
            const int DRUMNOTE_MAX = 101;
            const int DOUBLE_KICK_NOTE = 95;
            const int DOUBLE_KICK_MASK = 1 << (3 * MAX_NUMPADS + 1);
            const int FIVE_LANE_INDEX = 6;
            const int YELLOW_FLAG = 110;
            const int GREEN_FLAG = 112;

            var validations = DifficultyMask.None;
            int statusBitMask = 0;
            var note = default(MidiNote);
            var stats = default(YARGMidiTrack.Stats);
            while (track.ParseEvent(ref stats))
            {
                if (stats.Type != MidiEventType.Note_On && stats.Type != MidiEventType.Note_Off)
                {
                    continue;
                }

                track.ExtractMidiNote(ref note);
                // Must be checked first as it still resides in the normal note range window
                if (note.value == DOUBLE_KICK_NOTE)
                {
                    if ((validations & DifficultyMask.ExpertPlus) > 0)
                    {
                        continue;
                    }

                    // Note Ons with no velocity equates to a note Off by spec
                    if (stats.Type == MidiEventType.Note_On && note.velocity > 0)
                    {
                        statusBitMask |= DOUBLE_KICK_MASK;
                    }
                    // NoteOff here
                    else if ((statusBitMask & DOUBLE_KICK_MASK) > 0)
                    {
                        validations |= DifficultyMask.Expert | DifficultyMask.ExpertPlus;
                    }
                }
                else if (MidiPreparser_Constants.DEFAULT_NOTE_MIN <= note.value && note.value <= DRUMNOTE_MAX)
                {
                    int noteOffset = note.value - MidiPreparser_Constants.DEFAULT_NOTE_MIN;
                    int diffIndex = MidiPreparser_Constants.DIFF_INDICES[noteOffset];
                    var diffMask = (DifficultyMask) (1 << (diffIndex + 1));
                    // Necessary to account for undetermined five lane
                    // Anything greater than DrumsType.FiveLane, in bits, *contains* the DrumsType.FiveLane bit
                    if ((validations & diffMask) > DifficultyMask.None && drumsType <= DrumsType.FiveLane)
                    {
                        continue;
                    }

                    int laneIndex = INDICES[noteOffset];
                    // The double "greater than" check against FIVE_LANE_INDEX keeps the number of comparisons performed
                    // to ONE when laneIndex is less than that value.
                    //
                    // And if drumsType is less than DrumsType.FiveLane, the DrumsType.FiveLane bit is not set.
                    // Testing FIVE_LANE_INDEX would thereby produce no results.
                    if (laneIndex >= FIVE_LANE_INDEX && (laneIndex > FIVE_LANE_INDEX || drumsType < DrumsType.FiveLane))
                    {
                        continue;
                    }

                    int statusMask = 1 << (diffIndex * MAX_NUMPADS + laneIndex);
                    // Note Ons with no velocity equates to a note Off by spec
                    if (stats.Type == MidiEventType.Note_On && note.velocity > 0)
                    {
                        statusBitMask |= statusMask;
                        if (laneIndex == FIVE_LANE_INDEX)
                        {
                            drumsType = DrumsType.FiveLane;
                        }
                    }
                    // NoteOff here
                    else if ((statusBitMask & statusMask) > 0)
                    {
                        validations |= diffMask;
                    }
                }
                else if (YELLOW_FLAG <= note.value && note.value <= GREEN_FLAG && (drumsType & DrumsType.ProDrums) == DrumsType.ProDrums)
                {
                    drumsType = DrumsType.ProDrums;
                }

                if (validations == MidiPreparser_Constants.ALL_DIFFICULTIES_PLUS && (drumsType == DrumsType.FourLane || drumsType == DrumsType.ProDrums || drumsType == DrumsType.FiveLane))
                {
                    break;
                }
            }
            return validations;
        }
    }
}
</file>

<file path="Song/MidiPreparsers/MidiEliteDrumsPreparser.cs">
using YARG.Core.IO;

namespace YARG.Core.Song
{
    internal static class Midi_EliteDrums_Preparser
    {
        private const int ELITE_NOTES_PER_DIFFICULTY = 24;
        private const int NUM_LANES = 11;
        private const int ELITE_MAX = 82;

        public static unsafe DifficultyMask Parse(YARGMidiTrack track)
        {
            var validations = default(DifficultyMask);
            long statusBitMask = 0;

            var note = default(MidiNote);
            var stats = default(YARGMidiTrack.Stats);
            while (track.ParseEvent(ref stats))
            {
                if (stats.Type is MidiEventType.Note_On or MidiEventType.Note_Off)
                {
                    track.ExtractMidiNote(ref note);
                    // Minimum is 0, so no minimum check required
                    if (note.value > ELITE_MAX)
                    {
                        continue;
                    }

                    int diffIndex = MidiPreparser_Constants.EXTENDED_DIFF_INDICES[note.value];
                    int laneIndex = MidiPreparser_Constants.EXTENDED_LANE_INDICES[note.value];
                    var diffMask = (DifficultyMask)(1 << (diffIndex + 1));
                    if ((validations & diffMask) > 0 || laneIndex >= NUM_LANES)
                    {
                        continue;
                    }

                    long statusMask = 1L << (diffIndex * NUM_LANES + laneIndex);
                    // Note Ons with no velocity equates to a note Off by spec
                    if (stats.Type == MidiEventType.Note_On && note.velocity > 0)
                    {
                        statusBitMask |= statusMask;
                    }
                    // Note off here
                    else if ((statusBitMask & statusMask) > 0)
                    {
                        validations |= diffMask;
                        if (validations == MidiPreparser_Constants.ALL_DIFFICULTIES)
                        {
                            break;
                        }
                    }
                }
            }
            return validations;
        }
    }
}
</file>

<file path="Song/MidiPreparsers/MidiFiveFretPreparser.cs">
using System;
using System.Text;
using YARG.Core.IO;

namespace YARG.Core.Song
{
    /// <remarks>
    /// Note: also functions as the five lane Keys preparser
    /// </remarks>
    internal static class Midi_FiveFret_Preparser
    {
        private const int FIVEFRET_MIN = 59;
        // Open note included
        private const int NUM_LANES = 6;
        private const int SYSEX_DIFFICULTY_INDEX = 4;
        private const int SYSEX_TYPE_INDEX = 5;
        private const int SYSEX_STATUS_INDEX = 6;
        private const int OPEN_NOTE_TYPE = 1;
        private const int SYSEX_ALL_DIFFICULTIES = 0xFF;
        private const int GREEN_INDEX = 1;

        private static readonly byte[][] ENHANCED_STRINGS = new byte[][] { Encoding.ASCII.GetBytes("[ENHANCED_OPENS]"), Encoding.ASCII.GetBytes("ENHANCED_OPENS") };

        public static unsafe DifficultyMask Parse(YARGMidiTrack track)
        {
            ReadOnlySpan<byte> SYSEXTAG = stackalloc byte[] { (byte) 'P', (byte) 'S', (byte) '\0', };
            var validations = default(DifficultyMask);
            int statusBitMask = 0;

            // Zero is reserved for open notes. Open notes apply in two situations:
            // 1. The 13s will swap to zeroes when the ENHANCED_OPENS toggle occurs
            // 2. The '1'(green) in a difficulty will swap to zero and back depending on the Open note sysex state
            //
            // Note: the 13s account for the -1 offset of the minimum note value
            var indices = stackalloc int[MidiPreparser_Constants.NUM_DIFFICULTIES * MidiPreparser_Constants.NOTES_PER_DIFFICULTY]
            {
                13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
                13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
                13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
                13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
            };

            var note = default(MidiNote);
            var stats = default(YARGMidiTrack.Stats);
            while (track.ParseEvent(ref stats))
            {
                if (stats.Type is MidiEventType.Note_On or MidiEventType.Note_Off)
                {
                    track.ExtractMidiNote(ref note);
                    if (note.value < FIVEFRET_MIN || note.value > MidiPreparser_Constants.DEFAULT_MAX)
                    {
                        continue;
                    }

                    int noteOffset = note.value - FIVEFRET_MIN;
                    int diffIndex = MidiPreparser_Constants.DIFF_INDICES[noteOffset];
                    int laneIndex = indices[noteOffset];
                    var diffMask = (DifficultyMask) (1 << (diffIndex + 1));
                    if ((validations & diffMask) > 0 || laneIndex >= NUM_LANES)
                    {
                        continue;
                    }

                    int statusMask = 1 << (diffIndex * NUM_LANES + laneIndex);
                    // Note Ons with no velocity equates to a note Off by spec
                    if (stats.Type == MidiEventType.Note_On && note.velocity > 0)
                    {
                        statusBitMask |= statusMask;
                    }
                    // Note off here
                    else if ((statusBitMask & statusMask) > 0)
                    {
                        validations |= diffMask;
                        if (validations == MidiPreparser_Constants.ALL_DIFFICULTIES)
                        {
                            break;
                        }
                    }
                }
                else if (stats.Type is MidiEventType.SysEx or MidiEventType.SysEx_End)
                {
                    var str = track.ExtractTextOrSysEx();
                    if (str.StartsWith(SYSEXTAG) && str[SYSEX_TYPE_INDEX] == OPEN_NOTE_TYPE)
                    {
                        // 1 = GREEN; 0 = OPEN
                        int status = str[SYSEX_STATUS_INDEX] == 0 ? 1 : 0;
                        if (str[SYSEX_DIFFICULTY_INDEX] == SYSEX_ALL_DIFFICULTIES)
                        {
                            for (int diff = 0; diff < MidiPreparser_Constants.NUM_DIFFICULTIES; ++diff)
                            {
                                indices[MidiPreparser_Constants.NOTES_PER_DIFFICULTY * diff + GREEN_INDEX] = status;
                            }
                        }
                        else
                        {
                            indices[MidiPreparser_Constants.NOTES_PER_DIFFICULTY * str[SYSEX_DIFFICULTY_INDEX] + GREEN_INDEX] = status;
                        }
                    }
                }
                else if (MidiEventType.Text <= stats.Type && stats.Type <= MidiEventType.Text_EnumLimit)
                {
                    var str = track.ExtractTextOrSysEx();
                    if (str.SequenceEqual(ENHANCED_STRINGS[0]) || str.SequenceEqual(ENHANCED_STRINGS[1]))
                    {
                        for (int diff = 0; diff < MidiPreparser_Constants.NUM_DIFFICULTIES; ++diff)
                        {
                            indices[MidiPreparser_Constants.NOTES_PER_DIFFICULTY * diff] = 0;
                        }
                    }
                }
            }
            return validations;
        }
    }
}
</file>

<file path="Song/MidiPreparsers/MidiInstrumentPreparser.cs">
namespace YARG.Core.Song
{
    internal static class MidiPreparser_Constants
    {
        public const DifficultyMask ALL_DIFFICULTIES = DifficultyMask.Easy | DifficultyMask.Medium | DifficultyMask.Hard | DifficultyMask.Expert;
        public const DifficultyMask ALL_DIFFICULTIES_PLUS = ALL_DIFFICULTIES | DifficultyMask.ExpertPlus;

        public const int DEFAULT_NOTE_MIN = 60;
        public const int DEFAULT_MAX = 100;
        public const int NUM_DIFFICULTIES = 4;
        public const int NOTES_PER_DIFFICULTY = 12;
        public const int EXTENDED_NOTES_PER_DIFFICULTY = 24;

        public static readonly int[] DIFF_INDICES = new int[NUM_DIFFICULTIES * NOTES_PER_DIFFICULTY]
        {
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        };

        public static readonly int[] EXTENDED_LANE_INDICES = new int[NUM_DIFFICULTIES * EXTENDED_NOTES_PER_DIFFICULTY]
        {
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
        };

        public static readonly int[] EXTENDED_DIFF_INDICES = new int[NUM_DIFFICULTIES * EXTENDED_NOTES_PER_DIFFICULTY]
        {
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        };
    }
}
</file>

<file path="Song/MidiPreparsers/MidiProGuitarPreparser.cs">
using YARG.Core.IO;

namespace YARG.Core.Song
{
    internal static class Midi_ProGuitar_Preparser
    {
        private const int NOTES_PER_DIFFICULTY = 24;
        private const int PROGUITAR_MAX = PROGUITAR_MIN + MidiPreparser_Constants.NUM_DIFFICULTIES * NOTES_PER_DIFFICULTY;
        private const int PROGUITAR_MIN = 24;
        private const int NUM_STRINGS = 6;
        private const int MIN_VELOCITY = 100;
        private const int ARPEGGIO_CHANNEL = 1;

        private const int MAXVELOCTIY_17 = 117;
        public static DifficultyMask Parse_17Fret(YARGMidiTrack track)
        {
            return Parse(track, MAXVELOCTIY_17);
        }

        private const int MAXVELOCITY_22 = 122;
        public static DifficultyMask Parse_22Fret(YARGMidiTrack track)
        {
            return Parse(track, MAXVELOCITY_22);
        }

        private static unsafe DifficultyMask Parse(YARGMidiTrack track, int maxVelocity)
        {
            var validations = default(DifficultyMask);
            int statusBitMask = 0;

            var note = default(MidiNote);
            var stats = default(YARGMidiTrack.Stats);
            while (track.ParseEvent(ref stats))
            {
                if (stats.Type is MidiEventType.Note_On or MidiEventType.Note_Off)
                {
                    track.ExtractMidiNote(ref note);
                    if (note.value < PROGUITAR_MIN || note.value > PROGUITAR_MAX)
                    {
                        continue;
                    }

                    int noteOffset = note.value - PROGUITAR_MIN;
                    int diffIndex = MidiPreparser_Constants.EXTENDED_DIFF_INDICES[noteOffset];
                    int laneIndex = MidiPreparser_Constants.EXTENDED_LANE_INDICES[noteOffset];
                    var diffMask = (DifficultyMask) (1 << (diffIndex + 1));
                    //                                                         Ghost notes aren't played
                    if ((validations & diffMask) > 0 || laneIndex >= NUM_STRINGS || stats.Channel == ARPEGGIO_CHANNEL)
                    {
                        continue;
                    }

                    int statusMask = 1 << (diffIndex * NUM_STRINGS + laneIndex);
                    // Note Ons with no velocity equates to a note Off by spec
                    if (stats.Type == MidiEventType.Note_On && note.velocity > 0)
                    {
                        if (MIN_VELOCITY <= note.velocity && note.velocity <= maxVelocity)
                        {
                            statusBitMask |= statusMask;
                        }
                    }
                    // Note off here
                    else if ((statusBitMask & statusMask) > 0)
                    {
                        validations |= diffMask;
                        if (validations == MidiPreparser_Constants.ALL_DIFFICULTIES)
                        {
                            break;
                        }
                    }
                }
            }
            return validations;
        }
    }
}
</file>

<file path="Song/MidiPreparsers/MidiProKeysPreparser.cs">
using YARG.Core.IO;

namespace YARG.Core.Song
{
    internal static class Midi_ProKeys_Preparser
    {
        private const int PROKEYS_MIN = 48;
        private const int PROKEYS_MAX = 72;
        private const int NOTES_IN_DIFFICULTY = PROKEYS_MAX - PROKEYS_MIN + 1;

        public static unsafe bool Parse(YARGMidiTrack track)
        {
            int statusBitMask = 0;
            var note = default(MidiNote);
            var stats = default(YARGMidiTrack.Stats);
            while (track.ParseEvent(ref stats))
            {
                if (stats.Type is MidiEventType.Note_On or MidiEventType.Note_Off)
                {
                    track.ExtractMidiNote(ref note);
                    if (PROKEYS_MIN <= note.value && note.value <= PROKEYS_MAX)
                    {
                        int statusMask = 1 << (note.value - PROKEYS_MIN);
                        if (stats.Type == MidiEventType.Note_On && note.velocity > 0)
                        {
                            statusBitMask |= statusMask;
                        }
                        else if ((statusBitMask & statusMask) > 0)
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
    }
}
</file>

<file path="Song/MidiPreparsers/MidiSixFretPreparser.cs">
using YARG.Core.IO;

namespace YARG.Core.Song
{
    internal static class Midi_SixFret_Preparser
    {
        private const int SIXFRET_MIN = 58;
        private const int SIXFRET_MAX = 103;
        // Open note included
        private const int NUM_LANES = 7;

        // Six fret indexing is fucked
        private static readonly int[] INDICES = new int[MidiPreparser_Constants.NUM_DIFFICULTIES * MidiPreparser_Constants.NOTES_PER_DIFFICULTY]
        {
            0, 4, 5, 6, 1, 2, 3, 7, 8, 9, 10, 11,
            0, 4, 5, 6, 1, 2, 3, 7, 8, 9, 10, 11,
            0, 4, 5, 6, 1, 2, 3, 7, 8, 9, 10, 11,
            0, 4, 5, 6, 1, 2, 3, 7, 8, 9, 10, 11,
        };

        public static unsafe DifficultyMask Parse(YARGMidiTrack track)
        {
            var validations = default(DifficultyMask);
            int statusBitMask = 0;

            var note = default(MidiNote);
            var stats = default(YARGMidiTrack.Stats);
            while (track.ParseEvent(ref stats))
            {
                if (stats.Type is MidiEventType.Note_On or MidiEventType.Note_Off)
                {
                    track.ExtractMidiNote(ref note);
                    if (note.value < SIXFRET_MIN || note.value > SIXFRET_MAX)
                    {
                        continue;
                    }

                    int noteOffset = note.value - SIXFRET_MIN;
                    int diffIndex = MidiPreparser_Constants.DIFF_INDICES[noteOffset];
                    int laneIndex = INDICES[noteOffset];
                    var diffMask = (DifficultyMask) (1 << (diffIndex + 1));
                    if ((validations & diffMask) > 0 || laneIndex >= NUM_LANES)
                    {
                        continue;
                    }

                    int statusMask = 1 << (diffIndex * NUM_LANES + laneIndex);
                    // Note Ons with no velocity equates to a note Off by spec
                    if (stats.Type == MidiEventType.Note_On && note.velocity > 0)
                    {
                        statusBitMask |= statusMask;
                    }
                    // Note off here
                    else if ((statusBitMask & statusMask) > 0)
                    {
                        validations |= diffMask;
                        if (validations == MidiPreparser_Constants.ALL_DIFFICULTIES)
                        {
                            break;
                        }
                    }
                }
            }
            return validations;
        }
    }
}
</file>

<file path="Song/MidiPreparsers/MidiVocalPreparser.cs">
using YARG.Core.IO;

namespace YARG.Core.Song
{
    internal static class Midi_Vocal_Preparser
    {
        private const int VOCAL_MIN = 36;
        private const int VOCAL_MAX = 84;
        private const int PERCUSSION_NOTE = 96;

        private const int VOCAL_PHRASE_1 = 105;
        private const int VOCAL_PHRASE_2 = 106;

        public static bool Parse(YARGMidiTrack track, bool isLeadVocals)
        {
            long vocalPosition = -1;
            long phrasePosition = -1;
            long percussionPosition = -1;

            var note = default(MidiNote);
            var stats = default(YARGMidiTrack.Stats);
            while (track.ParseEvent(ref stats))
            {
                if (stats.Type is MidiEventType.Note_On or MidiEventType.Note_Off)
                {
                    track.ExtractMidiNote(ref note);
                    // Note Ons with no velocity equates to a note Off by spec
                    if (stats.Type == MidiEventType.Note_On && note.velocity > 0)
                    {
                        if (VOCAL_MIN <= note.value && note.value <= VOCAL_MAX)
                        {
                            vocalPosition = stats.Position;
                        }
                        else if (note.value == VOCAL_PHRASE_1 || note.value == VOCAL_PHRASE_2)
                        {
                            phrasePosition = int.MaxValue;
                        }
                        else if (note.value == PERCUSSION_NOTE && isLeadVocals)
                        {
                            percussionPosition = stats.Position;
                        }
                    }
                    // NoteOff from this point
                    else if (VOCAL_MIN <= note.value && note.value <= VOCAL_MAX)
                    {
                        // HARM 2/3 do not use phrases defined in their own tracks to mark playable vocals
                        if (vocalPosition >= 0 && (stats.Position <= phrasePosition || !isLeadVocals))
                        {
                            return true;
                        }
                        vocalPosition = -1;
                    }
                    else if (note.value == VOCAL_PHRASE_1 || note.value == VOCAL_PHRASE_2)
                    {
                        // Accounts for when a phrase ends at the same time as a vocal/precussion note but is in-file first
                        phrasePosition = stats.Position;
                    }
                    else if (note.value == PERCUSSION_NOTE)
                    {
                        if (percussionPosition >= 0 && stats.Position <= phrasePosition)
                        {
                            return true;
                        }
                        percussionPosition = -1;
                    }
                }
            }
            return false;
        }
    }
}
</file>

<file path="Utility/IBinarySerializable.cs">
using System.IO;

namespace YARG.Core.Utility
{
    public interface IBinarySerializable
    {

        public void Serialize(BinaryWriter writer);

        public void Deserialize(BinaryReader reader, int version = 0);

    }
}
</file>

<file path="Utility/JsonColorConverter.cs">
using System;
using System.Drawing;
using System.Globalization;
using Newtonsoft.Json;

namespace YARG.Core.Utility
{
    public class JsonColorConverter : JsonConverter<Color>
    {
        public override void WriteJson(JsonWriter writer, Color value, JsonSerializer serializer)
        {
            int argb = value.ToArgb();

            byte a = (byte) ((argb >> 24) & 0xFF);

            // Convert from ARGB to RGBA
            argb <<= 8;
            argb |= a;

            writer.WriteValue(argb.ToString("X8"));
        }

        public override Color ReadJson(JsonReader reader, Type objectType, Color existingValue, bool hasExistingValue,
            JsonSerializer serializer)
        {
            if (reader.Value == null)
            {
                return Color.White;
            }

            var value = reader.Value.ToString();

            if (value.Length == 6)
            {
                value += "FF";
            } else if(value.Length != 8)
            {
                return Color.White;
            }

            try
            {
                int rgba = int.Parse(value, NumberStyles.AllowHexSpecifier);

                var a = (byte) (rgba & 0xFF);

                // Convert from RGBA to ARGB
                rgba >>= 8;
                // If rgba is negative, the above bit shift will result in the first byte being FF, so we need to clear it.
                rgba &= 0x00FFFFFF;
                rgba |= a << 24;

                return Color.FromArgb(rgba);
            }
            catch
            {
                return Color.White;
            }

        }

        public override bool CanRead => true;
    }
}
</file>

<file path="Utility/JsonHashWrapperConverter.cs">
using System;
using System.Globalization;
using Newtonsoft.Json;
using YARG.Core.Song;

namespace YARG.Core.Utility
{
    public class JsonHashWrapperConverter : JsonConverter<HashWrapper>
    {
        public override void WriteJson(JsonWriter writer, HashWrapper value, JsonSerializer serializer)
        {
            writer.WriteValue(value.ToString());
        }

        public override HashWrapper ReadJson(JsonReader reader, Type objectType, HashWrapper existingValue,
            bool hasExistingValue, JsonSerializer serializer)
        {
            return reader.Value != null ? HashWrapper.FromString(reader.Value.ToString().AsSpan()) : default;
        }
    }
}
</file>

<file path="Utility/MathUtil.cs">
using YARG.Core.Extensions;

namespace YARG.Core.Utility
{
    public static class MathUtil
    {
        // Backported from newer .NET
        public static double BitIncrement(double x)
        {
            ulong bits = UnsafeExtensions.DoubleToUInt64Bits(x);

            const ulong negativeZeroBits = 0x8000_0000_0000_0000;
            const ulong negativeInfinityBits = 0xFFF0_0000_0000_0000;

            if (!double.IsFinite(x))
            {
                return bits == negativeInfinityBits ? double.MinValue : x;
            }

            if (bits == negativeZeroBits)
            {
                return double.Epsilon;
            }

            if (double.IsNegative(x))
            {
                bits -= 1;
            }
            else
            {
                bits += 1;
            }

            return UnsafeExtensions.UInt64BitsToDouble(bits);
        }
    }
}
</file>

<file path="Utility/NullStringBinaryWriter.cs">
using System.IO;

namespace YARG.Core.Utility
{
    public class NullStringBinaryWriter : BinaryWriter
    {
        public NullStringBinaryWriter(Stream output) : base(output)
        {
        }

        public override void Write(string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                value = string.Empty;
            }

            base.Write(value);
        }
    }
}
</file>

<file path="Utility/RichTextUtils.cs">
using System;
using System.Collections.Generic;
using Cysharp.Text;
using YARG.Core.Extensions;

namespace YARG.Core.Utility
{
    [Flags]
    public enum RichTextTags : ulong
    {
        None = 0,

        // Organized according to the text tags in alphabetical order
        /// <summary>The "align" tag.</summary>
        Align = 1UL << 0,
        /// <summary>The "allcaps" tag.</summary>
        AllCaps = 1UL << 1,
        /// <summary>The "alpha" tag.</summary>
        Alpha = 1UL << 2,
        /// <summary>The "b" tag.</summary>
        Bold = 1UL << 3,
        /// <summary>The "br" tag.</summary>
        LineBreak = 1UL << 4,
        /// <summary>The "color" tag.</summary>
        Color = 1UL << 5,
        /// <summary>The "cspace" tag.</summary>
        CharSpace = 1UL << 6,
        /// <summary>The "font" tag.</summary>
        Font = 1UL << 7,
        /// <summary>The "font-weight" tag.</summary>
        FontWeight = 1UL << 8,
        /// <summary>The "gradient" tag.</summary>
        Gradient = 1UL << 9,
        /// <summary>The "i" tag.</summary>
        Italics = 1UL << 10,
        /// <summary>The "indent" tag.</summary>
        Indent = 1UL << 11,
        /// <summary>The "line-height" tag.</summary>
        LineHeight = 1UL << 12,
        /// <summary>The "line-indent" tag.</summary>
        LineIndent = 1UL << 13,
        /// <summary>The "link" tag.</summary>
        Link = 1UL << 14,
        /// <summary>The "lowercase" tag.</summary>
        Lowercase = 1UL << 15,
        /// <summary>The "margin" tag.</summary>
        Margin = 1UL << 16,
        /// <summary>The "mark" tag.</summary>
        Mark = 1UL << 17,
        /// <summary>The "mspace" tag.</summary>
        Monospace = 1UL << 18,
        /// <summary>The "noparse" tag.</summary>
        NoParse = 1UL << 19,
        /// <summary>The "nobr" tag.</summary>
        NoBreak = 1UL << 20,
        /// <summary>The "page" tag.</summary>
        PageBreak = 1UL << 21,
        /// <summary>The "pos" tag.</summary>
        HorizontalPosition = 1UL << 22,
        /// <summary>The "rotate" tag.</summary>
        Rotate = 1UL << 23,
        /// <summary>The "size" tag.</summary>
        FontSize = 1UL << 24,
        /// <summary>The "smallcaps" tag.</summary>
        SmallCaps = 1UL << 25,
        /// <summary>The "space" tag.</summary>
        HorizontalSpace = 1UL << 26,
        /// <summary>The "sprite" tag.</summary>
        Sprite = 1UL << 27,
        /// <summary>The "s" tag.</summary>
        Strikethrough = 1UL << 28,
        /// <summary>The "style" tag.</summary>
        Style = 1UL << 29,
        /// <summary>The "sub" tag.</summary>
        Subscript = 1UL << 30,
        /// <summary>The "sup" tag.</summary>
        Superscript = 1UL << 31,
        /// <summary>The "u" tag.</summary>
        Underline = 1UL << 32,
        /// <summary>The "uppercase" tag.</summary>
        Uppercase = 1UL << 33,
        /// <summary>The "voffset" tag.</summary>
        VerticalOffset = 1UL << 34,
        /// <summary>The "width" tag.</summary>
        Width = 1UL << 35,

        MaxBit = Width,

        AllTags = ~0UL,

        /// <summary>Tags which are acceptable for general purposes.</summary>
        GoodTags = Alpha | Color | Bold | Italics | Lowercase | Uppercase |
            SmallCaps | Strikethrough | Underline | Subscript | Superscript,

        /// <summary>Tags which are not desirable for general purposes.</summary>
        BadTags = ~GoodTags,
    }

    public static class RichTextUtils
    {
        static RichTextUtils() { }
        public static readonly (string Text, RichTextTags tag)[] RICH_TEXT_TAGS =
        {
            ( "align",       RichTextTags.Align),
            ( "allcaps",     RichTextTags.AllCaps),
            ( "alpha",       RichTextTags.Alpha),
            ( "b",           RichTextTags.Bold),
            ( "br",          RichTextTags.LineBreak),
            ( "color",       RichTextTags.Color),
            ( "cspace",      RichTextTags.CharSpace),
            ( "font",        RichTextTags.Font),
            ( "font-weight", RichTextTags.FontWeight),
            ( "gradient",    RichTextTags.Gradient),
            ( "i",           RichTextTags.Italics),
            ( "indent",      RichTextTags.Indent),
            ( "line-height", RichTextTags.LineHeight),
            ( "line-indent", RichTextTags.LineIndent),
            ( "link",        RichTextTags.Link),
            ( "lowercase",   RichTextTags.Lowercase),
            ( "margin",      RichTextTags.Margin),
            ( "mark",        RichTextTags.Mark),
            ( "mspace",      RichTextTags.Monospace),
            ( "noparse",     RichTextTags.NoParse),
            ( "nobr",        RichTextTags.NoBreak),
            ( "page",        RichTextTags.PageBreak),
            ( "pos",         RichTextTags.HorizontalPosition),
            ( "rotate",      RichTextTags.Rotate),
            ( "size",        RichTextTags.FontSize),
            ( "smallcaps",   RichTextTags.SmallCaps),
            ( "space",       RichTextTags.HorizontalSpace),
            ( "sprite",      RichTextTags.Sprite),
            ( "s",           RichTextTags.Strikethrough),
            ( "style",       RichTextTags.Style),
            ( "sub",         RichTextTags.Subscript),
            ( "sup",         RichTextTags.Superscript),
            ( "u",           RichTextTags.Underline),
            ( "uppercase",   RichTextTags.Uppercase),
            ( "voffset",     RichTextTags.VerticalOffset),
            ( "width",       RichTextTags.Width),
        };

        private static readonly Dictionary<RichTextTags, string[]> STRIP_CACHE = new();
        public static string StripRichTextTags(string text, RichTextTags excludeTags = RichTextTags.AllTags)
        {
            string[] tags = GetStripList(excludeTags);

            Span<char> buffer = stackalloc char[text.Length];
            int length = 0;

            var span = text.AsSpan();
            for (int position = 0, nextPosition; position < text.Length; position = nextPosition)
            {
                if (!ParseHTMLBounds(text, position, out int open, out int end))
                {
                    if (position == 0)
                    {
                        return text;
                    }
                    nextPosition = end = text.Length;
                }
                else
                {
                    nextPosition = ++end;
                    var tag = span[open..end];
                    foreach (var tagText in tags)
                    {
                        if (tag.StartsWith(tagText))
                        {
                            end = open;
                            break;
                        }
                    }
                }

                while (position < end)
                {
                    buffer[length++] = text[position++];
                }
            }
            return length < text.Length ? new string(buffer[0..length]) : text;
        }

        private static (string Original, string Replacement)[] COLOR_TO_HEX_LIST =
        {
            ( "aqua",      "<color=#00ffff>" ),
            ( "black",     "<color=#000000>" ),
            ( "blue",      "<color=#0000ff>" ),
            ( "brown",     "<color=#a52a2a>" ),
            ( "cyan",      "<color=#00ffff>" ),
            ( "darkblue",  "<color=#0000a0>" ),
            ( "fuchsia",   "<color=#ff00ff>" ),
            ( "green",     "<color=#008000>" ),
            ( "grey",      "<color=#808080>" ),
            ( "lightblue", "<color=#add8e6>" ),
            ( "lime",      "<color=#00ff00>" ),
            ( "magenta",   "<color=#ff00ff>" ),
            ( "maroon",    "<color=#800000>" ),
            ( "navy",      "<color=#000080>" ),
            ( "olive",     "<color=#808000>" ),
            ( "orange",    "<color=#ffa500>" ),
            ( "purple",    "<color=#800080>" ),
            ( "red",       "<color=#ff0000>" ),
            ( "silver",    "<color=#c0c0c0>" ),
            ( "teal",      "<color=#008080>" ),
            ( "white",     "<color=#ffffff>" ),
            ( "yellow",    "<color=#ffff00>" ),
        };

        public static string ReplaceColorNames(string text)
        {
            using var builder = ZString.CreateStringBuilder(notNested: true);
            var span = text.AsSpan();
            for (int position = 0, nextPosition; position < span.Length; position = nextPosition)
            {
                if (!ParseHTMLBounds(text, position, out int open, out int close))
                {
                    if (position == 0)
                    {
                        return text;
                    }
                    builder.Append(span[position..text.Length]);
                    break;
                }

                nextPosition = close + 1;

                bool found = false;
                var tag = span[(open + 1)..close];
                if (tag.StartsWith("color="))
                {
                    tag = tag[6..].TrimOnce('"');
                    foreach (var (original, replacement) in COLOR_TO_HEX_LIST)
                    {
                        if (tag.SequenceEqual(original))
                        {
                            builder.Append(span[position..open]);
                            builder.Append(replacement);
                            found = true;
                            break;
                        }
                    }
                }

                if (!found)
                {
                    builder.Append(span[position..(close + 1)]);
                }
            }
            return builder.ToString();
        }

        private static bool ParseHTMLBounds(string text, int position, out int open, out int close)
        {
            open = text.IndexOf('<', position);
            if (open == -1)
            {
                close = -1;
                return false;
            }

            close = text.IndexOf('>', open);
            return close != -1;
        }

        private static string[] GetStripList(RichTextTags excludeTags)
        {
            string[] tags;
            lock (STRIP_CACHE)
            {
                if (!STRIP_CACHE.TryGetValue(excludeTags, out tags))
                {
                    var list = new List<string>(RICH_TEXT_TAGS.Length * 3);
                    foreach (var (tagText, tag) in RICH_TEXT_TAGS)
                    {
                        if ((excludeTags & tag) != 0)
                        {
                            // Intern saves the string to the system pool, saving on memory
                            list.Add(string.Intern($"<{tagText}="));
                            list.Add(string.Intern($"<{tagText}>"));
                            list.Add(string.Intern($"</{tagText}>"));
                        }
                    }
                    STRIP_CACHE.Add(excludeTags, tags = list.ToArray());
                }
            }
            return tags;
        }
    }
}
</file>

<file path="Utility/SpanSplitter.cs">
using System;
using YARG.Core.Extensions;

namespace YARG.Core.Utility
{
    using TrimSplitter = SpanSplitter<char, TrimSplitProcessor>;
    using AsciiTrimSplitter = SpanSplitter<char, AsciiTrimSplitProcessor>;
    using Latin1TrimSplitter = SpanSplitter<char, Latin1TrimSplitProcessor>;

    /// <summary>
    /// Enumerates a <see cref="ReadOnlySpan{T}"/>, splitting based on a specific value of <typeparamref name="T"/>
    /// and using <typeparamref name="TSplitter"/> to refine the resulting split value.
    /// </summary>
    public ref struct SpanSplitter<T, TSplitter>
        where T : IEquatable<T>
        where TSplitter : ISplitProcessor<T>, new()
    {
        private readonly ReadOnlySpan<T> _original;
        private ReadOnlySpan<T> _remaining;
        private readonly T _split;
        private readonly TSplitter _splitter;

        public ReadOnlySpan<T> Current { get; private set; }
        public readonly ReadOnlySpan<T> CurrentToEnd
        {
            get
            {
                int fromEnd = _remaining.IsEmpty ? Current.Length
                    : Current.Length + 1 + _remaining.Length; // + 1 to account for split being skipped
                int index = _original.Length - fromEnd;
                return _original[index..];
            }
        }

        public readonly ReadOnlySpan<T> Original => _original;
        public readonly ReadOnlySpan<T> Remaining => _remaining;
        public readonly T Split => _split;

        public SpanSplitter(ReadOnlySpan<T> buffer, T split)
        {
            _original = buffer;
            _remaining = buffer;
            _split = split;
            _splitter = new();
            Current = ReadOnlySpan<T>.Empty;
        }

        public readonly SpanSplitter<T, TSplitter> GetEnumerator() => this;

        public ReadOnlySpan<T> GetNext() => MoveNext() ? Current : ReadOnlySpan<T>.Empty;

        public bool MoveNext()
        {
            if (_remaining.IsEmpty)
                return false;

            Current = _remaining.SplitOnce(_split, _splitter, out _remaining);
            return !Current.IsEmpty;
        }

        public void Reset()
        {
            Current = ReadOnlySpan<T>.Empty;
            _remaining = _original;
        }
    }

    public interface ISplitProcessor<T>
        where T : IEquatable<T>
    {
        ReadOnlySpan<T> GetSegment(ReadOnlySpan<T> buffer, int splitIndex);
        ReadOnlySpan<T> GetRemaining(ReadOnlySpan<T> buffer, int splitIndex);
    }

    public readonly struct SpanSplitProcessor<T> : ISplitProcessor<T>
        where T : IEquatable<T>
    {
        public readonly ReadOnlySpan<T> GetSegment(ReadOnlySpan<T> buffer, int splitIndex)
            => buffer[..splitIndex];
        public readonly ReadOnlySpan<T> GetRemaining(ReadOnlySpan<T> buffer, int splitIndex)
            => buffer[splitIndex..];
    }

    public readonly struct TrimSplitProcessor : ISplitProcessor<char>
    {
        public readonly ReadOnlySpan<char> GetSegment(ReadOnlySpan<char> buffer, int splitIndex)
            => buffer[..splitIndex].Trim();
        public readonly ReadOnlySpan<char> GetRemaining(ReadOnlySpan<char> buffer, int splitIndex)
            => buffer[splitIndex..].Trim();
    }

    public readonly struct AsciiTrimSplitProcessor : ISplitProcessor<char>
    {
        public readonly ReadOnlySpan<char> GetSegment(ReadOnlySpan<char> buffer, int splitIndex)
            => buffer[..splitIndex].TrimAscii();
        public readonly ReadOnlySpan<char> GetRemaining(ReadOnlySpan<char> buffer, int splitIndex)
            => buffer[splitIndex..].TrimAscii();
    }

    public readonly struct Latin1TrimSplitProcessor : ISplitProcessor<char>
    {
        public readonly ReadOnlySpan<char> GetSegment(ReadOnlySpan<char> buffer, int splitIndex)
            => buffer[..splitIndex].TrimLatin1();
        public readonly ReadOnlySpan<char> GetRemaining(ReadOnlySpan<char> buffer, int splitIndex)
            => buffer[splitIndex..].TrimLatin1();
    }

    public static class SpanSplitterExtensions
    {
        public static SpanSplitter<char, SpanSplitProcessor<char>> SplitAsSpan(this string buffer, char split)
            => new(buffer, split);

        public static SpanSplitter<T, SpanSplitProcessor<T>> Split<T>(this Span<T> buffer, T split)
            where T : IEquatable<T>
            => new(buffer, split);

        public static SpanSplitter<T, SpanSplitProcessor<T>> Split<T>(this ReadOnlySpan<T> buffer, T split)
            where T : IEquatable<T>
            => new(buffer, split);

        public static TrimSplitter SplitTrimmed(this string buffer, char split)
            => new(buffer, split);

        public static TrimSplitter SplitTrimmed(this ReadOnlySpan<char> buffer, char split)
            => new(buffer, split);

        public static AsciiTrimSplitter SplitTrimmedAscii(this string buffer, char split)
            => new(buffer, split);

        public static AsciiTrimSplitter SplitTrimmedAscii(this ReadOnlySpan<char> buffer, char split)
            => new(buffer, split);

        public static Latin1TrimSplitter SplitTrimmedLatin1(this string buffer, char split)
            => new(buffer, split);

        public static Latin1TrimSplitter SplitTrimmedLatin1(this ReadOnlySpan<char> buffer, char split)
            => new(buffer, split);

        public static ReadOnlySpan<char> SplitOnce(this string buffer, char split, out ReadOnlySpan<char> remaining)
            => SplitOnce(buffer.AsSpan(), split, out remaining);

        public static ReadOnlySpan<T> SplitOnce<T>(this Span<T> buffer, T split, out ReadOnlySpan<T> remaining)
            where T : IEquatable<T>
            => SplitOnce((ReadOnlySpan<T>) buffer, split, out remaining);

        public static ReadOnlySpan<T> SplitOnce<T>(this ReadOnlySpan<T> buffer, T split, out ReadOnlySpan<T> remaining)
            where T : IEquatable<T>
            => buffer.SplitOnce(split, new SpanSplitProcessor<T>(), out remaining);

        public static ReadOnlySpan<char> SplitOnceTrimmed(this string buffer, char split, out ReadOnlySpan<char> remaining)
            => SplitOnceTrimmed(buffer.AsSpan(), split, out remaining);

        public static ReadOnlySpan<char> SplitOnceTrimmed(this ReadOnlySpan<char> buffer, char split, out ReadOnlySpan<char> remaining)
            => buffer.SplitOnce(split, new TrimSplitProcessor(), out remaining);

        public static ReadOnlySpan<char> SplitOnceTrimmedAscii(this string buffer, char split, out ReadOnlySpan<char> remaining)
            => SplitOnceTrimmedAscii(buffer.AsSpan(), split, out remaining);

        public static ReadOnlySpan<char> SplitOnceTrimmedAscii(this ReadOnlySpan<char> buffer, char split, out ReadOnlySpan<char> remaining)
            => buffer.SplitOnce(split, new AsciiTrimSplitProcessor(), out remaining);

        public static ReadOnlySpan<char> SplitOnceTrimmedLatin1(this string buffer, char split, out ReadOnlySpan<char> remaining)
            => SplitOnceTrimmedLatin1(buffer.AsSpan(), split, out remaining);

        public static ReadOnlySpan<char> SplitOnceTrimmedLatin1(this ReadOnlySpan<char> buffer, char split, out ReadOnlySpan<char> remaining)
            => buffer.SplitOnce(split, new Latin1TrimSplitProcessor(), out remaining);

        public static ReadOnlySpan<T> SplitOnce<T, TSplitter>(this ReadOnlySpan<T> buffer, T split, TSplitter splitter,
            out ReadOnlySpan<T> remaining)
            where T : IEquatable<T>
            where TSplitter : ISplitProcessor<T>
        {
            remaining = buffer;
            var result = ReadOnlySpan<T>.Empty;

            // For ignoring empty splits
            while (result.IsEmpty && !remaining.IsEmpty)
            {
                int splitIndex = remaining.IndexOf(split);
                if (splitIndex < 0)
                    splitIndex = remaining.Length;

                // Split on the value
                result = splitter.GetSegment(remaining, splitIndex);

                // Skip the split value and ignore consecutive split values
                while (splitIndex < remaining.Length && remaining[splitIndex].Equals(split))
                    splitIndex++;

                remaining = splitter.GetRemaining(remaining, splitIndex);
            }

            return result;
        }
    }
}
</file>

<file path="Utility/StringTransformations.cs">
using System.Globalization;
using System.Text;

namespace YARG.Core.Utility
{
    public enum CharacterGroup
    {
        Empty,
        AsciiSymbol,
        AsciiNumber,
        AsciiLetter,
        NonAscii
    }

    public static class StringTransformations
    {
        // Order of these static variables matters
        private static readonly (string, string)[] SearchLeniency =
        {
            ("", "AE") // Tool - nema
        };

        private static readonly string[] Articles =
        {
            "the ", // The beatles, The day that never comes
            "el ",  // El final, El sol no regresa
            "la ",  // La quinta estacion, La bamba, La muralla verde
            "le ",  // Le temps de la rentre
            "les ", // Les Rita Mitsouko, Les Wampas
            "los ", // Los fabulosos cadillacs, Los enanitos verdes,
        };

        public static string RemoveDiacritics(string? text)
        {
            if (text == null)
            {
                return string.Empty;
            }

            foreach (var c in SearchLeniency)
            {
                text = text.Replace(c.Item1, c.Item2);
            }

            var normalizedString = text.Normalize(NormalizationForm.FormD);
            unsafe
            {
                var buffer = stackalloc char[normalizedString.Length];
                int length = 0;
                foreach (char c in normalizedString)
                {
                    switch (CharUnicodeInfo.GetUnicodeCategory(c))
                    {
                        case UnicodeCategory.NonSpacingMark:
                        case UnicodeCategory.Format:
                        case UnicodeCategory.SpacingCombiningMark:
                            break;
                        default:
                            buffer[length++] = c;
                            break;
                    }
                }

                if (length < normalizedString.Length)
                {
                    normalizedString = new string(buffer, 0, length);
                }
                return normalizedString.ToLowerInvariant().Normalize(NormalizationForm.FormC);
            }
        }

        public static unsafe string RemoveUnwantedWhitespace(string arg)
        {
            var buffer = stackalloc char[arg.Length];
            int length = 0;
            int index = 0;
            while (index < arg.Length)
            {
                char curr = arg[index++];
                if (curr > 32)
                {
                    buffer[length++] = curr;
                    continue;
                }

                while (index < arg.Length && arg[index] <= 32)
                {
                    ++index;
                }

                if (length > 0 && index < arg.Length)
                {
                    buffer[length++] = ' ';
                    buffer[length++] = arg[index++];
                }
            }
            return length == arg.Length ? arg : new string(buffer, 0, length);
        }

        public static string RemoveArticle(string name)
        {
            if (!string.IsNullOrEmpty(name))
            {
                foreach (var article in Articles)
                {
                    if (StartsWith(name, article))
                    {
                        return name[article.Length..];
                    }
                }
            }
            return name;
        }

        // Why use a custom function versus .NET's built-in one? Because hot paths baby! YIPPEEEEEE!
        // Also, the use case is very controlled, so this won't hurt
        private static bool StartsWith(string str, string query)
        {
            int index = 0;
            if (str.Length >= query.Length)
            {
                while (index < query.Length && char.ToLowerInvariant(str[index]) == query[index])
                {
                    index++;
                }
            }
            return index == query.Length;
        }

        public static CharacterGroup GetCharacterGrouping(string str)
        {
            if (str.Length == 0)
            {
                return CharacterGroup.Empty;
            }

            return str[0] switch
            {
                >= 'a' and <= 'z' => CharacterGroup.AsciiLetter,
                >= '0' and <= '9' => CharacterGroup.AsciiNumber,
                _                 => str[0] > 127 ? CharacterGroup.NonAscii : CharacterGroup.AsciiSymbol
            };
        }
    }
}
</file>

<file path="Venue/VenueType.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace YARG.Core.Venue
{
    [Flags]
    public enum BackgroundType
    {
        Yarground = 1 << 0,
        Video = 1 << 1,
        Image = 1 << 2,
    }
}
</file>

<file path="Assembly.cs">
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("YARG.Core.Benchmarks")]
[assembly: InternalsVisibleTo("YARG.Core.UnitTests")]
</file>

<file path="InstrumentEnums.cs">
using System;
using System.Runtime.CompilerServices;

namespace YARG.Core
{
    // !DO NOT MODIFY THE VALUES OR ORDER OF THESE ENUMS!
    // Since they are serialized in replays, they *must* remain the same across changes.
    // Add new values in the gaps between reserved ranges, or reserve a new range at the end of the enum.

    /// <summary>
    /// Available game modes.
    /// </summary>
    public enum GameMode : byte
    {
        // Game modes are reserved in multiples of 5
        // 0-4: Guitar
        FiveFretGuitar = 0,
        SixFretGuitar = 1,

        // 5-9: Drums
        FourLaneDrums = 5,
        FiveLaneDrums = 6,
        // EliteDrums = 7,

        // 10-14: Pro instruments
        ProGuitar = 10,
        ProKeys = 11,

        // 15-19: Vocals
        Vocals = 15,

        // 20-24: Other
        // Dj = 20,
    }

    /// <summary>
    /// Available instruments.
    /// </summary>
    public enum Instrument : byte
    {
        // Instruments are reserved in multiples of 10
        // 0-9: 5-fret guitar
        FiveFretGuitar = 0,
        FiveFretBass = 1,
        FiveFretRhythm = 2,
        FiveFretCoopGuitar = 3,
        Keys = 4,

        // 10-19: 6-fret guitar
        SixFretGuitar = 10,
        SixFretBass = 11,
        SixFretRhythm = 12,
        SixFretCoopGuitar = 13,

        // 20-29: Drums
        FourLaneDrums = 20,
        ProDrums = 21,
        FiveLaneDrums = 22,
        EliteDrums = 23,

        // 30-39: Pro instruments
        ProGuitar_17Fret = 30,
        ProGuitar_22Fret = 31,
        ProBass_17Fret = 32,
        ProBass_22Fret = 33,

        ProKeys = 34,

        // 40-49: Vocals
        Vocals = 40,
        Harmony = 41,

        // 50-59: DJ
        // DjSingle = 50,
        // DjDouble = 51,

        Band = byte.MaxValue
    }

    /// <summary>
    /// Available difficulty levels.
    /// </summary>
    public enum Difficulty : byte
    {
        Beginner = 0,
        Easy = 1,
        Medium = 2,
        Hard = 3,
        Expert = 4,
        ExpertPlus = 5,
    }

    /// <summary>
    /// Available difficulty levels.
    /// <remarks>DO NOT MAKE THIS LARGER THAN A BYTE!</remarks>
    /// </summary>
    [Flags]
    public enum DifficultyMask : byte
    {
        None = 0,

        Beginner   = 1 << Difficulty.Beginner,
        Easy       = 1 << Difficulty.Easy,
        Medium     = 1 << Difficulty.Medium,
        Hard       = 1 << Difficulty.Hard,
        Expert     = 1 << Difficulty.Expert,
        ExpertPlus = 1 << Difficulty.ExpertPlus,

        All = Beginner | Easy | Medium | Hard | Expert | ExpertPlus,
    }

    public static class ChartEnumExtensions
    {
        public static GameMode ToGameMode(this Instrument instrument)
        {
            return instrument switch
            {
                Instrument.FiveFretGuitar or
                Instrument.FiveFretBass or
                Instrument.FiveFretRhythm or
                Instrument.FiveFretCoopGuitar or
                Instrument.Keys => GameMode.FiveFretGuitar,

                Instrument.SixFretGuitar or
                Instrument.SixFretBass or
                Instrument.SixFretRhythm or
                Instrument.SixFretCoopGuitar => GameMode.SixFretGuitar,

                Instrument.FourLaneDrums or
                Instrument.ProDrums => GameMode.FourLaneDrums,

                Instrument.FiveLaneDrums => GameMode.FiveLaneDrums,

                // Instrument.EliteDrums => GameMode.EliteDrums,

                Instrument.ProGuitar_17Fret or
                Instrument.ProGuitar_22Fret or
                Instrument.ProBass_17Fret or
                Instrument.ProBass_22Fret => GameMode.ProGuitar,

                Instrument.ProKeys => GameMode.ProKeys,

                Instrument.Vocals or
                Instrument.Harmony => GameMode.Vocals,

                // Instrument.DjSingle => GameMode.Dj,
                // Instrument.DjDouble => GameMode.Dj,

                _ => throw new NotImplementedException($"Unhandled instrument {instrument}!")
            };
        }

        public static Instrument[] PossibleInstruments(this GameMode gameMode)
        {
            return gameMode switch
            {
                GameMode.FiveFretGuitar => new[]
                {
                    Instrument.FiveFretGuitar,
                    Instrument.FiveFretBass,
                    Instrument.FiveFretRhythm,
                    Instrument.FiveFretCoopGuitar,
                    Instrument.Keys,
                },
                GameMode.SixFretGuitar  => new[]
                {
                    Instrument.SixFretGuitar,
                    Instrument.SixFretBass,
                    Instrument.SixFretRhythm,
                    Instrument.SixFretCoopGuitar,
                },
                GameMode.FourLaneDrums  => new[]
                {
                    Instrument.FourLaneDrums,
                    Instrument.ProDrums,
                },
                GameMode.FiveLaneDrums  => new[]
                {
                    Instrument.FiveLaneDrums
                },
                //GameMode.EliteDrums     => new[]
                //{
                //     Instrument.EliteDrums,
                //},
                GameMode.ProGuitar      => new[]
                {
                    Instrument.ProGuitar_17Fret,
                    Instrument.ProGuitar_22Fret,
                    Instrument.ProBass_17Fret,
                    Instrument.ProBass_22Fret,
                },
                GameMode.ProKeys        => new[]
                {
                    Instrument.ProKeys
                },
                GameMode.Vocals         => new[]
                {
                    Instrument.Vocals,
                    Instrument.Harmony
                },
                // GameMode.Dj             => new[]
                // {
                //     Instrument.DjSingle,
                //     Instrument.DjDouble,
                // },
                _  => throw new NotImplementedException($"Unhandled game mode {gameMode}!")
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DifficultyMask ToDifficultyMask(this Difficulty difficulty)
        {
            return (DifficultyMask) (1 << (int) difficulty);
        }

        public static Difficulty ToDifficulty(this DifficultyMask difficulty)
        {
            return difficulty switch
            {
                DifficultyMask.Beginner   => Difficulty.Beginner,
                DifficultyMask.Easy       => Difficulty.Easy,
                DifficultyMask.Medium     => Difficulty.Medium,
                DifficultyMask.Hard       => Difficulty.Hard,
                DifficultyMask.Expert     => Difficulty.Expert,
                DifficultyMask.ExpertPlus => Difficulty.ExpertPlus,
                _ => throw new ArgumentException($"Cannot convert difficulty mask {difficulty} into a single difficulty!")
            };
        }
    }
}
</file>

<file path="YARG.Core.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <LangVersion>9</LangVersion>
    <PublishRelease>true</PublishRelease>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Melanchall.DryWetMidi.Nativeless" Version="7.0.0" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
    <PackageReference Include="PolySharp" Version="1.13.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="System.Runtime.CompilerServices.Unsafe" Version="6.0.0" />
    <PackageReference Include="ZString" Version="2.5.1" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Chart\Loaders\" />
  </ItemGroup>

  <ItemGroup>
    <None Update="Logging\YargLogger.Methods.t4">
      <Generator>TextTemplatingFileGenerator</Generator>
      <LastGenOutput>YargLogger.Methods.cs</LastGenOutput>
    </None>
  </ItemGroup>

  <ItemGroup>
    <Compile Update="Logging\YargLogger.Methods.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>YargLogger.Methods.t4</DependentUpon>
    </Compile>
  </ItemGroup>

</Project>
</file>

<file path="YARG.Core.csproj.DotSettings">
<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:Boolean x:Key="/Default/CodeInspection/NamespaceProvider/NamespaceFoldersToSkip/=chart_005Cnotes/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/CodeInspection/NamespaceProvider/NamespaceFoldersToSkip/=game_005Cpresets/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/CodeInspection/NamespaceProvider/NamespaceFoldersToSkip/=io_005Csnghandler/@EntryIndexedValue">True</s:Boolean></wpf:ResourceDictionary>
</file>

<file path="YargMath.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YARG.Core
{
    public static class YargMath
    {
        #region Lerp
        public static int Lerp(int start, int end, float percent)
        {
            return (int) (start + (end - start) * percent);
        }

        public static uint Lerp(uint start, uint end, float percent)
        {
            return (uint) (start + (end - start) * percent);
        }

        public static float Lerp(float start, float end, float percent)
        {
            return (float) (start + (end - start) * percent);
        }

        public static double Lerp(double start, double end, float percent)
        {
            return (double) (start + (end - start) * percent);
        }

        public static int Lerp(int start, int end, double percent)
        {
            return (int) (start + (end - start) * percent);
        }

        public static uint Lerp(uint start, uint end, double percent)
        {
            return (uint) (start + (end - start) * percent);
        }

        public static float Lerp(float start, float end, double percent)
        {
            return (float) (start + (end - start) * percent);
        }

        public static double Lerp(double start, double end, double percent)
        {
            return (double) (start + (end - start) * percent);
        }

        public static float LerpF(int start, int end, float percent)
        {
            return (float) (start + (end - start) * percent);
        }

        public static float LerpF(uint start, uint end, float percent)
        {
            return (float) (start + (end - start) * percent);
        }

        public static float LerpF(float start, float end, float percent)
        {
            return (float) (start + (end - start) * percent);
        }

        public static float LerpF(double start, double end, float percent)
        {
            return (float) (start + (end - start) * percent);
        }

        public static double LerpD(int start, int end, double percent)
        {
            return (double) (start + (end - start) * percent);
        }

        public static double LerpD(uint start, uint end, double percent)
        {
            return (double) (start + (end - start) * percent);
        }

        public static double LerpD(float start, float end, double percent)
        {
            return (double) (start + (end - start) * percent);
        }

        public static double LerpD(double start, double end, double percent)
        {
            return (double) (start + (end - start) * percent);
        }

        #endregion

        #region InverseLerp
        public static float InverseLerpF(int start, int end, int value)
        {
            if (start == end)
                return value < start ? 0 : 1;

            return (float) (value - start) / (float) (end - start);
        }

        public static float InverseLerpF(uint start, uint end, uint value)
        {
            if (start == end)
                return value < start ? 0 : 1;

            return (float) (value - start) / (float) (end - start);
        }

        public static float InverseLerpF(float start, float end, float value)
        {
            if (start == end)
                return value < start ? 0 : 1;

            return (float) (value - start) / (float) (end - start);
        }

        public static float InverseLerpF(double start, double end, double value)
        {
            if (start == end)
                return value < start ? 0 : 1;

            return (float) (value - start) / (float) (end - start);
        }

        public static double InverseLerpD(int start, int end, int value)
        {
            if (start == end)
                return value < start ? 0 : 1;

            return (double) (value - start) / (double) (end - start);
        }

        public static double InverseLerpD(uint start, uint end, uint value)
        {
            if (start == end)
                return value < start ? 0 : 1;

            return (double) (value - start) / (double) (end - start);
        }

        public static double InverseLerpD(float start, float end, float value)
        {
            if (start == end)
                return value < start ? 0 : 1;

            return (double) (value - start) / (double) (end - start);
        }

        public static double InverseLerpD(double start, double end, double value)
        {
            if (start == end)
                return value < start ? 0 : 1;

            return (double) (value - start) / (double) (end - start);
        }

        #endregion
    }
}
</file>

<file path="YargMath.t4">
<#@ template hostspecific="false" language="C#" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

<#
var intTypes = new string[] {
    "int",
    "uint",
    // Not necessary currently, uncomment and re-generate if needed
    // "long",
    // "ulong",
};

var percentTypes = new (string name, string suffix)[] {
    ("float", "F"),
    ("double", "D"),
};

var types = intTypes.Concat(percentTypes.Select((val) => val.name));
#>
namespace YARG.Core
{
    public static class YargMath
    {
        #region Lerp
<#
foreach (var (percentType, _) in percentTypes)
{
    foreach (var inputType in types)
    {
#>
        public static <#= inputType #> Lerp(<#= inputType #> start, <#= inputType #> end, <#= percentType #> percent)
        {
            return (<#= inputType #>) (start + (end - start) * percent);
        }

<#
    }
}

foreach (var (percentType, percentSuffix) in percentTypes)
{
    foreach (var inputType in types)
    {
#>
        public static <#= percentType #> Lerp<#= percentSuffix #>(<#= inputType #> start, <#= inputType #> end, <#= percentType #> percent)
        {
            return (<#= percentType #>) (start + (end - start) * percent);
        }

<#
    }
}
#>
        #endregion

        #region InverseLerp
<#
foreach (var (percentType, percentSuffix) in percentTypes)
{
    foreach (var inputType in types)
    {
#>
        public static <#= percentType #> InverseLerp<#= percentSuffix #>(<#= inputType #> start, <#= inputType #> end, <#= inputType #> value)
        {
            if (start == end)
                return value < start ? 0 : 1;

            return (<#= percentType #>) (value - start) / (<#= percentType #>) (end - start);
        }

<#
    }
}
#>
        #endregion
    }
}
</file>

</files>
